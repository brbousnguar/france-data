/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/doctrine";
exports.ids = ["vendor-chunks/doctrine"];
exports.modules = {

/***/ "(rsc)/./node_modules/doctrine/lib/doctrine.js":
/*!***********************************************!*\
  !*** ./node_modules/doctrine/lib/doctrine.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * @fileoverview Main Doctrine object\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */ (function() {\n    \"use strict\";\n    var typed, utility, jsdoc, esutils, hasOwnProperty;\n    esutils = __webpack_require__(/*! esutils */ \"(rsc)/./node_modules/esutils/lib/utils.js\");\n    typed = __webpack_require__(/*! ./typed */ \"(rsc)/./node_modules/doctrine/lib/typed.js\");\n    utility = __webpack_require__(/*! ./utility */ \"(rsc)/./node_modules/doctrine/lib/utility.js\");\n    function sliceSource(source, index, last) {\n        return source.slice(index, last);\n    }\n    hasOwnProperty = function() {\n        var func = Object.prototype.hasOwnProperty;\n        return function hasOwnProperty(obj, name) {\n            return func.call(obj, name);\n        };\n    }();\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for(key in obj){\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    function isASCIIAlphanumeric(ch) {\n        return ch >= 0x61 /* 'a' */  && ch <= 0x7A /* 'z' */  || ch >= 0x41 /* 'A' */  && ch <= 0x5A /* 'Z' */  || ch >= 0x30 /* '0' */  && ch <= 0x39 /* '9' */ ;\n    }\n    function isParamTitle(title) {\n        return title === \"param\" || title === \"argument\" || title === \"arg\";\n    }\n    function isReturnTitle(title) {\n        return title === \"return\" || title === \"returns\";\n    }\n    function isProperty(title) {\n        return title === \"property\" || title === \"prop\";\n    }\n    function isNameParameterRequired(title) {\n        return isParamTitle(title) || isProperty(title) || title === \"alias\" || title === \"this\" || title === \"mixes\" || title === \"requires\";\n    }\n    function isAllowedName(title) {\n        return isNameParameterRequired(title) || title === \"const\" || title === \"constant\";\n    }\n    function isAllowedNested(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n    function isAllowedOptional(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n    function isTypeParameterRequired(title) {\n        return isParamTitle(title) || isReturnTitle(title) || title === \"define\" || title === \"enum\" || title === \"implements\" || title === \"this\" || title === \"type\" || title === \"typedef\" || isProperty(title);\n    }\n    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\n    // This would require changes to 'parseType'\n    function isAllowedType(title) {\n        return isTypeParameterRequired(title) || title === \"throws\" || title === \"const\" || title === \"constant\" || title === \"namespace\" || title === \"member\" || title === \"var\" || title === \"module\" || title === \"constructor\" || title === \"class\" || title === \"extends\" || title === \"augments\" || title === \"public\" || title === \"private\" || title === \"protected\";\n    }\n    // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\n    var WHITESPACE = \"[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]\";\n    var STAR_MATCHER = \"(\" + WHITESPACE + \"*(?:\\\\*\" + WHITESPACE + \"?)?)(.+|[\\r\\n\\u2028\\u2029])\";\n    function unwrapComment(doc) {\n        // JSDoc comment is following form\n        //   /**\n        //    * .......\n        //    */\n        return doc.// remove /**\n        replace(/^\\/\\*\\*?/, \"\").// remove */\n        replace(/\\*\\/$/, \"\").// remove ' * ' at the beginning of a line\n        replace(new RegExp(STAR_MATCHER, \"g\"), \"$2\").// remove trailing whitespace\n        replace(/\\s*$/, \"\");\n    }\n    /**\n     * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\n     * @param {string} originalSource The original wrapped comment\n     * @param {number} unwrappedIndex The index of a character in the unwrapped string\n     * @returns {number} The index of the corresponding character in the original wrapped string\n     */ function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\n        var replacedSource = originalSource.replace(/^\\/\\*\\*?/, \"\");\n        var numSkippedChars = 0;\n        var matcher = new RegExp(STAR_MATCHER, \"g\");\n        var match;\n        while(match = matcher.exec(replacedSource)){\n            numSkippedChars += match[1].length;\n            if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\n                return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\n            }\n        }\n        return originalSource.replace(/\\*\\/$/, \"\").replace(/\\s*$/, \"\").length;\n    }\n    // JSDoc Tag Parser\n    (function(exports1) {\n        var Rules, index, lineNumber, length, source, originalSource, recoverable, sloppy, strict;\n        function advance() {\n            var ch = source.charCodeAt(index);\n            index += 1;\n            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D /* '\\r' */  && source.charCodeAt(index) === 0x0A /* '\\n' */ )) {\n                lineNumber += 1;\n            }\n            return String.fromCharCode(ch);\n        }\n        function scanTitle() {\n            var title = \"\";\n            // waste '@'\n            advance();\n            while(index < length && isASCIIAlphanumeric(source.charCodeAt(index))){\n                title += advance();\n            }\n            return title;\n        }\n        function seekContent() {\n            var ch, waiting, last = index;\n            waiting = false;\n            while(last < length){\n                ch = source.charCodeAt(last);\n                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D /* '\\r' */  && source.charCodeAt(last + 1) === 0x0A /* '\\n' */ )) {\n                    waiting = true;\n                } else if (waiting) {\n                    if (ch === 0x40 /* '@' */ ) {\n                        break;\n                    }\n                    if (!esutils.code.isWhiteSpace(ch)) {\n                        waiting = false;\n                    }\n                }\n                last += 1;\n            }\n            return last;\n        }\n        // type expression may have nest brace, such as,\n        // { { ok: string } }\n        //\n        // therefore, scanning type expression with balancing braces.\n        function parseType(title, last, addRange) {\n            var ch, brace, type, startIndex, direct = false;\n            // search '{'\n            while(index < last){\n                ch = source.charCodeAt(index);\n                if (esutils.code.isWhiteSpace(ch)) {\n                    advance();\n                } else if (ch === 0x7B /* '{' */ ) {\n                    advance();\n                    break;\n                } else {\n                    // this is direct pattern\n                    direct = true;\n                    break;\n                }\n            }\n            if (direct) {\n                return null;\n            }\n            // type expression { is found\n            brace = 1;\n            type = \"\";\n            while(index < last){\n                ch = source.charCodeAt(index);\n                if (esutils.code.isLineTerminator(ch)) {\n                    advance();\n                } else {\n                    if (ch === 0x7D /* '}' */ ) {\n                        brace -= 1;\n                        if (brace === 0) {\n                            advance();\n                            break;\n                        }\n                    } else if (ch === 0x7B /* '{' */ ) {\n                        brace += 1;\n                    }\n                    if (type === \"\") {\n                        startIndex = index;\n                    }\n                    type += advance();\n                }\n            }\n            if (brace !== 0) {\n                // braces is not balanced\n                return utility.throwError(\"Braces are not balanced\");\n            }\n            if (isAllowedOptional(title)) {\n                return typed.parseParamType(type, {\n                    startIndex: convertIndex(startIndex),\n                    range: addRange\n                });\n            }\n            return typed.parseType(type, {\n                startIndex: convertIndex(startIndex),\n                range: addRange\n            });\n        }\n        function scanIdentifier(last) {\n            var identifier;\n            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\n                return null;\n            }\n            identifier = advance();\n            while(index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))){\n                identifier += advance();\n            }\n            return identifier;\n        }\n        function skipWhiteSpace(last) {\n            while(index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))){\n                advance();\n            }\n        }\n        function parseName(last, allowBrackets, allowNestedParams) {\n            var name = \"\", useBrackets, insideString;\n            skipWhiteSpace(last);\n            if (index >= last) {\n                return null;\n            }\n            if (source.charCodeAt(index) === 0x5B /* '[' */ ) {\n                if (allowBrackets) {\n                    useBrackets = true;\n                    name = advance();\n                } else {\n                    return null;\n                }\n            }\n            name += scanIdentifier(last);\n            if (allowNestedParams) {\n                if (source.charCodeAt(index) === 0x3A /* ':' */  && (name === \"module\" || name === \"external\" || name === \"event\")) {\n                    name += advance();\n                    name += scanIdentifier(last);\n                }\n                if (source.charCodeAt(index) === 0x5B /* '[' */  && source.charCodeAt(index + 1) === 0x5D /* ']' */ ) {\n                    name += advance();\n                    name += advance();\n                }\n                while(source.charCodeAt(index) === 0x2E /* '.' */  || source.charCodeAt(index) === 0x2F /* '/' */  || source.charCodeAt(index) === 0x23 /* '#' */  || source.charCodeAt(index) === 0x2D /* '-' */  || source.charCodeAt(index) === 0x7E /* '~' */ ){\n                    name += advance();\n                    name += scanIdentifier(last);\n                }\n            }\n            if (useBrackets) {\n                skipWhiteSpace(last);\n                // do we have a default value for this?\n                if (source.charCodeAt(index) === 0x3D /* '=' */ ) {\n                    // consume the '='' symbol\n                    name += advance();\n                    skipWhiteSpace(last);\n                    var ch;\n                    var bracketDepth = 1;\n                    // scan in the default value\n                    while(index < last){\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isWhiteSpace(ch)) {\n                            if (!insideString) {\n                                skipWhiteSpace(last);\n                                ch = source.charCodeAt(index);\n                            }\n                        }\n                        if (ch === 0x27 /* ''' */ ) {\n                            if (!insideString) {\n                                insideString = \"'\";\n                            } else {\n                                if (insideString === \"'\") {\n                                    insideString = \"\";\n                                }\n                            }\n                        }\n                        if (ch === 0x22 /* '\"' */ ) {\n                            if (!insideString) {\n                                insideString = '\"';\n                            } else {\n                                if (insideString === '\"') {\n                                    insideString = \"\";\n                                }\n                            }\n                        }\n                        if (ch === 0x5B /* '[' */ ) {\n                            bracketDepth++;\n                        } else if (ch === 0x5D /* ']' */  && --bracketDepth === 0) {\n                            break;\n                        }\n                        name += advance();\n                    }\n                }\n                skipWhiteSpace(last);\n                if (index >= last || source.charCodeAt(index) !== 0x5D /* ']' */ ) {\n                    // we never found a closing ']'\n                    return null;\n                }\n                // collect the last ']'\n                name += advance();\n            }\n            return name;\n        }\n        function skipToTag() {\n            while(index < length && source.charCodeAt(index) !== 0x40 /* '@' */ ){\n                advance();\n            }\n            if (index >= length) {\n                return false;\n            }\n            utility.assert(source.charCodeAt(index) === 0x40 /* '@' */ );\n            return true;\n        }\n        function convertIndex(rangeIndex) {\n            if (source === originalSource) {\n                return rangeIndex;\n            }\n            return convertUnwrappedCommentIndex(originalSource, rangeIndex);\n        }\n        function TagParser(options, title) {\n            this._options = options;\n            this._title = title.toLowerCase();\n            this._tag = {\n                title: title,\n                description: null\n            };\n            if (this._options.lineNumbers) {\n                this._tag.lineNumber = lineNumber;\n            }\n            this._first = index - title.length - 1;\n            this._last = 0;\n            // space to save special information for title parsers.\n            this._extra = {};\n        }\n        // addError(err, ...)\n        TagParser.prototype.addError = function addError(errorText) {\n            var args = Array.prototype.slice.call(arguments, 1), msg = errorText.replace(/%(\\d)/g, function(whole, index) {\n                utility.assert(index < args.length, \"Message reference must be in range\");\n                return args[index];\n            });\n            if (!this._tag.errors) {\n                this._tag.errors = [];\n            }\n            if (strict) {\n                utility.throwError(msg);\n            }\n            this._tag.errors.push(msg);\n            return recoverable;\n        };\n        TagParser.prototype.parseType = function() {\n            // type required titles\n            if (isTypeParameterRequired(this._title)) {\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                    if (!this._tag.type) {\n                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\n                            if (!this.addError(\"Missing or invalid tag type\")) {\n                                return false;\n                            }\n                        }\n                    }\n                } catch (error) {\n                    this._tag.type = null;\n                    if (!this.addError(error.message)) {\n                        return false;\n                    }\n                }\n            } else if (isAllowedType(this._title)) {\n                // optional types\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                } catch (e) {\n                //For optional types, lets drop the thrown error when we hit the end of the file\n                }\n            }\n            return true;\n        };\n        TagParser.prototype._parseNamePath = function(optional) {\n            var name;\n            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\n            if (!name) {\n                if (!optional) {\n                    if (!this.addError(\"Missing or invalid tag name\")) {\n                        return false;\n                    }\n                }\n            }\n            this._tag.name = name;\n            return true;\n        };\n        TagParser.prototype.parseNamePath = function() {\n            return this._parseNamePath(false);\n        };\n        TagParser.prototype.parseNamePathOptional = function() {\n            return this._parseNamePath(true);\n        };\n        TagParser.prototype.parseName = function() {\n            var assign, name;\n            // param, property requires name\n            if (isAllowedName(this._title)) {\n                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\n                if (!this._tag.name) {\n                    if (!isNameParameterRequired(this._title)) {\n                        return true;\n                    }\n                    // it's possible the name has already been parsed but interpreted as a type\n                    // it's also possible this is a sloppy declaration, in which case it will be\n                    // fixed at the end\n                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\n                        this._extra.name = this._tag.type;\n                        this._tag.name = this._tag.type.name;\n                        this._tag.type = null;\n                    } else {\n                        if (!this.addError(\"Missing or invalid tag name\")) {\n                            return false;\n                        }\n                    }\n                } else {\n                    name = this._tag.name;\n                    if (name.charAt(0) === \"[\" && name.charAt(name.length - 1) === \"]\") {\n                        // extract the default value if there is one\n                        // example: @param {string} [somebody=John Doe] description\n                        assign = name.substring(1, name.length - 1).split(\"=\");\n                        if (assign.length > 1) {\n                            this._tag[\"default\"] = assign.slice(1).join(\"=\");\n                        }\n                        this._tag.name = assign[0];\n                        // convert to an optional type\n                        if (this._tag.type && this._tag.type.type !== \"OptionalType\") {\n                            this._tag.type = {\n                                type: \"OptionalType\",\n                                expression: this._tag.type\n                            };\n                        }\n                    }\n                }\n            }\n            return true;\n        };\n        TagParser.prototype.parseDescription = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            if (description) {\n                if (/^-\\s+/.test(description)) {\n                    description = description.substring(2);\n                }\n                this._tag.description = description;\n            }\n            return true;\n        };\n        TagParser.prototype.parseCaption = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            var captionStartTag = \"<caption>\";\n            var captionEndTag = \"</caption>\";\n            var captionStart = description.indexOf(captionStartTag);\n            var captionEnd = description.indexOf(captionEndTag);\n            if (captionStart >= 0 && captionEnd >= 0) {\n                this._tag.caption = description.substring(captionStart + captionStartTag.length, captionEnd).trim();\n                this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\n            } else {\n                this._tag.description = description;\n            }\n            return true;\n        };\n        TagParser.prototype.parseKind = function parseKind() {\n            var kind, kinds;\n            kinds = {\n                \"class\": true,\n                \"constant\": true,\n                \"event\": true,\n                \"external\": true,\n                \"file\": true,\n                \"function\": true,\n                \"member\": true,\n                \"mixin\": true,\n                \"module\": true,\n                \"namespace\": true,\n                \"typedef\": true\n            };\n            kind = sliceSource(source, index, this._last).trim();\n            this._tag.kind = kind;\n            if (!hasOwnProperty(kinds, kind)) {\n                if (!this.addError(\"Invalid kind name '%0'\", kind)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        TagParser.prototype.parseAccess = function parseAccess() {\n            var access;\n            access = sliceSource(source, index, this._last).trim();\n            this._tag.access = access;\n            if (access !== \"private\" && access !== \"protected\" && access !== \"public\") {\n                if (!this.addError(\"Invalid access name '%0'\", access)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        TagParser.prototype.parseThis = function parseThis() {\n            // this name may be a name expression (e.g. {foo.bar}),\n            // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\n            var value = sliceSource(source, index, this._last).trim();\n            if (value && value.charAt(0) === \"{\") {\n                var gotType = this.parseType();\n                if (gotType && this._tag.type.type === \"NameExpression\" || this._tag.type.type === \"UnionType\") {\n                    this._tag.name = this._tag.type.name;\n                    return true;\n                } else {\n                    return this.addError(\"Invalid name for this\");\n                }\n            } else {\n                return this.parseNamePath();\n            }\n        };\n        TagParser.prototype.parseVariation = function parseVariation() {\n            var variation, text;\n            text = sliceSource(source, index, this._last).trim();\n            variation = parseFloat(text, 10);\n            this._tag.variation = variation;\n            if (isNaN(variation)) {\n                if (!this.addError(\"Invalid variation '%0'\", text)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        TagParser.prototype.ensureEnd = function() {\n            var shouldBeEmpty = sliceSource(source, index, this._last).trim();\n            if (shouldBeEmpty) {\n                if (!this.addError(\"Unknown content '%0'\", shouldBeEmpty)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        TagParser.prototype.epilogue = function epilogue() {\n            var description;\n            description = this._tag.description;\n            // un-fix potentially sloppy declaration\n            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === \"[\") {\n                this._tag.type = this._extra.name;\n                if (!this._tag.name) {\n                    this._tag.name = undefined;\n                }\n                if (!sloppy) {\n                    if (!this.addError(\"Missing or invalid tag name\")) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        Rules = {\n            // http://usejsdoc.org/tags-access.html\n            \"access\": [\n                \"parseAccess\"\n            ],\n            // http://usejsdoc.org/tags-alias.html\n            \"alias\": [\n                \"parseNamePath\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-augments.html\n            \"augments\": [\n                \"parseType\",\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-constructor.html\n            \"constructor\": [\n                \"parseType\",\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // Synonym: http://usejsdoc.org/tags-constructor.html\n            \"class\": [\n                \"parseType\",\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // Synonym: http://usejsdoc.org/tags-extends.html\n            \"extends\": [\n                \"parseType\",\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-example.html\n            \"example\": [\n                \"parseCaption\"\n            ],\n            // http://usejsdoc.org/tags-deprecated.html\n            \"deprecated\": [\n                \"parseDescription\"\n            ],\n            // http://usejsdoc.org/tags-global.html\n            \"global\": [\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-inner.html\n            \"inner\": [\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-instance.html\n            \"instance\": [\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-kind.html\n            \"kind\": [\n                \"parseKind\"\n            ],\n            // http://usejsdoc.org/tags-mixes.html\n            \"mixes\": [\n                \"parseNamePath\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-mixin.html\n            \"mixin\": [\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-member.html\n            \"member\": [\n                \"parseType\",\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-method.html\n            \"method\": [\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-module.html\n            \"module\": [\n                \"parseType\",\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            \"func\": [\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            \"function\": [\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // Synonym: http://usejsdoc.org/tags-member.html\n            \"var\": [\n                \"parseType\",\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-name.html\n            \"name\": [\n                \"parseNamePath\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-namespace.html\n            \"namespace\": [\n                \"parseType\",\n                \"parseNamePathOptional\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-private.html\n            \"private\": [\n                \"parseType\",\n                \"parseDescription\"\n            ],\n            // http://usejsdoc.org/tags-protected.html\n            \"protected\": [\n                \"parseType\",\n                \"parseDescription\"\n            ],\n            // http://usejsdoc.org/tags-public.html\n            \"public\": [\n                \"parseType\",\n                \"parseDescription\"\n            ],\n            // http://usejsdoc.org/tags-readonly.html\n            \"readonly\": [\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-requires.html\n            \"requires\": [\n                \"parseNamePath\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-since.html\n            \"since\": [\n                \"parseDescription\"\n            ],\n            // http://usejsdoc.org/tags-static.html\n            \"static\": [\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-summary.html\n            \"summary\": [\n                \"parseDescription\"\n            ],\n            // http://usejsdoc.org/tags-this.html\n            \"this\": [\n                \"parseThis\",\n                \"ensureEnd\"\n            ],\n            // http://usejsdoc.org/tags-todo.html\n            \"todo\": [\n                \"parseDescription\"\n            ],\n            // http://usejsdoc.org/tags-typedef.html\n            \"typedef\": [\n                \"parseType\",\n                \"parseNamePathOptional\"\n            ],\n            // http://usejsdoc.org/tags-variation.html\n            \"variation\": [\n                \"parseVariation\"\n            ],\n            // http://usejsdoc.org/tags-version.html\n            \"version\": [\n                \"parseDescription\"\n            ]\n        };\n        TagParser.prototype.parse = function parse() {\n            var i, iz, sequences, method;\n            // empty title\n            if (!this._title) {\n                if (!this.addError(\"Missing or invalid title\")) {\n                    return null;\n                }\n            }\n            // Seek to content last index.\n            this._last = seekContent(this._title);\n            if (this._options.range) {\n                this._tag.range = [\n                    this._first,\n                    source.slice(0, this._last).replace(/\\s*$/, \"\").length\n                ].map(convertIndex);\n            }\n            if (hasOwnProperty(Rules, this._title)) {\n                sequences = Rules[this._title];\n            } else {\n                // default sequences\n                sequences = [\n                    \"parseType\",\n                    \"parseName\",\n                    \"parseDescription\",\n                    \"epilogue\"\n                ];\n            }\n            for(i = 0, iz = sequences.length; i < iz; ++i){\n                method = sequences[i];\n                if (!this[method]()) {\n                    return null;\n                }\n            }\n            return this._tag;\n        };\n        function parseTag(options) {\n            var title, parser, tag;\n            // skip to tag\n            if (!skipToTag()) {\n                return null;\n            }\n            // scan title\n            title = scanTitle();\n            // construct tag parser\n            parser = new TagParser(options, title);\n            tag = parser.parse();\n            // Seek global index to end of this tag.\n            while(index < parser._last){\n                advance();\n            }\n            return tag;\n        }\n        //\n        // Parse JSDoc\n        //\n        function scanJSDocDescription(preserveWhitespace) {\n            var description = \"\", ch, atAllowed;\n            atAllowed = true;\n            while(index < length){\n                ch = source.charCodeAt(index);\n                if (atAllowed && ch === 0x40 /* '@' */ ) {\n                    break;\n                }\n                if (esutils.code.isLineTerminator(ch)) {\n                    atAllowed = true;\n                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\n                    atAllowed = false;\n                }\n                description += advance();\n            }\n            return preserveWhitespace ? description : description.trim();\n        }\n        function parse(comment, options) {\n            var tags = [], tag, description, interestingTags, i, iz;\n            if (options === undefined) {\n                options = {};\n            }\n            if (typeof options.unwrap === \"boolean\" && options.unwrap) {\n                source = unwrapComment(comment);\n            } else {\n                source = comment;\n            }\n            originalSource = comment;\n            // array of relevant tags\n            if (options.tags) {\n                if (Array.isArray(options.tags)) {\n                    interestingTags = {};\n                    for(i = 0, iz = options.tags.length; i < iz; i++){\n                        if (typeof options.tags[i] === \"string\") {\n                            interestingTags[options.tags[i]] = true;\n                        } else {\n                            utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                        }\n                    }\n                } else {\n                    utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                }\n            }\n            length = source.length;\n            index = 0;\n            lineNumber = 0;\n            recoverable = options.recoverable;\n            sloppy = options.sloppy;\n            strict = options.strict;\n            description = scanJSDocDescription(options.preserveWhitespace);\n            while(true){\n                tag = parseTag(options);\n                if (!tag) {\n                    break;\n                }\n                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\n                    tags.push(tag);\n                }\n            }\n            return {\n                description: description,\n                tags: tags\n            };\n        }\n        exports1.parse = parse;\n    })(jsdoc = {});\n    exports.version = utility.VERSION;\n    exports.parse = jsdoc.parse;\n    exports.parseType = typed.parseType;\n    exports.parseParamType = typed.parseParamType;\n    exports.unwrapComment = unwrapComment;\n    exports.Syntax = shallowCopy(typed.Syntax);\n    exports.Error = utility.DoctrineError;\n    exports.type = {\n        Syntax: exports.Syntax,\n        parseType: typed.parseType,\n        parseParamType: typed.parseParamType,\n        stringify: typed.stringify\n    };\n})(); /* vim: set sw=4 ts=4 et tw=80 : */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jdHJpbmUvbGliL2RvY3RyaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBRUE7SUFDRztJQUVBLElBQUlBLE9BQ0FDLFNBQ0FDLE9BQ0FDLFNBQ0FDO0lBRUpELFVBQVVFLG1CQUFPQSxDQUFDO0lBQ2xCTCxRQUFRSyxtQkFBT0EsQ0FBQztJQUNoQkosVUFBVUksbUJBQU9BLENBQUM7SUFFbEIsU0FBU0MsWUFBWUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUk7UUFDcEMsT0FBT0YsT0FBT0csS0FBSyxDQUFDRixPQUFPQztJQUMvQjtJQUVBTCxpQkFBa0I7UUFDZCxJQUFJTyxPQUFPQyxPQUFPQyxTQUFTLENBQUNULGNBQWM7UUFDMUMsT0FBTyxTQUFTQSxlQUFlVSxHQUFHLEVBQUVDLElBQUk7WUFDcEMsT0FBT0osS0FBS0ssSUFBSSxDQUFDRixLQUFLQztRQUMxQjtJQUNKO0lBQ0EsU0FBU0UsWUFBWUgsR0FBRztRQUNwQixJQUFJSSxNQUFNLENBQUMsR0FBR0M7UUFDZCxJQUFLQSxPQUFPTCxJQUFLO1lBQ2IsSUFBSUEsSUFBSVYsY0FBYyxDQUFDZSxNQUFNO2dCQUN6QkQsR0FBRyxDQUFDQyxJQUFJLEdBQUdMLEdBQUcsQ0FBQ0ssSUFBSTtZQUN2QjtRQUNKO1FBQ0EsT0FBT0Q7SUFDWDtJQUVBLFNBQVNFLG9CQUFvQkMsRUFBRTtRQUMzQixPQUFPLE1BQU8sS0FBTSxPQUFPLE9BQU1BLE1BQU0sS0FBTSxPQUFPLE9BQy9DQSxNQUFNLEtBQU0sT0FBTyxPQUFNQSxNQUFNLEtBQU0sT0FBTyxPQUM1Q0EsTUFBTSxLQUFNLE9BQU8sT0FBTUEsTUFBTSxLQUFNLE9BQU87SUFDckQ7SUFFQSxTQUFTQyxhQUFhQyxLQUFLO1FBQ3ZCLE9BQU9BLFVBQVUsV0FBV0EsVUFBVSxjQUFjQSxVQUFVO0lBQ2xFO0lBRUEsU0FBU0MsY0FBY0QsS0FBSztRQUN4QixPQUFPQSxVQUFVLFlBQVlBLFVBQVU7SUFDM0M7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QWM7UUFDcENtRyxXQUFXekssTUFBTXlLLFNBQVM7SUFDOUI7QUFDSixNQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25hbnRlcy1wdWJsaWMtZGF0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvZG9jdHJpbmUvbGliL2RvY3RyaW5lLmpzP2ExYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEBmaWxlb3ZlcnZpZXcgTWFpbiBEb2N0cmluZSBvYmplY3RcbiAqIEBhdXRob3IgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICogQGF1dGhvciBEYW4gVGFvIDxkYW5pZWwudGFvQGdtYWlsLmNvbT5cbiAqIEBhdXRob3IgQW5kcmV3IEVpc2VuYmVyZyA8YW5kcmV3QGVpc2VuYmVyZy5hcz5cbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciB0eXBlZCxcbiAgICAgICAgdXRpbGl0eSxcbiAgICAgICAganNkb2MsXG4gICAgICAgIGVzdXRpbHMsXG4gICAgICAgIGhhc093blByb3BlcnR5O1xuXG4gICAgZXN1dGlscyA9IHJlcXVpcmUoJ2VzdXRpbHMnKTtcbiAgICB0eXBlZCA9IHJlcXVpcmUoJy4vdHlwZWQnKTtcbiAgICB1dGlsaXR5ID0gcmVxdWlyZSgnLi91dGlsaXR5Jyk7XG5cbiAgICBmdW5jdGlvbiBzbGljZVNvdXJjZShzb3VyY2UsIGluZGV4LCBsYXN0KSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoaW5kZXgsIGxhc3QpO1xuICAgIH1cblxuICAgIGhhc093blByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKG9iaiwgbmFtZSk7XG4gICAgICAgIH07XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBzaGFsbG93Q29weShvYmopIHtcbiAgICAgICAgdmFyIHJldCA9IHt9LCBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQVNDSUlBbHBoYW51bWVyaWMoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA+PSAweDYxICAvKiAnYScgKi8gJiYgY2ggPD0gMHg3QSAgLyogJ3onICovKSB8fFxuICAgICAgICAgICAgKGNoID49IDB4NDEgIC8qICdBJyAqLyAmJiBjaCA8PSAweDVBICAvKiAnWicgKi8pIHx8XG4gICAgICAgICAgICAoY2ggPj0gMHgzMCAgLyogJzAnICovICYmIGNoIDw9IDB4MzkgIC8qICc5JyAqLyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQYXJhbVRpdGxlKHRpdGxlKSB7XG4gICAgICAgIHJldHVybiB0aXRsZSA9PT0gJ3BhcmFtJyB8fCB0aXRsZSA9PT0gJ2FyZ3VtZW50JyB8fCB0aXRsZSA9PT0gJ2FyZyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXR1cm5UaXRsZSh0aXRsZSkge1xuICAgICAgICByZXR1cm4gdGl0bGUgPT09ICdyZXR1cm4nIHx8IHRpdGxlID09PSAncmV0dXJucyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQcm9wZXJ0eSh0aXRsZSkge1xuICAgICAgICByZXR1cm4gdGl0bGUgPT09ICdwcm9wZXJ0eScgfHwgdGl0bGUgPT09ICdwcm9wJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc05hbWVQYXJhbWV0ZXJSZXF1aXJlZCh0aXRsZSkge1xuICAgICAgICByZXR1cm4gaXNQYXJhbVRpdGxlKHRpdGxlKSB8fCBpc1Byb3BlcnR5KHRpdGxlKSB8fFxuICAgICAgICAgICAgdGl0bGUgPT09ICdhbGlhcycgfHwgdGl0bGUgPT09ICd0aGlzJyB8fCB0aXRsZSA9PT0gJ21peGVzJyB8fCB0aXRsZSA9PT0gJ3JlcXVpcmVzJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FsbG93ZWROYW1lKHRpdGxlKSB7XG4gICAgICAgIHJldHVybiBpc05hbWVQYXJhbWV0ZXJSZXF1aXJlZCh0aXRsZSkgfHwgdGl0bGUgPT09ICdjb25zdCcgfHwgdGl0bGUgPT09ICdjb25zdGFudCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBbGxvd2VkTmVzdGVkKHRpdGxlKSB7XG4gICAgICAgIHJldHVybiBpc1Byb3BlcnR5KHRpdGxlKSB8fCBpc1BhcmFtVGl0bGUodGl0bGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWxsb3dlZE9wdGlvbmFsKHRpdGxlKSB7XG4gICAgICAgIHJldHVybiBpc1Byb3BlcnR5KHRpdGxlKSB8fCBpc1BhcmFtVGl0bGUodGl0bGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVHlwZVBhcmFtZXRlclJlcXVpcmVkKHRpdGxlKSB7XG4gICAgICAgIHJldHVybiBpc1BhcmFtVGl0bGUodGl0bGUpIHx8IGlzUmV0dXJuVGl0bGUodGl0bGUpIHx8XG4gICAgICAgICAgICB0aXRsZSA9PT0gJ2RlZmluZScgfHwgdGl0bGUgPT09ICdlbnVtJyB8fFxuICAgICAgICAgICAgdGl0bGUgPT09ICdpbXBsZW1lbnRzJyB8fCB0aXRsZSA9PT0gJ3RoaXMnIHx8XG4gICAgICAgICAgICB0aXRsZSA9PT0gJ3R5cGUnIHx8IHRpdGxlID09PSAndHlwZWRlZicgfHwgaXNQcm9wZXJ0eSh0aXRsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29uc2lkZXIgZGVwcmVjYXRpb24gaW5zdGVhZCB1c2luZyAnaXNUeXBlUGFyYW1ldGVyUmVxdWlyZWQnIGFuZCAnUnVsZXMnIGRlY2xhcmF0aW9uIHRvIHBpY2sgd2hlbiBhIHR5cGUgaXMgb3B0aW9uYWwvcmVxdWlyZWRcbiAgICAvLyBUaGlzIHdvdWxkIHJlcXVpcmUgY2hhbmdlcyB0byAncGFyc2VUeXBlJ1xuICAgIGZ1bmN0aW9uIGlzQWxsb3dlZFR5cGUodGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIGlzVHlwZVBhcmFtZXRlclJlcXVpcmVkKHRpdGxlKSB8fCB0aXRsZSA9PT0gJ3Rocm93cycgfHwgdGl0bGUgPT09ICdjb25zdCcgfHwgdGl0bGUgPT09ICdjb25zdGFudCcgfHxcbiAgICAgICAgICAgIHRpdGxlID09PSAnbmFtZXNwYWNlJyB8fCB0aXRsZSA9PT0gJ21lbWJlcicgfHwgdGl0bGUgPT09ICd2YXInIHx8IHRpdGxlID09PSAnbW9kdWxlJyB8fFxuICAgICAgICAgICAgdGl0bGUgPT09ICdjb25zdHJ1Y3RvcicgfHwgdGl0bGUgPT09ICdjbGFzcycgfHwgdGl0bGUgPT09ICdleHRlbmRzJyB8fCB0aXRsZSA9PT0gJ2F1Z21lbnRzJyB8fFxuICAgICAgICAgICAgdGl0bGUgPT09ICdwdWJsaWMnIHx8IHRpdGxlID09PSAncHJpdmF0ZScgfHwgdGl0bGUgPT09ICdwcm90ZWN0ZWQnO1xuICAgIH1cblxuICAgIC8vIEEgcmVnZXggY2hhcmFjdGVyIGNsYXNzIHRoYXQgY29udGFpbnMgYWxsIHdoaXRlc3BhY2UgZXhjZXB0IGxpbmVicmVhayBjaGFyYWN0ZXJzIChcXHIsIFxcbiwgXFx1MjAyOCwgXFx1MjAyOSlcbiAgICB2YXIgV0hJVEVTUEFDRSA9ICdbIFxcXFxmXFxcXHRcXFxcdlxcXFx1MDBhMFxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMC1cXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDBcXFxcdWZlZmZdJztcblxuICAgIHZhciBTVEFSX01BVENIRVIgPSAnKCcgKyBXSElURVNQQUNFICsgJyooPzpcXFxcKicgKyBXSElURVNQQUNFICsgJz8pPykoLit8W1xcclxcblxcdTIwMjhcXHUyMDI5XSknO1xuXG4gICAgZnVuY3Rpb24gdW53cmFwQ29tbWVudChkb2MpIHtcbiAgICAgICAgLy8gSlNEb2MgY29tbWVudCBpcyBmb2xsb3dpbmcgZm9ybVxuICAgICAgICAvLyAgIC8qKlxuICAgICAgICAvLyAgICAqIC4uLi4uLi5cbiAgICAgICAgLy8gICAgKi9cblxuICAgICAgICByZXR1cm4gZG9jLlxuICAgICAgICAgICAgLy8gcmVtb3ZlIC8qKlxuICAgICAgICAgICAgcmVwbGFjZSgvXlxcL1xcKlxcKj8vLCAnJykuXG4gICAgICAgICAgICAvLyByZW1vdmUgKi9cbiAgICAgICAgICAgIHJlcGxhY2UoL1xcKlxcLyQvLCAnJykuXG4gICAgICAgICAgICAvLyByZW1vdmUgJyAqICcgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGxpbmVcbiAgICAgICAgICAgIHJlcGxhY2UobmV3IFJlZ0V4cChTVEFSX01BVENIRVIsICdnJyksICckMicpLlxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHJlcGxhY2UoL1xccyokLywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIGluZGV4IGluIGFuIFwidW53cmFwcGVkXCIgSlNEb2MgY29tbWVudCB0byB0aGUgY29ycmVzcG9uZGluZyBpbmRleCBpbiB0aGUgb3JpZ2luYWwgXCJ3cmFwcGVkXCIgdmVyc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5hbFNvdXJjZSBUaGUgb3JpZ2luYWwgd3JhcHBlZCBjb21tZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVud3JhcHBlZEluZGV4IFRoZSBpbmRleCBvZiBhIGNoYXJhY3RlciBpbiB0aGUgdW53cmFwcGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXIgaW4gdGhlIG9yaWdpbmFsIHdyYXBwZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydFVud3JhcHBlZENvbW1lbnRJbmRleChvcmlnaW5hbFNvdXJjZSwgdW53cmFwcGVkSW5kZXgpIHtcbiAgICAgICAgdmFyIHJlcGxhY2VkU291cmNlID0gb3JpZ2luYWxTb3VyY2UucmVwbGFjZSgvXlxcL1xcKlxcKj8vLCAnJyk7XG4gICAgICAgIHZhciBudW1Ta2lwcGVkQ2hhcnMgPSAwO1xuICAgICAgICB2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoU1RBUl9NQVRDSEVSLCAnZycpO1xuICAgICAgICB2YXIgbWF0Y2g7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IG1hdGNoZXIuZXhlYyhyZXBsYWNlZFNvdXJjZSkpKSB7XG4gICAgICAgICAgICBudW1Ta2lwcGVkQ2hhcnMgKz0gbWF0Y2hbMV0ubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggPiB1bndyYXBwZWRJbmRleCArIG51bVNraXBwZWRDaGFycykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bndyYXBwZWRJbmRleCArIG51bVNraXBwZWRDaGFycyArIG9yaWdpbmFsU291cmNlLmxlbmd0aCAtIHJlcGxhY2VkU291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFNvdXJjZS5yZXBsYWNlKC9cXCpcXC8kLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBKU0RvYyBUYWcgUGFyc2VyXG5cbiAgICAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAgICAgdmFyIFJ1bGVzLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICAgICAgICByZWNvdmVyYWJsZSxcbiAgICAgICAgICAgIHNsb3BweSxcbiAgICAgICAgICAgIHN0cmljdDtcblxuICAgICAgICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgICAgICAgdmFyIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjaCkgJiYgIShjaCA9PT0gMHgwRCAgLyogJ1xccicgKi8gJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDBBICAvKiAnXFxuJyAqLykpIHtcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzY2FuVGl0bGUoKSB7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIC8vIHdhc3RlICdAJ1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGggJiYgaXNBU0NJSUFscGhhbnVtZXJpYyhzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgKz0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZWVrQ29udGVudCgpIHtcbiAgICAgICAgICAgIHZhciBjaCwgd2FpdGluZywgbGFzdCA9IGluZGV4O1xuXG4gICAgICAgICAgICB3YWl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAobGFzdCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQobGFzdCk7XG4gICAgICAgICAgICAgICAgaWYgKGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGNoKSAmJiAhKGNoID09PSAweDBEICAvKiAnXFxyJyAqLyAmJiBzb3VyY2UuY2hhckNvZGVBdChsYXN0ICsgMSkgPT09IDB4MEEgIC8qICdcXG4nICovKSkge1xuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdhaXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDQwICAvKiAnQCcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHR5cGUgZXhwcmVzc2lvbiBtYXkgaGF2ZSBuZXN0IGJyYWNlLCBzdWNoIGFzLFxuICAgICAgICAvLyB7IHsgb2s6IHN0cmluZyB9IH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhlcmVmb3JlLCBzY2FubmluZyB0eXBlIGV4cHJlc3Npb24gd2l0aCBiYWxhbmNpbmcgYnJhY2VzLlxuICAgICAgICBmdW5jdGlvbiBwYXJzZVR5cGUodGl0bGUsIGxhc3QsIGFkZFJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgY2gsIGJyYWNlLCB0eXBlLCBzdGFydEluZGV4LCBkaXJlY3QgPSBmYWxzZTtcblxuXG4gICAgICAgICAgICAvLyBzZWFyY2ggJ3snXG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsYXN0KSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDdCICAvKiAneycgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGRpcmVjdCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAoZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHR5cGUgZXhwcmVzc2lvbiB7IGlzIGZvdW5kXG4gICAgICAgICAgICBicmFjZSA9IDE7XG4gICAgICAgICAgICB0eXBlID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsYXN0KSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDdEICAvKiAnfScgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYWNlIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4N0IgIC8qICd7JyAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2UgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eXBlICs9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChicmFjZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGJyYWNlcyBpcyBub3QgYmFsYW5jZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbGl0eS50aHJvd0Vycm9yKCdCcmFjZXMgYXJlIG5vdCBiYWxhbmNlZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBbGxvd2VkT3B0aW9uYWwodGl0bGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkLnBhcnNlUGFyYW1UeXBlKHR5cGUsIHtzdGFydEluZGV4OiBjb252ZXJ0SW5kZXgoc3RhcnRJbmRleCksIHJhbmdlOiBhZGRSYW5nZX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHlwZWQucGFyc2VUeXBlKHR5cGUsIHtzdGFydEluZGV4OiBjb252ZXJ0SW5kZXgoc3RhcnRJbmRleCksIHJhbmdlOiBhZGRSYW5nZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2NhbklkZW50aWZpZXIobGFzdCkge1xuICAgICAgICAgICAgdmFyIGlkZW50aWZpZXI7XG4gICAgICAgICAgICBpZiAoIWVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJTdGFydEVTNShzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpICYmICFzb3VyY2VbaW5kZXhdLm1hdGNoKC9bMC05XS8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZGVudGlmaWVyID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGFzdCAmJiBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydEVTNShzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciArPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNraXBXaGl0ZVNwYWNlKGxhc3QpIHtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxhc3QgJiYgKGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2Uoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSkge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTmFtZShsYXN0LCBhbGxvd0JyYWNrZXRzLCBhbGxvd05lc3RlZFBhcmFtcykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSAnJyxcbiAgICAgICAgICAgICAgICB1c2VCcmFja2V0cyxcbiAgICAgICAgICAgICAgICBpbnNpZGVTdHJpbmc7XG5cblxuICAgICAgICAgICAgc2tpcFdoaXRlU3BhY2UobGFzdCk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4NUIgIC8qICdbJyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0JyYWNrZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZUJyYWNrZXRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5hbWUgKz0gc2NhbklkZW50aWZpZXIobGFzdCk7XG5cbiAgICAgICAgICAgIGlmIChhbGxvd05lc3RlZFBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0EgLyogJzonICovICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPT09ICdtb2R1bGUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID09PSAnZXh0ZXJuYWwnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID09PSAnZXZlbnQnKSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSArPSBzY2FuSWRlbnRpZmllcihsYXN0KTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4NUIgIC8qICdbJyAqLyAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDVEICAvKiAnXScgKi8pe1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSArPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MkUgIC8qICcuJyAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDJGICAvKiAnLycgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgyMyAgLyogJyMnICovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MkQgIC8qICctJyAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDdFICAvKiAnficgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSArPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gc2NhbklkZW50aWZpZXIobGFzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXNlQnJhY2tldHMpIHtcbiAgICAgICAgICAgICAgICBza2lwV2hpdGVTcGFjZShsYXN0KTtcbiAgICAgICAgICAgICAgICAvLyBkbyB3ZSBoYXZlIGEgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcz9cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDNEICAvKiAnPScgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3VtZSB0aGUgJz0nJyBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgbmFtZSArPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNraXBXaGl0ZVNwYWNlKGxhc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJyYWNrZXREZXB0aCA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2NhbiBpbiB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnNpZGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFdoaXRlU3BhY2UobGFzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDI3IC8qICcnJyAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5zaWRlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVN0cmluZyA9ICdcXCcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNpZGVTdHJpbmcgPT09ICdcXCcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVTdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDIyIC8qICdcIicgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2lkZVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVTdHJpbmcgPSAnXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNpZGVTdHJpbmcgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVN0cmluZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4NUIgLyogJ1snICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2tldERlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDVEICAvKiAnXScgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWJyYWNrZXREZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNraXBXaGl0ZVNwYWNlKGxhc3QpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGxhc3QgfHwgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDVEICAvKiAnXScgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmV2ZXIgZm91bmQgYSBjbG9zaW5nICddJ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBsYXN0ICddJ1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNraXBUb1RhZygpIHtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NDAgIC8qICdAJyAqLykge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlsaXR5LmFzc2VydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4NDAgIC8qICdAJyAqLyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRJbmRleChyYW5nZUluZGV4KSB7XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSBvcmlnaW5hbFNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRVbndyYXBwZWRDb21tZW50SW5kZXgob3JpZ2luYWxTb3VyY2UsIHJhbmdlSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gVGFnUGFyc2VyKG9wdGlvbnMsIHRpdGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX3RpdGxlID0gdGl0bGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3RhZyA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5saW5lTnVtYmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhZy5saW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gaW5kZXggLSB0aXRsZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IDA7XG4gICAgICAgICAgICAvLyBzcGFjZSB0byBzYXZlIHNwZWNpYWwgaW5mb3JtYXRpb24gZm9yIHRpdGxlIHBhcnNlcnMuXG4gICAgICAgICAgICB0aGlzLl9leHRyYSA9IHsgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZEVycm9yKGVyciwgLi4uKVxuICAgICAgICBUYWdQYXJzZXIucHJvdG90eXBlLmFkZEVycm9yID0gZnVuY3Rpb24gYWRkRXJyb3IoZXJyb3JUZXh0KSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICAgICAgbXNnID0gZXJyb3JUZXh0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC8lKFxcZCkvZyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHdob2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbGl0eS5hc3NlcnQoaW5kZXggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fdGFnLmVycm9ycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhZy5lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICB1dGlsaXR5LnRocm93RXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RhZy5lcnJvcnMucHVzaChtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY292ZXJhYmxlO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRhZ1BhcnNlci5wcm90b3R5cGUucGFyc2VUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdHlwZSByZXF1aXJlZCB0aXRsZXNcbiAgICAgICAgICAgIGlmIChpc1R5cGVQYXJhbWV0ZXJSZXF1aXJlZCh0aGlzLl90aXRsZSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YWcudHlwZSA9IHBhcnNlVHlwZSh0aGlzLl90aXRsZSwgdGhpcy5fbGFzdCwgdGhpcy5fb3B0aW9ucy5yYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdGFnLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQYXJhbVRpdGxlKHRoaXMuX3RpdGxlKSAmJiAhaXNSZXR1cm5UaXRsZSh0aGlzLl90aXRsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWRkRXJyb3IoJ01pc3Npbmcgb3IgaW52YWxpZCB0YWcgdHlwZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YWcudHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hZGRFcnJvcihlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FsbG93ZWRUeXBlKHRoaXMuX3RpdGxlKSkge1xuICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsIHR5cGVzXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFnLnR5cGUgPSBwYXJzZVR5cGUodGhpcy5fdGl0bGUsIHRoaXMuX2xhc3QsIHRoaXMuX29wdGlvbnMucmFuZ2UpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9Gb3Igb3B0aW9uYWwgdHlwZXMsIGxldHMgZHJvcCB0aGUgdGhyb3duIGVycm9yIHdoZW4gd2UgaGl0IHRoZSBlbmQgb2YgdGhlIGZpbGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBUYWdQYXJzZXIucHJvdG90eXBlLl9wYXJzZU5hbWVQYXRoID0gZnVuY3Rpb24gKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSBwYXJzZU5hbWUodGhpcy5fbGFzdCwgc2xvcHB5ICYmIGlzQWxsb3dlZE9wdGlvbmFsKHRoaXMuX3RpdGxlKSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hZGRFcnJvcignTWlzc2luZyBvciBpbnZhbGlkIHRhZyBuYW1lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RhZy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRhZ1BhcnNlci5wcm90b3R5cGUucGFyc2VOYW1lUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZU5hbWVQYXRoKGZhbHNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBUYWdQYXJzZXIucHJvdG90eXBlLnBhcnNlTmFtZVBhdGhPcHRpb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZU5hbWVQYXRoKHRydWUpO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgVGFnUGFyc2VyLnByb3RvdHlwZS5wYXJzZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXNzaWduLCBuYW1lO1xuXG4gICAgICAgICAgICAvLyBwYXJhbSwgcHJvcGVydHkgcmVxdWlyZXMgbmFtZVxuICAgICAgICAgICAgaWYgKGlzQWxsb3dlZE5hbWUodGhpcy5fdGl0bGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFnLm5hbWUgPSBwYXJzZU5hbWUodGhpcy5fbGFzdCwgc2xvcHB5ICYmIGlzQWxsb3dlZE9wdGlvbmFsKHRoaXMuX3RpdGxlKSwgaXNBbGxvd2VkTmVzdGVkKHRoaXMuX3RpdGxlKSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90YWcubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFtZVBhcmFtZXRlclJlcXVpcmVkKHRoaXMuX3RpdGxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoZSBuYW1lIGhhcyBhbHJlYWR5IGJlZW4gcGFyc2VkIGJ1dCBpbnRlcnByZXRlZCBhcyBhIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBhbHNvIHBvc3NpYmxlIHRoaXMgaXMgYSBzbG9wcHkgZGVjbGFyYXRpb24sIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBmaXhlZCBhdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BhcmFtVGl0bGUodGhpcy5fdGl0bGUpICYmIHRoaXMuX3RhZy50eXBlICYmIHRoaXMuX3RhZy50eXBlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJhLm5hbWUgPSB0aGlzLl90YWcudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhZy5uYW1lID0gdGhpcy5fdGFnLnR5cGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhZy50eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hZGRFcnJvcignTWlzc2luZyBvciBpbnZhbGlkIHRhZyBuYW1lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5fdGFnLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gJ1snICYmIG5hbWUuY2hhckF0KG5hbWUubGVuZ3RoIC0gMSkgPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0cmFjdCB0aGUgZGVmYXVsdCB2YWx1ZSBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4YW1wbGU6IEBwYXJhbSB7c3RyaW5nfSBbc29tZWJvZHk9Sm9obiBEb2VdIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ24gPSBuYW1lLnN1YnN0cmluZygxLCBuYW1lLmxlbmd0aCAtIDEpLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNzaWduLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90YWdbJ2RlZmF1bHQnXSA9IGFzc2lnbi5zbGljZSgxKS5qb2luKCc9Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90YWcubmFtZSA9IGFzc2lnblswXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB0byBhbiBvcHRpb25hbCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGFnLnR5cGUgJiYgdGhpcy5fdGFnLnR5cGUudHlwZSAhPT0gJ09wdGlvbmFsVHlwZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90YWcudHlwZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ09wdGlvbmFsVHlwZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHRoaXMuX3RhZy50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBUYWdQYXJzZXIucHJvdG90eXBlLnBhcnNlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBwYXJzZURlc2NyaXB0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gc2xpY2VTb3VyY2Uoc291cmNlLCBpbmRleCwgdGhpcy5fbGFzdCkudHJpbSgpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgvXi1cXHMrLykudGVzdChkZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3RhZy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgVGFnUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcHRpb24gPSBmdW5jdGlvbiBwYXJzZURlc2NyaXB0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gc2xpY2VTb3VyY2Uoc291cmNlLCBpbmRleCwgdGhpcy5fbGFzdCkudHJpbSgpO1xuICAgICAgICAgICAgdmFyIGNhcHRpb25TdGFydFRhZyA9ICc8Y2FwdGlvbj4nO1xuICAgICAgICAgICAgdmFyIGNhcHRpb25FbmRUYWcgPSAnPC9jYXB0aW9uPic7XG4gICAgICAgICAgICB2YXIgY2FwdGlvblN0YXJ0ID0gZGVzY3JpcHRpb24uaW5kZXhPZihjYXB0aW9uU3RhcnRUYWcpO1xuICAgICAgICAgICAgdmFyIGNhcHRpb25FbmQgPSBkZXNjcmlwdGlvbi5pbmRleE9mKGNhcHRpb25FbmRUYWcpO1xuICAgICAgICAgICAgaWYgKGNhcHRpb25TdGFydCA+PSAwICYmIGNhcHRpb25FbmQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhZy5jYXB0aW9uID0gZGVzY3JpcHRpb24uc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBjYXB0aW9uU3RhcnQgKyBjYXB0aW9uU3RhcnRUYWcubGVuZ3RoLCBjYXB0aW9uRW5kKS50cmltKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFnLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24uc3Vic3RyaW5nKGNhcHRpb25FbmQgKyBjYXB0aW9uRW5kVGFnLmxlbmd0aCkudHJpbSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWcuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRhZ1BhcnNlci5wcm90b3R5cGUucGFyc2VLaW5kID0gZnVuY3Rpb24gcGFyc2VLaW5kKCkge1xuICAgICAgICAgICAgdmFyIGtpbmQsIGtpbmRzO1xuICAgICAgICAgICAga2luZHMgPSB7XG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnY29uc3RhbnQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdldmVudCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2V4dGVybmFsJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnbWVtYmVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnbWl4aW4nOiB0cnVlLFxuICAgICAgICAgICAgICAgICdtb2R1bGUnOiB0cnVlLFxuICAgICAgICAgICAgICAgICduYW1lc3BhY2UnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd0eXBlZGVmJzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGtpbmQgPSBzbGljZVNvdXJjZShzb3VyY2UsIGluZGV4LCB0aGlzLl9sYXN0KS50cmltKCk7XG4gICAgICAgICAgICB0aGlzLl90YWcua2luZCA9IGtpbmQ7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGtpbmRzLCBraW5kKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hZGRFcnJvcignSW52YWxpZCBraW5kIG5hbWUgXFwnJTBcXCcnLCBraW5kKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgVGFnUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFjY2VzcyA9IGZ1bmN0aW9uIHBhcnNlQWNjZXNzKCkge1xuICAgICAgICAgICAgdmFyIGFjY2VzcztcbiAgICAgICAgICAgIGFjY2VzcyA9IHNsaWNlU291cmNlKHNvdXJjZSwgaW5kZXgsIHRoaXMuX2xhc3QpLnRyaW0oKTtcbiAgICAgICAgICAgIHRoaXMuX3RhZy5hY2Nlc3MgPSBhY2Nlc3M7XG4gICAgICAgICAgICBpZiAoYWNjZXNzICE9PSAncHJpdmF0ZScgJiYgYWNjZXNzICE9PSAncHJvdGVjdGVkJyAmJiBhY2Nlc3MgIT09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFkZEVycm9yKCdJbnZhbGlkIGFjY2VzcyBuYW1lIFxcJyUwXFwnJywgYWNjZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgVGFnUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRoaXMgPSBmdW5jdGlvbiBwYXJzZVRoaXMoKSB7XG4gICAgICAgICAgICAvLyB0aGlzIG5hbWUgbWF5IGJlIGEgbmFtZSBleHByZXNzaW9uIChlLmcuIHtmb28uYmFyfSksXG4gICAgICAgICAgICAvLyBhbiB1bmlvbiAoZS5nLiB7Zm9vLmJhcnxmb28uYmF6fSkgb3IgYSBuYW1lIHBhdGggKGUuZy4gZm9vLmJhcilcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNsaWNlU291cmNlKHNvdXJjZSwgaW5kZXgsIHRoaXMuX2xhc3QpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jaGFyQXQoMCkgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIHZhciBnb3RUeXBlID0gdGhpcy5wYXJzZVR5cGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZ290VHlwZSAmJiB0aGlzLl90YWcudHlwZS50eXBlID09PSAnTmFtZUV4cHJlc3Npb24nIHx8IHRoaXMuX3RhZy50eXBlLnR5cGUgPT09ICdVbmlvblR5cGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhZy5uYW1lID0gdGhpcy5fdGFnLnR5cGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRXJyb3IoJ0ludmFsaWQgbmFtZSBmb3IgdGhpcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VOYW1lUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIFRhZ1BhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYXRpb24gPSBmdW5jdGlvbiBwYXJzZVZhcmlhdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YXJpYXRpb24sIHRleHQ7XG4gICAgICAgICAgICB0ZXh0ID0gc2xpY2VTb3VyY2Uoc291cmNlLCBpbmRleCwgdGhpcy5fbGFzdCkudHJpbSgpO1xuICAgICAgICAgICAgdmFyaWF0aW9uID0gcGFyc2VGbG9hdCh0ZXh0LCAxMCk7XG4gICAgICAgICAgICB0aGlzLl90YWcudmFyaWF0aW9uID0gdmFyaWF0aW9uO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHZhcmlhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWRkRXJyb3IoJ0ludmFsaWQgdmFyaWF0aW9uIFxcJyUwXFwnJywgdGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRhZ1BhcnNlci5wcm90b3R5cGUuZW5zdXJlRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNob3VsZEJlRW1wdHkgPSBzbGljZVNvdXJjZShzb3VyY2UsIGluZGV4LCB0aGlzLl9sYXN0KS50cmltKCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQmVFbXB0eSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hZGRFcnJvcignVW5rbm93biBjb250ZW50IFxcJyUwXFwnJywgc2hvdWxkQmVFbXB0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRhZ1BhcnNlci5wcm90b3R5cGUuZXBpbG9ndWUgPSBmdW5jdGlvbiBlcGlsb2d1ZSgpIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvbjtcblxuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSB0aGlzLl90YWcuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAvLyB1bi1maXggcG90ZW50aWFsbHkgc2xvcHB5IGRlY2xhcmF0aW9uXG4gICAgICAgICAgICBpZiAoaXNBbGxvd2VkT3B0aW9uYWwodGhpcy5fdGl0bGUpICYmICF0aGlzLl90YWcudHlwZSAmJiBkZXNjcmlwdGlvbiAmJiBkZXNjcmlwdGlvbi5jaGFyQXQoMCkgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhZy50eXBlID0gdGhpcy5fZXh0cmEubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RhZy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhZy5uYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghc2xvcHB5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hZGRFcnJvcignTWlzc2luZyBvciBpbnZhbGlkIHRhZyBuYW1lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgUnVsZXMgPSB7XG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtYWNjZXNzLmh0bWxcbiAgICAgICAgICAgICdhY2Nlc3MnOiBbJ3BhcnNlQWNjZXNzJ10sXG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtYWxpYXMuaHRtbFxuICAgICAgICAgICAgJ2FsaWFzJzogWydwYXJzZU5hbWVQYXRoJywgJ2Vuc3VyZUVuZCddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLWF1Z21lbnRzLmh0bWxcbiAgICAgICAgICAgICdhdWdtZW50cyc6IFsncGFyc2VUeXBlJywgJ3BhcnNlTmFtZVBhdGhPcHRpb25hbCcsICdlbnN1cmVFbmQnXSxcbiAgICAgICAgICAgIC8vIGh0dHA6Ly91c2Vqc2RvYy5vcmcvdGFncy1jb25zdHJ1Y3Rvci5odG1sXG4gICAgICAgICAgICAnY29uc3RydWN0b3InOiBbJ3BhcnNlVHlwZScsICdwYXJzZU5hbWVQYXRoT3B0aW9uYWwnLCAnZW5zdXJlRW5kJ10sXG4gICAgICAgICAgICAvLyBTeW5vbnltOiBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtY29uc3RydWN0b3IuaHRtbFxuICAgICAgICAgICAgJ2NsYXNzJzogWydwYXJzZVR5cGUnLCAncGFyc2VOYW1lUGF0aE9wdGlvbmFsJywgJ2Vuc3VyZUVuZCddLFxuICAgICAgICAgICAgLy8gU3lub255bTogaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLWV4dGVuZHMuaHRtbFxuICAgICAgICAgICAgJ2V4dGVuZHMnOiBbJ3BhcnNlVHlwZScsICdwYXJzZU5hbWVQYXRoT3B0aW9uYWwnLCAnZW5zdXJlRW5kJ10sXG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtZXhhbXBsZS5odG1sXG4gICAgICAgICAgICAnZXhhbXBsZSc6IFsncGFyc2VDYXB0aW9uJ10sXG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtZGVwcmVjYXRlZC5odG1sXG4gICAgICAgICAgICAnZGVwcmVjYXRlZCc6IFsncGFyc2VEZXNjcmlwdGlvbiddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLWdsb2JhbC5odG1sXG4gICAgICAgICAgICAnZ2xvYmFsJzogWydlbnN1cmVFbmQnXSxcbiAgICAgICAgICAgIC8vIGh0dHA6Ly91c2Vqc2RvYy5vcmcvdGFncy1pbm5lci5odG1sXG4gICAgICAgICAgICAnaW5uZXInOiBbJ2Vuc3VyZUVuZCddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLWluc3RhbmNlLmh0bWxcbiAgICAgICAgICAgICdpbnN0YW5jZSc6IFsnZW5zdXJlRW5kJ10sXG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3Mta2luZC5odG1sXG4gICAgICAgICAgICAna2luZCc6IFsncGFyc2VLaW5kJ10sXG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtbWl4ZXMuaHRtbFxuICAgICAgICAgICAgJ21peGVzJzogWydwYXJzZU5hbWVQYXRoJywgJ2Vuc3VyZUVuZCddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLW1peGluLmh0bWxcbiAgICAgICAgICAgICdtaXhpbic6IFsncGFyc2VOYW1lUGF0aE9wdGlvbmFsJywgJ2Vuc3VyZUVuZCddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLW1lbWJlci5odG1sXG4gICAgICAgICAgICAnbWVtYmVyJzogWydwYXJzZVR5cGUnLCAncGFyc2VOYW1lUGF0aE9wdGlvbmFsJywgJ2Vuc3VyZUVuZCddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLW1ldGhvZC5odG1sXG4gICAgICAgICAgICAnbWV0aG9kJzogWydwYXJzZU5hbWVQYXRoT3B0aW9uYWwnLCAnZW5zdXJlRW5kJ10sXG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtbW9kdWxlLmh0bWxcbiAgICAgICAgICAgICdtb2R1bGUnOiBbJ3BhcnNlVHlwZScsICdwYXJzZU5hbWVQYXRoT3B0aW9uYWwnLCAnZW5zdXJlRW5kJ10sXG4gICAgICAgICAgICAvLyBTeW5vbnltOiBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtbWV0aG9kLmh0bWxcbiAgICAgICAgICAgICdmdW5jJzogWydwYXJzZU5hbWVQYXRoT3B0aW9uYWwnLCAnZW5zdXJlRW5kJ10sXG4gICAgICAgICAgICAvLyBTeW5vbnltOiBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtbWV0aG9kLmh0bWxcbiAgICAgICAgICAgICdmdW5jdGlvbic6IFsncGFyc2VOYW1lUGF0aE9wdGlvbmFsJywgJ2Vuc3VyZUVuZCddLFxuICAgICAgICAgICAgLy8gU3lub255bTogaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLW1lbWJlci5odG1sXG4gICAgICAgICAgICAndmFyJzogWydwYXJzZVR5cGUnLCAncGFyc2VOYW1lUGF0aE9wdGlvbmFsJywgJ2Vuc3VyZUVuZCddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLW5hbWUuaHRtbFxuICAgICAgICAgICAgJ25hbWUnOiBbJ3BhcnNlTmFtZVBhdGgnLCAnZW5zdXJlRW5kJ10sXG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtbmFtZXNwYWNlLmh0bWxcbiAgICAgICAgICAgICduYW1lc3BhY2UnOiBbJ3BhcnNlVHlwZScsICdwYXJzZU5hbWVQYXRoT3B0aW9uYWwnLCAnZW5zdXJlRW5kJ10sXG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtcHJpdmF0ZS5odG1sXG4gICAgICAgICAgICAncHJpdmF0ZSc6IFsncGFyc2VUeXBlJywgJ3BhcnNlRGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgIC8vIGh0dHA6Ly91c2Vqc2RvYy5vcmcvdGFncy1wcm90ZWN0ZWQuaHRtbFxuICAgICAgICAgICAgJ3Byb3RlY3RlZCc6IFsncGFyc2VUeXBlJywgJ3BhcnNlRGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgIC8vIGh0dHA6Ly91c2Vqc2RvYy5vcmcvdGFncy1wdWJsaWMuaHRtbFxuICAgICAgICAgICAgJ3B1YmxpYyc6IFsncGFyc2VUeXBlJywgJ3BhcnNlRGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgIC8vIGh0dHA6Ly91c2Vqc2RvYy5vcmcvdGFncy1yZWFkb25seS5odG1sXG4gICAgICAgICAgICAncmVhZG9ubHknOiBbJ2Vuc3VyZUVuZCddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLXJlcXVpcmVzLmh0bWxcbiAgICAgICAgICAgICdyZXF1aXJlcyc6IFsncGFyc2VOYW1lUGF0aCcsICdlbnN1cmVFbmQnXSxcbiAgICAgICAgICAgIC8vIGh0dHA6Ly91c2Vqc2RvYy5vcmcvdGFncy1zaW5jZS5odG1sXG4gICAgICAgICAgICAnc2luY2UnOiBbJ3BhcnNlRGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgIC8vIGh0dHA6Ly91c2Vqc2RvYy5vcmcvdGFncy1zdGF0aWMuaHRtbFxuICAgICAgICAgICAgJ3N0YXRpYyc6IFsnZW5zdXJlRW5kJ10sXG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3Mtc3VtbWFyeS5odG1sXG4gICAgICAgICAgICAnc3VtbWFyeSc6IFsncGFyc2VEZXNjcmlwdGlvbiddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLXRoaXMuaHRtbFxuICAgICAgICAgICAgJ3RoaXMnOiBbJ3BhcnNlVGhpcycsICdlbnN1cmVFbmQnXSxcbiAgICAgICAgICAgIC8vIGh0dHA6Ly91c2Vqc2RvYy5vcmcvdGFncy10b2RvLmh0bWxcbiAgICAgICAgICAgICd0b2RvJzogWydwYXJzZURlc2NyaXB0aW9uJ10sXG4gICAgICAgICAgICAvLyBodHRwOi8vdXNlanNkb2Mub3JnL3RhZ3MtdHlwZWRlZi5odG1sXG4gICAgICAgICAgICAndHlwZWRlZic6IFsncGFyc2VUeXBlJywgJ3BhcnNlTmFtZVBhdGhPcHRpb25hbCddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLXZhcmlhdGlvbi5odG1sXG4gICAgICAgICAgICAndmFyaWF0aW9uJzogWydwYXJzZVZhcmlhdGlvbiddLFxuICAgICAgICAgICAgLy8gaHR0cDovL3VzZWpzZG9jLm9yZy90YWdzLXZlcnNpb24uaHRtbFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiBbJ3BhcnNlRGVzY3JpcHRpb24nXVxuICAgICAgICB9O1xuXG4gICAgICAgIFRhZ1BhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgICAgICAgIHZhciBpLCBpeiwgc2VxdWVuY2VzLCBtZXRob2Q7XG5cblxuICAgICAgICAgICAgLy8gZW1wdHkgdGl0bGVcbiAgICAgICAgICAgIGlmICghdGhpcy5fdGl0bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWRkRXJyb3IoJ01pc3Npbmcgb3IgaW52YWxpZCB0aXRsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2VlayB0byBjb250ZW50IGxhc3QgaW5kZXguXG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gc2Vla0NvbnRlbnQodGhpcy5fdGl0bGUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5yYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhZy5yYW5nZSA9IFt0aGlzLl9maXJzdCwgc291cmNlLnNsaWNlKDAsIHRoaXMuX2xhc3QpLnJlcGxhY2UoL1xccyokLywgJycpLmxlbmd0aF0ubWFwKGNvbnZlcnRJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShSdWxlcywgdGhpcy5fdGl0bGUpKSB7XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VzID0gUnVsZXNbdGhpcy5fdGl0bGVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlcyA9IFsncGFyc2VUeXBlJywgJ3BhcnNlTmFtZScsICdwYXJzZURlc2NyaXB0aW9uJywgJ2VwaWxvZ3VlJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc2VxdWVuY2VzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBzZXF1ZW5jZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzW21ldGhvZF0oKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YWc7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VUYWcob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHRpdGxlLCBwYXJzZXIsIHRhZztcblxuICAgICAgICAgICAgLy8gc2tpcCB0byB0YWdcbiAgICAgICAgICAgIGlmICghc2tpcFRvVGFnKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2NhbiB0aXRsZVxuICAgICAgICAgICAgdGl0bGUgPSBzY2FuVGl0bGUoKTtcblxuICAgICAgICAgICAgLy8gY29uc3RydWN0IHRhZyBwYXJzZXJcbiAgICAgICAgICAgIHBhcnNlciA9IG5ldyBUYWdQYXJzZXIob3B0aW9ucywgdGl0bGUpO1xuICAgICAgICAgICAgdGFnID0gcGFyc2VyLnBhcnNlKCk7XG5cbiAgICAgICAgICAgIC8vIFNlZWsgZ2xvYmFsIGluZGV4IHRvIGVuZCBvZiB0aGlzIHRhZy5cbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IHBhcnNlci5fbGFzdCkge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnNlIEpTRG9jXG4gICAgICAgIC8vXG5cbiAgICAgICAgZnVuY3Rpb24gc2NhbkpTRG9jRGVzY3JpcHRpb24ocHJlc2VydmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSAnJywgY2gsIGF0QWxsb3dlZDtcblxuICAgICAgICAgICAgYXRBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF0QWxsb3dlZCAmJiBjaCA9PT0gMHg0MCAgLyogJ0AnICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXRBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0QWxsb3dlZCAmJiAhZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXRBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJlc2VydmVXaGl0ZXNwYWNlID8gZGVzY3JpcHRpb24gOiBkZXNjcmlwdGlvbi50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZShjb21tZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdGFncyA9IFtdLCB0YWcsIGRlc2NyaXB0aW9uLCBpbnRlcmVzdGluZ1RhZ3MsIGksIGl6O1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudW53cmFwID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy51bndyYXApIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB1bndyYXBDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBjb21tZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcmlnaW5hbFNvdXJjZSA9IGNvbW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIGFycmF5IG9mIHJlbGV2YW50IHRhZ3NcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRhZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnRhZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyZXN0aW5nVGFncyA9IHsgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBvcHRpb25zLnRhZ3MubGVuZ3RoOyBpIDwgaXo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRhZ3NbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJlc3RpbmdUYWdzW29wdGlvbnMudGFnc1tpXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsaXR5LnRocm93RXJyb3IoJ0ludmFsaWQgXCJ0YWdzXCIgcGFyYW1ldGVyOiAnICsgb3B0aW9ucy50YWdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxpdHkudGhyb3dFcnJvcignSW52YWxpZCBcInRhZ3NcIiBwYXJhbWV0ZXI6ICcgKyBvcHRpb25zLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSAwO1xuICAgICAgICAgICAgcmVjb3ZlcmFibGUgPSBvcHRpb25zLnJlY292ZXJhYmxlO1xuICAgICAgICAgICAgc2xvcHB5ID0gb3B0aW9ucy5zbG9wcHk7XG4gICAgICAgICAgICBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcblxuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBzY2FuSlNEb2NEZXNjcmlwdGlvbihvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSk7XG5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGFnID0gcGFyc2VUYWcob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaW50ZXJlc3RpbmdUYWdzIHx8IGludGVyZXN0aW5nVGFncy5oYXNPd25Qcm9wZXJ0eSh0YWcudGl0bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3MucHVzaCh0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgdGFnczogdGFnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gICAgfShqc2RvYyA9IHt9KSk7XG5cbiAgICBleHBvcnRzLnZlcnNpb24gPSB1dGlsaXR5LlZFUlNJT047XG4gICAgZXhwb3J0cy5wYXJzZSA9IGpzZG9jLnBhcnNlO1xuICAgIGV4cG9ydHMucGFyc2VUeXBlID0gdHlwZWQucGFyc2VUeXBlO1xuICAgIGV4cG9ydHMucGFyc2VQYXJhbVR5cGUgPSB0eXBlZC5wYXJzZVBhcmFtVHlwZTtcbiAgICBleHBvcnRzLnVud3JhcENvbW1lbnQgPSB1bndyYXBDb21tZW50O1xuICAgIGV4cG9ydHMuU3ludGF4ID0gc2hhbGxvd0NvcHkodHlwZWQuU3ludGF4KTtcbiAgICBleHBvcnRzLkVycm9yID0gdXRpbGl0eS5Eb2N0cmluZUVycm9yO1xuICAgIGV4cG9ydHMudHlwZSA9IHtcbiAgICAgICAgU3ludGF4OiBleHBvcnRzLlN5bnRheCxcbiAgICAgICAgcGFyc2VUeXBlOiB0eXBlZC5wYXJzZVR5cGUsXG4gICAgICAgIHBhcnNlUGFyYW1UeXBlOiB0eXBlZC5wYXJzZVBhcmFtVHlwZSxcbiAgICAgICAgc3RyaW5naWZ5OiB0eXBlZC5zdHJpbmdpZnlcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwibmFtZXMiOlsidHlwZWQiLCJ1dGlsaXR5IiwianNkb2MiLCJlc3V0aWxzIiwiaGFzT3duUHJvcGVydHkiLCJyZXF1aXJlIiwic2xpY2VTb3VyY2UiLCJzb3VyY2UiLCJpbmRleCIsImxhc3QiLCJzbGljZSIsImZ1bmMiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJvYmoiLCJuYW1lIiwiY2FsbCIsInNoYWxsb3dDb3B5IiwicmV0Iiwia2V5IiwiaXNBU0NJSUFscGhhbnVtZXJpYyIsImNoIiwiaXNQYXJhbVRpdGxlIiwidGl0bGUiLCJpc1JldHVyblRpdGxlIiwiaXNQcm9wZXJ0eSIsImlzTmFtZVBhcmFtZXRlclJlcXVpcmVkIiwiaXNBbGxvd2VkTmFtZSIsImlzQWxsb3dlZE5lc3RlZCIsImlzQWxsb3dlZE9wdGlvbmFsIiwiaXNUeXBlUGFyYW1ldGVyUmVxdWlyZWQiLCJpc0FsbG93ZWRUeXBlIiwiV0hJVEVTUEFDRSIsIlNUQVJfTUFUQ0hFUiIsInVud3JhcENvbW1lbnQiLCJkb2MiLCJyZXBsYWNlIiwiUmVnRXhwIiwiY29udmVydFVud3JhcHBlZENvbW1lbnRJbmRleCIsIm9yaWdpbmFsU291cmNlIiwidW53cmFwcGVkSW5kZXgiLCJyZXBsYWNlZFNvdXJjZSIsIm51bVNraXBwZWRDaGFycyIsIm1hdGNoZXIiLCJtYXRjaCIsImV4ZWMiLCJsZW5ndGgiLCJleHBvcnRzIiwiUnVsZXMiLCJsaW5lTnVtYmVyIiwicmVjb3ZlcmFibGUiLCJzbG9wcHkiLCJzdHJpY3QiLCJhZHZhbmNlIiwiY2hhckNvZGVBdCIsImNvZGUiLCJpc0xpbmVUZXJtaW5hdG9yIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic2NhblRpdGxlIiwic2Vla0NvbnRlbnQiLCJ3YWl0aW5nIiwiaXNXaGl0ZVNwYWNlIiwicGFyc2VUeXBlIiwiYWRkUmFuZ2UiLCJicmFjZSIsInR5cGUiLCJzdGFydEluZGV4IiwiZGlyZWN0IiwidGhyb3dFcnJvciIsInBhcnNlUGFyYW1UeXBlIiwiY29udmVydEluZGV4IiwicmFuZ2UiLCJzY2FuSWRlbnRpZmllciIsImlkZW50aWZpZXIiLCJpc0lkZW50aWZpZXJTdGFydEVTNSIsImlzSWRlbnRpZmllclBhcnRFUzUiLCJza2lwV2hpdGVTcGFjZSIsInBhcnNlTmFtZSIsImFsbG93QnJhY2tldHMiLCJhbGxvd05lc3RlZFBhcmFtcyIsInVzZUJyYWNrZXRzIiwiaW5zaWRlU3RyaW5nIiwiYnJhY2tldERlcHRoIiwic2tpcFRvVGFnIiwiYXNzZXJ0IiwicmFuZ2VJbmRleCIsIlRhZ1BhcnNlciIsIm9wdGlvbnMiLCJfb3B0aW9ucyIsIl90aXRsZSIsInRvTG93ZXJDYXNlIiwiX3RhZyIsImRlc2NyaXB0aW9uIiwibGluZU51bWJlcnMiLCJfZmlyc3QiLCJfbGFzdCIsIl9leHRyYSIsImFkZEVycm9yIiwiZXJyb3JUZXh0IiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwibXNnIiwid2hvbGUiLCJlcnJvcnMiLCJwdXNoIiwiZXJyb3IiLCJtZXNzYWdlIiwiZSIsIl9wYXJzZU5hbWVQYXRoIiwib3B0aW9uYWwiLCJwYXJzZU5hbWVQYXRoIiwicGFyc2VOYW1lUGF0aE9wdGlvbmFsIiwiYXNzaWduIiwiY2hhckF0Iiwic3Vic3RyaW5nIiwic3BsaXQiLCJqb2luIiwiZXhwcmVzc2lvbiIsInBhcnNlRGVzY3JpcHRpb24iLCJ0cmltIiwidGVzdCIsInBhcnNlQ2FwdGlvbiIsImNhcHRpb25TdGFydFRhZyIsImNhcHRpb25FbmRUYWciLCJjYXB0aW9uU3RhcnQiLCJpbmRleE9mIiwiY2FwdGlvbkVuZCIsImNhcHRpb24iLCJwYXJzZUtpbmQiLCJraW5kIiwia2luZHMiLCJwYXJzZUFjY2VzcyIsImFjY2VzcyIsInBhcnNlVGhpcyIsInZhbHVlIiwiZ290VHlwZSIsInBhcnNlVmFyaWF0aW9uIiwidmFyaWF0aW9uIiwidGV4dCIsInBhcnNlRmxvYXQiLCJpc05hTiIsImVuc3VyZUVuZCIsInNob3VsZEJlRW1wdHkiLCJlcGlsb2d1ZSIsInVuZGVmaW5lZCIsInBhcnNlIiwiaSIsIml6Iiwic2VxdWVuY2VzIiwibWV0aG9kIiwibWFwIiwicGFyc2VUYWciLCJwYXJzZXIiLCJ0YWciLCJzY2FuSlNEb2NEZXNjcmlwdGlvbiIsInByZXNlcnZlV2hpdGVzcGFjZSIsImF0QWxsb3dlZCIsImNvbW1lbnQiLCJ0YWdzIiwiaW50ZXJlc3RpbmdUYWdzIiwidW53cmFwIiwiaXNBcnJheSIsInZlcnNpb24iLCJWRVJTSU9OIiwiU3ludGF4IiwiRXJyb3IiLCJEb2N0cmluZUVycm9yIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/doctrine/lib/doctrine.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/doctrine/lib/typed.js":
/*!********************************************!*\
  !*** ./node_modules/doctrine/lib/typed.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * @fileoverview Type expression parser.\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */ // \"typed\", the Type Expression Parser for doctrine.\n(function() {\n    \"use strict\";\n    var Syntax, Token, source, length, index, previous, token, value, esutils, utility, rangeOffset, addRange;\n    esutils = __webpack_require__(/*! esutils */ \"(rsc)/./node_modules/esutils/lib/utils.js\");\n    utility = __webpack_require__(/*! ./utility */ \"(rsc)/./node_modules/doctrine/lib/utility.js\");\n    Syntax = {\n        NullableLiteral: \"NullableLiteral\",\n        AllLiteral: \"AllLiteral\",\n        NullLiteral: \"NullLiteral\",\n        UndefinedLiteral: \"UndefinedLiteral\",\n        VoidLiteral: \"VoidLiteral\",\n        UnionType: \"UnionType\",\n        ArrayType: \"ArrayType\",\n        RecordType: \"RecordType\",\n        FieldType: \"FieldType\",\n        FunctionType: \"FunctionType\",\n        ParameterType: \"ParameterType\",\n        RestType: \"RestType\",\n        NonNullableType: \"NonNullableType\",\n        OptionalType: \"OptionalType\",\n        NullableType: \"NullableType\",\n        NameExpression: \"NameExpression\",\n        TypeApplication: \"TypeApplication\",\n        StringLiteralType: \"StringLiteralType\",\n        NumericLiteralType: \"NumericLiteralType\",\n        BooleanLiteralType: \"BooleanLiteralType\"\n    };\n    Token = {\n        ILLEGAL: 0,\n        DOT_LT: 1,\n        REST: 2,\n        LT: 3,\n        GT: 4,\n        LPAREN: 5,\n        RPAREN: 6,\n        LBRACE: 7,\n        RBRACE: 8,\n        LBRACK: 9,\n        RBRACK: 10,\n        COMMA: 11,\n        COLON: 12,\n        STAR: 13,\n        PIPE: 14,\n        QUESTION: 15,\n        BANG: 16,\n        EQUAL: 17,\n        NAME: 18,\n        STRING: 19,\n        NUMBER: 20,\n        EOF: 21\n    };\n    function isTypeName(ch) {\n        return \"><(){}[],:*|?!=\".indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\n    }\n    function Context(previous, index, token, value) {\n        this._previous = previous;\n        this._index = index;\n        this._token = token;\n        this._value = value;\n    }\n    Context.prototype.restore = function() {\n        previous = this._previous;\n        index = this._index;\n        token = this._token;\n        value = this._value;\n    };\n    Context.save = function() {\n        return new Context(previous, index, token, value);\n    };\n    function maybeAddRange(node, range) {\n        if (addRange) {\n            node.range = [\n                range[0] + rangeOffset,\n                range[1] + rangeOffset\n            ];\n        }\n        return node;\n    }\n    function advance() {\n        var ch = source.charAt(index);\n        index += 1;\n        return ch;\n    }\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n        len = prefix === \"u\" ? 4 : 2;\n        for(i = 0; i < len; ++i){\n            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\n                ch = advance();\n                code = code * 16 + \"0123456789abcdef\".indexOf(ch.toLowerCase());\n            } else {\n                return \"\";\n            }\n        }\n        return String.fromCharCode(code);\n    }\n    function scanString() {\n        var str = \"\", quote, ch, code, unescaped, restore; //TODO review removal octal = false\n        quote = source.charAt(index);\n        ++index;\n        while(index < length){\n            ch = advance();\n            if (ch === quote) {\n                quote = \"\";\n                break;\n            } else if (ch === \"\\\\\") {\n                ch = advance();\n                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                    switch(ch){\n                        case \"n\":\n                            str += \"\\n\";\n                            break;\n                        case \"r\":\n                            str += \"\\r\";\n                            break;\n                        case \"t\":\n                            str += \"\t\";\n                            break;\n                        case \"u\":\n                        case \"x\":\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                str += unescaped;\n                            } else {\n                                index = restore;\n                                str += ch;\n                            }\n                            break;\n                        case \"b\":\n                            str += \"\\b\";\n                            break;\n                        case \"f\":\n                            str += \"\\f\";\n                            break;\n                        case \"v\":\n                            str += \"\\v\";\n                            break;\n                        default:\n                            if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\n                                code = \"01234567\".indexOf(ch);\n                                // \\0 is not octal escape sequence\n                                // Deprecating unused code. TODO review removal\n                                //if (code !== 0) {\n                                //    octal = true;\n                                //}\n                                if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                    //TODO Review Removal octal = true;\n                                    code = code * 8 + \"01234567\".indexOf(advance());\n                                    // 3 digits are only allowed when string starts\n                                    // with 0, 1, 2, 3\n                                    if (\"0123\".indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                        code = code * 8 + \"01234567\".indexOf(advance());\n                                    }\n                                }\n                                str += String.fromCharCode(code);\n                            } else {\n                                str += ch;\n                            }\n                            break;\n                    }\n                } else {\n                    if (ch === \"\\r\" && source.charCodeAt(index) === 0x0A /* '\\n' */ ) {\n                        ++index;\n                    }\n                }\n            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n        if (quote !== \"\") {\n            utility.throwError(\"unexpected quote\");\n        }\n        value = str;\n        return Token.STRING;\n    }\n    function scanNumber() {\n        var number, ch;\n        number = \"\";\n        ch = source.charCodeAt(index);\n        if (ch !== 0x2E /* '.' */ ) {\n            number = advance();\n            ch = source.charCodeAt(index);\n            if (number === \"0\") {\n                if (ch === 0x78 /* 'x' */  || ch === 0x58 /* 'X' */ ) {\n                    number += advance();\n                    while(index < length){\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isHexDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n                    if (number.length <= 2) {\n                        // only 0x\n                        utility.throwError(\"unexpected token\");\n                    }\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch)) {\n                            utility.throwError(\"unexpected token\");\n                        }\n                    }\n                    value = parseInt(number, 16);\n                    return Token.NUMBER;\n                }\n                if (esutils.code.isOctalDigit(ch)) {\n                    number += advance();\n                    while(index < length){\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\n                            utility.throwError(\"unexpected token\");\n                        }\n                    }\n                    value = parseInt(number, 8);\n                    return Token.NUMBER;\n                }\n                if (esutils.code.isDecimalDigit(ch)) {\n                    utility.throwError(\"unexpected token\");\n                }\n            }\n            while(index < length){\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n        if (ch === 0x2E /* '.' */ ) {\n            number += advance();\n            while(index < length){\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n        if (ch === 0x65 /* 'e' */  || ch === 0x45 /* 'E' */ ) {\n            number += advance();\n            ch = source.charCodeAt(index);\n            if (ch === 0x2B /* '+' */  || ch === 0x2D /* '-' */ ) {\n                number += advance();\n            }\n            ch = source.charCodeAt(index);\n            if (esutils.code.isDecimalDigit(ch)) {\n                number += advance();\n                while(index < length){\n                    ch = source.charCodeAt(index);\n                    if (!esutils.code.isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += advance();\n                }\n            } else {\n                utility.throwError(\"unexpected token\");\n            }\n        }\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            if (esutils.code.isIdentifierStartES5(ch)) {\n                utility.throwError(\"unexpected token\");\n            }\n        }\n        value = parseFloat(number);\n        return Token.NUMBER;\n    }\n    function scanTypeName() {\n        var ch, ch2;\n        value = advance();\n        while(index < length && isTypeName(source.charCodeAt(index))){\n            ch = source.charCodeAt(index);\n            if (ch === 0x2E /* '.' */ ) {\n                if (index + 1 >= length) {\n                    return Token.ILLEGAL;\n                }\n                ch2 = source.charCodeAt(index + 1);\n                if (ch2 === 0x3C /* '<' */ ) {\n                    break;\n                }\n            }\n            value += advance();\n        }\n        return Token.NAME;\n    }\n    function next() {\n        var ch;\n        previous = index;\n        while(index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))){\n            advance();\n        }\n        if (index >= length) {\n            token = Token.EOF;\n            return token;\n        }\n        ch = source.charCodeAt(index);\n        switch(ch){\n            case 0x27:\n            /* ''' */ case 0x22:\n                /* '\"' */ token = scanString();\n                return token;\n            case 0x3A:\n                /* ':' */ advance();\n                token = Token.COLON;\n                return token;\n            case 0x2C:\n                /* ',' */ advance();\n                token = Token.COMMA;\n                return token;\n            case 0x28:\n                /* '(' */ advance();\n                token = Token.LPAREN;\n                return token;\n            case 0x29:\n                /* ')' */ advance();\n                token = Token.RPAREN;\n                return token;\n            case 0x5B:\n                /* '[' */ advance();\n                token = Token.LBRACK;\n                return token;\n            case 0x5D:\n                /* ']' */ advance();\n                token = Token.RBRACK;\n                return token;\n            case 0x7B:\n                /* '{' */ advance();\n                token = Token.LBRACE;\n                return token;\n            case 0x7D:\n                /* '}' */ advance();\n                token = Token.RBRACE;\n                return token;\n            case 0x2E:\n                /* '.' */ if (index + 1 < length) {\n                    ch = source.charCodeAt(index + 1);\n                    if (ch === 0x3C /* '<' */ ) {\n                        advance(); // '.'\n                        advance(); // '<'\n                        token = Token.DOT_LT;\n                        return token;\n                    }\n                    if (ch === 0x2E /* '.' */  && index + 2 < length && source.charCodeAt(index + 2) === 0x2E /* '.' */ ) {\n                        advance(); // '.'\n                        advance(); // '.'\n                        advance(); // '.'\n                        token = Token.REST;\n                        return token;\n                    }\n                    if (esutils.code.isDecimalDigit(ch)) {\n                        token = scanNumber();\n                        return token;\n                    }\n                }\n                token = Token.ILLEGAL;\n                return token;\n            case 0x3C:\n                /* '<' */ advance();\n                token = Token.LT;\n                return token;\n            case 0x3E:\n                /* '>' */ advance();\n                token = Token.GT;\n                return token;\n            case 0x2A:\n                /* '*' */ advance();\n                token = Token.STAR;\n                return token;\n            case 0x7C:\n                /* '|' */ advance();\n                token = Token.PIPE;\n                return token;\n            case 0x3F:\n                /* '?' */ advance();\n                token = Token.QUESTION;\n                return token;\n            case 0x21:\n                /* '!' */ advance();\n                token = Token.BANG;\n                return token;\n            case 0x3D:\n                /* '=' */ advance();\n                token = Token.EQUAL;\n                return token;\n            case 0x2D:\n                /* '-' */ token = scanNumber();\n                return token;\n            default:\n                if (esutils.code.isDecimalDigit(ch)) {\n                    token = scanNumber();\n                    return token;\n                }\n                // type string permits following case,\n                //\n                // namespace.module.MyClass\n                //\n                // this reduced 1 token TK_NAME\n                utility.assert(isTypeName(ch));\n                token = scanTypeName();\n                return token;\n        }\n    }\n    function consume(target, text) {\n        utility.assert(token === target, text || \"consumed token not matched\");\n        next();\n    }\n    function expect(target, message) {\n        if (token !== target) {\n            utility.throwError(message || \"unexpected token\");\n        }\n        next();\n    }\n    // UnionType := '(' TypeUnionList ')'\n    //\n    // TypeUnionList :=\n    //     <<empty>>\n    //   | NonemptyTypeUnionList\n    //\n    // NonemptyTypeUnionList :=\n    //     TypeExpression\n    //   | TypeExpression '|' NonemptyTypeUnionList\n    function parseUnionType() {\n        var elements, startIndex = index - 1;\n        consume(Token.LPAREN, \"UnionType should start with (\");\n        elements = [];\n        if (token !== Token.RPAREN) {\n            while(true){\n                elements.push(parseTypeExpression());\n                if (token === Token.RPAREN) {\n                    break;\n                }\n                expect(Token.PIPE);\n            }\n        }\n        consume(Token.RPAREN, \"UnionType should end with )\");\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [\n            startIndex,\n            previous\n        ]);\n    }\n    // ArrayType := '[' ElementTypeList ']'\n    //\n    // ElementTypeList :=\n    //     <<empty>>\n    //  | TypeExpression\n    //  | '...' TypeExpression\n    //  | TypeExpression ',' ElementTypeList\n    function parseArrayType() {\n        var elements, startIndex = index - 1, restStartIndex;\n        consume(Token.LBRACK, \"ArrayType should start with [\");\n        elements = [];\n        while(token !== Token.RBRACK){\n            if (token === Token.REST) {\n                restStartIndex = index - 3;\n                consume(Token.REST);\n                elements.push(maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: parseTypeExpression()\n                }, [\n                    restStartIndex,\n                    previous\n                ]));\n                break;\n            } else {\n                elements.push(parseTypeExpression());\n            }\n            if (token !== Token.RBRACK) {\n                expect(Token.COMMA);\n            }\n        }\n        expect(Token.RBRACK);\n        return maybeAddRange({\n            type: Syntax.ArrayType,\n            elements: elements\n        }, [\n            startIndex,\n            previous\n        ]);\n    }\n    function parseFieldName() {\n        var v = value;\n        if (token === Token.NAME || token === Token.STRING) {\n            next();\n            return v;\n        }\n        if (token === Token.NUMBER) {\n            consume(Token.NUMBER);\n            return String(v);\n        }\n        utility.throwError(\"unexpected token\");\n    }\n    // FieldType :=\n    //     FieldName\n    //   | FieldName ':' TypeExpression\n    //\n    // FieldName :=\n    //     NameExpression\n    //   | StringLiteral\n    //   | NumberLiteral\n    //   | ReservedIdentifier\n    function parseFieldType() {\n        var key, rangeStart = previous;\n        key = parseFieldName();\n        if (token === Token.COLON) {\n            consume(Token.COLON);\n            return maybeAddRange({\n                type: Syntax.FieldType,\n                key: key,\n                value: parseTypeExpression()\n            }, [\n                rangeStart,\n                previous\n            ]);\n        }\n        return maybeAddRange({\n            type: Syntax.FieldType,\n            key: key,\n            value: null\n        }, [\n            rangeStart,\n            previous\n        ]);\n    }\n    // RecordType := '{' FieldTypeList '}'\n    //\n    // FieldTypeList :=\n    //     <<empty>>\n    //   | FieldType\n    //   | FieldType ',' FieldTypeList\n    function parseRecordType() {\n        var fields, rangeStart = index - 1, rangeEnd;\n        consume(Token.LBRACE, \"RecordType should start with {\");\n        fields = [];\n        if (token === Token.COMMA) {\n            consume(Token.COMMA);\n        } else {\n            while(token !== Token.RBRACE){\n                fields.push(parseFieldType());\n                if (token !== Token.RBRACE) {\n                    expect(Token.COMMA);\n                }\n            }\n        }\n        rangeEnd = index;\n        expect(Token.RBRACE);\n        return maybeAddRange({\n            type: Syntax.RecordType,\n            fields: fields\n        }, [\n            rangeStart,\n            rangeEnd\n        ]);\n    }\n    // NameExpression :=\n    //    Identifier\n    //  | TagIdentifier ':' Identifier\n    //\n    // Tag identifier is one of \"module\", \"external\" or \"event\"\n    // Identifier is the same as Token.NAME, including any dots, something like\n    // namespace.module.MyClass\n    function parseNameExpression() {\n        var name = value, rangeStart = index - name.length;\n        expect(Token.NAME);\n        if (token === Token.COLON && (name === \"module\" || name === \"external\" || name === \"event\")) {\n            consume(Token.COLON);\n            name += \":\" + value;\n            expect(Token.NAME);\n        }\n        return maybeAddRange({\n            type: Syntax.NameExpression,\n            name: name\n        }, [\n            rangeStart,\n            previous\n        ]);\n    }\n    // TypeExpressionList :=\n    //     TopLevelTypeExpression\n    //   | TopLevelTypeExpression ',' TypeExpressionList\n    function parseTypeExpressionList() {\n        var elements = [];\n        elements.push(parseTop());\n        while(token === Token.COMMA){\n            consume(Token.COMMA);\n            elements.push(parseTop());\n        }\n        return elements;\n    }\n    // TypeName :=\n    //     NameExpression\n    //   | NameExpression TypeApplication\n    //\n    // TypeApplication :=\n    //     '.<' TypeExpressionList '>'\n    //   | '<' TypeExpressionList '>'   // this is extension of doctrine\n    function parseTypeName() {\n        var expr, applications, startIndex = index - value.length;\n        expr = parseNameExpression();\n        if (token === Token.DOT_LT || token === Token.LT) {\n            next();\n            applications = parseTypeExpressionList();\n            expect(Token.GT);\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: expr,\n                applications: applications\n            }, [\n                startIndex,\n                previous\n            ]);\n        }\n        return expr;\n    }\n    // ResultType :=\n    //     <<empty>>\n    //   | ':' void\n    //   | ':' TypeExpression\n    //\n    // BNF is above\n    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\n    function parseResultType() {\n        consume(Token.COLON, \"ResultType should start with :\");\n        if (token === Token.NAME && value === \"void\") {\n            consume(Token.NAME);\n            return {\n                type: Syntax.VoidLiteral\n            };\n        }\n        return parseTypeExpression();\n    }\n    // ParametersType :=\n    //     RestParameterType\n    //   | NonRestParametersType\n    //   | NonRestParametersType ',' RestParameterType\n    //\n    // RestParameterType :=\n    //     '...'\n    //     '...' Identifier\n    //\n    // NonRestParametersType :=\n    //     ParameterType ',' NonRestParametersType\n    //   | ParameterType\n    //   | OptionalParametersType\n    //\n    // OptionalParametersType :=\n    //     OptionalParameterType\n    //   | OptionalParameterType, OptionalParametersType\n    //\n    // OptionalParameterType := ParameterType=\n    //\n    // ParameterType := TypeExpression | Identifier ':' TypeExpression\n    //\n    // Identifier is \"new\" or \"this\"\n    function parseParametersType() {\n        var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;\n        while(token !== Token.RPAREN){\n            if (token === Token.REST) {\n                // RestParameterType\n                consume(Token.REST);\n                rest = true;\n            }\n            startIndex = previous;\n            expr = parseTypeExpression();\n            if (expr.type === Syntax.NameExpression && token === Token.COLON) {\n                nameStartIndex = previous - expr.name.length;\n                // Identifier ':' TypeExpression\n                consume(Token.COLON);\n                expr = maybeAddRange({\n                    type: Syntax.ParameterType,\n                    name: expr.name,\n                    expression: parseTypeExpression()\n                }, [\n                    nameStartIndex,\n                    previous\n                ]);\n            }\n            if (token === Token.EQUAL) {\n                consume(Token.EQUAL);\n                expr = maybeAddRange({\n                    type: Syntax.OptionalType,\n                    expression: expr\n                }, [\n                    startIndex,\n                    previous\n                ]);\n                optionalSequence = true;\n            } else {\n                if (optionalSequence) {\n                    utility.throwError(\"unexpected token\");\n                }\n            }\n            if (rest) {\n                expr = maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: expr\n                }, [\n                    restStartIndex,\n                    previous\n                ]);\n            }\n            params.push(expr);\n            if (token !== Token.RPAREN) {\n                expect(Token.COMMA);\n            }\n        }\n        return params;\n    }\n    // FunctionType := 'function' FunctionSignatureType\n    //\n    // FunctionSignatureType :=\n    //   | TypeParameters '(' ')' ResultType\n    //   | TypeParameters '(' ParametersType ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\n    function parseFunctionType() {\n        var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;\n        utility.assert(token === Token.NAME && value === \"function\", \"FunctionType should start with 'function'\");\n        consume(Token.NAME);\n        // Google Closure Compiler is not implementing TypeParameters.\n        // So we do not. if we don't get '(', we see it as error.\n        expect(Token.LPAREN);\n        isNew = false;\n        params = [];\n        thisBinding = null;\n        if (token !== Token.RPAREN) {\n            // ParametersType or 'this'\n            if (token === Token.NAME && (value === \"this\" || value === \"new\")) {\n                // 'this' or 'new'\n                // 'new' is Closure Compiler extension\n                isNew = value === \"new\";\n                consume(Token.NAME);\n                expect(Token.COLON);\n                thisBinding = parseTypeName();\n                if (token === Token.COMMA) {\n                    consume(Token.COMMA);\n                    params = parseParametersType();\n                }\n            } else {\n                params = parseParametersType();\n            }\n        }\n        expect(Token.RPAREN);\n        result = null;\n        if (token === Token.COLON) {\n            result = parseResultType();\n        }\n        fnType = maybeAddRange({\n            type: Syntax.FunctionType,\n            params: params,\n            result: result\n        }, [\n            startIndex,\n            previous\n        ]);\n        if (thisBinding) {\n            // avoid adding null 'new' and 'this' properties\n            fnType[\"this\"] = thisBinding;\n            if (isNew) {\n                fnType[\"new\"] = true;\n            }\n        }\n        return fnType;\n    }\n    // BasicTypeExpression :=\n    //     '*'\n    //   | 'null'\n    //   | 'undefined'\n    //   | TypeName\n    //   | FunctionType\n    //   | UnionType\n    //   | RecordType\n    //   | ArrayType\n    function parseBasicTypeExpression() {\n        var context, startIndex;\n        switch(token){\n            case Token.STAR:\n                consume(Token.STAR);\n                return maybeAddRange({\n                    type: Syntax.AllLiteral\n                }, [\n                    previous - 1,\n                    previous\n                ]);\n            case Token.LPAREN:\n                return parseUnionType();\n            case Token.LBRACK:\n                return parseArrayType();\n            case Token.LBRACE:\n                return parseRecordType();\n            case Token.NAME:\n                startIndex = index - value.length;\n                if (value === \"null\") {\n                    consume(Token.NAME);\n                    return maybeAddRange({\n                        type: Syntax.NullLiteral\n                    }, [\n                        startIndex,\n                        previous\n                    ]);\n                }\n                if (value === \"undefined\") {\n                    consume(Token.NAME);\n                    return maybeAddRange({\n                        type: Syntax.UndefinedLiteral\n                    }, [\n                        startIndex,\n                        previous\n                    ]);\n                }\n                if (value === \"true\" || value === \"false\") {\n                    consume(Token.NAME);\n                    return maybeAddRange({\n                        type: Syntax.BooleanLiteralType,\n                        value: value === \"true\"\n                    }, [\n                        startIndex,\n                        previous\n                    ]);\n                }\n                context = Context.save();\n                if (value === \"function\") {\n                    try {\n                        return parseFunctionType();\n                    } catch (e) {\n                        context.restore();\n                    }\n                }\n                return parseTypeName();\n            case Token.STRING:\n                next();\n                return maybeAddRange({\n                    type: Syntax.StringLiteralType,\n                    value: value\n                }, [\n                    previous - value.length - 2,\n                    previous\n                ]);\n            case Token.NUMBER:\n                next();\n                return maybeAddRange({\n                    type: Syntax.NumericLiteralType,\n                    value: value\n                }, [\n                    previous - String(value).length,\n                    previous\n                ]);\n            default:\n                utility.throwError(\"unexpected token\");\n        }\n    }\n    // TypeExpression :=\n    //     BasicTypeExpression\n    //   | '?' BasicTypeExpression\n    //   | '!' BasicTypeExpression\n    //   | BasicTypeExpression '?'\n    //   | BasicTypeExpression '!'\n    //   | '?'\n    //   | BasicTypeExpression '[]'\n    function parseTypeExpression() {\n        var expr, rangeStart;\n        if (token === Token.QUESTION) {\n            rangeStart = index - 1;\n            consume(Token.QUESTION);\n            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {\n                return maybeAddRange({\n                    type: Syntax.NullableLiteral\n                }, [\n                    rangeStart,\n                    previous\n                ]);\n            }\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [\n                rangeStart,\n                previous\n            ]);\n        } else if (token === Token.BANG) {\n            rangeStart = index - 1;\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [\n                rangeStart,\n                previous\n            ]);\n        } else {\n            rangeStart = previous;\n        }\n        expr = parseBasicTypeExpression();\n        if (token === Token.BANG) {\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: expr,\n                prefix: false\n            }, [\n                rangeStart,\n                previous\n            ]);\n        }\n        if (token === Token.QUESTION) {\n            consume(Token.QUESTION);\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: expr,\n                prefix: false\n            }, [\n                rangeStart,\n                previous\n            ]);\n        }\n        if (token === Token.LBRACK) {\n            consume(Token.LBRACK);\n            expect(Token.RBRACK, \"expected an array-style type declaration (\" + value + \"[])\");\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: maybeAddRange({\n                    type: Syntax.NameExpression,\n                    name: \"Array\"\n                }, [\n                    rangeStart,\n                    previous\n                ]),\n                applications: [\n                    expr\n                ]\n            }, [\n                rangeStart,\n                previous\n            ]);\n        }\n        return expr;\n    }\n    // TopLevelTypeExpression :=\n    //      TypeExpression\n    //    | TypeUnionList\n    //\n    // This rule is Google Closure Compiler extension, not ES4\n    // like,\n    //   { number | string }\n    // If strict to ES4, we should write it as\n    //   { (number|string) }\n    function parseTop() {\n        var expr, elements;\n        expr = parseTypeExpression();\n        if (token !== Token.PIPE) {\n            return expr;\n        }\n        elements = [\n            expr\n        ];\n        consume(Token.PIPE);\n        while(true){\n            elements.push(parseTypeExpression());\n            if (token !== Token.PIPE) {\n                break;\n            }\n            consume(Token.PIPE);\n        }\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [\n            0,\n            index\n        ]);\n    }\n    function parseTopParamType() {\n        var expr;\n        if (token === Token.REST) {\n            consume(Token.REST);\n            return maybeAddRange({\n                type: Syntax.RestType,\n                expression: parseTop()\n            }, [\n                0,\n                index\n            ]);\n        }\n        expr = parseTop();\n        if (token === Token.EQUAL) {\n            consume(Token.EQUAL);\n            return maybeAddRange({\n                type: Syntax.OptionalType,\n                expression: expr\n            }, [\n                0,\n                index\n            ]);\n        }\n        return expr;\n    }\n    function parseType(src, opt) {\n        var expr;\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n        next();\n        expr = parseTop();\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n        if (token !== Token.EOF) {\n            utility.throwError(\"not reach to EOF\");\n        }\n        return expr;\n    }\n    function parseParamType(src, opt) {\n        var expr;\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n        next();\n        expr = parseTopParamType();\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n        if (token !== Token.EOF) {\n            utility.throwError(\"not reach to EOF\");\n        }\n        return expr;\n    }\n    function stringifyImpl(node, compact, topLevel) {\n        var result, i, iz;\n        switch(node.type){\n            case Syntax.NullableLiteral:\n                result = \"?\";\n                break;\n            case Syntax.AllLiteral:\n                result = \"*\";\n                break;\n            case Syntax.NullLiteral:\n                result = \"null\";\n                break;\n            case Syntax.UndefinedLiteral:\n                result = \"undefined\";\n                break;\n            case Syntax.VoidLiteral:\n                result = \"void\";\n                break;\n            case Syntax.UnionType:\n                if (!topLevel) {\n                    result = \"(\";\n                } else {\n                    result = \"\";\n                }\n                for(i = 0, iz = node.elements.length; i < iz; ++i){\n                    result += stringifyImpl(node.elements[i], compact);\n                    if (i + 1 !== iz) {\n                        result += compact ? \"|\" : \" | \";\n                    }\n                }\n                if (!topLevel) {\n                    result += \")\";\n                }\n                break;\n            case Syntax.ArrayType:\n                result = \"[\";\n                for(i = 0, iz = node.elements.length; i < iz; ++i){\n                    result += stringifyImpl(node.elements[i], compact);\n                    if (i + 1 !== iz) {\n                        result += compact ? \",\" : \", \";\n                    }\n                }\n                result += \"]\";\n                break;\n            case Syntax.RecordType:\n                result = \"{\";\n                for(i = 0, iz = node.fields.length; i < iz; ++i){\n                    result += stringifyImpl(node.fields[i], compact);\n                    if (i + 1 !== iz) {\n                        result += compact ? \",\" : \", \";\n                    }\n                }\n                result += \"}\";\n                break;\n            case Syntax.FieldType:\n                if (node.value) {\n                    result = node.key + (compact ? \":\" : \": \") + stringifyImpl(node.value, compact);\n                } else {\n                    result = node.key;\n                }\n                break;\n            case Syntax.FunctionType:\n                result = compact ? \"function(\" : \"function (\";\n                if (node[\"this\"]) {\n                    if (node[\"new\"]) {\n                        result += compact ? \"new:\" : \"new: \";\n                    } else {\n                        result += compact ? \"this:\" : \"this: \";\n                    }\n                    result += stringifyImpl(node[\"this\"], compact);\n                    if (node.params.length !== 0) {\n                        result += compact ? \",\" : \", \";\n                    }\n                }\n                for(i = 0, iz = node.params.length; i < iz; ++i){\n                    result += stringifyImpl(node.params[i], compact);\n                    if (i + 1 !== iz) {\n                        result += compact ? \",\" : \", \";\n                    }\n                }\n                result += \")\";\n                if (node.result) {\n                    result += (compact ? \":\" : \": \") + stringifyImpl(node.result, compact);\n                }\n                break;\n            case Syntax.ParameterType:\n                result = node.name + (compact ? \":\" : \": \") + stringifyImpl(node.expression, compact);\n                break;\n            case Syntax.RestType:\n                result = \"...\";\n                if (node.expression) {\n                    result += stringifyImpl(node.expression, compact);\n                }\n                break;\n            case Syntax.NonNullableType:\n                if (node.prefix) {\n                    result = \"!\" + stringifyImpl(node.expression, compact);\n                } else {\n                    result = stringifyImpl(node.expression, compact) + \"!\";\n                }\n                break;\n            case Syntax.OptionalType:\n                result = stringifyImpl(node.expression, compact) + \"=\";\n                break;\n            case Syntax.NullableType:\n                if (node.prefix) {\n                    result = \"?\" + stringifyImpl(node.expression, compact);\n                } else {\n                    result = stringifyImpl(node.expression, compact) + \"?\";\n                }\n                break;\n            case Syntax.NameExpression:\n                result = node.name;\n                break;\n            case Syntax.TypeApplication:\n                result = stringifyImpl(node.expression, compact) + \".<\";\n                for(i = 0, iz = node.applications.length; i < iz; ++i){\n                    result += stringifyImpl(node.applications[i], compact);\n                    if (i + 1 !== iz) {\n                        result += compact ? \",\" : \", \";\n                    }\n                }\n                result += \">\";\n                break;\n            case Syntax.StringLiteralType:\n                result = '\"' + node.value + '\"';\n                break;\n            case Syntax.NumericLiteralType:\n                result = String(node.value);\n                break;\n            case Syntax.BooleanLiteralType:\n                result = String(node.value);\n                break;\n            default:\n                utility.throwError(\"Unknown type \" + node.type);\n        }\n        return result;\n    }\n    function stringify(node, options) {\n        if (options == null) {\n            options = {};\n        }\n        return stringifyImpl(node, options.compact, options.topLevel);\n    }\n    exports.parseType = parseType;\n    exports.parseParamType = parseParamType;\n    exports.stringify = stringify;\n    exports.Syntax = Syntax;\n})(); /* vim: set sw=4 ts=4 et tw=80 : */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jdHJpbmUvbGliL3R5cGVkLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBRUQsb0RBQW9EO0FBRW5EO0lBQ0c7SUFFQSxJQUFJQSxRQUNBQyxPQUNBQyxRQUNBQyxRQUNBQyxPQUNBQyxVQUNBQyxPQUNBQyxPQUNBQyxTQUNBQyxTQUNBQyxhQUNBQztJQUVKSCxVQUFVSSxtQkFBT0EsQ0FBQztJQUNsQkgsVUFBVUcsbUJBQU9BLENBQUM7SUFFbEJaLFNBQVM7UUFDTGEsaUJBQWlCO1FBQ2pCQyxZQUFZO1FBQ1pDLGFBQWE7UUFDYkMsa0JBQWtCO1FBQ2xCQyxhQUFhO1FBQ2JDLFdBQVc7UUFDWEMsV0FBVztRQUNYQyxZQUFZO1FBQ1pDLFdBQVc7UUFDWEMsY0FBYztRQUNkQyxlQUFlO1FBQ2ZDLFVBQVU7UUFDVkMsaUJBQWlCO1FBQ2pCQyxjQUFjO1FBQ2RDLGNBQWM7UUFDZEMsZ0JBQWdCO1FBQ2hCQyxpQkFBaUI7UUFDakJDLG1CQUFtQjtRQUNuQkMsb0JBQW9CO1FBQ3BCQyxvQkFBb0I7SUFDeEI7SUFFQS9CLFFBQVE7UUFDSmdDLFNBQVM7UUFDVEMsUUFBUTtRQUNSQyxNQUFNO1FBQ05DLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxRQUFRO1FBQ1JDLFFBQVE7UUFDUkMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLFFBQVE7UUFDUkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLE9BQU87UUFDUEMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLEtBQUs7SUFDVDtJQUVBLFNBQVNDLFdBQVdDLEVBQUU7UUFDbEIsT0FBTyxrQkFBa0JDLE9BQU8sQ0FBQ0MsT0FBT0MsWUFBWSxDQUFDSCxTQUFTLENBQUMsS0FBSyxDQUFDaEQsUUFBUW9ELElBQUksQ0FBQ0MsWUFBWSxDQUFDTCxPQUFPLENBQUNoRCxRQUFRb0Qs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cUMsV0FBVztnQkFDbkQsSUFBS3ZFLElBQUksR0FBR3lFLEtBQUsvRSxLQUFLdUQsWUFBWSxDQUFDNUgsTUFBTSxFQUFFMkUsSUFBSXlFLElBQUksRUFBRXpFLEVBQUc7b0JBQ3BEMkQsVUFBVVcsY0FBYzVFLEtBQUt1RCxZQUFZLENBQUNqRCxFQUFFLEVBQUV1RTtvQkFDOUMsSUFBSSxJQUFLLE1BQU9FLElBQUk7d0JBQ2hCZCxVQUFVWSxVQUFVLE1BQU07b0JBQzlCO2dCQUNKO2dCQUNBWixVQUFVO2dCQUNWO1lBRUosS0FBS3pJLE9BQU84QixpQkFBaUI7Z0JBQ3pCMkcsU0FBUyxNQUFNakUsS0FBS2pFLEtBQUssR0FBRztnQkFDNUI7WUFFSixLQUFLUCxPQUFPK0Isa0JBQWtCO2dCQUMxQjBHLFNBQVMvRSxPQUFPYyxLQUFLakUsS0FBSztnQkFDMUI7WUFFSixLQUFLUCxPQUFPZ0Msa0JBQWtCO2dCQUMxQnlHLFNBQVMvRSxPQUFPYyxLQUFLakUsS0FBSztnQkFDMUI7WUFFSjtnQkFDSUUsUUFBUStFLFVBQVUsQ0FBQyxrQkFBa0JoQixLQUFLcUMsSUFBSTtRQUNsRDtRQUVBLE9BQU80QjtJQUNYO0lBRUEsU0FBU2UsVUFBVWhGLElBQUksRUFBRWlGLE9BQU87UUFDNUIsSUFBSUEsV0FBVyxNQUFNO1lBQ2pCQSxVQUFVLENBQUM7UUFDZjtRQUNBLE9BQU9MLGNBQWM1RSxNQUFNaUYsUUFBUUosT0FBTyxFQUFFSSxRQUFRSCxRQUFRO0lBQ2hFO0lBRUFJLGlCQUFpQixHQUFHWDtJQUNwQlcsc0JBQXNCLEdBQUdQO0lBQ3pCTyxpQkFBaUIsR0FBR0Y7SUFDcEJFLGNBQWMsR0FBRzFKO0FBQ3JCLE1BQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9kb2N0cmluZS9saWIvdHlwZWQuanM/MzViNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQGZpbGVvdmVydmlldyBUeXBlIGV4cHJlc3Npb24gcGFyc2VyLlxuICogQGF1dGhvciBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gKiBAYXV0aG9yIERhbiBUYW8gPGRhbmllbC50YW9AZ21haWwuY29tPlxuICogQGF1dGhvciBBbmRyZXcgRWlzZW5iZXJnIDxhbmRyZXdAZWlzZW5iZXJnLmFzPlxuICovXG5cbi8vIFwidHlwZWRcIiwgdGhlIFR5cGUgRXhwcmVzc2lvbiBQYXJzZXIgZm9yIGRvY3RyaW5lLlxuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTeW50YXgsXG4gICAgICAgIFRva2VuLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHByZXZpb3VzLFxuICAgICAgICB0b2tlbixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGVzdXRpbHMsXG4gICAgICAgIHV0aWxpdHksXG4gICAgICAgIHJhbmdlT2Zmc2V0LFxuICAgICAgICBhZGRSYW5nZTtcblxuICAgIGVzdXRpbHMgPSByZXF1aXJlKCdlc3V0aWxzJyk7XG4gICAgdXRpbGl0eSA9IHJlcXVpcmUoJy4vdXRpbGl0eScpO1xuXG4gICAgU3ludGF4ID0ge1xuICAgICAgICBOdWxsYWJsZUxpdGVyYWw6ICdOdWxsYWJsZUxpdGVyYWwnLFxuICAgICAgICBBbGxMaXRlcmFsOiAnQWxsTGl0ZXJhbCcsXG4gICAgICAgIE51bGxMaXRlcmFsOiAnTnVsbExpdGVyYWwnLFxuICAgICAgICBVbmRlZmluZWRMaXRlcmFsOiAnVW5kZWZpbmVkTGl0ZXJhbCcsXG4gICAgICAgIFZvaWRMaXRlcmFsOiAnVm9pZExpdGVyYWwnLFxuICAgICAgICBVbmlvblR5cGU6ICdVbmlvblR5cGUnLFxuICAgICAgICBBcnJheVR5cGU6ICdBcnJheVR5cGUnLFxuICAgICAgICBSZWNvcmRUeXBlOiAnUmVjb3JkVHlwZScsXG4gICAgICAgIEZpZWxkVHlwZTogJ0ZpZWxkVHlwZScsXG4gICAgICAgIEZ1bmN0aW9uVHlwZTogJ0Z1bmN0aW9uVHlwZScsXG4gICAgICAgIFBhcmFtZXRlclR5cGU6ICdQYXJhbWV0ZXJUeXBlJyxcbiAgICAgICAgUmVzdFR5cGU6ICdSZXN0VHlwZScsXG4gICAgICAgIE5vbk51bGxhYmxlVHlwZTogJ05vbk51bGxhYmxlVHlwZScsXG4gICAgICAgIE9wdGlvbmFsVHlwZTogJ09wdGlvbmFsVHlwZScsXG4gICAgICAgIE51bGxhYmxlVHlwZTogJ051bGxhYmxlVHlwZScsXG4gICAgICAgIE5hbWVFeHByZXNzaW9uOiAnTmFtZUV4cHJlc3Npb24nLFxuICAgICAgICBUeXBlQXBwbGljYXRpb246ICdUeXBlQXBwbGljYXRpb24nLFxuICAgICAgICBTdHJpbmdMaXRlcmFsVHlwZTogJ1N0cmluZ0xpdGVyYWxUeXBlJyxcbiAgICAgICAgTnVtZXJpY0xpdGVyYWxUeXBlOiAnTnVtZXJpY0xpdGVyYWxUeXBlJyxcbiAgICAgICAgQm9vbGVhbkxpdGVyYWxUeXBlOiAnQm9vbGVhbkxpdGVyYWxUeXBlJ1xuICAgIH07XG5cbiAgICBUb2tlbiA9IHtcbiAgICAgICAgSUxMRUdBTDogMCwgICAgLy8gSUxMRUdBTFxuICAgICAgICBET1RfTFQ6IDEsICAgICAvLyAuPFxuICAgICAgICBSRVNUOiAyLCAgICAgICAvLyAuLi5cbiAgICAgICAgTFQ6IDMsICAgICAgICAgLy8gPFxuICAgICAgICBHVDogNCwgICAgICAgICAvLyA+XG4gICAgICAgIExQQVJFTjogNSwgICAgIC8vIChcbiAgICAgICAgUlBBUkVOOiA2LCAgICAgLy8gKVxuICAgICAgICBMQlJBQ0U6IDcsICAgICAvLyB7XG4gICAgICAgIFJCUkFDRTogOCwgICAgIC8vIH1cbiAgICAgICAgTEJSQUNLOiA5LCAgICAvLyBbXG4gICAgICAgIFJCUkFDSzogMTAsICAgIC8vIF1cbiAgICAgICAgQ09NTUE6IDExLCAgICAgLy8gLFxuICAgICAgICBDT0xPTjogMTIsICAgICAvLyA6XG4gICAgICAgIFNUQVI6IDEzLCAgICAgIC8vICpcbiAgICAgICAgUElQRTogMTQsICAgICAgLy8gfFxuICAgICAgICBRVUVTVElPTjogMTUsICAvLyA/XG4gICAgICAgIEJBTkc6IDE2LCAgICAgIC8vICFcbiAgICAgICAgRVFVQUw6IDE3LCAgICAgLy8gPVxuICAgICAgICBOQU1FOiAxOCwgICAgICAvLyBuYW1lIHRva2VuXG4gICAgICAgIFNUUklORzogMTksICAgIC8vIHN0cmluZ1xuICAgICAgICBOVU1CRVI6IDIwLCAgICAvLyBudW1iZXJcbiAgICAgICAgRU9GOiAyMVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1R5cGVOYW1lKGNoKSB7XG4gICAgICAgIHJldHVybiAnPjwoKXt9W10sOip8PyE9Jy5pbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSA9PT0gLTEgJiYgIWVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoY2gpICYmICFlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29udGV4dChwcmV2aW91cywgaW5kZXgsIHRva2VuLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl90b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIENvbnRleHQucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByZXZpb3VzID0gdGhpcy5fcHJldmlvdXM7XG4gICAgICAgIGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHRva2VuID0gdGhpcy5fdG9rZW47XG4gICAgICAgIHZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgfTtcblxuICAgIENvbnRleHQuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0KHByZXZpb3VzLCBpbmRleCwgdG9rZW4sIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF5YmVBZGRSYW5nZShub2RlLCByYW5nZSkge1xuICAgICAgICBpZiAoYWRkUmFuZ2UpIHtcbiAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBbcmFuZ2VbMF0gKyByYW5nZU9mZnNldCwgcmFuZ2VbMV0gKyByYW5nZU9mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICAgICAgdmFyIGNoID0gc291cmNlLmNoYXJBdChpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSGV4RXNjYXBlKHByZWZpeCkge1xuICAgICAgICB2YXIgaSwgbGVuLCBjaCwgY29kZSA9IDA7XG5cbiAgICAgICAgbGVuID0gKHByZWZpeCA9PT0gJ3UnKSA/IDQgOiAyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlc3V0aWxzLmNvZGUuaXNIZXhEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblN0cmluZygpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnLCBxdW90ZSwgY2gsIGNvZGUsIHVuZXNjYXBlZCwgcmVzdG9yZTsgLy9UT0RPIHJldmlldyByZW1vdmFsIG9jdGFsID0gZmFsc2VcbiAgICAgICAgcXVvdGUgPSBzb3VyY2UuY2hhckF0KGluZGV4KTtcbiAgICAgICAgKytpbmRleDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gYWR2YW5jZSgpO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNoID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcHJlY2F0aW5nIHVudXNlZCBjb2RlLiBUT0RPIHJldmlldyByZW1vdmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlc3V0aWxzLmNvZGUuaXNPY3RhbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFJldmlldyBSZW1vdmFsIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKGFkdmFuY2UoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXN1dGlscy5jb2RlLmlzT2N0YWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2YoYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICAnXFxyJyAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MEEgIC8qICdcXG4nICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocXVvdGUgIT09ICcnKSB7XG4gICAgICAgICAgICB1dGlsaXR5LnRocm93RXJyb3IoJ3VuZXhwZWN0ZWQgcXVvdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gc3RyO1xuICAgICAgICByZXR1cm4gVG9rZW4uU1RSSU5HO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5OdW1iZXIoKSB7XG4gICAgICAgIHZhciBudW1iZXIsIGNoO1xuXG4gICAgICAgIG51bWJlciA9ICcnO1xuICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICBpZiAoY2ggIT09IDB4MkUgIC8qICcuJyAqLykge1xuICAgICAgICAgICAgbnVtYmVyID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHg3OCAgLyogJ3gnICovIHx8IGNoID09PSAweDU4ICAvKiAnWCcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXN1dGlscy5jb2RlLmlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSAweFxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbGl0eS50aHJvd0Vycm9yKCd1bmV4cGVjdGVkIHRva2VuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJTdGFydEVTNShjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsaXR5LnRocm93RXJyb3IoJ3VuZXhwZWN0ZWQgdG9rZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KG51bWJlciwgMTYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVG9rZW4uTlVNQkVSO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlc3V0aWxzLmNvZGUuaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclN0YXJ0RVM1KGNoKSB8fCBlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbGl0eS50aHJvd0Vycm9yKCd1bmV4cGVjdGVkIHRva2VuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChudW1iZXIsIDgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVG9rZW4uTlVNQkVSO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxpdHkudGhyb3dFcnJvcigndW5leHBlY3RlZCB0b2tlbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCFlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAweDJFICAvKiAnLicgKi8pIHtcbiAgICAgICAgICAgIG51bWJlciArPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIWVzdXRpbHMuY29kZS5pc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51bWJlciArPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09IDB4NjUgIC8qICdlJyAqLyB8fCBjaCA9PT0gMHg0NSAgLyogJ0UnICovKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gYWR2YW5jZSgpO1xuXG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHgyQiAgLyogJysnICovIHx8IGNoID09PSAweDJEICAvKiAnLScgKi8pIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXN1dGlscy5jb2RlLmlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxpdHkudGhyb3dFcnJvcigndW5leHBlY3RlZCB0b2tlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyU3RhcnRFUzUoY2gpKSB7XG4gICAgICAgICAgICAgICAgdXRpbGl0eS50aHJvd0Vycm9yKCd1bmV4cGVjdGVkIHRva2VuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQobnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFRva2VuLk5VTUJFUjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHNjYW5UeXBlTmFtZSgpIHtcbiAgICAgICAgdmFyIGNoLCBjaDI7XG5cbiAgICAgICAgdmFsdWUgPSBhZHZhbmNlKCk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiBpc1R5cGVOYW1lKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAweDJFICAvKiAnLicgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoKGluZGV4ICsgMSkgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUb2tlbi5JTExFR0FMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaDIgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjaDIgPT09IDB4M0MgIC8qICc8JyAqLykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBhZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRva2VuLk5BTUU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIGNoO1xuXG4gICAgICAgIHByZXZpb3VzID0gaW5kZXg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoICYmIGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2Uoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuID0gVG9rZW4uRU9GO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAweDI3OiAgLyogJycnICovXG4gICAgICAgIGNhc2UgMHgyMjogIC8qICdcIicgKi9cbiAgICAgICAgICAgIHRva2VuID0gc2NhblN0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuXG4gICAgICAgIGNhc2UgMHgzQTogIC8qICc6JyAqL1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgdG9rZW4gPSBUb2tlbi5DT0xPTjtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblxuICAgICAgICBjYXNlIDB4MkM6ICAvKiAnLCcgKi9cbiAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgIHRva2VuID0gVG9rZW4uQ09NTUE7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cbiAgICAgICAgY2FzZSAweDI4OiAgLyogJygnICovXG4gICAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgICB0b2tlbiA9IFRva2VuLkxQQVJFTjtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblxuICAgICAgICBjYXNlIDB4Mjk6ICAvKiAnKScgKi9cbiAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgIHRva2VuID0gVG9rZW4uUlBBUkVOO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuXG4gICAgICAgIGNhc2UgMHg1QjogIC8qICdbJyAqL1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgdG9rZW4gPSBUb2tlbi5MQlJBQ0s7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cbiAgICAgICAgY2FzZSAweDVEOiAgLyogJ10nICovXG4gICAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgICB0b2tlbiA9IFRva2VuLlJCUkFDSztcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblxuICAgICAgICBjYXNlIDB4N0I6ICAvKiAneycgKi9cbiAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgIHRva2VuID0gVG9rZW4uTEJSQUNFO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuXG4gICAgICAgIGNhc2UgMHg3RDogIC8qICd9JyAqL1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgdG9rZW4gPSBUb2tlbi5SQlJBQ0U7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cbiAgICAgICAgY2FzZSAweDJFOiAgLyogJy4nICovXG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgzQyAgLyogJzwnICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKTsgIC8vICcuJ1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCk7ICAvLyAnPCdcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBUb2tlbi5ET1RfTFQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MkUgIC8qICcuJyAqLyAmJiBpbmRleCArIDIgPCBsZW5ndGggJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAyKSA9PT0gMHgyRSAgLyogJy4nICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKTsgIC8vICcuJ1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCk7ICAvLyAnLidcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgpOyAgLy8gJy4nXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gVG9rZW4uUkVTVDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gc2Nhbk51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4gPSBUb2tlbi5JTExFR0FMO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuXG4gICAgICAgIGNhc2UgMHgzQzogIC8qICc8JyAqL1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgdG9rZW4gPSBUb2tlbi5MVDtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblxuICAgICAgICBjYXNlIDB4M0U6ICAvKiAnPicgKi9cbiAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgIHRva2VuID0gVG9rZW4uR1Q7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cbiAgICAgICAgY2FzZSAweDJBOiAgLyogJyonICovXG4gICAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgICB0b2tlbiA9IFRva2VuLlNUQVI7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cbiAgICAgICAgY2FzZSAweDdDOiAgLyogJ3wnICovXG4gICAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgICB0b2tlbiA9IFRva2VuLlBJUEU7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cbiAgICAgICAgY2FzZSAweDNGOiAgLyogJz8nICovXG4gICAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgICB0b2tlbiA9IFRva2VuLlFVRVNUSU9OO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuXG4gICAgICAgIGNhc2UgMHgyMTogIC8qICchJyAqL1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgdG9rZW4gPSBUb2tlbi5CQU5HO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuXG4gICAgICAgIGNhc2UgMHgzRDogIC8qICc9JyAqL1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgdG9rZW4gPSBUb2tlbi5FUVVBTDtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblxuICAgICAgICBjYXNlIDB4MkQ6IC8qICctJyAqL1xuICAgICAgICAgICAgdG9rZW4gPSBzY2FuTnVtYmVyKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBzY2FuTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0eXBlIHN0cmluZyBwZXJtaXRzIGZvbGxvd2luZyBjYXNlLFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIG5hbWVzcGFjZS5tb2R1bGUuTXlDbGFzc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoaXMgcmVkdWNlZCAxIHRva2VuIFRLX05BTUVcbiAgICAgICAgICAgIHV0aWxpdHkuYXNzZXJ0KGlzVHlwZU5hbWUoY2gpKTtcbiAgICAgICAgICAgIHRva2VuID0gc2NhblR5cGVOYW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25zdW1lKHRhcmdldCwgdGV4dCkge1xuICAgICAgICB1dGlsaXR5LmFzc2VydCh0b2tlbiA9PT0gdGFyZ2V0LCB0ZXh0IHx8ICdjb25zdW1lZCB0b2tlbiBub3QgbWF0Y2hlZCcpO1xuICAgICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwZWN0KHRhcmdldCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodG9rZW4gIT09IHRhcmdldCkge1xuICAgICAgICAgICAgdXRpbGl0eS50aHJvd0Vycm9yKG1lc3NhZ2UgfHwgJ3VuZXhwZWN0ZWQgdG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgLy8gVW5pb25UeXBlIDo9ICcoJyBUeXBlVW5pb25MaXN0ICcpJ1xuICAgIC8vXG4gICAgLy8gVHlwZVVuaW9uTGlzdCA6PVxuICAgIC8vICAgICA8PGVtcHR5Pj5cbiAgICAvLyAgIHwgTm9uZW1wdHlUeXBlVW5pb25MaXN0XG4gICAgLy9cbiAgICAvLyBOb25lbXB0eVR5cGVVbmlvbkxpc3QgOj1cbiAgICAvLyAgICAgVHlwZUV4cHJlc3Npb25cbiAgICAvLyAgIHwgVHlwZUV4cHJlc3Npb24gJ3wnIE5vbmVtcHR5VHlwZVVuaW9uTGlzdFxuICAgIGZ1bmN0aW9uIHBhcnNlVW5pb25UeXBlKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMsIHN0YXJ0SW5kZXggPSBpbmRleCAtIDE7XG4gICAgICAgIGNvbnN1bWUoVG9rZW4uTFBBUkVOLCAnVW5pb25UeXBlIHNob3VsZCBzdGFydCB3aXRoICgnKTtcbiAgICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRva2VuICE9PSBUb2tlbi5SUEFSRU4pIHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZVR5cGVFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gVG9rZW4uUlBBUkVOKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoVG9rZW4uUElQRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3VtZShUb2tlbi5SUEFSRU4sICdVbmlvblR5cGUgc2hvdWxkIGVuZCB3aXRoICknKTtcbiAgICAgICAgcmV0dXJuIG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LlVuaW9uVHlwZSxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgICAgICB9LCBbc3RhcnRJbmRleCwgcHJldmlvdXNdKTtcbiAgICB9XG5cbiAgICAvLyBBcnJheVR5cGUgOj0gJ1snIEVsZW1lbnRUeXBlTGlzdCAnXSdcbiAgICAvL1xuICAgIC8vIEVsZW1lbnRUeXBlTGlzdCA6PVxuICAgIC8vICAgICA8PGVtcHR5Pj5cbiAgICAvLyAgfCBUeXBlRXhwcmVzc2lvblxuICAgIC8vICB8ICcuLi4nIFR5cGVFeHByZXNzaW9uXG4gICAgLy8gIHwgVHlwZUV4cHJlc3Npb24gJywnIEVsZW1lbnRUeXBlTGlzdFxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXlUeXBlKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMsIHN0YXJ0SW5kZXggPSBpbmRleCAtIDEsIHJlc3RTdGFydEluZGV4O1xuICAgICAgICBjb25zdW1lKFRva2VuLkxCUkFDSywgJ0FycmF5VHlwZSBzaG91bGQgc3RhcnQgd2l0aCBbJyk7XG4gICAgICAgIGVsZW1lbnRzID0gW107XG4gICAgICAgIHdoaWxlICh0b2tlbiAhPT0gVG9rZW4uUkJSQUNLKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLlJFU1QpIHtcbiAgICAgICAgICAgICAgICByZXN0U3RhcnRJbmRleCA9IGluZGV4IC0gMztcbiAgICAgICAgICAgICAgICBjb25zdW1lKFRva2VuLlJFU1QpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobWF5YmVBZGRSYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5SZXN0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogcGFyc2VUeXBlRXhwcmVzc2lvbigpXG4gICAgICAgICAgICAgICAgfSwgW3Jlc3RTdGFydEluZGV4LCBwcmV2aW91c10pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZVR5cGVFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuICE9PSBUb2tlbi5SQlJBQ0spIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoVG9rZW4uQ09NTUEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV4cGVjdChUb2tlbi5SQlJBQ0spO1xuICAgICAgICByZXR1cm4gbWF5YmVBZGRSYW5nZSh7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQXJyYXlUeXBlLFxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICAgIH0sIFtzdGFydEluZGV4LCBwcmV2aW91c10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRmllbGROYW1lKCkge1xuICAgICAgICB2YXIgdiA9IHZhbHVlO1xuICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLk5BTUUgfHwgdG9rZW4gPT09IFRva2VuLlNUUklORykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLk5VTUJFUikge1xuICAgICAgICAgICAgY29uc3VtZShUb2tlbi5OVU1CRVIpO1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWxpdHkudGhyb3dFcnJvcigndW5leHBlY3RlZCB0b2tlbicpO1xuICAgIH1cblxuICAgIC8vIEZpZWxkVHlwZSA6PVxuICAgIC8vICAgICBGaWVsZE5hbWVcbiAgICAvLyAgIHwgRmllbGROYW1lICc6JyBUeXBlRXhwcmVzc2lvblxuICAgIC8vXG4gICAgLy8gRmllbGROYW1lIDo9XG4gICAgLy8gICAgIE5hbWVFeHByZXNzaW9uXG4gICAgLy8gICB8IFN0cmluZ0xpdGVyYWxcbiAgICAvLyAgIHwgTnVtYmVyTGl0ZXJhbFxuICAgIC8vICAgfCBSZXNlcnZlZElkZW50aWZpZXJcbiAgICBmdW5jdGlvbiBwYXJzZUZpZWxkVHlwZSgpIHtcbiAgICAgICAgdmFyIGtleSwgcmFuZ2VTdGFydCA9IHByZXZpb3VzO1xuXG4gICAgICAgIGtleSA9IHBhcnNlRmllbGROYW1lKCk7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gVG9rZW4uQ09MT04pIHtcbiAgICAgICAgICAgIGNvbnN1bWUoVG9rZW4uQ09MT04pO1xuICAgICAgICAgICAgcmV0dXJuIG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5GaWVsZFR5cGUsXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlVHlwZUV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfSwgW3JhbmdlU3RhcnQsIHByZXZpb3VzXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZpZWxkVHlwZSxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSwgW3JhbmdlU3RhcnQsIHByZXZpb3VzXSk7XG4gICAgfVxuXG4gICAgLy8gUmVjb3JkVHlwZSA6PSAneycgRmllbGRUeXBlTGlzdCAnfSdcbiAgICAvL1xuICAgIC8vIEZpZWxkVHlwZUxpc3QgOj1cbiAgICAvLyAgICAgPDxlbXB0eT4+XG4gICAgLy8gICB8IEZpZWxkVHlwZVxuICAgIC8vICAgfCBGaWVsZFR5cGUgJywnIEZpZWxkVHlwZUxpc3RcbiAgICBmdW5jdGlvbiBwYXJzZVJlY29yZFR5cGUoKSB7XG4gICAgICAgIHZhciBmaWVsZHMsIHJhbmdlU3RhcnQgPSBpbmRleCAtIDEsIHJhbmdlRW5kO1xuXG4gICAgICAgIGNvbnN1bWUoVG9rZW4uTEJSQUNFLCAnUmVjb3JkVHlwZSBzaG91bGQgc3RhcnQgd2l0aCB7Jyk7XG4gICAgICAgIGZpZWxkcyA9IFtdO1xuICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLkNPTU1BKSB7XG4gICAgICAgICAgICBjb25zdW1lKFRva2VuLkNPTU1BKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICh0b2tlbiAhPT0gVG9rZW4uUkJSQUNFKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2gocGFyc2VGaWVsZFR5cGUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBUb2tlbi5SQlJBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFRva2VuLkNPTU1BKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2VFbmQgPSBpbmRleDtcbiAgICAgICAgZXhwZWN0KFRva2VuLlJCUkFDRSk7XG4gICAgICAgIHJldHVybiBtYXliZUFkZFJhbmdlKHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5SZWNvcmRUeXBlLFxuICAgICAgICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICAgICAgfSwgW3JhbmdlU3RhcnQsIHJhbmdlRW5kXSk7XG4gICAgfVxuXG4gICAgLy8gTmFtZUV4cHJlc3Npb24gOj1cbiAgICAvLyAgICBJZGVudGlmaWVyXG4gICAgLy8gIHwgVGFnSWRlbnRpZmllciAnOicgSWRlbnRpZmllclxuICAgIC8vXG4gICAgLy8gVGFnIGlkZW50aWZpZXIgaXMgb25lIG9mIFwibW9kdWxlXCIsIFwiZXh0ZXJuYWxcIiBvciBcImV2ZW50XCJcbiAgICAvLyBJZGVudGlmaWVyIGlzIHRoZSBzYW1lIGFzIFRva2VuLk5BTUUsIGluY2x1ZGluZyBhbnkgZG90cywgc29tZXRoaW5nIGxpa2VcbiAgICAvLyBuYW1lc3BhY2UubW9kdWxlLk15Q2xhc3NcbiAgICBmdW5jdGlvbiBwYXJzZU5hbWVFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLCByYW5nZVN0YXJ0ID0gaW5kZXggLSBuYW1lLmxlbmd0aDtcbiAgICAgICAgZXhwZWN0KFRva2VuLk5BTUUpO1xuXG4gICAgICAgIGlmICh0b2tlbiA9PT0gVG9rZW4uQ09MT04gJiYgKFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdtb2R1bGUnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2V4dGVybmFsJyB8fFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdldmVudCcpKSB7XG4gICAgICAgICAgICBjb25zdW1lKFRva2VuLkNPTE9OKTtcbiAgICAgICAgICAgIG5hbWUgKz0gJzonICsgdmFsdWU7XG4gICAgICAgICAgICBleHBlY3QoVG9rZW4uTkFNRSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF5YmVBZGRSYW5nZSh7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguTmFtZUV4cHJlc3Npb24sXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH0sIFtyYW5nZVN0YXJ0LCBwcmV2aW91c10pO1xuICAgIH1cblxuICAgIC8vIFR5cGVFeHByZXNzaW9uTGlzdCA6PVxuICAgIC8vICAgICBUb3BMZXZlbFR5cGVFeHByZXNzaW9uXG4gICAgLy8gICB8IFRvcExldmVsVHlwZUV4cHJlc3Npb24gJywnIFR5cGVFeHByZXNzaW9uTGlzdFxuICAgIGZ1bmN0aW9uIHBhcnNlVHlwZUV4cHJlc3Npb25MaXN0KCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlVG9wKCkpO1xuICAgICAgICB3aGlsZSAodG9rZW4gPT09IFRva2VuLkNPTU1BKSB7XG4gICAgICAgICAgICBjb25zdW1lKFRva2VuLkNPTU1BKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VUb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cblxuICAgIC8vIFR5cGVOYW1lIDo9XG4gICAgLy8gICAgIE5hbWVFeHByZXNzaW9uXG4gICAgLy8gICB8IE5hbWVFeHByZXNzaW9uIFR5cGVBcHBsaWNhdGlvblxuICAgIC8vXG4gICAgLy8gVHlwZUFwcGxpY2F0aW9uIDo9XG4gICAgLy8gICAgICcuPCcgVHlwZUV4cHJlc3Npb25MaXN0ICc+J1xuICAgIC8vICAgfCAnPCcgVHlwZUV4cHJlc3Npb25MaXN0ICc+JyAgIC8vIHRoaXMgaXMgZXh0ZW5zaW9uIG9mIGRvY3RyaW5lXG4gICAgZnVuY3Rpb24gcGFyc2VUeXBlTmFtZSgpIHtcbiAgICAgICAgdmFyIGV4cHIsIGFwcGxpY2F0aW9ucywgc3RhcnRJbmRleCA9IGluZGV4IC0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZU5hbWVFeHByZXNzaW9uKCk7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gVG9rZW4uRE9UX0xUIHx8IHRva2VuID09PSBUb2tlbi5MVCkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgYXBwbGljYXRpb25zID0gcGFyc2VUeXBlRXhwcmVzc2lvbkxpc3QoKTtcbiAgICAgICAgICAgIGV4cGVjdChUb2tlbi5HVCk7XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVBZGRSYW5nZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlR5cGVBcHBsaWNhdGlvbixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uczogYXBwbGljYXRpb25zXG4gICAgICAgICAgICB9LCBbc3RhcnRJbmRleCwgcHJldmlvdXNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyBSZXN1bHRUeXBlIDo9XG4gICAgLy8gICAgIDw8ZW1wdHk+PlxuICAgIC8vICAgfCAnOicgdm9pZFxuICAgIC8vICAgfCAnOicgVHlwZUV4cHJlc3Npb25cbiAgICAvL1xuICAgIC8vIEJORiBpcyBhYm92ZVxuICAgIC8vIGJ1dCwgd2UgcmVtb3ZlIDw8ZW1wdHk+PiBwYXR0ZXJuLCBzbyB0b2tlbiBpcyBhbHdheXMgVHlwZVRva2VuOjpDT0xPTlxuICAgIGZ1bmN0aW9uIHBhcnNlUmVzdWx0VHlwZSgpIHtcbiAgICAgICAgY29uc3VtZShUb2tlbi5DT0xPTiwgJ1Jlc3VsdFR5cGUgc2hvdWxkIHN0YXJ0IHdpdGggOicpO1xuICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLk5BTUUgJiYgdmFsdWUgPT09ICd2b2lkJykge1xuICAgICAgICAgICAgY29uc3VtZShUb2tlbi5OQU1FKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlZvaWRMaXRlcmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVR5cGVFeHByZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgLy8gUGFyYW1ldGVyc1R5cGUgOj1cbiAgICAvLyAgICAgUmVzdFBhcmFtZXRlclR5cGVcbiAgICAvLyAgIHwgTm9uUmVzdFBhcmFtZXRlcnNUeXBlXG4gICAgLy8gICB8IE5vblJlc3RQYXJhbWV0ZXJzVHlwZSAnLCcgUmVzdFBhcmFtZXRlclR5cGVcbiAgICAvL1xuICAgIC8vIFJlc3RQYXJhbWV0ZXJUeXBlIDo9XG4gICAgLy8gICAgICcuLi4nXG4gICAgLy8gICAgICcuLi4nIElkZW50aWZpZXJcbiAgICAvL1xuICAgIC8vIE5vblJlc3RQYXJhbWV0ZXJzVHlwZSA6PVxuICAgIC8vICAgICBQYXJhbWV0ZXJUeXBlICcsJyBOb25SZXN0UGFyYW1ldGVyc1R5cGVcbiAgICAvLyAgIHwgUGFyYW1ldGVyVHlwZVxuICAgIC8vICAgfCBPcHRpb25hbFBhcmFtZXRlcnNUeXBlXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbFBhcmFtZXRlcnNUeXBlIDo9XG4gICAgLy8gICAgIE9wdGlvbmFsUGFyYW1ldGVyVHlwZVxuICAgIC8vICAgfCBPcHRpb25hbFBhcmFtZXRlclR5cGUsIE9wdGlvbmFsUGFyYW1ldGVyc1R5cGVcbiAgICAvL1xuICAgIC8vIE9wdGlvbmFsUGFyYW1ldGVyVHlwZSA6PSBQYXJhbWV0ZXJUeXBlPVxuICAgIC8vXG4gICAgLy8gUGFyYW1ldGVyVHlwZSA6PSBUeXBlRXhwcmVzc2lvbiB8IElkZW50aWZpZXIgJzonIFR5cGVFeHByZXNzaW9uXG4gICAgLy9cbiAgICAvLyBJZGVudGlmaWVyIGlzIFwibmV3XCIgb3IgXCJ0aGlzXCJcbiAgICBmdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnNUeXBlKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0gW10sIG9wdGlvbmFsU2VxdWVuY2UgPSBmYWxzZSwgZXhwciwgcmVzdCA9IGZhbHNlLCBzdGFydEluZGV4LCByZXN0U3RhcnRJbmRleCA9IGluZGV4IC0gMywgbmFtZVN0YXJ0SW5kZXg7XG5cbiAgICAgICAgd2hpbGUgKHRva2VuICE9PSBUb2tlbi5SUEFSRU4pIHtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gVG9rZW4uUkVTVCkge1xuICAgICAgICAgICAgICAgIC8vIFJlc3RQYXJhbWV0ZXJUeXBlXG4gICAgICAgICAgICAgICAgY29uc3VtZShUb2tlbi5SRVNUKTtcbiAgICAgICAgICAgICAgICByZXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhcnRJbmRleCA9IHByZXZpb3VzO1xuXG4gICAgICAgICAgICBleHByID0gcGFyc2VUeXBlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4Lk5hbWVFeHByZXNzaW9uICYmIHRva2VuID09PSBUb2tlbi5DT0xPTikge1xuICAgICAgICAgICAgICAgIG5hbWVTdGFydEluZGV4ID0gcHJldmlvdXMgLSBleHByLm5hbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIElkZW50aWZpZXIgJzonIFR5cGVFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgY29uc3VtZShUb2tlbi5DT0xPTik7XG4gICAgICAgICAgICAgICAgZXhwciA9IG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUGFyYW1ldGVyVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZXhwci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBwYXJzZVR5cGVFeHByZXNzaW9uKClcbiAgICAgICAgICAgICAgICB9LCBbbmFtZVN0YXJ0SW5kZXgsIHByZXZpb3VzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLkVRVUFMKSB7XG4gICAgICAgICAgICAgICAgY29uc3VtZShUb2tlbi5FUVVBTCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguT3B0aW9uYWxUeXBlLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByXG4gICAgICAgICAgICAgICAgfSwgW3N0YXJ0SW5kZXgsIHByZXZpb3VzXSk7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxTZXF1ZW5jZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbFNlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxpdHkudGhyb3dFcnJvcigndW5leHBlY3RlZCB0b2tlbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUmVzdFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJcbiAgICAgICAgICAgICAgICB9LCBbcmVzdFN0YXJ0SW5kZXgsIHByZXZpb3VzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMucHVzaChleHByKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gVG9rZW4uUlBBUkVOKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFRva2VuLkNPTU1BKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uVHlwZSA6PSAnZnVuY3Rpb24nIEZ1bmN0aW9uU2lnbmF0dXJlVHlwZVxuICAgIC8vXG4gICAgLy8gRnVuY3Rpb25TaWduYXR1cmVUeXBlIDo9XG4gICAgLy8gICB8IFR5cGVQYXJhbWV0ZXJzICcoJyAnKScgUmVzdWx0VHlwZVxuICAgIC8vICAgfCBUeXBlUGFyYW1ldGVycyAnKCcgUGFyYW1ldGVyc1R5cGUgJyknIFJlc3VsdFR5cGVcbiAgICAvLyAgIHwgVHlwZVBhcmFtZXRlcnMgJygnICd0aGlzJyAnOicgVHlwZU5hbWUgJyknIFJlc3VsdFR5cGVcbiAgICAvLyAgIHwgVHlwZVBhcmFtZXRlcnMgJygnICd0aGlzJyAnOicgVHlwZU5hbWUgJywnIFBhcmFtZXRlcnNUeXBlICcpJyBSZXN1bHRUeXBlXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvblR5cGUoKSB7XG4gICAgICAgIHZhciBpc05ldywgdGhpc0JpbmRpbmcsIHBhcmFtcywgcmVzdWx0LCBmblR5cGUsIHN0YXJ0SW5kZXggPSBpbmRleCAtIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdXRpbGl0eS5hc3NlcnQodG9rZW4gPT09IFRva2VuLk5BTUUgJiYgdmFsdWUgPT09ICdmdW5jdGlvbicsICdGdW5jdGlvblR5cGUgc2hvdWxkIHN0YXJ0IHdpdGggXFwnZnVuY3Rpb25cXCcnKTtcbiAgICAgICAgY29uc3VtZShUb2tlbi5OQU1FKTtcblxuICAgICAgICAvLyBHb29nbGUgQ2xvc3VyZSBDb21waWxlciBpcyBub3QgaW1wbGVtZW50aW5nIFR5cGVQYXJhbWV0ZXJzLlxuICAgICAgICAvLyBTbyB3ZSBkbyBub3QuIGlmIHdlIGRvbid0IGdldCAnKCcsIHdlIHNlZSBpdCBhcyBlcnJvci5cbiAgICAgICAgZXhwZWN0KFRva2VuLkxQQVJFTik7XG5cbiAgICAgICAgaXNOZXcgPSBmYWxzZTtcbiAgICAgICAgcGFyYW1zID0gW107XG4gICAgICAgIHRoaXNCaW5kaW5nID0gbnVsbDtcbiAgICAgICAgaWYgKHRva2VuICE9PSBUb2tlbi5SUEFSRU4pIHtcbiAgICAgICAgICAgIC8vIFBhcmFtZXRlcnNUeXBlIG9yICd0aGlzJ1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBUb2tlbi5OQU1FICYmXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ3RoaXMnIHx8IHZhbHVlID09PSAnbmV3JykpIHtcbiAgICAgICAgICAgICAgICAvLyAndGhpcycgb3IgJ25ldydcbiAgICAgICAgICAgICAgICAvLyAnbmV3JyBpcyBDbG9zdXJlIENvbXBpbGVyIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIGlzTmV3ID0gdmFsdWUgPT09ICduZXcnO1xuICAgICAgICAgICAgICAgIGNvbnN1bWUoVG9rZW4uTkFNRSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFRva2VuLkNPTE9OKTtcbiAgICAgICAgICAgICAgICB0aGlzQmluZGluZyA9IHBhcnNlVHlwZU5hbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLkNPTU1BKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWUoVG9rZW4uQ09NTUEpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJzZVBhcmFtZXRlcnNUeXBlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJzZVBhcmFtZXRlcnNUeXBlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoVG9rZW4uUlBBUkVOKTtcblxuICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLkNPTE9OKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJzZVJlc3VsdFR5cGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuVHlwZSA9IG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZ1bmN0aW9uVHlwZSxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgfSwgW3N0YXJ0SW5kZXgsIHByZXZpb3VzXSk7XG4gICAgICAgIGlmICh0aGlzQmluZGluZykge1xuICAgICAgICAgICAgLy8gYXZvaWQgYWRkaW5nIG51bGwgJ25ldycgYW5kICd0aGlzJyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBmblR5cGVbJ3RoaXMnXSA9IHRoaXNCaW5kaW5nO1xuICAgICAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICAgICAgZm5UeXBlWyduZXcnXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuVHlwZTtcbiAgICB9XG5cbiAgICAvLyBCYXNpY1R5cGVFeHByZXNzaW9uIDo9XG4gICAgLy8gICAgICcqJ1xuICAgIC8vICAgfCAnbnVsbCdcbiAgICAvLyAgIHwgJ3VuZGVmaW5lZCdcbiAgICAvLyAgIHwgVHlwZU5hbWVcbiAgICAvLyAgIHwgRnVuY3Rpb25UeXBlXG4gICAgLy8gICB8IFVuaW9uVHlwZVxuICAgIC8vICAgfCBSZWNvcmRUeXBlXG4gICAgLy8gICB8IEFycmF5VHlwZVxuICAgIGZ1bmN0aW9uIHBhcnNlQmFzaWNUeXBlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGNvbnRleHQsIHN0YXJ0SW5kZXg7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSBUb2tlbi5TVEFSOlxuICAgICAgICAgICAgY29uc3VtZShUb2tlbi5TVEFSKTtcbiAgICAgICAgICAgIHJldHVybiBtYXliZUFkZFJhbmdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQWxsTGl0ZXJhbFxuICAgICAgICAgICAgfSwgW3ByZXZpb3VzIC0gMSwgcHJldmlvdXNdKTtcblxuICAgICAgICBjYXNlIFRva2VuLkxQQVJFTjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVVuaW9uVHlwZSgpO1xuXG4gICAgICAgIGNhc2UgVG9rZW4uTEJSQUNLOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlUeXBlKCk7XG5cbiAgICAgICAgY2FzZSBUb2tlbi5MQlJBQ0U6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSZWNvcmRUeXBlKCk7XG5cbiAgICAgICAgY2FzZSBUb2tlbi5OQU1FOlxuICAgICAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4IC0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIGNvbnN1bWUoVG9rZW4uTkFNRSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTnVsbExpdGVyYWxcbiAgICAgICAgICAgICAgICB9LCBbc3RhcnRJbmRleCwgcHJldmlvdXNdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN1bWUoVG9rZW4uTkFNRSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVW5kZWZpbmVkTGl0ZXJhbFxuICAgICAgICAgICAgICAgIH0sIFtzdGFydEluZGV4LCBwcmV2aW91c10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgIGNvbnN1bWUoVG9rZW4uTkFNRSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQm9vbGVhbkxpdGVyYWxUeXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT09ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH0sIFtzdGFydEluZGV4LCBwcmV2aW91c10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0ID0gQ29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvblR5cGUoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHlwZU5hbWUoKTtcblxuICAgICAgICBjYXNlIFRva2VuLlNUUklORzpcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBtYXliZUFkZFJhbmdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguU3RyaW5nTGl0ZXJhbFR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9LCBbcHJldmlvdXMgLSB2YWx1ZS5sZW5ndGggLSAyLCBwcmV2aW91c10pO1xuXG4gICAgICAgIGNhc2UgVG9rZW4uTlVNQkVSOlxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OdW1lcmljTGl0ZXJhbFR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9LCBbcHJldmlvdXMgLSBTdHJpbmcodmFsdWUpLmxlbmd0aCwgcHJldmlvdXNdKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdXRpbGl0eS50aHJvd0Vycm9yKCd1bmV4cGVjdGVkIHRva2VuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUeXBlRXhwcmVzc2lvbiA6PVxuICAgIC8vICAgICBCYXNpY1R5cGVFeHByZXNzaW9uXG4gICAgLy8gICB8ICc/JyBCYXNpY1R5cGVFeHByZXNzaW9uXG4gICAgLy8gICB8ICchJyBCYXNpY1R5cGVFeHByZXNzaW9uXG4gICAgLy8gICB8IEJhc2ljVHlwZUV4cHJlc3Npb24gJz8nXG4gICAgLy8gICB8IEJhc2ljVHlwZUV4cHJlc3Npb24gJyEnXG4gICAgLy8gICB8ICc/J1xuICAgIC8vICAgfCBCYXNpY1R5cGVFeHByZXNzaW9uICdbXSdcbiAgICBmdW5jdGlvbiBwYXJzZVR5cGVFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgcmFuZ2VTdGFydDtcblxuICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLlFVRVNUSU9OKSB7XG4gICAgICAgICAgICByYW5nZVN0YXJ0ID0gaW5kZXggLSAxO1xuICAgICAgICAgICAgY29uc3VtZShUb2tlbi5RVUVTVElPTik7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLkNPTU1BIHx8IHRva2VuID09PSBUb2tlbi5FUVVBTCB8fCB0b2tlbiA9PT0gVG9rZW4uUkJSQUNFIHx8XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID09PSBUb2tlbi5SUEFSRU4gfHwgdG9rZW4gPT09IFRva2VuLlBJUEUgfHwgdG9rZW4gPT09IFRva2VuLkVPRiB8fFxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9PT0gVG9rZW4uUkJSQUNLIHx8IHRva2VuID09PSBUb2tlbi5HVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXliZUFkZFJhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk51bGxhYmxlTGl0ZXJhbFxuICAgICAgICAgICAgICAgIH0sIFtyYW5nZVN0YXJ0LCBwcmV2aW91c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OdWxsYWJsZVR5cGUsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogcGFyc2VCYXNpY1R5cGVFeHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAgcHJlZml4OiB0cnVlXG4gICAgICAgICAgICB9LCBbcmFuZ2VTdGFydCwgcHJldmlvdXNdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gVG9rZW4uQkFORykge1xuICAgICAgICAgICAgcmFuZ2VTdGFydCA9IGluZGV4IC0gMTtcbiAgICAgICAgICAgIGNvbnN1bWUoVG9rZW4uQkFORyk7XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVBZGRSYW5nZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk5vbk51bGxhYmxlVHlwZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBwYXJzZUJhc2ljVHlwZUV4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWVcbiAgICAgICAgICAgIH0sIFtyYW5nZVN0YXJ0LCBwcmV2aW91c10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2VTdGFydCA9IHByZXZpb3VzO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwciA9IHBhcnNlQmFzaWNUeXBlRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLkJBTkcpIHtcbiAgICAgICAgICAgIGNvbnN1bWUoVG9rZW4uQkFORyk7XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVBZGRSYW5nZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk5vbk51bGxhYmxlVHlwZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgIHByZWZpeDogZmFsc2VcbiAgICAgICAgICAgIH0sIFtyYW5nZVN0YXJ0LCBwcmV2aW91c10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuID09PSBUb2tlbi5RVUVTVElPTikge1xuICAgICAgICAgICAgY29uc3VtZShUb2tlbi5RVUVTVElPTik7XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVBZGRSYW5nZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk51bGxhYmxlVHlwZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgIHByZWZpeDogZmFsc2VcbiAgICAgICAgICAgIH0sIFtyYW5nZVN0YXJ0LCBwcmV2aW91c10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuID09PSBUb2tlbi5MQlJBQ0spIHtcbiAgICAgICAgICAgIGNvbnN1bWUoVG9rZW4uTEJSQUNLKTtcbiAgICAgICAgICAgIGV4cGVjdChUb2tlbi5SQlJBQ0ssICdleHBlY3RlZCBhbiBhcnJheS1zdHlsZSB0eXBlIGRlY2xhcmF0aW9uICgnICsgdmFsdWUgKyAnW10pJyk7XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVBZGRSYW5nZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlR5cGVBcHBsaWNhdGlvbixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYXliZUFkZFJhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk5hbWVFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXJyYXknXG4gICAgICAgICAgICAgICAgfSwgW3JhbmdlU3RhcnQsIHByZXZpb3VzXSksXG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb25zOiBbZXhwcl1cbiAgICAgICAgICAgIH0sIFtyYW5nZVN0YXJ0LCBwcmV2aW91c10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gVG9wTGV2ZWxUeXBlRXhwcmVzc2lvbiA6PVxuICAgIC8vICAgICAgVHlwZUV4cHJlc3Npb25cbiAgICAvLyAgICB8IFR5cGVVbmlvbkxpc3RcbiAgICAvL1xuICAgIC8vIFRoaXMgcnVsZSBpcyBHb29nbGUgQ2xvc3VyZSBDb21waWxlciBleHRlbnNpb24sIG5vdCBFUzRcbiAgICAvLyBsaWtlLFxuICAgIC8vICAgeyBudW1iZXIgfCBzdHJpbmcgfVxuICAgIC8vIElmIHN0cmljdCB0byBFUzQsIHdlIHNob3VsZCB3cml0ZSBpdCBhc1xuICAgIC8vICAgeyAobnVtYmVyfHN0cmluZykgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVG9wKCkge1xuICAgICAgICB2YXIgZXhwciwgZWxlbWVudHM7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlVHlwZUV4cHJlc3Npb24oKTtcbiAgICAgICAgaWYgKHRva2VuICE9PSBUb2tlbi5QSVBFKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzID0gW2V4cHJdO1xuICAgICAgICBjb25zdW1lKFRva2VuLlBJUEUpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZVR5cGVFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgaWYgKHRva2VuICE9PSBUb2tlbi5QSVBFKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lKFRva2VuLlBJUEUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LlVuaW9uVHlwZSxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgICAgICB9LCBbMCwgaW5kZXhdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRvcFBhcmFtVHlwZSgpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgaWYgKHRva2VuID09PSBUb2tlbi5SRVNUKSB7XG4gICAgICAgICAgICBjb25zdW1lKFRva2VuLlJFU1QpO1xuICAgICAgICAgICAgcmV0dXJuIG1heWJlQWRkUmFuZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5SZXN0VHlwZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBwYXJzZVRvcCgpXG4gICAgICAgICAgICB9LCBbMCwgaW5kZXhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHIgPSBwYXJzZVRvcCgpO1xuICAgICAgICBpZiAodG9rZW4gPT09IFRva2VuLkVRVUFMKSB7XG4gICAgICAgICAgICBjb25zdW1lKFRva2VuLkVRVUFMKTtcbiAgICAgICAgICAgIHJldHVybiBtYXliZUFkZFJhbmdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguT3B0aW9uYWxUeXBlLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJcbiAgICAgICAgICAgIH0sIFswLCBpbmRleF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUeXBlKHNyYywgb3B0KSB7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIHNvdXJjZSA9IHNyYztcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBwcmV2aW91cyA9IDA7XG4gICAgICAgIGFkZFJhbmdlID0gb3B0ICYmIG9wdC5yYW5nZTtcbiAgICAgICAgcmFuZ2VPZmZzZXQgPSBvcHQgJiYgb3B0LnN0YXJ0SW5kZXggfHwgMDtcblxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGV4cHIgPSBwYXJzZVRvcCgpO1xuXG4gICAgICAgIGlmIChvcHQgJiYgb3B0Lm1pZHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgIGluZGV4OiBwcmV2aW91c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbiAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB1dGlsaXR5LnRocm93RXJyb3IoJ25vdCByZWFjaCB0byBFT0YnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGFyYW1UeXBlKHNyYywgb3B0KSB7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIHNvdXJjZSA9IHNyYztcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBwcmV2aW91cyA9IDA7XG4gICAgICAgIGFkZFJhbmdlID0gb3B0ICYmIG9wdC5yYW5nZTtcbiAgICAgICAgcmFuZ2VPZmZzZXQgPSBvcHQgJiYgb3B0LnN0YXJ0SW5kZXggfHwgMDtcblxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGV4cHIgPSBwYXJzZVRvcFBhcmFtVHlwZSgpO1xuXG4gICAgICAgIGlmIChvcHQgJiYgb3B0Lm1pZHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgIGluZGV4OiBwcmV2aW91c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbiAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB1dGlsaXR5LnRocm93RXJyb3IoJ25vdCByZWFjaCB0byBFT0YnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeUltcGwobm9kZSwgY29tcGFjdCwgdG9wTGV2ZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXo7XG5cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBTeW50YXguTnVsbGFibGVMaXRlcmFsOlxuICAgICAgICAgICAgcmVzdWx0ID0gJz8nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguQWxsTGl0ZXJhbDpcbiAgICAgICAgICAgIHJlc3VsdCA9ICcqJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4Lk51bGxMaXRlcmFsOlxuICAgICAgICAgICAgcmVzdWx0ID0gJ251bGwnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguVW5kZWZpbmVkTGl0ZXJhbDpcbiAgICAgICAgICAgIHJlc3VsdCA9ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguVm9pZExpdGVyYWw6XG4gICAgICAgICAgICByZXN1bHQgPSAndm9pZCc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5VbmlvblR5cGU6XG4gICAgICAgICAgICBpZiAoIXRvcExldmVsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJygnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBub2RlLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5SW1wbChub2RlLmVsZW1lbnRzW2ldLCBjb21wYWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoKGkgKyAxKSAhPT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNvbXBhY3QgPyAnfCcgOiAnIHwgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdG9wTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguQXJyYXlUeXBlOlxuICAgICAgICAgICAgcmVzdWx0ID0gJ1snO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBub2RlLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5SW1wbChub2RlLmVsZW1lbnRzW2ldLCBjb21wYWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoKGkgKyAxKSAhPT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNvbXBhY3QgPyAnLCcgOiAnLCAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5SZWNvcmRUeXBlOlxuICAgICAgICAgICAgcmVzdWx0ID0gJ3snO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBub2RlLmZpZWxkcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeUltcGwobm9kZS5maWVsZHNbaV0sIGNvbXBhY3QpO1xuICAgICAgICAgICAgICAgIGlmICgoaSArIDEpICE9PSBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY29tcGFjdCA/ICcsJyA6ICcsICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICd9JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkZpZWxkVHlwZTpcbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbm9kZS5rZXkgKyAoY29tcGFjdCA/ICc6JyA6ICc6ICcpICsgc3RyaW5naWZ5SW1wbChub2RlLnZhbHVlLCBjb21wYWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbm9kZS5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvblR5cGU6XG4gICAgICAgICAgICByZXN1bHQgPSBjb21wYWN0ID8gJ2Z1bmN0aW9uKCcgOiAnZnVuY3Rpb24gKCc7XG5cbiAgICAgICAgICAgIGlmIChub2RlWyd0aGlzJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVsnbmV3J10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IChjb21wYWN0ID8gJ25ldzonIDogJ25ldzogJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IChjb21wYWN0ID8gJ3RoaXM6JyA6ICd0aGlzOiAnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5SW1wbChub2RlWyd0aGlzJ10sIGNvbXBhY3QpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY29tcGFjdCA/ICcsJyA6ICcsICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IG5vZGUucGFyYW1zLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5SW1wbChub2RlLnBhcmFtc1tpXSwgY29tcGFjdCk7XG4gICAgICAgICAgICAgICAgaWYgKChpICsgMSkgIT09IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjb21wYWN0ID8gJywnIDogJywgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSAnKSc7XG5cbiAgICAgICAgICAgIGlmIChub2RlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoY29tcGFjdCA/ICc6JyA6ICc6ICcpICsgc3RyaW5naWZ5SW1wbChub2RlLnJlc3VsdCwgY29tcGFjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5QYXJhbWV0ZXJUeXBlOlxuICAgICAgICAgICAgcmVzdWx0ID0gbm9kZS5uYW1lICsgKGNvbXBhY3QgPyAnOicgOiAnOiAnKSArIHN0cmluZ2lmeUltcGwobm9kZS5leHByZXNzaW9uLCBjb21wYWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LlJlc3RUeXBlOlxuICAgICAgICAgICAgcmVzdWx0ID0gJy4uLic7XG4gICAgICAgICAgICBpZiAobm9kZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeUltcGwobm9kZS5leHByZXNzaW9uLCBjb21wYWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4Lk5vbk51bGxhYmxlVHlwZTpcbiAgICAgICAgICAgIGlmIChub2RlLnByZWZpeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICchJyArIHN0cmluZ2lmeUltcGwobm9kZS5leHByZXNzaW9uLCBjb21wYWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3RyaW5naWZ5SW1wbChub2RlLmV4cHJlc3Npb24sIGNvbXBhY3QpICsgJyEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguT3B0aW9uYWxUeXBlOlxuICAgICAgICAgICAgcmVzdWx0ID0gc3RyaW5naWZ5SW1wbChub2RlLmV4cHJlc3Npb24sIGNvbXBhY3QpICsgJz0nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguTnVsbGFibGVUeXBlOlxuICAgICAgICAgICAgaWYgKG5vZGUucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJz8nICsgc3RyaW5naWZ5SW1wbChub2RlLmV4cHJlc3Npb24sIGNvbXBhY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHJpbmdpZnlJbXBsKG5vZGUuZXhwcmVzc2lvbiwgY29tcGFjdCkgKyAnPyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5OYW1lRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vZGUubmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LlR5cGVBcHBsaWNhdGlvbjpcbiAgICAgICAgICAgIHJlc3VsdCA9IHN0cmluZ2lmeUltcGwobm9kZS5leHByZXNzaW9uLCBjb21wYWN0KSArICcuPCc7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IG5vZGUuYXBwbGljYXRpb25zLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5SW1wbChub2RlLmFwcGxpY2F0aW9uc1tpXSwgY29tcGFjdCk7XG4gICAgICAgICAgICAgICAgaWYgKChpICsgMSkgIT09IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjb21wYWN0ID8gJywnIDogJywgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJz4nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguU3RyaW5nTGl0ZXJhbFR5cGU6XG4gICAgICAgICAgICByZXN1bHQgPSAnXCInICsgbm9kZS52YWx1ZSArICdcIic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5OdW1lcmljTGl0ZXJhbFR5cGU6XG4gICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Cb29sZWFuTGl0ZXJhbFR5cGU6XG4gICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdXRpbGl0eS50aHJvd0Vycm9yKCdVbmtub3duIHR5cGUgJyArIG5vZGUudHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5SW1wbChub2RlLCBvcHRpb25zLmNvbXBhY3QsIG9wdGlvbnMudG9wTGV2ZWwpO1xuICAgIH1cblxuICAgIGV4cG9ydHMucGFyc2VUeXBlID0gcGFyc2VUeXBlO1xuICAgIGV4cG9ydHMucGFyc2VQYXJhbVR5cGUgPSBwYXJzZVBhcmFtVHlwZTtcbiAgICBleHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbiAgICBleHBvcnRzLlN5bnRheCA9IFN5bnRheDtcbn0oKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sIm5hbWVzIjpbIlN5bnRheCIsIlRva2VuIiwic291cmNlIiwibGVuZ3RoIiwiaW5kZXgiLCJwcmV2aW91cyIsInRva2VuIiwidmFsdWUiLCJlc3V0aWxzIiwidXRpbGl0eSIsInJhbmdlT2Zmc2V0IiwiYWRkUmFuZ2UiLCJyZXF1aXJlIiwiTnVsbGFibGVMaXRlcmFsIiwiQWxsTGl0ZXJhbCIsIk51bGxMaXRlcmFsIiwiVW5kZWZpbmVkTGl0ZXJhbCIsIlZvaWRMaXRlcmFsIiwiVW5pb25UeXBlIiwiQXJyYXlUeXBlIiwiUmVjb3JkVHlwZSIsIkZpZWxkVHlwZSIsIkZ1bmN0aW9uVHlwZSIsIlBhcmFtZXRlclR5cGUiLCJSZXN0VHlwZSIsIk5vbk51bGxhYmxlVHlwZSIsIk9wdGlvbmFsVHlwZSIsIk51bGxhYmxlVHlwZSIsIk5hbWVFeHByZXNzaW9uIiwiVHlwZUFwcGxpY2F0aW9uIiwiU3RyaW5nTGl0ZXJhbFR5cGUiLCJOdW1lcmljTGl0ZXJhbFR5cGUiLCJCb29sZWFuTGl0ZXJhbFR5cGUiLCJJTExFR0FMIiwiRE9UX0xUIiwiUkVTVCIsIkxUIiwiR1QiLCJMUEFSRU4iLCJSUEFSRU4iLCJMQlJBQ0UiLCJSQlJBQ0UiLCJMQlJBQ0siLCJSQlJBQ0siLCJDT01NQSIsIkNPTE9OIiwiU1RBUiIsIlBJUEUiLCJRVUVTVElPTiIsIkJBTkciLCJFUVVBTCIsIk5BTUUiLCJTVFJJTkciLCJOVU1CRVIiLCJFT0YiLCJpc1R5cGVOYW1lIiwiY2giLCJpbmRleE9mIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiY29kZSIsImlzV2hpdGVTcGFjZSIsImlzTGluZVRlcm1pbmF0b3IiLCJDb250ZXh0IiwiX3ByZXZpb3VzIiwiX2luZGV4IiwiX3Rva2VuIiwiX3ZhbHVlIiwicHJvdG90eXBlIiwicmVzdG9yZSIsInNhdmUiLCJtYXliZUFkZFJhbmdlIiwibm9kZSIsInJhbmdlIiwiYWR2YW5jZSIsImNoYXJBdCIsInNjYW5IZXhFc2NhcGUiLCJwcmVmaXgiLCJpIiwibGVuIiwiaXNIZXhEaWdpdCIsImNoYXJDb2RlQXQiLCJ0b0xvd2VyQ2FzZSIsInNjYW5TdHJpbmciLCJzdHIiLCJxdW90ZSIsInVuZXNjYXBlZCIsImlzT2N0YWxEaWdpdCIsInRocm93RXJyb3IiLCJzY2FuTnVtYmVyIiwibnVtYmVyIiwiaXNJZGVudGlmaWVyU3RhcnRFUzUiLCJwYXJzZUludCIsImlzRGVjaW1hbERpZ2l0IiwicGFyc2VGbG9hdCIsInNjYW5UeXBlTmFtZSIsImNoMiIsIm5leHQiLCJhc3NlcnQiLCJjb25zdW1lIiwidGFyZ2V0IiwidGV4dCIsImV4cGVjdCIsIm1lc3NhZ2UiLCJwYXJzZVVuaW9uVHlwZSIsImVsZW1lbnRzIiwic3RhcnRJbmRleCIsInB1c2giLCJwYXJzZVR5cGVFeHByZXNzaW9uIiwidHlwZSIsInBhcnNlQXJyYXlUeXBlIiwicmVzdFN0YXJ0SW5kZXgiLCJleHByZXNzaW9uIiwicGFyc2VGaWVsZE5hbWUiLCJ2IiwicGFyc2VGaWVsZFR5cGUiLCJrZXkiLCJyYW5nZVN0YXJ0IiwicGFyc2VSZWNvcmRUeXBlIiwiZmllbGRzIiwicmFuZ2VFbmQiLCJwYXJzZU5hbWVFeHByZXNzaW9uIiwibmFtZSIsInBhcnNlVHlwZUV4cHJlc3Npb25MaXN0IiwicGFyc2VUb3AiLCJwYXJzZVR5cGVOYW1lIiwiZXhwciIsImFwcGxpY2F0aW9ucyIsInBhcnNlUmVzdWx0VHlwZSIsInBhcnNlUGFyYW1ldGVyc1R5cGUiLCJwYXJhbXMiLCJvcHRpb25hbFNlcXVlbmNlIiwicmVzdCIsIm5hbWVTdGFydEluZGV4IiwicGFyc2VGdW5jdGlvblR5cGUiLCJpc05ldyIsInRoaXNCaW5kaW5nIiwicmVzdWx0IiwiZm5UeXBlIiwicGFyc2VCYXNpY1R5cGVFeHByZXNzaW9uIiwiY29udGV4dCIsImUiLCJwYXJzZVRvcFBhcmFtVHlwZSIsInBhcnNlVHlwZSIsInNyYyIsIm9wdCIsIm1pZHN0cmVhbSIsInBhcnNlUGFyYW1UeXBlIiwic3RyaW5naWZ5SW1wbCIsImNvbXBhY3QiLCJ0b3BMZXZlbCIsIml6Iiwic3RyaW5naWZ5Iiwib3B0aW9ucyIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/doctrine/lib/typed.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/doctrine/lib/utility.js":
/*!**********************************************!*\
  !*** ./node_modules/doctrine/lib/utility.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * @fileoverview Utilities for Doctrine\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n */ (function() {\n    \"use strict\";\n    var VERSION;\n    VERSION = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/doctrine/package.json\").version);\n    exports.VERSION = VERSION;\n    function DoctrineError(message) {\n        this.name = \"DoctrineError\";\n        this.message = message;\n    }\n    DoctrineError.prototype = function() {\n        var Middle = function() {};\n        Middle.prototype = Error.prototype;\n        return new Middle();\n    }();\n    DoctrineError.prototype.constructor = DoctrineError;\n    exports.DoctrineError = DoctrineError;\n    function throwError(message) {\n        throw new DoctrineError(message);\n    }\n    exports.throwError = throwError;\n    exports.assert = __webpack_require__(/*! assert */ \"assert\");\n})(); /* vim: set sw=4 ts=4 et tw=80 : */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jdHJpbmUvbGliL3V0aWxpdHkuanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBR0E7SUFDRztJQUVBLElBQUlBO0lBRUpBLFVBQVVDLGtHQUFrQztJQUM1Q0UsZUFBZSxHQUFHSDtJQUVsQixTQUFTSSxjQUFjQyxPQUFPO1FBQzFCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FELGNBQWNHLFNBQVMsR0FBSTtRQUN2QixJQUFJQyxTQUFTLFlBQWM7UUFDM0JBLE9BQU9ELFNBQVMsR0FBR0UsTUFBTUYsU0FBUztRQUNsQyxPQUFPLElBQUlDO0lBQ2Y7SUFDQUosY0FBY0csU0FBUyxDQUFDRyxXQUFXLEdBQUdOO0lBQ3RDRCxxQkFBcUIsR0FBR0M7SUFFeEIsU0FBU08sV0FBV04sT0FBTztRQUN2QixNQUFNLElBQUlELGNBQWNDO0lBQzVCO0lBQ0FGLGtCQUFrQixHQUFHUTtJQUVyQlIsNERBQXlCO0FBQzdCLE1BRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9kb2N0cmluZS9saWIvdXRpbGl0eS5qcz8wZTYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdGllcyBmb3IgRG9jdHJpbmVcbiAqIEBhdXRob3IgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICovXG5cblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgVkVSU0lPTjtcblxuICAgIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICAgIGV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICBmdW5jdGlvbiBEb2N0cmluZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RvY3RyaW5lRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBEb2N0cmluZUVycm9yLnByb3RvdHlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBNaWRkbGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIE1pZGRsZS5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBuZXcgTWlkZGxlKCk7XG4gICAgfSgpKTtcbiAgICBEb2N0cmluZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERvY3RyaW5lRXJyb3I7XG4gICAgZXhwb3J0cy5Eb2N0cmluZUVycm9yID0gRG9jdHJpbmVFcnJvcjtcblxuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRG9jdHJpbmVFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgZXhwb3J0cy50aHJvd0Vycm9yID0gdGhyb3dFcnJvcjtcblxuICAgIGV4cG9ydHMuYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG59KCkpO1xuXG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sIm5hbWVzIjpbIlZFUlNJT04iLCJyZXF1aXJlIiwidmVyc2lvbiIsImV4cG9ydHMiLCJEb2N0cmluZUVycm9yIiwibWVzc2FnZSIsIm5hbWUiLCJwcm90b3R5cGUiLCJNaWRkbGUiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwidGhyb3dFcnJvciIsImFzc2VydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/doctrine/lib/utility.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/doctrine/package.json":
/*!********************************************!*\
  !*** ./node_modules/doctrine/package.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"doctrine","description":"JSDoc parser","homepage":"https://github.com/eslint/doctrine","main":"lib/doctrine.js","version":"3.0.0","engines":{"node":">=6.0.0"},"directories":{"lib":"./lib"},"files":["lib"],"maintainers":[{"name":"Nicholas C. Zakas","email":"nicholas+npm@nczconsulting.com","web":"https://www.nczonline.net"},{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","web":"https://github.com/Constellation"}],"repository":"eslint/doctrine","devDependencies":{"coveralls":"^3.0.1","dateformat":"^1.0.11","eslint":"^1.10.3","eslint-release":"^1.0.0","linefix":"^0.1.1","mocha":"^3.4.2","npm-license":"^0.3.1","nyc":"^10.3.2","semver":"^5.0.3","shelljs":"^0.5.3","shelljs-nodecli":"^0.1.1","should":"^5.0.1"},"license":"Apache-2.0","scripts":{"pretest":"npm run lint","test":"nyc mocha","coveralls":"nyc report --reporter=text-lcov | coveralls","lint":"eslint lib/","generate-release":"eslint-generate-release","generate-alpharelease":"eslint-generate-prerelease alpha","generate-betarelease":"eslint-generate-prerelease beta","generate-rcrelease":"eslint-generate-prerelease rc","publish-release":"eslint-publish-release"},"dependencies":{"esutils":"^2.0.2"}}');

/***/ })

};
;