"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@apidevtools";
exports.ids = ["vendor-chunks/@apidevtools"];
exports.modules = {

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/bundle.js":
/*!************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/bundle.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst $Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js\");\nconst Pointer = __webpack_require__(/*! ./pointer */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/pointer.js\");\nconst url = __webpack_require__(/*! ./util/url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\nmodule.exports = bundle;\n/**\n * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that\n * only has *internal* references, not any *external* references.\n * This method mutates the JSON schema object, adding new references and re-mapping existing ones.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n */ function bundle(parser, options) {\n    // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);\n    // Build an inventory of all $ref pointers in the JSON Schema\n    let inventory = [];\n    crawl(parser, \"schema\", parser.$refs._root$Ref.path + \"#\", \"#\", 0, inventory, parser.$refs, options);\n    // Remap all $ref pointers\n    remap(inventory);\n}\n/**\n * Recursively crawls the given value, and inventories all JSON references.\n *\n * @param {object} parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.\n * @param {string} key - The property key of `parent` to be crawled\n * @param {string} path - The full path of the property being crawled, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of the property being crawled, from the schema root\n * @param {object[]} inventory - An array of already-inventoried $ref pointers\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n */ function crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {\n    let obj = key === null ? parent : parent[key];\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj)) {\n        if ($Ref.isAllowed$Ref(obj)) {\n            inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);\n        } else {\n            // Crawl the object in a specific order that's optimized for bundling.\n            // This is important because it determines how `pathFromRoot` gets built,\n            // which later determines which keys get dereferenced and which ones get remapped\n            let keys = Object.keys(obj).sort((a, b)=>{\n                // Most people will expect references to be bundled into the the \"definitions\" property,\n                // so we always crawl that property first, if it exists.\n                if (a === \"definitions\") {\n                    return -1;\n                } else if (b === \"definitions\") {\n                    return 1;\n                } else {\n                    // Otherwise, crawl the keys based on their length.\n                    // This produces the shortest possible bundled references\n                    return a.length - b.length;\n                }\n            });\n            // eslint-disable-next-line no-shadow\n            for (let key of keys){\n                let keyPath = Pointer.join(path, key);\n                let keyPathFromRoot = Pointer.join(pathFromRoot, key);\n                let value = obj[key];\n                if ($Ref.isAllowed$Ref(value)) {\n                    inventory$Ref(obj, key, path, keyPathFromRoot, indirections, inventory, $refs, options);\n                } else {\n                    crawl(obj, key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);\n                }\n            }\n        }\n    }\n}\n/**\n * Inventories the given JSON Reference (i.e. records detailed information about it so we can\n * optimize all $refs in the schema), and then crawls the resolved value.\n *\n * @param {object} $refParent - The object that contains a JSON Reference as one of its keys\n * @param {string} $refKey - The key in `$refParent` that is a JSON Reference\n * @param {string} path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root\n * @param {object[]} inventory - An array of already-inventoried $ref pointers\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n */ function inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {\n    let $ref = $refKey === null ? $refParent : $refParent[$refKey];\n    let $refPath = url.resolve(path, $ref.$ref);\n    let pointer = $refs._resolve($refPath, pathFromRoot, options);\n    if (pointer === null) {\n        return;\n    }\n    let depth = Pointer.parse(pathFromRoot).length;\n    let file = url.stripHash(pointer.path);\n    let hash = url.getHash(pointer.path);\n    let external = file !== $refs._root$Ref.path;\n    let extended = $Ref.isExtended$Ref($ref);\n    indirections += pointer.indirections;\n    let existingEntry = findInInventory(inventory, $refParent, $refKey);\n    if (existingEntry) {\n        // This $Ref has already been inventoried, so we don't need to process it again\n        if (depth < existingEntry.depth || indirections < existingEntry.indirections) {\n            removeFromInventory(inventory, existingEntry);\n        } else {\n            return;\n        }\n    }\n    inventory.push({\n        $ref,\n        parent: $refParent,\n        key: $refKey,\n        pathFromRoot,\n        depth,\n        file,\n        hash,\n        value: pointer.value,\n        circular: pointer.circular,\n        extended,\n        external,\n        indirections\n    });\n    // Recursively crawl the resolved value\n    if (!existingEntry) {\n        crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);\n    }\n}\n/**\n * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.\n * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same\n * value are re-mapped to point to the first reference.\n *\n * @example:\n *  {\n *    first: { $ref: somefile.json#/some/part },\n *    second: { $ref: somefile.json#/another/part },\n *    third: { $ref: somefile.json },\n *    fourth: { $ref: somefile.json#/some/part/sub/part }\n *  }\n *\n * In this example, there are four references to the same file, but since the third reference points\n * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be\n * remapped to point inside the third one.\n *\n * On the other hand, if the third reference DIDN'T exist, then the first and second would both need\n * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT\n * need to be dereferenced, because it can be remapped to point inside the first one.\n *\n * @param {object[]} inventory\n */ function remap(inventory) {\n    // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them\n    inventory.sort((a, b)=>{\n        if (a.file !== b.file) {\n            // Group all the $refs that point to the same file\n            return a.file < b.file ? -1 : +1;\n        } else if (a.hash !== b.hash) {\n            // Group all the $refs that point to the same part of the file\n            return a.hash < b.hash ? -1 : +1;\n        } else if (a.circular !== b.circular) {\n            // If the $ref points to itself, then sort it higher than other $refs that point to this $ref\n            return a.circular ? -1 : +1;\n        } else if (a.extended !== b.extended) {\n            // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value\n            return a.extended ? +1 : -1;\n        } else if (a.indirections !== b.indirections) {\n            // Sort direct references higher than indirect references\n            return a.indirections - b.indirections;\n        } else if (a.depth !== b.depth) {\n            // Sort $refs by how close they are to the JSON Schema root\n            return a.depth - b.depth;\n        } else {\n            // Determine how far each $ref is from the \"definitions\" property.\n            // Most people will expect references to be bundled into the the \"definitions\" property if possible.\n            let aDefinitionsIndex = a.pathFromRoot.lastIndexOf(\"/definitions\");\n            let bDefinitionsIndex = b.pathFromRoot.lastIndexOf(\"/definitions\");\n            if (aDefinitionsIndex !== bDefinitionsIndex) {\n                // Give higher priority to the $ref that's closer to the \"definitions\" property\n                return bDefinitionsIndex - aDefinitionsIndex;\n            } else {\n                // All else is equal, so use the shorter path, which will produce the shortest possible reference\n                return a.pathFromRoot.length - b.pathFromRoot.length;\n            }\n        }\n    });\n    let file, hash, pathFromRoot;\n    for (let entry of inventory){\n        // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n        if (!entry.external) {\n            // This $ref already resolves to the main JSON Schema file\n            entry.$ref.$ref = entry.hash;\n        } else if (entry.file === file && entry.hash === hash) {\n            // This $ref points to the same value as the prevous $ref, so remap it to the same path\n            entry.$ref.$ref = pathFromRoot;\n        } else if (entry.file === file && entry.hash.indexOf(hash + \"/\") === 0) {\n            // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path\n            entry.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(entry.hash.replace(hash, \"#\")));\n        } else {\n            // We've moved to a new file or new hash\n            file = entry.file;\n            hash = entry.hash;\n            pathFromRoot = entry.pathFromRoot;\n            // This is the first $ref to point to this value, so dereference the value.\n            // Any other $refs that point to the same value will point to this $ref instead\n            entry.$ref = entry.parent[entry.key] = $Ref.dereference(entry.$ref, entry.value);\n            if (entry.circular) {\n                // This $ref points to itself\n                entry.$ref.$ref = entry.pathFromRoot;\n            }\n        }\n    // console.log('    new value: %s', (entry.$ref && entry.$ref.$ref) ? entry.$ref.$ref : '[object Object]');\n    }\n}\n/**\n * TODO\n */ function findInInventory(inventory, $refParent, $refKey) {\n    for(let i = 0; i < inventory.length; i++){\n        let existingEntry = inventory[i];\n        if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {\n            return existingEntry;\n        }\n    }\n}\nfunction removeFromInventory(inventory, entry) {\n    let index = inventory.indexOf(entry);\n    inventory.splice(index, 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL2J1bmRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDLGtGQUFPO0FBQzVCLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDBGQUFXO0FBQ25DLE1BQU1FLE1BQU1GLG1CQUFPQSxDQUFDLDRGQUFZO0FBRWhDRyxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQSxPQUFRQyxNQUFNLEVBQUVDLE9BQU87SUFDOUIsNEVBQTRFO0lBRTVFLDZEQUE2RDtJQUM3RCxJQUFJQyxZQUFZLEVBQUU7SUFDbEJDLE1BQU1ILFFBQVEsVUFBVUEsT0FBT0ksS0FBSyxDQUFDQyxTQUFTLENBQUNDLElBQUksR0FBRyxLQUFLLEtBQUssR0FBR0osV0FBV0YsT0FBT0ksS0FBSyxFQUFFSDtJQUU1RiwwQkFBMEI7SUFDMUJNLE1BQU1MO0FBQ1I7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU0MsTUFBT0ssTUFBTSxFQUFFQyxHQUFHLEVBQUVILElBQUksRUFBRUksWUFBWSxFQUFFQyxZQUFZLEVBQUVULFNBQVMsRUFBRUUsS0FBSyxFQUFFSCxPQUFPO0lBQ3RGLElBQUlXLE1BQU1ILFFBQVEsT0FBT0QsU0FBU0EsTUFBTSxDQUFDQyxJQUFJO0lBRTdDLElBQUlHLE9BQU8sT0FBT0EsUUFBUSxZQUFZLENBQUNDLFlBQVlDLE1BQU0sQ0FBQ0YsTUFBTTtRQUM5RCxJQUFJbkIsS0FBS3NCLGFBQWEsQ0FBQ0gsTUFBTTtZQUMzQkksY0FBY1IsUUFBUUMsS0FBS0gsTUFBTUksY0FBY0MsY0FBY1QsV0FBV0UsT0FBT0g7UUFDakYsT0FDSztZQUNILHNFQUFzRTtZQUN0RSx5RUFBeUU7WUFDekUsaUZBQWlGO1lBQ2pGLElBQUlnQixPQUFPQyxPQUFPRCxJQUFJLENBQUNMLEtBQ3BCTyxJQUFJLENBQUMsQ0FBQ0Ms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RUMsT0FBTztJQUN0RCxJQUFLLElBQUkyQixJQUFJLEdBQUdBLElBQUlyRCxVQUFVb0IsTUFBTSxFQUFFaUMsSUFBSztRQUN6QyxJQUFJWixnQkFBZ0J6QyxTQUFTLENBQUNxRCxFQUFFO1FBQ2hDLElBQUlaLGNBQWNuQyxNQUFNLEtBQUttQixjQUFjZ0IsY0FBY2xDLEdBQUcsS0FBS21CLFNBQVM7WUFDeEUsT0FBT2U7UUFDVDtJQUNGO0FBQ0Y7QUFFQSxTQUFTRSxvQkFBcUIzQyxTQUFTLEVBQUVpRCxLQUFLO0lBQzVDLElBQUlLLFFBQVF0RCxVQUFVa0QsT0FBTyxDQUFDRDtJQUM5QmpELFVBQVV1RCxNQUFNLENBQUNELE9BQU87QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2xpYi9idW5kbGUuanM/MjIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgJFJlZiA9IHJlcXVpcmUoXCIuL3JlZlwiKTtcbmNvbnN0IFBvaW50ZXIgPSByZXF1aXJlKFwiLi9wb2ludGVyXCIpO1xuY29uc3QgdXJsID0gcmVxdWlyZShcIi4vdXRpbC91cmxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gYnVuZGxlO1xuXG4vKipcbiAqIEJ1bmRsZXMgYWxsIGV4dGVybmFsIEpTT04gcmVmZXJlbmNlcyBpbnRvIHRoZSBtYWluIEpTT04gc2NoZW1hLCB0aHVzIHJlc3VsdGluZyBpbiBhIHNjaGVtYSB0aGF0XG4gKiBvbmx5IGhhcyAqaW50ZXJuYWwqIHJlZmVyZW5jZXMsIG5vdCBhbnkgKmV4dGVybmFsKiByZWZlcmVuY2VzLlxuICogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgSlNPTiBzY2hlbWEgb2JqZWN0LCBhZGRpbmcgbmV3IHJlZmVyZW5jZXMgYW5kIHJlLW1hcHBpbmcgZXhpc3Rpbmcgb25lcy5cbiAqXG4gKiBAcGFyYW0geyRSZWZQYXJzZXJ9IHBhcnNlclxuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBidW5kbGUgKHBhcnNlciwgb3B0aW9ucykge1xuICAvLyBjb25zb2xlLmxvZygnQnVuZGxpbmcgJHJlZiBwb2ludGVycyBpbiAlcycsIHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCk7XG5cbiAgLy8gQnVpbGQgYW4gaW52ZW50b3J5IG9mIGFsbCAkcmVmIHBvaW50ZXJzIGluIHRoZSBKU09OIFNjaGVtYVxuICBsZXQgaW52ZW50b3J5ID0gW107XG4gIGNyYXdsKHBhcnNlciwgXCJzY2hlbWFcIiwgcGFyc2VyLiRyZWZzLl9yb290JFJlZi5wYXRoICsgXCIjXCIsIFwiI1wiLCAwLCBpbnZlbnRvcnksIHBhcnNlci4kcmVmcywgb3B0aW9ucyk7XG5cbiAgLy8gUmVtYXAgYWxsICRyZWYgcG9pbnRlcnNcbiAgcmVtYXAoaW52ZW50b3J5KTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBjcmF3bHMgdGhlIGdpdmVuIHZhbHVlLCBhbmQgaW52ZW50b3JpZXMgYWxsIEpTT04gcmVmZXJlbmNlcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyZW50IC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSB2YWx1ZSB0byBjcmF3bC4gSWYgdGhlIHZhbHVlIGlzIG5vdCBhbiBvYmplY3Qgb3IgYXJyYXksIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgcHJvcGVydHkga2V5IG9mIGBwYXJlbnRgIHRvIGJlIGNyYXdsZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiB0aGUgcHJvcGVydHkgYmVpbmcgY3Jhd2xlZCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhGcm9tUm9vdCAtIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBjcmF3bGVkLCBmcm9tIHRoZSBzY2hlbWEgcm9vdFxuICogQHBhcmFtIHtvYmplY3RbXX0gaW52ZW50b3J5IC0gQW4gYXJyYXkgb2YgYWxyZWFkeS1pbnZlbnRvcmllZCAkcmVmIHBvaW50ZXJzXG4gKiBAcGFyYW0geyRSZWZzfSAkcmVmc1xuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmF3bCAocGFyZW50LCBrZXksIHBhdGgsIHBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zLCBpbnZlbnRvcnksICRyZWZzLCBvcHRpb25zKSB7XG4gIGxldCBvYmogPSBrZXkgPT09IG51bGwgPyBwYXJlbnQgOiBwYXJlbnRba2V5XTtcblxuICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgIUFycmF5QnVmZmVyLmlzVmlldyhvYmopKSB7XG4gICAgaWYgKCRSZWYuaXNBbGxvd2VkJFJlZihvYmopKSB7XG4gICAgICBpbnZlbnRvcnkkUmVmKHBhcmVudCwga2V5LCBwYXRoLCBwYXRoRnJvbVJvb3QsIGluZGlyZWN0aW9ucywgaW52ZW50b3J5LCAkcmVmcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gQ3Jhd2wgdGhlIG9iamVjdCBpbiBhIHNwZWNpZmljIG9yZGVyIHRoYXQncyBvcHRpbWl6ZWQgZm9yIGJ1bmRsaW5nLlxuICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSBpdCBkZXRlcm1pbmVzIGhvdyBgcGF0aEZyb21Sb290YCBnZXRzIGJ1aWx0LFxuICAgICAgLy8gd2hpY2ggbGF0ZXIgZGV0ZXJtaW5lcyB3aGljaCBrZXlzIGdldCBkZXJlZmVyZW5jZWQgYW5kIHdoaWNoIG9uZXMgZ2V0IHJlbWFwcGVkXG4gICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAvLyBNb3N0IHBlb3BsZSB3aWxsIGV4cGVjdCByZWZlcmVuY2VzIHRvIGJlIGJ1bmRsZWQgaW50byB0aGUgdGhlIFwiZGVmaW5pdGlvbnNcIiBwcm9wZXJ0eSxcbiAgICAgICAgICAvLyBzbyB3ZSBhbHdheXMgY3Jhd2wgdGhhdCBwcm9wZXJ0eSBmaXJzdCwgaWYgaXQgZXhpc3RzLlxuICAgICAgICAgIGlmIChhID09PSBcImRlZmluaXRpb25zXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYiA9PT0gXCJkZWZpbml0aW9uc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNyYXdsIHRoZSBrZXlzIGJhc2VkIG9uIHRoZWlyIGxlbmd0aC5cbiAgICAgICAgICAgIC8vIFRoaXMgcHJvZHVjZXMgdGhlIHNob3J0ZXN0IHBvc3NpYmxlIGJ1bmRsZWQgcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICAgICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgbGV0IGtleVBhdGggPSBQb2ludGVyLmpvaW4ocGF0aCwga2V5KTtcbiAgICAgICAgbGV0IGtleVBhdGhGcm9tUm9vdCA9IFBvaW50ZXIuam9pbihwYXRoRnJvbVJvb3QsIGtleSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAgIGlmICgkUmVmLmlzQWxsb3dlZCRSZWYodmFsdWUpKSB7XG4gICAgICAgICAgaW52ZW50b3J5JFJlZihvYmosIGtleSwgcGF0aCwga2V5UGF0aEZyb21Sb290LCBpbmRpcmVjdGlvbnMsIGludmVudG9yeSwgJHJlZnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNyYXdsKG9iaiwga2V5LCBrZXlQYXRoLCBrZXlQYXRoRnJvbVJvb3QsIGluZGlyZWN0aW9ucywgaW52ZW50b3J5LCAkcmVmcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbnZlbnRvcmllcyB0aGUgZ2l2ZW4gSlNPTiBSZWZlcmVuY2UgKGkuZS4gcmVjb3JkcyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBpdCBzbyB3ZSBjYW5cbiAqIG9wdGltaXplIGFsbCAkcmVmcyBpbiB0aGUgc2NoZW1hKSwgYW5kIHRoZW4gY3Jhd2xzIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gJHJlZlBhcmVudCAtIFRoZSBvYmplY3QgdGhhdCBjb250YWlucyBhIEpTT04gUmVmZXJlbmNlIGFzIG9uZSBvZiBpdHMga2V5c1xuICogQHBhcmFtIHtzdHJpbmd9ICRyZWZLZXkgLSBUaGUga2V5IGluIGAkcmVmUGFyZW50YCB0aGF0IGlzIGEgSlNPTiBSZWZlcmVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiB0aGUgSlNPTiBSZWZlcmVuY2UgYXQgYCRyZWZLZXlgLCBwb3NzaWJseSB3aXRoIGEgSlNPTiBQb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aEZyb21Sb290IC0gVGhlIHBhdGggb2YgdGhlIEpTT04gUmVmZXJlbmNlIGF0IGAkcmVmS2V5YCwgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAqIEBwYXJhbSB7b2JqZWN0W119IGludmVudG9yeSAtIEFuIGFycmF5IG9mIGFscmVhZHktaW52ZW50b3JpZWQgJHJlZiBwb2ludGVyc1xuICogQHBhcmFtIHskUmVmc30gJHJlZnNcbiAqIEBwYXJhbSB7JFJlZlBhcnNlck9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gaW52ZW50b3J5JFJlZiAoJHJlZlBhcmVudCwgJHJlZktleSwgcGF0aCwgcGF0aEZyb21Sb290LCBpbmRpcmVjdGlvbnMsIGludmVudG9yeSwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgbGV0ICRyZWYgPSAkcmVmS2V5ID09PSBudWxsID8gJHJlZlBhcmVudCA6ICRyZWZQYXJlbnRbJHJlZktleV07XG4gIGxldCAkcmVmUGF0aCA9IHVybC5yZXNvbHZlKHBhdGgsICRyZWYuJHJlZik7XG4gIGxldCBwb2ludGVyID0gJHJlZnMuX3Jlc29sdmUoJHJlZlBhdGgsIHBhdGhGcm9tUm9vdCwgb3B0aW9ucyk7XG4gIGlmIChwb2ludGVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGRlcHRoID0gUG9pbnRlci5wYXJzZShwYXRoRnJvbVJvb3QpLmxlbmd0aDtcbiAgbGV0IGZpbGUgPSB1cmwuc3RyaXBIYXNoKHBvaW50ZXIucGF0aCk7XG4gIGxldCBoYXNoID0gdXJsLmdldEhhc2gocG9pbnRlci5wYXRoKTtcbiAgbGV0IGV4dGVybmFsID0gZmlsZSAhPT0gJHJlZnMuX3Jvb3QkUmVmLnBhdGg7XG4gIGxldCBleHRlbmRlZCA9ICRSZWYuaXNFeHRlbmRlZCRSZWYoJHJlZik7XG4gIGluZGlyZWN0aW9ucyArPSBwb2ludGVyLmluZGlyZWN0aW9ucztcblxuICBsZXQgZXhpc3RpbmdFbnRyeSA9IGZpbmRJbkludmVudG9yeShpbnZlbnRvcnksICRyZWZQYXJlbnQsICRyZWZLZXkpO1xuICBpZiAoZXhpc3RpbmdFbnRyeSkge1xuICAgIC8vIFRoaXMgJFJlZiBoYXMgYWxyZWFkeSBiZWVuIGludmVudG9yaWVkLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHByb2Nlc3MgaXQgYWdhaW5cbiAgICBpZiAoZGVwdGggPCBleGlzdGluZ0VudHJ5LmRlcHRoIHx8IGluZGlyZWN0aW9ucyA8IGV4aXN0aW5nRW50cnkuaW5kaXJlY3Rpb25zKSB7XG4gICAgICByZW1vdmVGcm9tSW52ZW50b3J5KGludmVudG9yeSwgZXhpc3RpbmdFbnRyeSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGludmVudG9yeS5wdXNoKHtcbiAgICAkcmVmLCAgICAgICAgICAgICAgICAgICAvLyBUaGUgSlNPTiBSZWZlcmVuY2UgKGUuZy4geyRyZWY6IHN0cmluZ30pXG4gICAgcGFyZW50OiAkcmVmUGFyZW50LCAgICAgICAgICAgLy8gVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoaXMgJHJlZiBwb2ludGVyXG4gICAga2V5OiAkcmVmS2V5LCAgICAgICAgICAgICAgICAgLy8gVGhlIGtleSBpbiBgcGFyZW50YCB0aGF0IGlzIHRoZSAkcmVmIHBvaW50ZXJcbiAgICBwYXRoRnJvbVJvb3QsICAgLy8gVGhlIHBhdGggdG8gdGhlICRyZWYgcG9pbnRlciwgZnJvbSB0aGUgSlNPTiBTY2hlbWEgcm9vdFxuICAgIGRlcHRoLCAgICAgICAgICAgICAgICAgLy8gSG93IGZhciBmcm9tIHRoZSBKU09OIFNjaGVtYSByb290IGlzIHRoaXMgJHJlZiBwb2ludGVyP1xuICAgIGZpbGUsICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIHRoYXQgdGhlICRyZWYgcG9pbnRlciByZXNvbHZlcyB0b1xuICAgIGhhc2gsICAgICAgICAgICAgICAgICAgIC8vIFRoZSBoYXNoIHdpdGhpbiBgZmlsZWAgdGhhdCB0aGUgJHJlZiBwb2ludGVyIHJlc29sdmVzIHRvXG4gICAgdmFsdWU6IHBvaW50ZXIudmFsdWUsICAgICAgICAgLy8gVGhlIHJlc29sdmVkIHZhbHVlIG9mIHRoZSAkcmVmIHBvaW50ZXJcbiAgICBjaXJjdWxhcjogcG9pbnRlci5jaXJjdWxhciwgICAvLyBJcyB0aGlzICRyZWYgcG9pbnRlciBESVJFQ1RMWSBjaXJjdWxhcj8gKGkuZS4gaXQgcmVmZXJlbmNlcyBpdHNlbGYpXG4gICAgZXh0ZW5kZWQsICAgICAgICAgICAvLyBEb2VzIHRoaXMgJHJlZiBleHRlbmQgaXRzIHJlc29sdmVkIHZhbHVlPyAoaS5lLiBpdCBoYXMgZXh0cmEgcHJvcGVydGllcywgaW4gYWRkaXRpb24gdG8gXCIkcmVmXCIpXG4gICAgZXh0ZXJuYWwsICAgICAgICAgICAvLyBEb2VzIHRoaXMgJHJlZiBwb2ludGVyIHBvaW50IHRvIGEgZmlsZSBvdGhlciB0aGFuIHRoZSBtYWluIEpTT04gU2NoZW1hIGZpbGU/XG4gICAgaW5kaXJlY3Rpb25zLCAgIC8vIFRoZSBudW1iZXIgb2YgaW5kaXJlY3QgcmVmZXJlbmNlcyB0aGF0IHdlcmUgdHJhdmVyc2VkIHRvIHJlc29sdmUgdGhlIHZhbHVlXG4gIH0pO1xuXG4gIC8vIFJlY3Vyc2l2ZWx5IGNyYXdsIHRoZSByZXNvbHZlZCB2YWx1ZVxuICBpZiAoIWV4aXN0aW5nRW50cnkpIHtcbiAgICBjcmF3bChwb2ludGVyLnZhbHVlLCBudWxsLCBwb2ludGVyLnBhdGgsIHBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zICsgMSwgaW52ZW50b3J5LCAkcmVmcywgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZS1tYXBzIGV2ZXJ5ICRyZWYgcG9pbnRlciwgc28gdGhhdCB0aGV5J3JlIGFsbCByZWxhdGl2ZSB0byB0aGUgcm9vdCBvZiB0aGUgSlNPTiBTY2hlbWEuXG4gKiBFYWNoIHJlZmVyZW5jZWQgdmFsdWUgaXMgZGVyZWZlcmVuY2VkIEVYQUNUTFkgT05DRS4gIEFsbCBzdWJzZXF1ZW50IHJlZmVyZW5jZXMgdG8gdGhlIHNhbWVcbiAqIHZhbHVlIGFyZSByZS1tYXBwZWQgdG8gcG9pbnQgdG8gdGhlIGZpcnN0IHJlZmVyZW5jZS5cbiAqXG4gKiBAZXhhbXBsZTpcbiAqICB7XG4gKiAgICBmaXJzdDogeyAkcmVmOiBzb21lZmlsZS5qc29uIy9zb21lL3BhcnQgfSxcbiAqICAgIHNlY29uZDogeyAkcmVmOiBzb21lZmlsZS5qc29uIy9hbm90aGVyL3BhcnQgfSxcbiAqICAgIHRoaXJkOiB7ICRyZWY6IHNvbWVmaWxlLmpzb24gfSxcbiAqICAgIGZvdXJ0aDogeyAkcmVmOiBzb21lZmlsZS5qc29uIy9zb21lL3BhcnQvc3ViL3BhcnQgfVxuICogIH1cbiAqXG4gKiBJbiB0aGlzIGV4YW1wbGUsIHRoZXJlIGFyZSBmb3VyIHJlZmVyZW5jZXMgdG8gdGhlIHNhbWUgZmlsZSwgYnV0IHNpbmNlIHRoZSB0aGlyZCByZWZlcmVuY2UgcG9pbnRzXG4gKiB0byB0aGUgRU5USVJFIGZpbGUsIHRoYXQncyB0aGUgb25seSBvbmUgd2UgbmVlZCB0byBkZXJlZmVyZW5jZS4gIFRoZSBvdGhlciB0aHJlZSBjYW4ganVzdCBiZVxuICogcmVtYXBwZWQgdG8gcG9pbnQgaW5zaWRlIHRoZSB0aGlyZCBvbmUuXG4gKlxuICogT24gdGhlIG90aGVyIGhhbmQsIGlmIHRoZSB0aGlyZCByZWZlcmVuY2UgRElETidUIGV4aXN0LCB0aGVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIHdvdWxkIGJvdGggbmVlZFxuICogdG8gYmUgZGVyZWZlcmVuY2VkLCBzaW5jZSB0aGV5IHBvaW50IHRvIGRpZmZlcmVudCBwYXJ0cyBvZiB0aGUgZmlsZS4gVGhlIGZvdXJ0aCByZWZlcmVuY2UgZG9lcyBOT1RcbiAqIG5lZWQgdG8gYmUgZGVyZWZlcmVuY2VkLCBiZWNhdXNlIGl0IGNhbiBiZSByZW1hcHBlZCB0byBwb2ludCBpbnNpZGUgdGhlIGZpcnN0IG9uZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdFtdfSBpbnZlbnRvcnlcbiAqL1xuZnVuY3Rpb24gcmVtYXAgKGludmVudG9yeSkge1xuICAvLyBHcm91cCAmIHNvcnQgYWxsIHRoZSAkcmVmIHBvaW50ZXJzLCBzbyB0aGV5J3JlIGluIHRoZSBvcmRlciB0aGF0IHdlIG5lZWQgdG8gZGVyZWZlcmVuY2UvcmVtYXAgdGhlbVxuICBpbnZlbnRvcnkuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChhLmZpbGUgIT09IGIuZmlsZSkge1xuICAgICAgLy8gR3JvdXAgYWxsIHRoZSAkcmVmcyB0aGF0IHBvaW50IHRvIHRoZSBzYW1lIGZpbGVcbiAgICAgIHJldHVybiBhLmZpbGUgPCBiLmZpbGUgPyAtMSA6ICsxO1xuICAgIH1cbiAgICBlbHNlIGlmIChhLmhhc2ggIT09IGIuaGFzaCkge1xuICAgICAgLy8gR3JvdXAgYWxsIHRoZSAkcmVmcyB0aGF0IHBvaW50IHRvIHRoZSBzYW1lIHBhcnQgb2YgdGhlIGZpbGVcbiAgICAgIHJldHVybiBhLmhhc2ggPCBiLmhhc2ggPyAtMSA6ICsxO1xuICAgIH1cbiAgICBlbHNlIGlmIChhLmNpcmN1bGFyICE9PSBiLmNpcmN1bGFyKSB7XG4gICAgICAvLyBJZiB0aGUgJHJlZiBwb2ludHMgdG8gaXRzZWxmLCB0aGVuIHNvcnQgaXQgaGlnaGVyIHRoYW4gb3RoZXIgJHJlZnMgdGhhdCBwb2ludCB0byB0aGlzICRyZWZcbiAgICAgIHJldHVybiBhLmNpcmN1bGFyID8gLTEgOiArMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYS5leHRlbmRlZCAhPT0gYi5leHRlbmRlZCkge1xuICAgICAgLy8gSWYgdGhlICRyZWYgZXh0ZW5kcyB0aGUgcmVzb2x2ZWQgdmFsdWUsIHRoZW4gc29ydCBpdCBsb3dlciB0aGFuIG90aGVyICRyZWZzIHRoYXQgZG9uJ3QgZXh0ZW5kIHRoZSB2YWx1ZVxuICAgICAgcmV0dXJuIGEuZXh0ZW5kZWQgPyArMSA6IC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChhLmluZGlyZWN0aW9ucyAhPT0gYi5pbmRpcmVjdGlvbnMpIHtcbiAgICAgIC8vIFNvcnQgZGlyZWN0IHJlZmVyZW5jZXMgaGlnaGVyIHRoYW4gaW5kaXJlY3QgcmVmZXJlbmNlc1xuICAgICAgcmV0dXJuIGEuaW5kaXJlY3Rpb25zIC0gYi5pbmRpcmVjdGlvbnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEuZGVwdGggIT09IGIuZGVwdGgpIHtcbiAgICAgIC8vIFNvcnQgJHJlZnMgYnkgaG93IGNsb3NlIHRoZXkgYXJlIHRvIHRoZSBKU09OIFNjaGVtYSByb290XG4gICAgICByZXR1cm4gYS5kZXB0aCAtIGIuZGVwdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBmYXIgZWFjaCAkcmVmIGlzIGZyb20gdGhlIFwiZGVmaW5pdGlvbnNcIiBwcm9wZXJ0eS5cbiAgICAgIC8vIE1vc3QgcGVvcGxlIHdpbGwgZXhwZWN0IHJlZmVyZW5jZXMgdG8gYmUgYnVuZGxlZCBpbnRvIHRoZSB0aGUgXCJkZWZpbml0aW9uc1wiIHByb3BlcnR5IGlmIHBvc3NpYmxlLlxuICAgICAgbGV0IGFEZWZpbml0aW9uc0luZGV4ID0gYS5wYXRoRnJvbVJvb3QubGFzdEluZGV4T2YoXCIvZGVmaW5pdGlvbnNcIik7XG4gICAgICBsZXQgYkRlZmluaXRpb25zSW5kZXggPSBiLnBhdGhGcm9tUm9vdC5sYXN0SW5kZXhPZihcIi9kZWZpbml0aW9uc1wiKTtcblxuICAgICAgaWYgKGFEZWZpbml0aW9uc0luZGV4ICE9PSBiRGVmaW5pdGlvbnNJbmRleCkge1xuICAgICAgICAvLyBHaXZlIGhpZ2hlciBwcmlvcml0eSB0byB0aGUgJHJlZiB0aGF0J3MgY2xvc2VyIHRvIHRoZSBcImRlZmluaXRpb25zXCIgcHJvcGVydHlcbiAgICAgICAgcmV0dXJuIGJEZWZpbml0aW9uc0luZGV4IC0gYURlZmluaXRpb25zSW5kZXg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gQWxsIGVsc2UgaXMgZXF1YWwsIHNvIHVzZSB0aGUgc2hvcnRlciBwYXRoLCB3aGljaCB3aWxsIHByb2R1Y2UgdGhlIHNob3J0ZXN0IHBvc3NpYmxlIHJlZmVyZW5jZVxuICAgICAgICByZXR1cm4gYS5wYXRoRnJvbVJvb3QubGVuZ3RoIC0gYi5wYXRoRnJvbVJvb3QubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGZpbGUsIGhhc2gsIHBhdGhGcm9tUm9vdDtcbiAgZm9yIChsZXQgZW50cnkgb2YgaW52ZW50b3J5KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1JlLW1hcHBpbmcgJHJlZiBwb2ludGVyIFwiJXNcIiBhdCAlcycsIGVudHJ5LiRyZWYuJHJlZiwgZW50cnkucGF0aEZyb21Sb290KTtcblxuICAgIGlmICghZW50cnkuZXh0ZXJuYWwpIHtcbiAgICAgIC8vIFRoaXMgJHJlZiBhbHJlYWR5IHJlc29sdmVzIHRvIHRoZSBtYWluIEpTT04gU2NoZW1hIGZpbGVcbiAgICAgIGVudHJ5LiRyZWYuJHJlZiA9IGVudHJ5Lmhhc2g7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVudHJ5LmZpbGUgPT09IGZpbGUgJiYgZW50cnkuaGFzaCA9PT0gaGFzaCkge1xuICAgICAgLy8gVGhpcyAkcmVmIHBvaW50cyB0byB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgcHJldm91cyAkcmVmLCBzbyByZW1hcCBpdCB0byB0aGUgc2FtZSBwYXRoXG4gICAgICBlbnRyeS4kcmVmLiRyZWYgPSBwYXRoRnJvbVJvb3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVudHJ5LmZpbGUgPT09IGZpbGUgJiYgZW50cnkuaGFzaC5pbmRleE9mKGhhc2ggKyBcIi9cIikgPT09IDApIHtcbiAgICAgIC8vIFRoaXMgJHJlZiBwb2ludHMgdG8gYSBzdWItdmFsdWUgb2YgdGhlIHByZXZvdXMgJHJlZiwgc28gcmVtYXAgaXQgYmVuZWF0aCB0aGF0IHBhdGhcbiAgICAgIGVudHJ5LiRyZWYuJHJlZiA9IFBvaW50ZXIuam9pbihwYXRoRnJvbVJvb3QsIFBvaW50ZXIucGFyc2UoZW50cnkuaGFzaC5yZXBsYWNlKGhhc2gsIFwiI1wiKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFdlJ3ZlIG1vdmVkIHRvIGEgbmV3IGZpbGUgb3IgbmV3IGhhc2hcbiAgICAgIGZpbGUgPSBlbnRyeS5maWxlO1xuICAgICAgaGFzaCA9IGVudHJ5Lmhhc2g7XG4gICAgICBwYXRoRnJvbVJvb3QgPSBlbnRyeS5wYXRoRnJvbVJvb3Q7XG5cbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0ICRyZWYgdG8gcG9pbnQgdG8gdGhpcyB2YWx1ZSwgc28gZGVyZWZlcmVuY2UgdGhlIHZhbHVlLlxuICAgICAgLy8gQW55IG90aGVyICRyZWZzIHRoYXQgcG9pbnQgdG8gdGhlIHNhbWUgdmFsdWUgd2lsbCBwb2ludCB0byB0aGlzICRyZWYgaW5zdGVhZFxuICAgICAgZW50cnkuJHJlZiA9IGVudHJ5LnBhcmVudFtlbnRyeS5rZXldID0gJFJlZi5kZXJlZmVyZW5jZShlbnRyeS4kcmVmLCBlbnRyeS52YWx1ZSk7XG5cbiAgICAgIGlmIChlbnRyeS5jaXJjdWxhcikge1xuICAgICAgICAvLyBUaGlzICRyZWYgcG9pbnRzIHRvIGl0c2VsZlxuICAgICAgICBlbnRyeS4kcmVmLiRyZWYgPSBlbnRyeS5wYXRoRnJvbVJvb3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJyAgICBuZXcgdmFsdWU6ICVzJywgKGVudHJ5LiRyZWYgJiYgZW50cnkuJHJlZi4kcmVmKSA/IGVudHJ5LiRyZWYuJHJlZiA6ICdbb2JqZWN0IE9iamVjdF0nKTtcbiAgfVxufVxuXG4vKipcbiAqIFRPRE9cbiAqL1xuZnVuY3Rpb24gZmluZEluSW52ZW50b3J5IChpbnZlbnRvcnksICRyZWZQYXJlbnQsICRyZWZLZXkpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnZlbnRvcnkubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgZXhpc3RpbmdFbnRyeSA9IGludmVudG9yeVtpXTtcbiAgICBpZiAoZXhpc3RpbmdFbnRyeS5wYXJlbnQgPT09ICRyZWZQYXJlbnQgJiYgZXhpc3RpbmdFbnRyeS5rZXkgPT09ICRyZWZLZXkpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0VudHJ5O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVGcm9tSW52ZW50b3J5IChpbnZlbnRvcnksIGVudHJ5KSB7XG4gIGxldCBpbmRleCA9IGludmVudG9yeS5pbmRleE9mKGVudHJ5KTtcbiAgaW52ZW50b3J5LnNwbGljZShpbmRleCwgMSk7XG59XG4iXSwibmFtZXMiOlsiJFJlZiIsInJlcXVpcmUiLCJQb2ludGVyIiwidXJsIiwibW9kdWxlIiwiZXhwb3J0cyIsImJ1bmRsZSIsInBhcnNlciIsIm9wdGlvbnMiLCJpbnZlbnRvcnkiLCJjcmF3bCIsIiRyZWZzIiwiX3Jvb3QkUmVmIiwicGF0aCIsInJlbWFwIiwicGFyZW50Iiwia2V5IiwicGF0aEZyb21Sb290IiwiaW5kaXJlY3Rpb25zIiwib2JqIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJpc0FsbG93ZWQkUmVmIiwiaW52ZW50b3J5JFJlZiIsImtleXMiLCJPYmplY3QiLCJzb3J0IiwiYSIsImIiLCJsZW5ndGgiLCJrZXlQYXRoIiwiam9pbiIsImtleVBhdGhGcm9tUm9vdCIsInZhbHVlIiwiJHJlZlBhcmVudCIsIiRyZWZLZXkiLCIkcmVmIiwiJHJlZlBhdGgiLCJyZXNvbHZlIiwicG9pbnRlciIsIl9yZXNvbHZlIiwiZGVwdGgiLCJwYXJzZSIsImZpbGUiLCJzdHJpcEhhc2giLCJoYXNoIiwiZ2V0SGFzaCIsImV4dGVybmFsIiwiZXh0ZW5kZWQiLCJpc0V4dGVuZGVkJFJlZiIsImV4aXN0aW5nRW50cnkiLCJmaW5kSW5JbnZlbnRvcnkiLCJyZW1vdmVGcm9tSW52ZW50b3J5IiwicHVzaCIsImNpcmN1bGFyIiwiYURlZmluaXRpb25zSW5kZXgiLCJsYXN0SW5kZXhPZiIsImJEZWZpbml0aW9uc0luZGV4IiwiZW50cnkiLCJpbmRleE9mIiwicmVwbGFjZSIsImRlcmVmZXJlbmNlIiwiaSIsImluZGV4Iiwic3BsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/bundle.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/dereference.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/dereference.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst $Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js\");\nconst Pointer = __webpack_require__(/*! ./pointer */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/pointer.js\");\nconst { ono } = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __webpack_require__(/*! ./util/url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\nmodule.exports = dereference;\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n */ function dereference(parser, options) {\n    // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n    let dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, \"#\", new Set(), new Set(), new Map(), parser.$refs, options);\n    parser.$refs.circular = dereferenced.circular;\n    parser.schema = dereferenced.value;\n}\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced\n * @param {Set<object>} processedObjects - An array of all the objects that have already been processed\n * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */ function crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n    let dereferenced;\n    let result = {\n        value: obj,\n        circular: false\n    };\n    let isExcludedPath = options.dereference.excludedPathMatcher;\n    if (options.dereference.circular === \"ignore\" || !processedObjects.has(obj)) {\n        if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !isExcludedPath(pathFromRoot)) {\n            parents.add(obj);\n            processedObjects.add(obj);\n            if ($Ref.isAllowed$Ref(obj, options)) {\n                dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n                result.circular = dereferenced.circular;\n                result.value = dereferenced.value;\n            } else {\n                for (const key of Object.keys(obj)){\n                    let keyPath = Pointer.join(path, key);\n                    let keyPathFromRoot = Pointer.join(pathFromRoot, key);\n                    if (isExcludedPath(keyPathFromRoot)) {\n                        continue;\n                    }\n                    let value = obj[key];\n                    let circular = false;\n                    if ($Ref.isAllowed$Ref(value, options)) {\n                        dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n                        circular = dereferenced.circular;\n                        // Avoid pointless mutations; breaks frozen objects to no profit\n                        if (obj[key] !== dereferenced.value) {\n                            obj[key] = dereferenced.value;\n                        }\n                    } else {\n                        if (!parents.has(value)) {\n                            dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n                            circular = dereferenced.circular;\n                            // Avoid pointless mutations; breaks frozen objects to no profit\n                            if (obj[key] !== dereferenced.value) {\n                                obj[key] = dereferenced.value;\n                            }\n                        } else {\n                            circular = foundCircularReference(keyPath, $refs, options);\n                        }\n                    }\n                    // Set the \"isCircular\" flag if this or any other property is circular\n                    result.circular = result.circular || circular;\n                }\n            }\n            parents.delete(obj);\n        }\n    }\n    return result;\n}\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `$ref` from the schema root\n * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced\n * @param {Set<object>} processedObjects - An array of all the objects that have already been dereferenced\n * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */ function dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n    // console.log('Dereferencing $ref pointer \"%s\" at %s', $ref.$ref, path);\n    let $refPath = url.resolve(path, $ref.$ref);\n    const cache = dereferencedCache.get($refPath);\n    if (cache) {\n        const refKeys = Object.keys($ref);\n        if (refKeys.length > 1) {\n            const extraKeys = {};\n            for (let key of refKeys){\n                if (key !== \"$ref\" && !(key in cache.value)) {\n                    extraKeys[key] = $ref[key];\n                }\n            }\n            return {\n                circular: cache.circular,\n                value: Object.assign({}, cache.value, extraKeys)\n            };\n        }\n        return cache;\n    }\n    let pointer = $refs._resolve($refPath, path, options);\n    if (pointer === null) {\n        return {\n            circular: false,\n            value: null\n        };\n    }\n    // Check for circular references\n    let directCircular = pointer.circular;\n    let circular = directCircular || parents.has(pointer.value);\n    circular && foundCircularReference(path, $refs, options);\n    // Dereference the JSON reference\n    let dereferencedValue = $Ref.dereference($ref, pointer.value);\n    // Crawl the dereferenced value (unless it's circular)\n    if (!circular) {\n        // Determine if the dereferenced value is circular\n        let dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n        circular = dereferenced.circular;\n        dereferencedValue = dereferenced.value;\n    }\n    if (circular && !directCircular && options.dereference.circular === \"ignore\") {\n        // The user has chosen to \"ignore\" circular references, so don't change the value\n        dereferencedValue = $ref;\n    }\n    if (directCircular) {\n        // The pointer is a DIRECT circular reference (i.e. it references itself).\n        // So replace the $ref path with the absolute path from the JSON Schema root\n        dereferencedValue.$ref = pathFromRoot;\n    }\n    const dereferencedObject = {\n        circular,\n        value: dereferencedValue\n    };\n    // only cache if no extra properties than $ref\n    if (Object.keys($ref).length === 1) {\n        dereferencedCache.set($refPath, dereferencedObject);\n    }\n    return dereferencedObject;\n}\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.\n *\n * @param {string} keyPath - The JSON Reference path of the circular reference\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {boolean} - always returns true, to indicate that a circular reference was found\n */ function foundCircularReference(keyPath, $refs, options) {\n    $refs.circular = true;\n    if (!options.dereference.circular) {\n        throw ono.reference(`Circular $ref pointer found at ${keyPath}`);\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL2RlcmVmZXJlbmNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUMsa0ZBQU87QUFDNUIsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsMEZBQVc7QUFDbkMsTUFBTSxFQUFFRSxHQUFHLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMsMEVBQWlCO0FBQ3pDLE1BQU1HLE1BQU1ILG1CQUFPQSxDQUFDLDRGQUFZO0FBRWhDSSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCOzs7Ozs7Q0FNQyxHQUNELFNBQVNBLFlBQWFDLE1BQU0sRUFBRUMsT0FBTztJQUNuQyxpRkFBaUY7SUFDakYsSUFBSUMsZUFBZUMsTUFBTUgsT0FBT0ksTUFBTSxFQUFFSixPQUFPSyxLQUFLLENBQUNDLFNBQVMsQ0FBQ0MsSUFBSSxFQUFFLEtBQUssSUFBSUMsT0FBTyxJQUFJQSxPQUFPLElBQUlDLE9BQU9ULE9BQU9LLEtBQUssRUFBRUo7SUFDekhELE9BQU9LLEtBQUssQ0FBQ0ssUUFBUSxHQUFHUixhQUFhUSxRQUFRO0lBQzdDVixPQUFPSSxNQUFNLEdBQUdGLGFBQWFTLEtBQUs7QUFDcEM7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTUixNQUFPUyxHQUFHLEVBQUVMLElBQUksRUFBRU0sWUFBWSxFQUFFQyxPQUFPLEVBQUVDLGdCQUFnQixFQUFFQyxpQkFBaUIsRUFBRVgsS0FBSyxFQUFFSixPQUFPO0lBQ25HLElBQUlDO0lBQ0osSUFBSWUsU0FBUztRQUNYTixPQUFPQztRQUNQRixVQUFVO0lBQ1o7SUFFQSxJQUFJUSxpQkFBaUJqQixRQUFRRixXQUFXLENBQUNvQixtQkFBbUI7SUFFNUQsSUFBSWxCLFFBQVFGLFdBQVcsQ0FBQ1csUUFBUSxLQUFLLFlBQVksQ0FBQ0ssaUJBQWlCSyxHQUFHLENBQUNSLE1BQU07UUFDM0UsSUFBSUEsT0FBTyxP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RUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTZix1QkFBd0JILE9BQU8sRUFBRXhCLEtBQUssRUFBRUosT0FBTztJQUN0REksTUFBTUssUUFBUSxHQUFHO0lBQ2pCLElBQUksQ0FBQ1QsUUFBUUYsV0FBVyxDQUFDVyxRQUFRLEVBQUU7UUFDakMsTUFBTWYsSUFBSXNELFNBQVMsQ0FBQyxDQUFDLCtCQUErQixFQUFFcEIsUUFBUSxDQUFDO0lBQ2pFO0lBQ0EsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvZGVyZWZlcmVuY2UuanM/NmVjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgJFJlZiA9IHJlcXVpcmUoXCIuL3JlZlwiKTtcbmNvbnN0IFBvaW50ZXIgPSByZXF1aXJlKFwiLi9wb2ludGVyXCIpO1xuY29uc3QgeyBvbm8gfSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwiLi91dGlsL3VybFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZXJlZmVyZW5jZTtcblxuLyoqXG4gKiBDcmF3bHMgdGhlIEpTT04gc2NoZW1hLCBmaW5kcyBhbGwgSlNPTiByZWZlcmVuY2VzLCBhbmQgZGVyZWZlcmVuY2VzIHRoZW0uXG4gKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSBKU09OIHNjaGVtYSBvYmplY3QsIHJlcGxhY2luZyBKU09OIHJlZmVyZW5jZXMgd2l0aCB0aGVpciByZXNvbHZlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0geyRSZWZQYXJzZXJ9IHBhcnNlclxuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBkZXJlZmVyZW5jZSAocGFyc2VyLCBvcHRpb25zKSB7XG4gIC8vIGNvbnNvbGUubG9nKCdEZXJlZmVyZW5jaW5nICRyZWYgcG9pbnRlcnMgaW4gJXMnLCBwYXJzZXIuJHJlZnMuX3Jvb3QkUmVmLnBhdGgpO1xuICBsZXQgZGVyZWZlcmVuY2VkID0gY3Jhd2wocGFyc2VyLnNjaGVtYSwgcGFyc2VyLiRyZWZzLl9yb290JFJlZi5wYXRoLCBcIiNcIiwgbmV3IFNldCgpLCBuZXcgU2V0KCksIG5ldyBNYXAoKSwgcGFyc2VyLiRyZWZzLCBvcHRpb25zKTtcbiAgcGFyc2VyLiRyZWZzLmNpcmN1bGFyID0gZGVyZWZlcmVuY2VkLmNpcmN1bGFyO1xuICBwYXJzZXIuc2NoZW1hID0gZGVyZWZlcmVuY2VkLnZhbHVlO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNyYXdscyB0aGUgZ2l2ZW4gdmFsdWUsIGFuZCBkZXJlZmVyZW5jZXMgYW55IEpTT04gcmVmZXJlbmNlcy5cbiAqXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRoZSB2YWx1ZSB0byBjcmF3bC4gSWYgaXQncyBub3QgYW4gb2JqZWN0IG9yIGFycmF5LCBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBmdWxsIHBhdGggb2YgYG9iamAsIHBvc3NpYmx5IHdpdGggYSBKU09OIFBvaW50ZXIgaW4gdGhlIGhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoRnJvbVJvb3QgLSBUaGUgcGF0aCBvZiBgb2JqYCBmcm9tIHRoZSBzY2hlbWEgcm9vdFxuICogQHBhcmFtIHtTZXQ8b2JqZWN0Pn0gcGFyZW50cyAtIEFuIGFycmF5IG9mIHRoZSBwYXJlbnQgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRlcmVmZXJlbmNlZFxuICogQHBhcmFtIHtTZXQ8b2JqZWN0Pn0gcHJvY2Vzc2VkT2JqZWN0cyAtIEFuIGFycmF5IG9mIGFsbCB0aGUgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZFxuICogQHBhcmFtIHtNYXA8c3RyaW5nLG9iamVjdD59IGRlcmVmZXJlbmNlZENhY2hlIC0gQW4gbWFwIG9mIGFsbCB0aGUgZGVyZWZlcmVuY2VkIG9iamVjdHNcbiAqIEBwYXJhbSB7JFJlZnN9ICRyZWZzXG4gKiBAcGFyYW0geyRSZWZQYXJzZXJPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7e3ZhbHVlOiBvYmplY3QsIGNpcmN1bGFyOiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gY3Jhd2wgKG9iaiwgcGF0aCwgcGF0aEZyb21Sb290LCBwYXJlbnRzLCBwcm9jZXNzZWRPYmplY3RzLCBkZXJlZmVyZW5jZWRDYWNoZSwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgbGV0IGRlcmVmZXJlbmNlZDtcbiAgbGV0IHJlc3VsdCA9IHtcbiAgICB2YWx1ZTogb2JqLFxuICAgIGNpcmN1bGFyOiBmYWxzZVxuICB9O1xuXG4gIGxldCBpc0V4Y2x1ZGVkUGF0aCA9IG9wdGlvbnMuZGVyZWZlcmVuY2UuZXhjbHVkZWRQYXRoTWF0Y2hlcjtcblxuICBpZiAob3B0aW9ucy5kZXJlZmVyZW5jZS5jaXJjdWxhciA9PT0gXCJpZ25vcmVcIiB8fCAhcHJvY2Vzc2VkT2JqZWN0cy5oYXMob2JqKSkge1xuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgJiYgIWlzRXhjbHVkZWRQYXRoKHBhdGhGcm9tUm9vdCkpIHtcbiAgICAgIHBhcmVudHMuYWRkKG9iaik7XG4gICAgICBwcm9jZXNzZWRPYmplY3RzLmFkZChvYmopO1xuXG4gICAgICBpZiAoJFJlZi5pc0FsbG93ZWQkUmVmKG9iaiwgb3B0aW9ucykpIHtcbiAgICAgICAgZGVyZWZlcmVuY2VkID0gZGVyZWZlcmVuY2UkUmVmKG9iaiwgcGF0aCwgcGF0aEZyb21Sb290LCBwYXJlbnRzLCBwcm9jZXNzZWRPYmplY3RzLCBkZXJlZmVyZW5jZWRDYWNoZSwgJHJlZnMsIG9wdGlvbnMpO1xuICAgICAgICByZXN1bHQuY2lyY3VsYXIgPSBkZXJlZmVyZW5jZWQuY2lyY3VsYXI7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IGRlcmVmZXJlbmNlZC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgICAgbGV0IGtleVBhdGggPSBQb2ludGVyLmpvaW4ocGF0aCwga2V5KTtcbiAgICAgICAgICBsZXQga2V5UGF0aEZyb21Sb290ID0gUG9pbnRlci5qb2luKHBhdGhGcm9tUm9vdCwga2V5KTtcblxuICAgICAgICAgIGlmIChpc0V4Y2x1ZGVkUGF0aChrZXlQYXRoRnJvbVJvb3QpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICBsZXQgY2lyY3VsYXIgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICgkUmVmLmlzQWxsb3dlZCRSZWYodmFsdWUsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBkZXJlZmVyZW5jZWQgPSBkZXJlZmVyZW5jZSRSZWYodmFsdWUsIGtleVBhdGgsIGtleVBhdGhGcm9tUm9vdCwgcGFyZW50cywgcHJvY2Vzc2VkT2JqZWN0cywgZGVyZWZlcmVuY2VkQ2FjaGUsICRyZWZzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNpcmN1bGFyID0gZGVyZWZlcmVuY2VkLmNpcmN1bGFyO1xuICAgICAgICAgICAgLy8gQXZvaWQgcG9pbnRsZXNzIG11dGF0aW9uczsgYnJlYWtzIGZyb3plbiBvYmplY3RzIHRvIG5vIHByb2ZpdFxuICAgICAgICAgICAgaWYgKG9ialtrZXldICE9PSBkZXJlZmVyZW5jZWQudmFsdWUpIHtcbiAgICAgICAgICAgICAgb2JqW2tleV0gPSBkZXJlZmVyZW5jZWQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgZGVyZWZlcmVuY2VkID0gY3Jhd2wodmFsdWUsIGtleVBhdGgsIGtleVBhdGhGcm9tUm9vdCwgcGFyZW50cywgcHJvY2Vzc2VkT2JqZWN0cywgZGVyZWZlcmVuY2VkQ2FjaGUsICRyZWZzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgY2lyY3VsYXIgPSBkZXJlZmVyZW5jZWQuY2lyY3VsYXI7XG4gICAgICAgICAgICAgIC8vIEF2b2lkIHBvaW50bGVzcyBtdXRhdGlvbnM7IGJyZWFrcyBmcm96ZW4gb2JqZWN0cyB0byBubyBwcm9maXRcbiAgICAgICAgICAgICAgaWYgKG9ialtrZXldICE9PSBkZXJlZmVyZW5jZWQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGRlcmVmZXJlbmNlZC52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNpcmN1bGFyID0gZm91bmRDaXJjdWxhclJlZmVyZW5jZShrZXlQYXRoLCAkcmVmcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IHRoZSBcImlzQ2lyY3VsYXJcIiBmbGFnIGlmIHRoaXMgb3IgYW55IG90aGVyIHByb3BlcnR5IGlzIGNpcmN1bGFyXG4gICAgICAgICAgcmVzdWx0LmNpcmN1bGFyID0gcmVzdWx0LmNpcmN1bGFyIHx8IGNpcmN1bGFyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhcmVudHMuZGVsZXRlKG9iaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXJlZmVyZW5jZXMgdGhlIGdpdmVuIEpTT04gUmVmZXJlbmNlLCBhbmQgdGhlbiBjcmF3bHMgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3skcmVmOiBzdHJpbmd9fSAkcmVmIC0gVGhlIEpTT04gUmVmZXJlbmNlIHRvIHJlc29sdmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiBgJHJlZmAsIHBvc3NpYmx5IHdpdGggYSBKU09OIFBvaW50ZXIgaW4gdGhlIGhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoRnJvbVJvb3QgLSBUaGUgcGF0aCBvZiBgJHJlZmAgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAqIEBwYXJhbSB7U2V0PG9iamVjdD59IHBhcmVudHMgLSBBbiBhcnJheSBvZiB0aGUgcGFyZW50IG9iamVjdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXJlZmVyZW5jZWRcbiAqIEBwYXJhbSB7U2V0PG9iamVjdD59IHByb2Nlc3NlZE9iamVjdHMgLSBBbiBhcnJheSBvZiBhbGwgdGhlIG9iamVjdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXJlZmVyZW5jZWRcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxvYmplY3Q+fSBkZXJlZmVyZW5jZWRDYWNoZSAtIEFuIG1hcCBvZiBhbGwgdGhlIGRlcmVmZXJlbmNlZCBvYmplY3RzXG4gKiBAcGFyYW0geyRSZWZzfSAkcmVmc1xuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge3t2YWx1ZTogb2JqZWN0LCBjaXJjdWxhcjogYm9vbGVhbn19XG4gKi9cbmZ1bmN0aW9uIGRlcmVmZXJlbmNlJFJlZiAoJHJlZiwgcGF0aCwgcGF0aEZyb21Sb290LCBwYXJlbnRzLCBwcm9jZXNzZWRPYmplY3RzLCBkZXJlZmVyZW5jZWRDYWNoZSwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgLy8gY29uc29sZS5sb2coJ0RlcmVmZXJlbmNpbmcgJHJlZiBwb2ludGVyIFwiJXNcIiBhdCAlcycsICRyZWYuJHJlZiwgcGF0aCk7XG5cbiAgbGV0ICRyZWZQYXRoID0gdXJsLnJlc29sdmUocGF0aCwgJHJlZi4kcmVmKTtcblxuICBjb25zdCBjYWNoZSA9IGRlcmVmZXJlbmNlZENhY2hlLmdldCgkcmVmUGF0aCk7XG4gIGlmIChjYWNoZSkge1xuICAgIGNvbnN0IHJlZktleXMgPSBPYmplY3Qua2V5cygkcmVmKTtcbiAgICBpZiAocmVmS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBleHRyYUtleXMgPSB7fTtcbiAgICAgIGZvciAobGV0IGtleSBvZiByZWZLZXlzKSB7XG4gICAgICAgIGlmIChrZXkgIT09IFwiJHJlZlwiICYmICEoa2V5IGluIGNhY2hlLnZhbHVlKSkge1xuICAgICAgICAgIGV4dHJhS2V5c1trZXldID0gJHJlZltrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaXJjdWxhcjogY2FjaGUuY2lyY3VsYXIsXG4gICAgICAgIHZhbHVlOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZS52YWx1ZSwgZXh0cmFLZXlzKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG5cblxuICBsZXQgcG9pbnRlciA9ICRyZWZzLl9yZXNvbHZlKCRyZWZQYXRoLCBwYXRoLCBvcHRpb25zKTtcblxuICBpZiAocG9pbnRlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaXJjdWxhcjogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgbGV0IGRpcmVjdENpcmN1bGFyID0gcG9pbnRlci5jaXJjdWxhcjtcbiAgbGV0IGNpcmN1bGFyID0gZGlyZWN0Q2lyY3VsYXIgfHwgcGFyZW50cy5oYXMocG9pbnRlci52YWx1ZSk7XG4gIGNpcmN1bGFyICYmIGZvdW5kQ2lyY3VsYXJSZWZlcmVuY2UocGF0aCwgJHJlZnMsIG9wdGlvbnMpO1xuXG4gIC8vIERlcmVmZXJlbmNlIHRoZSBKU09OIHJlZmVyZW5jZVxuICBsZXQgZGVyZWZlcmVuY2VkVmFsdWUgPSAkUmVmLmRlcmVmZXJlbmNlKCRyZWYsIHBvaW50ZXIudmFsdWUpO1xuXG4gIC8vIENyYXdsIHRoZSBkZXJlZmVyZW5jZWQgdmFsdWUgKHVubGVzcyBpdCdzIGNpcmN1bGFyKVxuICBpZiAoIWNpcmN1bGFyKSB7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBkZXJlZmVyZW5jZWQgdmFsdWUgaXMgY2lyY3VsYXJcbiAgICBsZXQgZGVyZWZlcmVuY2VkID0gY3Jhd2woZGVyZWZlcmVuY2VkVmFsdWUsIHBvaW50ZXIucGF0aCwgcGF0aEZyb21Sb290LCBwYXJlbnRzLCBwcm9jZXNzZWRPYmplY3RzLCBkZXJlZmVyZW5jZWRDYWNoZSwgJHJlZnMsIG9wdGlvbnMpO1xuICAgIGNpcmN1bGFyID0gZGVyZWZlcmVuY2VkLmNpcmN1bGFyO1xuICAgIGRlcmVmZXJlbmNlZFZhbHVlID0gZGVyZWZlcmVuY2VkLnZhbHVlO1xuICB9XG5cbiAgaWYgKGNpcmN1bGFyICYmICFkaXJlY3RDaXJjdWxhciAmJiBvcHRpb25zLmRlcmVmZXJlbmNlLmNpcmN1bGFyID09PSBcImlnbm9yZVwiKSB7XG4gICAgLy8gVGhlIHVzZXIgaGFzIGNob3NlbiB0byBcImlnbm9yZVwiIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHNvIGRvbid0IGNoYW5nZSB0aGUgdmFsdWVcbiAgICBkZXJlZmVyZW5jZWRWYWx1ZSA9ICRyZWY7XG4gIH1cblxuICBpZiAoZGlyZWN0Q2lyY3VsYXIpIHtcbiAgICAvLyBUaGUgcG9pbnRlciBpcyBhIERJUkVDVCBjaXJjdWxhciByZWZlcmVuY2UgKGkuZS4gaXQgcmVmZXJlbmNlcyBpdHNlbGYpLlxuICAgIC8vIFNvIHJlcGxhY2UgdGhlICRyZWYgcGF0aCB3aXRoIHRoZSBhYnNvbHV0ZSBwYXRoIGZyb20gdGhlIEpTT04gU2NoZW1hIHJvb3RcbiAgICBkZXJlZmVyZW5jZWRWYWx1ZS4kcmVmID0gcGF0aEZyb21Sb290O1xuICB9XG5cblxuICBjb25zdCBkZXJlZmVyZW5jZWRPYmplY3QgPSB7XG4gICAgY2lyY3VsYXIsXG4gICAgdmFsdWU6IGRlcmVmZXJlbmNlZFZhbHVlXG4gIH07XG5cbiAgLy8gb25seSBjYWNoZSBpZiBubyBleHRyYSBwcm9wZXJ0aWVzIHRoYW4gJHJlZlxuICBpZiAoT2JqZWN0LmtleXMoJHJlZikubGVuZ3RoID09PSAxKSB7XG4gICAgZGVyZWZlcmVuY2VkQ2FjaGUuc2V0KCRyZWZQYXRoLCBkZXJlZmVyZW5jZWRPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIGRlcmVmZXJlbmNlZE9iamVjdDtcbn1cblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyBmb3VuZC5cbiAqIEl0IHNldHMgdGhlIHtAbGluayAkUmVmcyNjaXJjdWxhcn0gZmxhZywgYW5kIHRocm93cyBhbiBlcnJvciBpZiBvcHRpb25zLmRlcmVmZXJlbmNlLmNpcmN1bGFyIGlzIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlQYXRoIC0gVGhlIEpTT04gUmVmZXJlbmNlIHBhdGggb2YgdGhlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICogQHBhcmFtIHskUmVmc30gJHJlZnNcbiAqIEBwYXJhbSB7JFJlZlBhcnNlck9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIGFsd2F5cyByZXR1cm5zIHRydWUsIHRvIGluZGljYXRlIHRoYXQgYSBjaXJjdWxhciByZWZlcmVuY2Ugd2FzIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGZvdW5kQ2lyY3VsYXJSZWZlcmVuY2UgKGtleVBhdGgsICRyZWZzLCBvcHRpb25zKSB7XG4gICRyZWZzLmNpcmN1bGFyID0gdHJ1ZTtcbiAgaWYgKCFvcHRpb25zLmRlcmVmZXJlbmNlLmNpcmN1bGFyKSB7XG4gICAgdGhyb3cgb25vLnJlZmVyZW5jZShgQ2lyY3VsYXIgJHJlZiBwb2ludGVyIGZvdW5kIGF0ICR7a2V5UGF0aH1gKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiJdLCJuYW1lcyI6WyIkUmVmIiwicmVxdWlyZSIsIlBvaW50ZXIiLCJvbm8iLCJ1cmwiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVyZWZlcmVuY2UiLCJwYXJzZXIiLCJvcHRpb25zIiwiZGVyZWZlcmVuY2VkIiwiY3Jhd2wiLCJzY2hlbWEiLCIkcmVmcyIsIl9yb290JFJlZiIsInBhdGgiLCJTZXQiLCJNYXAiLCJjaXJjdWxhciIsInZhbHVlIiwib2JqIiwicGF0aEZyb21Sb290IiwicGFyZW50cyIsInByb2Nlc3NlZE9iamVjdHMiLCJkZXJlZmVyZW5jZWRDYWNoZSIsInJlc3VsdCIsImlzRXhjbHVkZWRQYXRoIiwiZXhjbHVkZWRQYXRoTWF0Y2hlciIsImhhcyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYWRkIiwiaXNBbGxvd2VkJFJlZiIsImRlcmVmZXJlbmNlJFJlZiIsImtleSIsIk9iamVjdCIsImtleXMiLCJrZXlQYXRoIiwiam9pbiIsImtleVBhdGhGcm9tUm9vdCIsImZvdW5kQ2lyY3VsYXJSZWZlcmVuY2UiLCJkZWxldGUiLCIkcmVmIiwiJHJlZlBhdGgiLCJyZXNvbHZlIiwiY2FjaGUiLCJnZXQiLCJyZWZLZXlzIiwibGVuZ3RoIiwiZXh0cmFLZXlzIiwiYXNzaWduIiwicG9pbnRlciIsIl9yZXNvbHZlIiwiZGlyZWN0Q2lyY3VsYXIiLCJkZXJlZmVyZW5jZWRWYWx1ZSIsImRlcmVmZXJlbmNlZE9iamVjdCIsInNldCIsInJlZmVyZW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/dereference.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable no-unused-vars */ \nconst $Refs = __webpack_require__(/*! ./refs */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/refs.js\");\nconst _parse = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parse.js\");\nconst normalizeArgs = __webpack_require__(/*! ./normalize-args */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/normalize-args.js\");\nconst resolveExternal = __webpack_require__(/*! ./resolve-external */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/resolve-external.js\");\nconst _bundle = __webpack_require__(/*! ./bundle */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/bundle.js\");\nconst _dereference = __webpack_require__(/*! ./dereference */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/dereference.js\");\nconst url = __webpack_require__(/*! ./util/url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\nconst { JSONParserError, InvalidPointerError, MissingPointerError, ResolverError, ParserError, UnmatchedParserError, UnmatchedResolverError, isHandledError, JSONParserErrorGroup } = __webpack_require__(/*! ./util/errors */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\");\nconst maybe = __webpack_require__(/*! call-me-maybe */ \"(rsc)/./node_modules/call-me-maybe/src/maybe.js\");\nconst { ono } = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/@jsdevtools/ono/esm/index.js\");\nmodule.exports = $RefParser;\nmodule.exports[\"default\"] = $RefParser;\nmodule.exports.JSONParserError = JSONParserError;\nmodule.exports.InvalidPointerError = InvalidPointerError;\nmodule.exports.MissingPointerError = MissingPointerError;\nmodule.exports.ResolverError = ResolverError;\nmodule.exports.ParserError = ParserError;\nmodule.exports.UnmatchedParserError = UnmatchedParserError;\nmodule.exports.UnmatchedResolverError = UnmatchedResolverError;\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */ function $RefParser() {\n    /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */ this.schema = null;\n    /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */ this.$refs = new $Refs();\n}\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */ $RefParser.parse = function parse(path, schema, options, callback) {\n    let Class = this; // eslint-disable-line consistent-this\n    let instance = new Class();\n    return instance.parse.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */ $RefParser.prototype.parse = async function parse(path, schema, options, callback) {\n    let args = normalizeArgs(arguments);\n    let promise;\n    if (!args.path && !args.schema) {\n        let err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n        return maybe(args.callback, Promise.reject(err));\n    }\n    // Reset everything\n    this.schema = null;\n    this.$refs = new $Refs();\n    // If the path is a filesystem path, then convert it to a URL.\n    // NOTE: According to the JSON Reference spec, these should already be URLs,\n    // but, in practice, many people use local filesystem paths instead.\n    // So we're being generous here and doing the conversion automatically.\n    // This is not intended to be a 100% bulletproof solution.\n    // If it doesn't work for your use-case, then use a URL instead.\n    let pathType = \"http\";\n    if (url.isFileSystemPath(args.path)) {\n        args.path = url.fromFileSystemPath(args.path);\n        pathType = \"file\";\n    }\n    // Resolve the absolute path of the schema\n    args.path = url.resolve(url.cwd(), args.path);\n    if (args.schema && typeof args.schema === \"object\") {\n        // A schema object was passed-in.\n        // So immediately add a new $Ref with the schema object as its value\n        let $ref = this.$refs._add(args.path);\n        $ref.value = args.schema;\n        $ref.pathType = pathType;\n        promise = Promise.resolve(args.schema);\n    } else {\n        // Parse the schema file/url\n        promise = _parse(args.path, this.$refs, args.options);\n    }\n    let me = this;\n    try {\n        let result = await promise;\n        if (result !== null && typeof result === \"object\" && !Buffer.isBuffer(result)) {\n            me.schema = result;\n            return maybe(args.callback, Promise.resolve(me.schema));\n        } else if (args.options.continueOnError) {\n            me.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability\n            return maybe(args.callback, Promise.resolve(me.schema));\n        } else {\n            throw ono.syntax(`\"${me.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n        }\n    } catch (err) {\n        if (!args.options.continueOnError || !isHandledError(err)) {\n            return maybe(args.callback, Promise.reject(err));\n        }\n        if (this.$refs._$refs[url.stripHash(args.path)]) {\n            this.$refs._$refs[url.stripHash(args.path)].addError(err);\n        }\n        return maybe(args.callback, Promise.resolve(null));\n    }\n};\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */ $RefParser.resolve = function resolve(path, schema, options, callback) {\n    let Class = this; // eslint-disable-line consistent-this\n    let instance = new Class();\n    return instance.resolve.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */ $RefParser.prototype.resolve = async function resolve(path, schema, options, callback) {\n    let me = this;\n    let args = normalizeArgs(arguments);\n    try {\n        await this.parse(args.path, args.schema, args.options);\n        await resolveExternal(me, args.options);\n        finalize(me);\n        return maybe(args.callback, Promise.resolve(me.$refs));\n    } catch (err) {\n        return maybe(args.callback, Promise.reject(err));\n    }\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */ $RefParser.bundle = function bundle(path, schema, options, callback) {\n    let Class = this; // eslint-disable-line consistent-this\n    let instance = new Class();\n    return instance.bundle.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */ $RefParser.prototype.bundle = async function bundle(path, schema, options, callback) {\n    let me = this;\n    let args = normalizeArgs(arguments);\n    try {\n        await this.resolve(args.path, args.schema, args.options);\n        _bundle(me, args.options);\n        finalize(me);\n        return maybe(args.callback, Promise.resolve(me.schema));\n    } catch (err) {\n        return maybe(args.callback, Promise.reject(err));\n    }\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */ $RefParser.dereference = function dereference(path, schema, options, callback) {\n    let Class = this; // eslint-disable-line consistent-this\n    let instance = new Class();\n    return instance.dereference.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */ $RefParser.prototype.dereference = async function dereference(path, schema, options, callback) {\n    let me = this;\n    let args = normalizeArgs(arguments);\n    try {\n        await this.resolve(args.path, args.schema, args.options);\n        _dereference(me, args.options);\n        finalize(me);\n        return maybe(args.callback, Promise.resolve(me.schema));\n    } catch (err) {\n        return maybe(args.callback, Promise.reject(err));\n    }\n};\nfunction finalize(parser) {\n    const errors = JSONParserErrorGroup.getParserErrors(parser);\n    if (errors.length > 0) {\n        throw new JSONParserErrorGroup(parser);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyxHQUNwQjtBQUViLE1BQU1BLFFBQVFDLG1CQUFPQSxDQUFDLG9GQUFRO0FBQzlCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLHNGQUFTO0FBQ2hDLE1BQU1FLGdCQUFnQkYsbUJBQU9BLENBQUMsd0dBQWtCO0FBQ2hELE1BQU1HLGtCQUFrQkgsbUJBQU9BLENBQUMsNEdBQW9CO0FBQ3BELE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLHdGQUFVO0FBQ2xDLE1BQU1LLGVBQWVMLG1CQUFPQSxDQUFDLGtHQUFlO0FBQzVDLE1BQU1NLE1BQU1OLG1CQUFPQSxDQUFDLDRGQUFZO0FBQ2hDLE1BQU0sRUFBRU8sZUFBZSxFQUFFQyxtQkFBbUIsRUFBRUMsbUJBQW1CLEVBQUVDLGFBQWEsRUFBRUMsV0FBVyxFQUFFQyxvQkFBb0IsRUFBRUMsc0JBQXNCLEVBQUVDLGNBQWMsRUFBRUMsb0JBQW9CLEVBQUUsR0FBR2YsbUJBQU9BLENBQUMsa0dBQWU7QUFDN00sTUFBTWdCLFFBQVFoQixtQkFBT0EsQ0FBQyxzRUFBZTtBQUNyQyxNQUFNLEVBQUVpQixHQUFHLEVBQUUsR0FBR2pCLG1CQUFPQSxDQUFDLDBFQUFpQjtBQUV6Q2tCLE9BQU9DLE9BQU8sR0FBR0M7QUFDakJGLHlCQUFzQixHQUFHRTtBQUN6QkYsOEJBQThCLEdBQUdYO0FBQ2pDVyxrQ0FBa0MsR0FBR1Y7QUFDckNVLGtDQUFrQyxHQUFHVDtBQUNyQ1MsNEJBQTRCLEdBQUdSO0FBQy9CUSwwQkFBMEIsR0FBR1A7QUFDN0JPLG1DQUFtQyxHQUFHTjtBQUN0Q00scUNBQXFDLEdBQUdMO0FBRXhDOzs7OztDQUtDLEdBQ0QsU0FBU087SUFDUDs7Ozs7R0FLQyxHQUNELElBQUksQ0FBQ0UsTUFBTSxHQUFHO0lBRWQ7Ozs7O0dBS0MsR0FDRCxJQUFJLENBQUND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QyxTQUFTNkIsV0FBVyxDQUFDNUIsS0FBSyxDQUFDRCxVQUFVRTtBQUM5QztBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNEWCxXQUFXWSxTQUFTLENBQUMwQixXQUFXLEdBQUcsZUFBZUEsWUFBYWpDLElBQUksRUFBRUgsTUFBTSxFQUFFSSxPQUFPLEVBQUVDLFFBQVE7SUFDNUYsSUFBSW1CLEtBQUssSUFBSTtJQUNiLElBQUliLE9BQU8vQixjQUFjNkI7SUFFekIsSUFBSTtRQUNGLE1BQU0sSUFBSSxDQUFDVSxPQUFPLENBQUNSLEtBQUtSLElBQUksRUFBRVEsS0FBS1gsTUFBTSxFQUFFVyxLQUFLUCxPQUFPO1FBQ3ZEckIsYUFBYXlDLElBQUliLEtBQUtQLE9BQU87UUFDN0I4QixTQUFTVjtRQUNULE9BQU85QixNQUFNaUIsS0FBS04sUUFBUSxFQUFFUyxRQUFRSyxPQUFPLENBQUNLLEdBQUd4QixNQUFNO0lBQ3ZELEVBQ0EsT0FBT2EsS0FBSztRQUNWLE9BQU9uQixNQUFNaUIsS0FBS04sUUFBUSxFQUFFUyxRQUFRQyxNQUFNLENBQUNGO0lBQzdDO0FBQ0Y7QUFFQSxTQUFTcUIsU0FBVUcsTUFBTTtJQUN2QixNQUFNQyxTQUFTN0MscUJBQXFCOEMsZUFBZSxDQUFDRjtJQUNwRCxJQUFJQyxPQUFPRSxNQUFNLEdBQUcsR0FBRztRQUNyQixNQUFNLElBQUkvQyxxQkFBcUI0QztJQUNqQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvaW5kZXguanM/OTc4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0ICRSZWZzID0gcmVxdWlyZShcIi4vcmVmc1wiKTtcbmNvbnN0IF9wYXJzZSA9IHJlcXVpcmUoXCIuL3BhcnNlXCIpO1xuY29uc3Qgbm9ybWFsaXplQXJncyA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS1hcmdzXCIpO1xuY29uc3QgcmVzb2x2ZUV4dGVybmFsID0gcmVxdWlyZShcIi4vcmVzb2x2ZS1leHRlcm5hbFwiKTtcbmNvbnN0IF9idW5kbGUgPSByZXF1aXJlKFwiLi9idW5kbGVcIik7XG5jb25zdCBfZGVyZWZlcmVuY2UgPSByZXF1aXJlKFwiLi9kZXJlZmVyZW5jZVwiKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCIuL3V0aWwvdXJsXCIpO1xuY29uc3QgeyBKU09OUGFyc2VyRXJyb3IsIEludmFsaWRQb2ludGVyRXJyb3IsIE1pc3NpbmdQb2ludGVyRXJyb3IsIFJlc29sdmVyRXJyb3IsIFBhcnNlckVycm9yLCBVbm1hdGNoZWRQYXJzZXJFcnJvciwgVW5tYXRjaGVkUmVzb2x2ZXJFcnJvciwgaXNIYW5kbGVkRXJyb3IsIEpTT05QYXJzZXJFcnJvckdyb3VwIH0gPSByZXF1aXJlKFwiLi91dGlsL2Vycm9yc1wiKTtcbmNvbnN0IG1heWJlID0gcmVxdWlyZShcImNhbGwtbWUtbWF5YmVcIik7XG5jb25zdCB7IG9ubyB9ID0gcmVxdWlyZShcIkBqc2RldnRvb2xzL29ub1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSAkUmVmUGFyc2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9ICRSZWZQYXJzZXI7XG5tb2R1bGUuZXhwb3J0cy5KU09OUGFyc2VyRXJyb3IgPSBKU09OUGFyc2VyRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5JbnZhbGlkUG9pbnRlckVycm9yID0gSW52YWxpZFBvaW50ZXJFcnJvcjtcbm1vZHVsZS5leHBvcnRzLk1pc3NpbmdQb2ludGVyRXJyb3IgPSBNaXNzaW5nUG9pbnRlckVycm9yO1xubW9kdWxlLmV4cG9ydHMuUmVzb2x2ZXJFcnJvciA9IFJlc29sdmVyRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5QYXJzZXJFcnJvciA9IFBhcnNlckVycm9yO1xubW9kdWxlLmV4cG9ydHMuVW5tYXRjaGVkUGFyc2VyRXJyb3IgPSBVbm1hdGNoZWRQYXJzZXJFcnJvcjtcbm1vZHVsZS5leHBvcnRzLlVubWF0Y2hlZFJlc29sdmVyRXJyb3IgPSBVbm1hdGNoZWRSZXNvbHZlckVycm9yO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgcGFyc2VzIGEgSlNPTiBzY2hlbWEsIGJ1aWxkcyBhIG1hcCBvZiBpdHMgSlNPTiByZWZlcmVuY2VzIGFuZCB0aGVpciByZXNvbHZlZCB2YWx1ZXMsXG4gKiBhbmQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgdHJhdmVyc2luZywgbWFuaXB1bGF0aW5nLCBhbmQgZGVyZWZlcmVuY2luZyB0aG9zZSByZWZlcmVuY2VzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiAkUmVmUGFyc2VyICgpIHtcbiAgLyoqXG4gICAqIFRoZSBwYXJzZWQgKGFuZCBwb3NzaWJseSBkZXJlZmVyZW5jZWQpIEpTT04gc2NoZW1hIG9iamVjdFxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHRoaXMuc2NoZW1hID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIHJlc29sdmVkIEpTT04gcmVmZXJlbmNlc1xuICAgKlxuICAgKiBAdHlwZSB7JFJlZnN9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgdGhpcy4kcmVmcyA9IG5ldyAkUmVmcygpO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gSlNPTiBzY2hlbWEuXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCByZXNvbHZlIGFueSBKU09OIHJlZmVyZW5jZXMuXG4gKiBJdCBqdXN0IHJlYWRzIGEgc2luZ2xlIGZpbGUgaW4gSlNPTiBvciBZQU1MIGZvcm1hdCwgYW5kIHBhcnNlIGl0IGFzIGEgSmF2YVNjcmlwdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoXSAtIFRoZSBmaWxlIHBhdGggb3IgVVJMIG9mIHRoZSBKU09OIHNjaGVtYVxuICogQHBhcmFtIHtvYmplY3R9IFtzY2hlbWFdIC0gQSBKU09OIHNjaGVtYSBvYmplY3QuIFRoaXMgb2JqZWN0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHJlYWRpbmcgZnJvbSBgcGF0aGAuXG4gKiBAcGFyYW0geyRSZWZQYXJzZXJPcHRpb25zfSBbb3B0aW9uc10gLSBPcHRpb25zIHRoYXQgZGV0ZXJtaW5lIGhvdyB0aGUgc2NoZW1hIGlzIHBhcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIGVycm9yLWZpcnN0IGNhbGxiYWNrLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0aGUgcGFyc2VkIEpTT04gc2NoZW1hIG9iamVjdC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHdpdGggdGhlIHBhcnNlZCBKU09OIHNjaGVtYSBvYmplY3QuXG4gKi9cbiRSZWZQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAocGF0aCwgc2NoZW1hLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBsZXQgQ2xhc3MgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICBsZXQgaW5zdGFuY2UgPSBuZXcgQ2xhc3MoKTtcbiAgcmV0dXJuIGluc3RhbmNlLnBhcnNlLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIEpTT04gc2NoZW1hLlxuICogVGhpcyBtZXRob2QgZG9lcyBub3QgcmVzb2x2ZSBhbnkgSlNPTiByZWZlcmVuY2VzLlxuICogSXQganVzdCByZWFkcyBhIHNpbmdsZSBmaWxlIGluIEpTT04gb3IgWUFNTCBmb3JtYXQsIGFuZCBwYXJzZSBpdCBhcyBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aF0gLSBUaGUgZmlsZSBwYXRoIG9yIFVSTCBvZiB0aGUgSlNPTiBzY2hlbWFcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2NoZW1hXSAtIEEgSlNPTiBzY2hlbWEgb2JqZWN0LiBUaGlzIG9iamVjdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiByZWFkaW5nIGZyb20gYHBhdGhgLlxuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gW29wdGlvbnNdIC0gT3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIHNjaGVtYSBpcyBwYXJzZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBlcnJvci1maXJzdCBjYWxsYmFjay4gVGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgdGhlIHBhcnNlZCBKU09OIHNjaGVtYSBvYmplY3QuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB3aXRoIHRoZSBwYXJzZWQgSlNPTiBzY2hlbWEgb2JqZWN0LlxuICovXG4kUmVmUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGFzeW5jIGZ1bmN0aW9uIHBhcnNlIChwYXRoLCBzY2hlbWEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGxldCBhcmdzID0gbm9ybWFsaXplQXJncyhhcmd1bWVudHMpO1xuICBsZXQgcHJvbWlzZTtcblxuICBpZiAoIWFyZ3MucGF0aCAmJiAhYXJncy5zY2hlbWEpIHtcbiAgICBsZXQgZXJyID0gb25vKGBFeHBlY3RlZCBhIGZpbGUgcGF0aCwgVVJMLCBvciBvYmplY3QuIEdvdCAke2FyZ3MucGF0aCB8fCBhcmdzLnNjaGVtYX1gKTtcbiAgICByZXR1cm4gbWF5YmUoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gIH1cblxuICAvLyBSZXNldCBldmVyeXRoaW5nXG4gIHRoaXMuc2NoZW1hID0gbnVsbDtcbiAgdGhpcy4kcmVmcyA9IG5ldyAkUmVmcygpO1xuXG4gIC8vIElmIHRoZSBwYXRoIGlzIGEgZmlsZXN5c3RlbSBwYXRoLCB0aGVuIGNvbnZlcnQgaXQgdG8gYSBVUkwuXG4gIC8vIE5PVEU6IEFjY29yZGluZyB0byB0aGUgSlNPTiBSZWZlcmVuY2Ugc3BlYywgdGhlc2Ugc2hvdWxkIGFscmVhZHkgYmUgVVJMcyxcbiAgLy8gYnV0LCBpbiBwcmFjdGljZSwgbWFueSBwZW9wbGUgdXNlIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHMgaW5zdGVhZC5cbiAgLy8gU28gd2UncmUgYmVpbmcgZ2VuZXJvdXMgaGVyZSBhbmQgZG9pbmcgdGhlIGNvbnZlcnNpb24gYXV0b21hdGljYWxseS5cbiAgLy8gVGhpcyBpcyBub3QgaW50ZW5kZWQgdG8gYmUgYSAxMDAlIGJ1bGxldHByb29mIHNvbHV0aW9uLlxuICAvLyBJZiBpdCBkb2Vzbid0IHdvcmsgZm9yIHlvdXIgdXNlLWNhc2UsIHRoZW4gdXNlIGEgVVJMIGluc3RlYWQuXG4gIGxldCBwYXRoVHlwZSA9IFwiaHR0cFwiO1xuICBpZiAodXJsLmlzRmlsZVN5c3RlbVBhdGgoYXJncy5wYXRoKSkge1xuICAgIGFyZ3MucGF0aCA9IHVybC5mcm9tRmlsZVN5c3RlbVBhdGgoYXJncy5wYXRoKTtcbiAgICBwYXRoVHlwZSA9IFwiZmlsZVwiO1xuICB9XG5cbiAgLy8gUmVzb2x2ZSB0aGUgYWJzb2x1dGUgcGF0aCBvZiB0aGUgc2NoZW1hXG4gIGFyZ3MucGF0aCA9IHVybC5yZXNvbHZlKHVybC5jd2QoKSwgYXJncy5wYXRoKTtcblxuICBpZiAoYXJncy5zY2hlbWEgJiYgdHlwZW9mIGFyZ3Muc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG4gICAgLy8gQSBzY2hlbWEgb2JqZWN0IHdhcyBwYXNzZWQtaW4uXG4gICAgLy8gU28gaW1tZWRpYXRlbHkgYWRkIGEgbmV3ICRSZWYgd2l0aCB0aGUgc2NoZW1hIG9iamVjdCBhcyBpdHMgdmFsdWVcbiAgICBsZXQgJHJlZiA9IHRoaXMuJHJlZnMuX2FkZChhcmdzLnBhdGgpO1xuICAgICRyZWYudmFsdWUgPSBhcmdzLnNjaGVtYTtcbiAgICAkcmVmLnBhdGhUeXBlID0gcGF0aFR5cGU7XG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhcmdzLnNjaGVtYSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gUGFyc2UgdGhlIHNjaGVtYSBmaWxlL3VybFxuICAgIHByb21pc2UgPSBfcGFyc2UoYXJncy5wYXRoLCB0aGlzLiRyZWZzLCBhcmdzLm9wdGlvbnMpO1xuICB9XG5cbiAgbGV0IG1lID0gdGhpcztcbiAgdHJ5IHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcblxuICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiAhQnVmZmVyLmlzQnVmZmVyKHJlc3VsdCkpIHtcbiAgICAgIG1lLnNjaGVtYSA9IHJlc3VsdDtcbiAgICAgIHJldHVybiBtYXliZShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUobWUuc2NoZW1hKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ3Mub3B0aW9ucy5jb250aW51ZU9uRXJyb3IpIHtcbiAgICAgIG1lLnNjaGVtYSA9IG51bGw7IC8vIGl0J3MgYWxyZWFkeSBzZXQgdG8gbnVsbCBhdCBsaW5lIDc5LCBidXQgbGV0J3Mgc2V0IGl0IGFnYWluIGZvciB0aGUgc2FrZSBvZiByZWFkYWJpbGl0eVxuICAgICAgcmV0dXJuIG1heWJlKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVzb2x2ZShtZS5zY2hlbWEpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBvbm8uc3ludGF4KGBcIiR7bWUuJHJlZnMuX3Jvb3QkUmVmLnBhdGggfHwgcmVzdWx0fVwiIGlzIG5vdCBhIHZhbGlkIEpTT04gU2NoZW1hYCk7XG4gICAgfVxuICB9XG4gIGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIWFyZ3Mub3B0aW9ucy5jb250aW51ZU9uRXJyb3IgfHwgIWlzSGFuZGxlZEVycm9yKGVycikpIHtcbiAgICAgIHJldHVybiBtYXliZShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlamVjdChlcnIpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy4kcmVmcy5fJHJlZnNbdXJsLnN0cmlwSGFzaChhcmdzLnBhdGgpXSkge1xuICAgICAgdGhpcy4kcmVmcy5fJHJlZnNbdXJsLnN0cmlwSGFzaChhcmdzLnBhdGgpXS5hZGRFcnJvcihlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUobnVsbCkpO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gSlNPTiBzY2hlbWEgYW5kIHJlc29sdmVzIGFueSBKU09OIHJlZmVyZW5jZXMsIGluY2x1ZGluZyByZWZlcmVuY2VzIGluXG4gKiBleHRlcm5hbGx5LXJlZmVyZW5jZWQgZmlsZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoXSAtIFRoZSBmaWxlIHBhdGggb3IgVVJMIG9mIHRoZSBKU09OIHNjaGVtYVxuICogQHBhcmFtIHtvYmplY3R9IFtzY2hlbWFdIC0gQSBKU09OIHNjaGVtYSBvYmplY3QuIFRoaXMgb2JqZWN0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHJlYWRpbmcgZnJvbSBgcGF0aGAuXG4gKiBAcGFyYW0geyRSZWZQYXJzZXJPcHRpb25zfSBbb3B0aW9uc10gLSBPcHRpb25zIHRoYXQgZGV0ZXJtaW5lIGhvdyB0aGUgc2NoZW1hIGlzIHBhcnNlZCBhbmQgcmVzb2x2ZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cbiAqIC0gQW4gZXJyb3ItZmlyc3QgY2FsbGJhY2suIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIGEge0BsaW5rICRSZWZzfSBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzb2x2ZWQgSlNPTiByZWZlcmVuY2VzXG4gKlxuICogQHJldHVybnMge1Byb21pc2V9XG4gKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB3aXRoIGEge0BsaW5rICRSZWZzfSBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzb2x2ZWQgSlNPTiByZWZlcmVuY2VzXG4gKi9cbiRSZWZQYXJzZXIucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKHBhdGgsIHNjaGVtYSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgbGV0IENsYXNzID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgbGV0IGluc3RhbmNlID0gbmV3IENsYXNzKCk7XG4gIHJldHVybiBpbnN0YW5jZS5yZXNvbHZlLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIEpTT04gc2NoZW1hIGFuZCByZXNvbHZlcyBhbnkgSlNPTiByZWZlcmVuY2VzLCBpbmNsdWRpbmcgcmVmZXJlbmNlcyBpblxuICogZXh0ZXJuYWxseS1yZWZlcmVuY2VkIGZpbGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aF0gLSBUaGUgZmlsZSBwYXRoIG9yIFVSTCBvZiB0aGUgSlNPTiBzY2hlbWFcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2NoZW1hXSAtIEEgSlNPTiBzY2hlbWEgb2JqZWN0LiBUaGlzIG9iamVjdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiByZWFkaW5nIGZyb20gYHBhdGhgLlxuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gW29wdGlvbnNdIC0gT3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIHNjaGVtYSBpcyBwYXJzZWQgYW5kIHJlc29sdmVkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gKiAtIEFuIGVycm9yLWZpcnN0IGNhbGxiYWNrLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyBhIHtAbGluayAkUmVmc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc29sdmVkIEpTT04gcmVmZXJlbmNlc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICogVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgd2l0aCBhIHtAbGluayAkUmVmc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc29sdmVkIEpTT04gcmVmZXJlbmNlc1xuICovXG4kUmVmUGFyc2VyLnByb3RvdHlwZS5yZXNvbHZlID0gYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZSAocGF0aCwgc2NoZW1hLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBsZXQgbWUgPSB0aGlzO1xuICBsZXQgYXJncyA9IG5vcm1hbGl6ZUFyZ3MoYXJndW1lbnRzKTtcblxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMucGFyc2UoYXJncy5wYXRoLCBhcmdzLnNjaGVtYSwgYXJncy5vcHRpb25zKTtcbiAgICBhd2FpdCByZXNvbHZlRXh0ZXJuYWwobWUsIGFyZ3Mub3B0aW9ucyk7XG4gICAgZmluYWxpemUobWUpO1xuICAgIHJldHVybiBtYXliZShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUobWUuJHJlZnMpKTtcbiAgfVxuICBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG1heWJlKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVqZWN0KGVycikpO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gSlNPTiBzY2hlbWEsIHJlc29sdmVzIGFueSBKU09OIHJlZmVyZW5jZXMsIGFuZCBidW5kbGVzIGFsbCBleHRlcm5hbCByZWZlcmVuY2VzXG4gKiBpbnRvIHRoZSBtYWluIEpTT04gc2NoZW1hLiBUaGlzIHByb2R1Y2VzIGEgSlNPTiBzY2hlbWEgdGhhdCBvbmx5IGhhcyAqaW50ZXJuYWwqIHJlZmVyZW5jZXMsXG4gKiBub3QgYW55ICpleHRlcm5hbCogcmVmZXJlbmNlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhdGhdIC0gVGhlIGZpbGUgcGF0aCBvciBVUkwgb2YgdGhlIEpTT04gc2NoZW1hXG4gKiBAcGFyYW0ge29iamVjdH0gW3NjaGVtYV0gLSBBIEpTT04gc2NoZW1hIG9iamVjdC4gVGhpcyBvYmplY3Qgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgcmVhZGluZyBmcm9tIGBwYXRoYC5cbiAqIEBwYXJhbSB7JFJlZlBhcnNlck9wdGlvbnN9IFtvcHRpb25zXSAtIE9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBzY2hlbWEgaXMgcGFyc2VkLCByZXNvbHZlZCwgYW5kIGRlcmVmZXJlbmNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIGVycm9yLWZpcnN0IGNhbGxiYWNrLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0aGUgYnVuZGxlZCBKU09OIHNjaGVtYSBvYmplY3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHdpdGggdGhlIGJ1bmRsZWQgSlNPTiBzY2hlbWEgb2JqZWN0LlxuICovXG4kUmVmUGFyc2VyLmJ1bmRsZSA9IGZ1bmN0aW9uIGJ1bmRsZSAocGF0aCwgc2NoZW1hLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBsZXQgQ2xhc3MgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICBsZXQgaW5zdGFuY2UgPSBuZXcgQ2xhc3MoKTtcbiAgcmV0dXJuIGluc3RhbmNlLmJ1bmRsZS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBKU09OIHNjaGVtYSwgcmVzb2x2ZXMgYW55IEpTT04gcmVmZXJlbmNlcywgYW5kIGJ1bmRsZXMgYWxsIGV4dGVybmFsIHJlZmVyZW5jZXNcbiAqIGludG8gdGhlIG1haW4gSlNPTiBzY2hlbWEuIFRoaXMgcHJvZHVjZXMgYSBKU09OIHNjaGVtYSB0aGF0IG9ubHkgaGFzICppbnRlcm5hbCogcmVmZXJlbmNlcyxcbiAqIG5vdCBhbnkgKmV4dGVybmFsKiByZWZlcmVuY2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aF0gLSBUaGUgZmlsZSBwYXRoIG9yIFVSTCBvZiB0aGUgSlNPTiBzY2hlbWFcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2NoZW1hXSAtIEEgSlNPTiBzY2hlbWEgb2JqZWN0LiBUaGlzIG9iamVjdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiByZWFkaW5nIGZyb20gYHBhdGhgLlxuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gW29wdGlvbnNdIC0gT3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIHNjaGVtYSBpcyBwYXJzZWQsIHJlc29sdmVkLCBhbmQgZGVyZWZlcmVuY2VkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gZXJyb3ItZmlyc3QgY2FsbGJhY2suIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBidW5kbGVkIEpTT04gc2NoZW1hIG9iamVjdFxuICogQHJldHVybnMge1Byb21pc2V9IC0gVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgYnVuZGxlZCBKU09OIHNjaGVtYSBvYmplY3QuXG4gKi9cbiRSZWZQYXJzZXIucHJvdG90eXBlLmJ1bmRsZSA9IGFzeW5jIGZ1bmN0aW9uIGJ1bmRsZSAocGF0aCwgc2NoZW1hLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBsZXQgbWUgPSB0aGlzO1xuICBsZXQgYXJncyA9IG5vcm1hbGl6ZUFyZ3MoYXJndW1lbnRzKTtcblxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMucmVzb2x2ZShhcmdzLnBhdGgsIGFyZ3Muc2NoZW1hLCBhcmdzLm9wdGlvbnMpO1xuICAgIF9idW5kbGUobWUsIGFyZ3Mub3B0aW9ucyk7XG4gICAgZmluYWxpemUobWUpO1xuICAgIHJldHVybiBtYXliZShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUobWUuc2NoZW1hKSk7XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBtYXliZShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlamVjdChlcnIpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIEpTT04gc2NoZW1hLCByZXNvbHZlcyBhbnkgSlNPTiByZWZlcmVuY2VzLCBhbmQgZGVyZWZlcmVuY2VzIHRoZSBKU09OIHNjaGVtYS5cbiAqIFRoYXQgaXMsIGFsbCBKU09OIHJlZmVyZW5jZXMgYXJlIHJlcGxhY2VkIHdpdGggdGhlaXIgcmVzb2x2ZWQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aF0gLSBUaGUgZmlsZSBwYXRoIG9yIFVSTCBvZiB0aGUgSlNPTiBzY2hlbWFcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2NoZW1hXSAtIEEgSlNPTiBzY2hlbWEgb2JqZWN0LiBUaGlzIG9iamVjdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiByZWFkaW5nIGZyb20gYHBhdGhgLlxuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gW29wdGlvbnNdIC0gT3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIHNjaGVtYSBpcyBwYXJzZWQsIHJlc29sdmVkLCBhbmQgZGVyZWZlcmVuY2VkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gZXJyb3ItZmlyc3QgY2FsbGJhY2suIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBkZXJlZmVyZW5jZWQgSlNPTiBzY2hlbWEgb2JqZWN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB3aXRoIHRoZSBkZXJlZmVyZW5jZWQgSlNPTiBzY2hlbWEgb2JqZWN0LlxuICovXG4kUmVmUGFyc2VyLmRlcmVmZXJlbmNlID0gZnVuY3Rpb24gZGVyZWZlcmVuY2UgKHBhdGgsIHNjaGVtYSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgbGV0IENsYXNzID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgbGV0IGluc3RhbmNlID0gbmV3IENsYXNzKCk7XG4gIHJldHVybiBpbnN0YW5jZS5kZXJlZmVyZW5jZS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBKU09OIHNjaGVtYSwgcmVzb2x2ZXMgYW55IEpTT04gcmVmZXJlbmNlcywgYW5kIGRlcmVmZXJlbmNlcyB0aGUgSlNPTiBzY2hlbWEuXG4gKiBUaGF0IGlzLCBhbGwgSlNPTiByZWZlcmVuY2VzIGFyZSByZXBsYWNlZCB3aXRoIHRoZWlyIHJlc29sdmVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhdGhdIC0gVGhlIGZpbGUgcGF0aCBvciBVUkwgb2YgdGhlIEpTT04gc2NoZW1hXG4gKiBAcGFyYW0ge29iamVjdH0gW3NjaGVtYV0gLSBBIEpTT04gc2NoZW1hIG9iamVjdC4gVGhpcyBvYmplY3Qgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgcmVhZGluZyBmcm9tIGBwYXRoYC5cbiAqIEBwYXJhbSB7JFJlZlBhcnNlck9wdGlvbnN9IFtvcHRpb25zXSAtIE9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBzY2hlbWEgaXMgcGFyc2VkLCByZXNvbHZlZCwgYW5kIGRlcmVmZXJlbmNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIGVycm9yLWZpcnN0IGNhbGxiYWNrLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0aGUgZGVyZWZlcmVuY2VkIEpTT04gc2NoZW1hIG9iamVjdFxuICogQHJldHVybnMge1Byb21pc2V9IC0gVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgZGVyZWZlcmVuY2VkIEpTT04gc2NoZW1hIG9iamVjdC5cbiAqL1xuJFJlZlBhcnNlci5wcm90b3R5cGUuZGVyZWZlcmVuY2UgPSBhc3luYyBmdW5jdGlvbiBkZXJlZmVyZW5jZSAocGF0aCwgc2NoZW1hLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBsZXQgbWUgPSB0aGlzO1xuICBsZXQgYXJncyA9IG5vcm1hbGl6ZUFyZ3MoYXJndW1lbnRzKTtcblxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMucmVzb2x2ZShhcmdzLnBhdGgsIGFyZ3Muc2NoZW1hLCBhcmdzLm9wdGlvbnMpO1xuICAgIF9kZXJlZmVyZW5jZShtZSwgYXJncy5vcHRpb25zKTtcbiAgICBmaW5hbGl6ZShtZSk7XG4gICAgcmV0dXJuIG1heWJlKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVzb2x2ZShtZS5zY2hlbWEpKTtcbiAgfVxuICBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG1heWJlKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVqZWN0KGVycikpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmaW5hbGl6ZSAocGFyc2VyKSB7XG4gIGNvbnN0IGVycm9ycyA9IEpTT05QYXJzZXJFcnJvckdyb3VwLmdldFBhcnNlckVycm9ycyhwYXJzZXIpO1xuICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgSlNPTlBhcnNlckVycm9yR3JvdXAocGFyc2VyKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIiRSZWZzIiwicmVxdWlyZSIsIl9wYXJzZSIsIm5vcm1hbGl6ZUFyZ3MiLCJyZXNvbHZlRXh0ZXJuYWwiLCJfYnVuZGxlIiwiX2RlcmVmZXJlbmNlIiwidXJsIiwiSlNPTlBhcnNlckVycm9yIiwiSW52YWxpZFBvaW50ZXJFcnJvciIsIk1pc3NpbmdQb2ludGVyRXJyb3IiLCJSZXNvbHZlckVycm9yIiwiUGFyc2VyRXJyb3IiLCJVbm1hdGNoZWRQYXJzZXJFcnJvciIsIlVubWF0Y2hlZFJlc29sdmVyRXJyb3IiLCJpc0hhbmRsZWRFcnJvciIsIkpTT05QYXJzZXJFcnJvckdyb3VwIiwibWF5YmUiLCJvbm8iLCJtb2R1bGUiLCJleHBvcnRzIiwiJFJlZlBhcnNlciIsImRlZmF1bHQiLCJzY2hlbWEiLCIkcmVmcyIsInBhcnNlIiwicGF0aCIsIm9wdGlvbnMiLCJjYWxsYmFjayIsIkNsYXNzIiwiaW5zdGFuY2UiLCJhcHBseSIsImFyZ3VtZW50cyIsInByb3RvdHlwZSIsImFyZ3MiLCJwcm9taXNlIiwiZXJyIiwiUHJvbWlzZSIsInJlamVjdCIsInBhdGhUeXBlIiwiaXNGaWxlU3lzdGVtUGF0aCIsImZyb21GaWxlU3lzdGVtUGF0aCIsInJlc29sdmUiLCJjd2QiLCIkcmVmIiwiX2FkZCIsInZhbHVlIiwibWUiLCJyZXN1bHQiLCJCdWZmZXIiLCJpc0J1ZmZlciIsImNvbnRpbnVlT25FcnJvciIsInN5bnRheCIsIl9yb290JFJlZiIsIl8kcmVmcyIsInN0cmlwSGFzaCIsImFkZEVycm9yIiwiZmluYWxpemUiLCJidW5kbGUiLCJkZXJlZmVyZW5jZSIsInBhcnNlciIsImVycm9ycyIsImdldFBhcnNlckVycm9ycyIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/normalize-args.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/normalize-args.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Options = __webpack_require__(/*! ./options */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/options.js\");\nmodule.exports = normalizeArgs;\n/**\n * Normalizes the given arguments, accounting for optional args.\n *\n * @param {Arguments} args\n * @returns {object}\n */ function normalizeArgs(args) {\n    let path, schema, options, callback;\n    args = Array.prototype.slice.call(args);\n    if (typeof args[args.length - 1] === \"function\") {\n        // The last parameter is a callback function\n        callback = args.pop();\n    }\n    if (typeof args[0] === \"string\") {\n        // The first parameter is the path\n        path = args[0];\n        if (typeof args[2] === \"object\") {\n            // The second parameter is the schema, and the third parameter is the options\n            schema = args[1];\n            options = args[2];\n        } else {\n            // The second parameter is the options\n            schema = undefined;\n            options = args[1];\n        }\n    } else {\n        // The first parameter is the schema\n        path = \"\";\n        schema = args[0];\n        options = args[1];\n    }\n    if (!(options instanceof Options)) {\n        options = new Options(options);\n    }\n    return {\n        path,\n        schema,\n        options,\n        callback\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL25vcm1hbGl6ZS1hcmdzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUMsMEZBQVc7QUFFbkNDLE9BQU9DLE9BQU8sR0FBR0M7QUFFakI7Ozs7O0NBS0MsR0FDRCxTQUFTQSxjQUFlQyxJQUFJO0lBQzFCLElBQUlDLE1BQU1DLFFBQVFDLFNBQVNDO0lBQzNCSixPQUFPSyxNQUFNQyxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDUjtJQUVsQyxJQUFJLE9BQU9BLElBQUksQ0FBQ0EsS0FBS1MsTUFBTSxHQUFHLEVBQUUsS0FBSyxZQUFZO1FBQy9DLDRDQUE0QztRQUM1Q0wsV0FBV0osS0FBS1UsR0FBRztJQUNyQjtJQUVBLElBQUksT0FBT1YsSUFBSSxDQUFDLEVBQUUsS0FBSyxVQUFVO1FBQy9CLGtDQUFrQztRQUNsQ0MsT0FBT0QsSUFBSSxDQUFDLEVBQUU7UUFDZCxJQUFJLE9BQU9BLElBQUksQ0FBQyxFQUFFLEtBQUssVUFBVTtZQUMvQiw2RUFBNkU7WUFDN0VFLFNBQVNGLElBQUksQ0FBQyxFQUFFO1lBQ2hCRyxVQUFVSCxJQUFJLENBQUMsRUFBRTtRQUNuQixPQUNLO1lBQ0gsc0NBQXNDO1lBQ3RDRSxTQUFTUztZQUNUUixVQUFVSCxJQUFJLENBQUMsRUFBRTtRQUNuQjtJQUNGLE9BQ0s7UUFDSCxvQ0FBb0M7UUFDcENDLE9BQU87UUFDUEMsU0FBU0YsSUFBSSxDQUFDLEVBQUU7UUFDaEJHLFVBQVVILElBQUksQ0FBQyxFQUFFO0lBQ25CO0lBRUEsSUFBSSxDQUFFRyxDQUFBQSxtQkFBbUJSLE9BQU0sR0FBSTtRQUNqQ1EsVUFBVSxJQUFJUixRQUFRUTtJQUN4QjtJQUVBLE9BQU87UUFDTEY7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvbm9ybWFsaXplLWFyZ3MuanM/YTFhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgT3B0aW9ucyA9IHJlcXVpcmUoXCIuL29wdGlvbnNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplQXJncztcblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBnaXZlbiBhcmd1bWVudHMsIGFjY291bnRpbmcgZm9yIG9wdGlvbmFsIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtBcmd1bWVudHN9IGFyZ3NcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3MgKGFyZ3MpIHtcbiAgbGV0IHBhdGgsIHNjaGVtYSwgb3B0aW9ucywgY2FsbGJhY2s7XG4gIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcblxuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gVGhlIGxhc3QgcGFyYW1ldGVyIGlzIGEgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSBwYXRoXG4gICAgcGF0aCA9IGFyZ3NbMF07XG4gICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAvLyBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0aGUgc2NoZW1hLCBhbmQgdGhlIHRoaXJkIHBhcmFtZXRlciBpcyB0aGUgb3B0aW9uc1xuICAgICAgc2NoZW1hID0gYXJnc1sxXTtcbiAgICAgIG9wdGlvbnMgPSBhcmdzWzJdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBvcHRpb25zXG4gICAgICBzY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgICBvcHRpb25zID0gYXJnc1sxXTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgc2NoZW1hXG4gICAgcGF0aCA9IFwiXCI7XG4gICAgc2NoZW1hID0gYXJnc1swXTtcbiAgICBvcHRpb25zID0gYXJnc1sxXTtcbiAgfVxuXG4gIGlmICghKG9wdGlvbnMgaW5zdGFuY2VvZiBPcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aCxcbiAgICBzY2hlbWEsXG4gICAgb3B0aW9ucyxcbiAgICBjYWxsYmFja1xuICB9O1xufVxuIl0sIm5hbWVzIjpbIk9wdGlvbnMiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsIm5vcm1hbGl6ZUFyZ3MiLCJhcmdzIiwicGF0aCIsInNjaGVtYSIsIm9wdGlvbnMiLCJjYWxsYmFjayIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwibGVuZ3RoIiwicG9wIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/normalize-args.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/options.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/options.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint lines-around-comment: [2, {beforeBlockComment: false}] */ \nconst jsonParser = __webpack_require__(/*! ./parsers/json */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/json.js\");\nconst yamlParser = __webpack_require__(/*! ./parsers/yaml */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/yaml.js\");\nconst textParser = __webpack_require__(/*! ./parsers/text */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/text.js\");\nconst binaryParser = __webpack_require__(/*! ./parsers/binary */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/binary.js\");\nconst fileResolver = __webpack_require__(/*! ./resolvers/file */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/file.js\");\nconst httpResolver = __webpack_require__(/*! ./resolvers/http */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/http.js\");\nmodule.exports = $RefParserOptions;\n/**\n * Options that determine how JSON schemas are parsed, resolved, and dereferenced.\n *\n * @param {object|$RefParserOptions} [options] - Overridden options\n * @constructor\n */ function $RefParserOptions(options) {\n    merge(this, $RefParserOptions.defaults);\n    merge(this, options);\n}\n$RefParserOptions.defaults = {\n    /**\n   * Determines how different types of files will be parsed.\n   *\n   * You can add additional parsers of your own, replace an existing one with\n   * your own implementation, or disable any parser by setting it to false.\n   */ parse: {\n        json: jsonParser,\n        yaml: yamlParser,\n        text: textParser,\n        binary: binaryParser\n    },\n    /**\n   * Determines how JSON References will be resolved.\n   *\n   * You can add additional resolvers of your own, replace an existing one with\n   * your own implementation, or disable any resolver by setting it to false.\n   */ resolve: {\n        file: fileResolver,\n        http: httpResolver,\n        /**\n     * Determines whether external $ref pointers will be resolved.\n     * If this option is disabled, then none of above resolvers will be called.\n     * Instead, external $ref pointers will simply be ignored.\n     *\n     * @type {boolean}\n     */ external: true\n    },\n    /**\n   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n   * causes it to keep processing as much as possible and then throw a single error that contains all errors\n   * that were encountered.\n  */ continueOnError: false,\n    /**\n   * Determines the types of JSON references that are allowed.\n   */ dereference: {\n        /**\n     * Dereference circular (recursive) JSON references?\n     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n     * If \"ignore\", then circular references will not be dereferenced.\n     *\n     * @type {boolean|string}\n     */ circular: true,\n        /**\n     * A function, called for each path, which can return true to stop this path and all\n     * subpaths from being dereferenced further. This is useful in schemas where some\n     * subpaths contain literal $ref keys that should not be dereferenced.\n     *\n     * @type {function}\n     */ excludedPathMatcher: ()=>false\n    }\n};\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param {object} target - The object that we're populating\n * @param {?object} source - The options that are being merged\n * @returns {object}\n */ function merge(target, source) {\n    if (isMergeable(source)) {\n        let keys = Object.keys(source);\n        for(let i = 0; i < keys.length; i++){\n            let key = keys[i];\n            let sourceSetting = source[key];\n            let targetSetting = target[key];\n            if (isMergeable(sourceSetting)) {\n                // It's a nested object, so merge it recursively\n                target[key] = merge(targetSetting || {}, sourceSetting);\n            } else if (sourceSetting !== undefined) {\n                // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n                target[key] = sourceSetting;\n            }\n        }\n    }\n    return target;\n}\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param   {*}  val\n * @returns {Boolean}\n */ function isMergeable(val) {\n    return val && typeof val === \"object\" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL29wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUVBQWlFLEdBQ3BEO0FBRWIsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUMsb0dBQWdCO0FBQzNDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLG9HQUFnQjtBQUMzQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyxvR0FBZ0I7QUFDM0MsTUFBTUcsZUFBZUgsbUJBQU9BLENBQUMsd0dBQWtCO0FBQy9DLE1BQU1JLGVBQWVKLG1CQUFPQSxDQUFDLHdHQUFrQjtBQUMvQyxNQUFNSyxlQUFlTCxtQkFBT0EsQ0FBQyx3R0FBa0I7QUFFL0NNLE9BQU9DLE9BQU8sR0FBR0M7QUFFakI7Ozs7O0NBS0MsR0FDRCxTQUFTQSxrQkFBbUJDLE9BQU87SUFDakNDLE1BQU0sSUFBSSxFQUFFRixrQkFBa0JHLFFBQVE7SUFDdENELE1BQU0sSUFBSSxFQUFFRDtBQUNkO0FBRUFELGtCQUFrQkcsUUFBUSxHQUFHO0lBQzNCOzs7OztHQUtDLEdBQ0RDLE9BQU87UUFDTEMsTUFBTWQ7UUFDTmUsTUFBTWI7UUFDTmMsTUFBTWI7UUFDTmMsUUFBUWI7SUFDVjtJQUVBOzs7OztHQUtDLEdBQ0RjLFNBQVM7UUFDUEMsTUFBTWQ7UUFDTmUsTUFBTWQ7UUFFTjs7Ozs7O0tBTUMsR0FDRGUsVUFBVTtJQUNaO0lBRUE7Ozs7RUFJQSxHQUNBQyxpQkFBaUI7SUFFakI7O0dBRUMsR0FDREMsYUFBYTtRQUNYOzs7Ozs7S0FNQyxHQUNEQyxVQUFVO1FBRVY7Ozs7OztLQU1DLEdBQ0RDLHFCQUFxQixJQUFNO0lBQzdCO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTZCxNQUFPZSxNQUFNLEVBQUVDLE1BQU07SUFDNUIsSUFBSUMsWUFBWUQsU0FBUztRQUN2QixJQUFJRSxPQUFPQyxPQUFPRCxJQUFJLENBQUNGO1FBQ3ZCLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJRixLQUFLRyxNQUFNLEVBQUVELElBQUs7WUFDcEMsSUFBSUUsTUFBTUosSUFBSSxDQUFDRSxFQUFFO1lBQ2pCLElBQUlHLGdCQUFnQlAsTUFBTSxDQUFDTSxJQUFJO1lBQy9CLElBQUlFLGdCQUFnQlQsTUFBTSxDQUFDTyxJQUFJO1lBRS9CLElBQUlMLFlBQVlNLGdCQUFnQjtnQkFDOUIsZ0RBQWdEO2dCQUNoRFIsTUFBTSxDQUFDTyxJQUFJLEdBQUd0QixNQUFNd0IsaUJBQWlCLENBQUMsR0FBR0Q7WUFDM0MsT0FDSyxJQUFJQSxrQkFBa0JFLFdBQVc7Z0JBQ3BDLGtHQUFrRztnQkFDbEdWLE1BQU0sQ0FBQ08sSUFBSSxHQUFHQztZQUNoQjtRQUNGO0lBQ0Y7SUFDQSxPQUFPUjtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0UsWUFBYVMsR0FBRztJQUN2QixPQUFPQSxPQUNKLE9BQU9BLFFBQVEsWUFDaEIsQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixRQUNmLENBQUVBLENBQUFBLGVBQWVHLE1BQUssS0FDdEIsQ0FBRUgsQ0FBQUEsZUFBZUksSUFBRztBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL25hbnRlcy1wdWJsaWMtZGF0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL29wdGlvbnMuanM/MTE4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbGluZXMtYXJvdW5kLWNvbW1lbnQ6IFsyLCB7YmVmb3JlQmxvY2tDb21tZW50OiBmYWxzZX1dICovXG5cInVzZSBzdHJpY3RcIjtcblxuY29uc3QganNvblBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvanNvblwiKTtcbmNvbnN0IHlhbWxQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL3lhbWxcIik7XG5jb25zdCB0ZXh0UGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy90ZXh0XCIpO1xuY29uc3QgYmluYXJ5UGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9iaW5hcnlcIik7XG5jb25zdCBmaWxlUmVzb2x2ZXIgPSByZXF1aXJlKFwiLi9yZXNvbHZlcnMvZmlsZVwiKTtcbmNvbnN0IGh0dHBSZXNvbHZlciA9IHJlcXVpcmUoXCIuL3Jlc29sdmVycy9odHRwXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRSZWZQYXJzZXJPcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IEpTT04gc2NoZW1hcyBhcmUgcGFyc2VkLCByZXNvbHZlZCwgYW5kIGRlcmVmZXJlbmNlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHwkUmVmUGFyc2VyT3B0aW9uc30gW29wdGlvbnNdIC0gT3ZlcnJpZGRlbiBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gJFJlZlBhcnNlck9wdGlvbnMgKG9wdGlvbnMpIHtcbiAgbWVyZ2UodGhpcywgJFJlZlBhcnNlck9wdGlvbnMuZGVmYXVsdHMpO1xuICBtZXJnZSh0aGlzLCBvcHRpb25zKTtcbn1cblxuJFJlZlBhcnNlck9wdGlvbnMuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGhvdyBkaWZmZXJlbnQgdHlwZXMgb2YgZmlsZXMgd2lsbCBiZSBwYXJzZWQuXG4gICAqXG4gICAqIFlvdSBjYW4gYWRkIGFkZGl0aW9uYWwgcGFyc2VycyBvZiB5b3VyIG93biwgcmVwbGFjZSBhbiBleGlzdGluZyBvbmUgd2l0aFxuICAgKiB5b3VyIG93biBpbXBsZW1lbnRhdGlvbiwgb3IgZGlzYWJsZSBhbnkgcGFyc2VyIGJ5IHNldHRpbmcgaXQgdG8gZmFsc2UuXG4gICAqL1xuICBwYXJzZToge1xuICAgIGpzb246IGpzb25QYXJzZXIsXG4gICAgeWFtbDogeWFtbFBhcnNlcixcbiAgICB0ZXh0OiB0ZXh0UGFyc2VyLFxuICAgIGJpbmFyeTogYmluYXJ5UGFyc2VyLFxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGhvdyBKU09OIFJlZmVyZW5jZXMgd2lsbCBiZSByZXNvbHZlZC5cbiAgICpcbiAgICogWW91IGNhbiBhZGQgYWRkaXRpb25hbCByZXNvbHZlcnMgb2YgeW91ciBvd24sIHJlcGxhY2UgYW4gZXhpc3Rpbmcgb25lIHdpdGhcbiAgICogeW91ciBvd24gaW1wbGVtZW50YXRpb24sIG9yIGRpc2FibGUgYW55IHJlc29sdmVyIGJ5IHNldHRpbmcgaXQgdG8gZmFsc2UuXG4gICAqL1xuICByZXNvbHZlOiB7XG4gICAgZmlsZTogZmlsZVJlc29sdmVyLFxuICAgIGh0dHA6IGh0dHBSZXNvbHZlcixcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBleHRlcm5hbCAkcmVmIHBvaW50ZXJzIHdpbGwgYmUgcmVzb2x2ZWQuXG4gICAgICogSWYgdGhpcyBvcHRpb24gaXMgZGlzYWJsZWQsIHRoZW4gbm9uZSBvZiBhYm92ZSByZXNvbHZlcnMgd2lsbCBiZSBjYWxsZWQuXG4gICAgICogSW5zdGVhZCwgZXh0ZXJuYWwgJHJlZiBwb2ludGVycyB3aWxsIHNpbXBseSBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZXh0ZXJuYWw6IHRydWUsXG4gIH0sXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIEpTT04gU2NoZW1hICRSZWYgUGFyc2VyIHRocm93cyB0aGUgZmlyc3QgZXJyb3IgaXQgZW5jb3VudGVycy4gU2V0dGluZyBgY29udGludWVPbkVycm9yYCB0byBgdHJ1ZWBcbiAgICogY2F1c2VzIGl0IHRvIGtlZXAgcHJvY2Vzc2luZyBhcyBtdWNoIGFzIHBvc3NpYmxlIGFuZCB0aGVuIHRocm93IGEgc2luZ2xlIGVycm9yIHRoYXQgY29udGFpbnMgYWxsIGVycm9yc1xuICAgKiB0aGF0IHdlcmUgZW5jb3VudGVyZWQuXG4gICovXG4gIGNvbnRpbnVlT25FcnJvcjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHR5cGVzIG9mIEpTT04gcmVmZXJlbmNlcyB0aGF0IGFyZSBhbGxvd2VkLlxuICAgKi9cbiAgZGVyZWZlcmVuY2U6IHtcbiAgICAvKipcbiAgICAgKiBEZXJlZmVyZW5jZSBjaXJjdWxhciAocmVjdXJzaXZlKSBKU09OIHJlZmVyZW5jZXM/XG4gICAgICogSWYgZmFsc2UsIHRoZW4gYSB7QGxpbmsgUmVmZXJlbmNlRXJyb3J9IHdpbGwgYmUgdGhyb3duIGlmIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIGZvdW5kLlxuICAgICAqIElmIFwiaWdub3JlXCIsIHRoZW4gY2lyY3VsYXIgcmVmZXJlbmNlcyB3aWxsIG5vdCBiZSBkZXJlZmVyZW5jZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnxzdHJpbmd9XG4gICAgICovXG4gICAgY2lyY3VsYXI6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uLCBjYWxsZWQgZm9yIGVhY2ggcGF0aCwgd2hpY2ggY2FuIHJldHVybiB0cnVlIHRvIHN0b3AgdGhpcyBwYXRoIGFuZCBhbGxcbiAgICAgKiBzdWJwYXRocyBmcm9tIGJlaW5nIGRlcmVmZXJlbmNlZCBmdXJ0aGVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBzY2hlbWFzIHdoZXJlIHNvbWVcbiAgICAgKiBzdWJwYXRocyBjb250YWluIGxpdGVyYWwgJHJlZiBrZXlzIHRoYXQgc2hvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgZXhjbHVkZWRQYXRoTWF0Y2hlcjogKCkgPT4gZmFsc2VcbiAgfSxcbn07XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSBvYmplY3QgdGhhdCB3ZSdyZSBwb3B1bGF0aW5nXG4gKiBAcGFyYW0gez9vYmplY3R9IHNvdXJjZSAtIFRoZSBvcHRpb25zIHRoYXQgYXJlIGJlaW5nIG1lcmdlZFxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWVyZ2UgKHRhcmdldCwgc291cmNlKSB7XG4gIGlmIChpc01lcmdlYWJsZShzb3VyY2UpKSB7XG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGtleSA9IGtleXNbaV07XG4gICAgICBsZXQgc291cmNlU2V0dGluZyA9IHNvdXJjZVtrZXldO1xuICAgICAgbGV0IHRhcmdldFNldHRpbmcgPSB0YXJnZXRba2V5XTtcblxuICAgICAgaWYgKGlzTWVyZ2VhYmxlKHNvdXJjZVNldHRpbmcpKSB7XG4gICAgICAgIC8vIEl0J3MgYSBuZXN0ZWQgb2JqZWN0LCBzbyBtZXJnZSBpdCByZWN1cnNpdmVseVxuICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFNldHRpbmcgfHwge30sIHNvdXJjZVNldHRpbmcpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlU2V0dGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEl0J3MgYSBzY2FsYXIgdmFsdWUsIGZ1bmN0aW9uLCBvciBhcnJheS4gTm8gbWVyZ2luZyBuZWNlc3NhcnkuIEp1c3Qgb3ZlcndyaXRlIHRoZSB0YXJnZXQgdmFsdWUuXG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlU2V0dGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBtZXJnZWQsXG4gKiBvciBpZiBpdCBpcyBhIHNjYWxhciB2YWx1ZSB0aGF0IHNob3VsZCBqdXN0IG92ZXJyaWRlIHRoZSB0YXJnZXQgdmFsdWUuXG4gKlxuICogQHBhcmFtICAgeyp9ICB2YWxcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01lcmdlYWJsZSAodmFsKSB7XG4gIHJldHVybiB2YWwgJiZcbiAgICAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIikgJiZcbiAgICAhQXJyYXkuaXNBcnJheSh2YWwpICYmXG4gICAgISh2YWwgaW5zdGFuY2VvZiBSZWdFeHApICYmXG4gICAgISh2YWwgaW5zdGFuY2VvZiBEYXRlKTtcbn1cbiJdLCJuYW1lcyI6WyJqc29uUGFyc2VyIiwicmVxdWlyZSIsInlhbWxQYXJzZXIiLCJ0ZXh0UGFyc2VyIiwiYmluYXJ5UGFyc2VyIiwiZmlsZVJlc29sdmVyIiwiaHR0cFJlc29sdmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsIiRSZWZQYXJzZXJPcHRpb25zIiwib3B0aW9ucyIsIm1lcmdlIiwiZGVmYXVsdHMiLCJwYXJzZSIsImpzb24iLCJ5YW1sIiwidGV4dCIsImJpbmFyeSIsInJlc29sdmUiLCJmaWxlIiwiaHR0cCIsImV4dGVybmFsIiwiY29udGludWVPbkVycm9yIiwiZGVyZWZlcmVuY2UiLCJjaXJjdWxhciIsImV4Y2x1ZGVkUGF0aE1hdGNoZXIiLCJ0YXJnZXQiLCJzb3VyY2UiLCJpc01lcmdlYWJsZSIsImtleXMiLCJPYmplY3QiLCJpIiwibGVuZ3RoIiwia2V5Iiwic291cmNlU2V0dGluZyIsInRhcmdldFNldHRpbmciLCJ1bmRlZmluZWQiLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJSZWdFeHAiLCJEYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parse.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/parse.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { ono } = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __webpack_require__(/*! ./util/url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\nconst plugins = __webpack_require__(/*! ./util/plugins */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/plugins.js\");\nconst { ResolverError, ParserError, UnmatchedParserError, UnmatchedResolverError, isHandledError } = __webpack_require__(/*! ./util/errors */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\");\nmodule.exports = parse;\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */ async function parse(path, $refs, options) {\n    // Remove the URL fragment, if any\n    path = url.stripHash(path);\n    // Add a new $Ref for this file, even though we don't have the value yet.\n    // This ensures that we don't simultaneously read & parse the same file multiple times\n    let $ref = $refs._add(path);\n    // This \"file object\" will be passed to all resolvers and parsers.\n    let file = {\n        url: path,\n        extension: url.getExtension(path)\n    };\n    // Read the file and then parse the data\n    try {\n        const resolver = await readFile(file, options, $refs);\n        $ref.pathType = resolver.plugin.name;\n        file.data = resolver.result;\n        const parser = await parseFile(file, options, $refs);\n        $ref.value = parser.result;\n        return parser.result;\n    } catch (err) {\n        if (isHandledError(err)) {\n            $ref.value = err;\n        }\n        throw err;\n    }\n}\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */ function readFile(file, options, $refs) {\n    return new Promise((resolve, reject)=>{\n        // console.log('Reading %s', file.url);\n        // Find the resolvers that can read this file\n        let resolvers = plugins.all(options.resolve);\n        resolvers = plugins.filter(resolvers, \"canRead\", file);\n        // Run the resolvers, in order, until one of them succeeds\n        plugins.sort(resolvers);\n        plugins.run(resolvers, \"read\", file, $refs).then(resolve, onError);\n        function onError(err) {\n            if (!err && options.continueOnError) {\n                // No resolver could be matched\n                reject(new UnmatchedResolverError(file.url));\n            } else if (!err || !(\"error\" in err)) {\n                // Throw a generic, friendly error.\n                reject(ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`));\n            } else if (err.error instanceof ResolverError) {\n                reject(err.error);\n            } else {\n                reject(new ResolverError(err, file.url));\n            }\n        }\n    });\n}\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */ function parseFile(file, options, $refs) {\n    return new Promise((resolve, reject)=>{\n        // console.log('Parsing %s', file.url);\n        // Find the parsers that can read this file type.\n        // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n        // This handles situations where the file IS a supported type, just with an unknown extension.\n        let allParsers = plugins.all(options.parse);\n        let filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n        let parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n        // Run the parsers, in order, until one of them succeeds\n        plugins.sort(parsers);\n        plugins.run(parsers, \"parse\", file, $refs).then(onParsed, onError);\n        function onParsed(parser) {\n            if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n                reject(ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`));\n            } else {\n                resolve(parser);\n            }\n        }\n        function onError(err) {\n            if (!err && options.continueOnError) {\n                // No resolver could be matched\n                reject(new UnmatchedParserError(file.url));\n            } else if (!err || !(\"error\" in err)) {\n                reject(ono.syntax(`Unable to parse ${file.url}`));\n            } else if (err.error instanceof ParserError) {\n                reject(err.error);\n            } else {\n                reject(new ParserError(err.error.message, file.url));\n            }\n        }\n    });\n}\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */ function isEmpty(value) {\n    return value === undefined || typeof value === \"object\" && Object.keys(value).length === 0 || typeof value === \"string\" && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsTUFBTSxFQUFFQSxHQUFHLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsMEVBQWlCO0FBQ3pDLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDLDRGQUFZO0FBQ2hDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLG9HQUFnQjtBQUN4QyxNQUFNLEVBQUVHLGFBQWEsRUFBRUMsV0FBVyxFQUFFQyxvQkFBb0IsRUFBRUMsc0JBQXNCLEVBQUVDLGNBQWMsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQyxrR0FBZTtBQUU1SFEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQjs7Ozs7Ozs7O0NBU0MsR0FDRCxlQUFlQSxNQUFPQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsT0FBTztJQUN4QyxrQ0FBa0M7SUFDbENGLE9BQU9WLElBQUlhLFNBQVMsQ0FBQ0g7SUFFckIseUVBQXlFO0lBQ3pFLHNGQUFzRjtJQUN0RixJQUFJSSxPQUFPSCxNQUFNSSxJQUFJLENBQUNMO0lBRXRCLGtFQUFrRTtJQUNsRSxJQUFJTSxPQUFPO1FBQ1RoQixLQUFLVTtRQUNMTyxXQUFXakIsSUFBSWtCLFlBQVksQ0FBQ1I7SUFDOUI7SUFFQSx3Q0FBd0M7SUFDeEMsSUFBSTtRQUNGLE1BQU1TLFdBQVcsTUFBTUMsU0FBU0osTUFBTUosU0FBU0Q7UUFDL0NHLEtBQUtPLFFBQVEsR0FBR0YsU0FBU0csTUFBTSxDQUFDQyxJQUFJO1FBQ3BDUCxLQUFLUSxJQUFJLEdBQUdMLFNBQVNNLE1BQU07UUFFM0IsTUFBTUMsU0FBUyxNQUFNQyxVQUFVWCxNQUFNSixTQUFTRDtRQUM5Q0csS0FBS2MsS0FBSyxHQUFHRixPQUFPRCxNQUFNO1FBRTFCLE9BQU9DLE9BQU9ELE1BQU07SUFDdEIsRUFDQSxPQUFPSSxLQUFLO1FBQ1YsSUFBSXZCLGVBQWV1QixNQUFNO1lBQ3ZCZixL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QixHQUFHO1lBQ3BEO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTaUQsUUFBU3JCLEtBQUs7SUFDckIsT0FBT0EsVUFBVXVCLGFBQ2QsT0FBT3ZCLFVBQVUsWUFBWXdCLE9BQU9DLElBQUksQ0FBQ3pCLE9BQU9rQixNQUFNLEtBQUssS0FDM0QsT0FBT2xCLFVBQVUsWUFBWUEsTUFBTTBCLElBQUksR0FBR1IsTUFBTSxLQUFLLEtBQ3JEUyxPQUFPQyxRQUFRLENBQUM1QixVQUFVQSxNQUFNa0IsTUFBTSxLQUFLO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvcGFyc2UuanM/MTM5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgeyBvbm8gfSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwiLi91dGlsL3VybFwiKTtcbmNvbnN0IHBsdWdpbnMgPSByZXF1aXJlKFwiLi91dGlsL3BsdWdpbnNcIik7XG5jb25zdCB7IFJlc29sdmVyRXJyb3IsIFBhcnNlckVycm9yLCBVbm1hdGNoZWRQYXJzZXJFcnJvciwgVW5tYXRjaGVkUmVzb2x2ZXJFcnJvciwgaXNIYW5kbGVkRXJyb3IgfSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG4vKipcbiAqIFJlYWRzIGFuZCBwYXJzZXMgdGhlIHNwZWNpZmllZCBmaWxlIHBhdGggb3IgVVJMLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhpcyBwYXRoIE1VU1QgYWxyZWFkeSBiZSByZXNvbHZlZCwgc2luY2UgYHJlYWRgIGRvZXNuJ3Qga25vdyB0aGUgcmVzb2x1dGlvbiBjb250ZXh0XG4gKiBAcGFyYW0geyRSZWZzfSAkcmVmc1xuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgcGFyc2VkIGZpbGUgY29udGVudHMsIE5PVCB0aGUgcmF3IChCdWZmZXIpIGNvbnRlbnRzLlxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZSAocGF0aCwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgLy8gUmVtb3ZlIHRoZSBVUkwgZnJhZ21lbnQsIGlmIGFueVxuICBwYXRoID0gdXJsLnN0cmlwSGFzaChwYXRoKTtcblxuICAvLyBBZGQgYSBuZXcgJFJlZiBmb3IgdGhpcyBmaWxlLCBldmVuIHRob3VnaCB3ZSBkb24ndCBoYXZlIHRoZSB2YWx1ZSB5ZXQuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IHNpbXVsdGFuZW91c2x5IHJlYWQgJiBwYXJzZSB0aGUgc2FtZSBmaWxlIG11bHRpcGxlIHRpbWVzXG4gIGxldCAkcmVmID0gJHJlZnMuX2FkZChwYXRoKTtcblxuICAvLyBUaGlzIFwiZmlsZSBvYmplY3RcIiB3aWxsIGJlIHBhc3NlZCB0byBhbGwgcmVzb2x2ZXJzIGFuZCBwYXJzZXJzLlxuICBsZXQgZmlsZSA9IHtcbiAgICB1cmw6IHBhdGgsXG4gICAgZXh0ZW5zaW9uOiB1cmwuZ2V0RXh0ZW5zaW9uKHBhdGgpLFxuICB9O1xuXG4gIC8vIFJlYWQgdGhlIGZpbGUgYW5kIHRoZW4gcGFyc2UgdGhlIGRhdGFcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHJlYWRGaWxlKGZpbGUsIG9wdGlvbnMsICRyZWZzKTtcbiAgICAkcmVmLnBhdGhUeXBlID0gcmVzb2x2ZXIucGx1Z2luLm5hbWU7XG4gICAgZmlsZS5kYXRhID0gcmVzb2x2ZXIucmVzdWx0O1xuXG4gICAgY29uc3QgcGFyc2VyID0gYXdhaXQgcGFyc2VGaWxlKGZpbGUsIG9wdGlvbnMsICRyZWZzKTtcbiAgICAkcmVmLnZhbHVlID0gcGFyc2VyLnJlc3VsdDtcblxuICAgIHJldHVybiBwYXJzZXIucmVzdWx0O1xuICB9XG4gIGNhdGNoIChlcnIpIHtcbiAgICBpZiAoaXNIYW5kbGVkRXJyb3IoZXJyKSkge1xuICAgICAgJHJlZi52YWx1ZSA9IGVycjtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFkcyB0aGUgZ2l2ZW4gZmlsZSwgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgcmVzb2x2ZXIgcGx1Z2luc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlICAgICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWZlcmVuY2VkIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlLnVybCAgICAgICAtIFRoZSBmdWxsIFVSTCBvZiB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZS5leHRlbnNpb24gLSBUaGUgbG93ZXJjYXNlZCBmaWxlIGV4dGVuc2lvbiAoZS5nLiBcIi50eHRcIiwgXCIuaHRtbFwiLCBldGMuKVxuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgcmF3IGZpbGUgY29udGVudHMgYW5kIHRoZSByZXNvbHZlciB0aGF0IHdhcyB1c2VkLlxuICovXG5mdW5jdGlvbiByZWFkRmlsZSAoZmlsZSwgb3B0aW9ucywgJHJlZnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ1JlYWRpbmcgJXMnLCBmaWxlLnVybCk7XG5cbiAgICAvLyBGaW5kIHRoZSByZXNvbHZlcnMgdGhhdCBjYW4gcmVhZCB0aGlzIGZpbGVcbiAgICBsZXQgcmVzb2x2ZXJzID0gcGx1Z2lucy5hbGwob3B0aW9ucy5yZXNvbHZlKTtcbiAgICByZXNvbHZlcnMgPSBwbHVnaW5zLmZpbHRlcihyZXNvbHZlcnMsIFwiY2FuUmVhZFwiLCBmaWxlKTtcblxuICAgIC8vIFJ1biB0aGUgcmVzb2x2ZXJzLCBpbiBvcmRlciwgdW50aWwgb25lIG9mIHRoZW0gc3VjY2VlZHNcbiAgICBwbHVnaW5zLnNvcnQocmVzb2x2ZXJzKTtcbiAgICBwbHVnaW5zLnJ1bihyZXNvbHZlcnMsIFwicmVhZFwiLCBmaWxlLCAkcmVmcylcbiAgICAgIC50aGVuKHJlc29sdmUsIG9uRXJyb3IpO1xuXG4gICAgZnVuY3Rpb24gb25FcnJvciAoZXJyKSB7XG4gICAgICBpZiAoIWVyciAmJiBvcHRpb25zLmNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICAvLyBObyByZXNvbHZlciBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgIHJlamVjdChuZXcgVW5tYXRjaGVkUmVzb2x2ZXJFcnJvcihmaWxlLnVybCkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWVyciB8fCAhKFwiZXJyb3JcIiBpbiBlcnIpKSB7XG4gICAgICAgIC8vIFRocm93IGEgZ2VuZXJpYywgZnJpZW5kbHkgZXJyb3IuXG4gICAgICAgIHJlamVjdChvbm8uc3ludGF4KGBVbmFibGUgdG8gcmVzb2x2ZSAkcmVmIHBvaW50ZXIgXCIke2ZpbGUudXJsfVwiYCkpO1xuICAgICAgfVxuICAgICAgLy8gVGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yLCBpZiBpdCdzIG9uZSBvZiBvdXIgb3duICh1c2VyLWZyaWVuZGx5KSBlcnJvcnMuXG4gICAgICBlbHNlIGlmIChlcnIuZXJyb3IgaW5zdGFuY2VvZiBSZXNvbHZlckVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnIuZXJyb3IpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgUmVzb2x2ZXJFcnJvcihlcnIsIGZpbGUudXJsKSk7XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBmaWxlJ3MgY29udGVudHMsIHVzaW5nIHRoZSBjb25maWd1cmVkIHBhcnNlciBwbHVnaW5zLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlICAgICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWZlcmVuY2VkIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlLnVybCAgICAgICAtIFRoZSBmdWxsIFVSTCBvZiB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZS5leHRlbnNpb24gLSBUaGUgbG93ZXJjYXNlZCBmaWxlIGV4dGVuc2lvbiAoZS5nLiBcIi50eHRcIiwgXCIuaHRtbFwiLCBldGMuKVxuICogQHBhcmFtIHsqfSAgICAgIGZpbGUuZGF0YSAgICAgIC0gVGhlIGZpbGUgY29udGVudHMuIFRoaXMgd2lsbCBiZSB3aGF0ZXZlciBkYXRhIHR5cGUgd2FzIHJldHVybmVkIGJ5IHRoZSByZXNvbHZlclxuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgcGFyc2VkIGZpbGUgY29udGVudHMgYW5kIHRoZSBwYXJzZXIgdGhhdCB3YXMgdXNlZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VGaWxlIChmaWxlLCBvcHRpb25zLCAkcmVmcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFyc2luZyAlcycsIGZpbGUudXJsKTtcblxuICAgIC8vIEZpbmQgdGhlIHBhcnNlcnMgdGhhdCBjYW4gcmVhZCB0aGlzIGZpbGUgdHlwZS5cbiAgICAvLyBJZiBub25lIG9mIHRoZSBwYXJzZXJzIGFyZSBhbiBleGFjdCBtYXRjaCBmb3IgdGhpcyBmaWxlLCB0aGVuIHdlJ2xsIHRyeSBBTEwgb2YgdGhlbS5cbiAgICAvLyBUaGlzIGhhbmRsZXMgc2l0dWF0aW9ucyB3aGVyZSB0aGUgZmlsZSBJUyBhIHN1cHBvcnRlZCB0eXBlLCBqdXN0IHdpdGggYW4gdW5rbm93biBleHRlbnNpb24uXG4gICAgbGV0IGFsbFBhcnNlcnMgPSBwbHVnaW5zLmFsbChvcHRpb25zLnBhcnNlKTtcbiAgICBsZXQgZmlsdGVyZWRQYXJzZXJzID0gcGx1Z2lucy5maWx0ZXIoYWxsUGFyc2VycywgXCJjYW5QYXJzZVwiLCBmaWxlKTtcbiAgICBsZXQgcGFyc2VycyA9IGZpbHRlcmVkUGFyc2Vycy5sZW5ndGggPiAwID8gZmlsdGVyZWRQYXJzZXJzIDogYWxsUGFyc2VycztcblxuICAgIC8vIFJ1biB0aGUgcGFyc2VycywgaW4gb3JkZXIsIHVudGlsIG9uZSBvZiB0aGVtIHN1Y2NlZWRzXG4gICAgcGx1Z2lucy5zb3J0KHBhcnNlcnMpO1xuICAgIHBsdWdpbnMucnVuKHBhcnNlcnMsIFwicGFyc2VcIiwgZmlsZSwgJHJlZnMpXG4gICAgICAudGhlbihvblBhcnNlZCwgb25FcnJvcik7XG5cbiAgICBmdW5jdGlvbiBvblBhcnNlZCAocGFyc2VyKSB7XG4gICAgICBpZiAoIXBhcnNlci5wbHVnaW4uYWxsb3dFbXB0eSAmJiBpc0VtcHR5KHBhcnNlci5yZXN1bHQpKSB7XG4gICAgICAgIHJlamVjdChvbm8uc3ludGF4KGBFcnJvciBwYXJzaW5nIFwiJHtmaWxlLnVybH1cIiBhcyAke3BhcnNlci5wbHVnaW4ubmFtZX0uIFxcblBhcnNlZCB2YWx1ZSBpcyBlbXB0eWApKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXNvbHZlKHBhcnNlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvciAoZXJyKSB7XG4gICAgICBpZiAoIWVyciAmJiBvcHRpb25zLmNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICAvLyBObyByZXNvbHZlciBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgIHJlamVjdChuZXcgVW5tYXRjaGVkUGFyc2VyRXJyb3IoZmlsZS51cmwpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFlcnIgfHwgIShcImVycm9yXCIgaW4gZXJyKSkge1xuICAgICAgICByZWplY3Qob25vLnN5bnRheChgVW5hYmxlIHRvIHBhcnNlICR7ZmlsZS51cmx9YCkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXJyLmVycm9yIGluc3RhbmNlb2YgUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVyci5lcnJvcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBQYXJzZXJFcnJvcihlcnIuZXJyb3IubWVzc2FnZSwgZmlsZS51cmwpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhcnNlZCB2YWx1ZSBpcyBcImVtcHR5XCIuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkgKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwKSB8fFxuICAgICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApO1xufVxuIl0sIm5hbWVzIjpbIm9ubyIsInJlcXVpcmUiLCJ1cmwiLCJwbHVnaW5zIiwiUmVzb2x2ZXJFcnJvciIsIlBhcnNlckVycm9yIiwiVW5tYXRjaGVkUGFyc2VyRXJyb3IiLCJVbm1hdGNoZWRSZXNvbHZlckVycm9yIiwiaXNIYW5kbGVkRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2UiLCJwYXRoIiwiJHJlZnMiLCJvcHRpb25zIiwic3RyaXBIYXNoIiwiJHJlZiIsIl9hZGQiLCJmaWxlIiwiZXh0ZW5zaW9uIiwiZ2V0RXh0ZW5zaW9uIiwicmVzb2x2ZXIiLCJyZWFkRmlsZSIsInBhdGhUeXBlIiwicGx1Z2luIiwibmFtZSIsImRhdGEiLCJyZXN1bHQiLCJwYXJzZXIiLCJwYXJzZUZpbGUiLCJ2YWx1ZSIsImVyciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzb2x2ZXJzIiwiYWxsIiwiZmlsdGVyIiwic29ydCIsInJ1biIsInRoZW4iLCJvbkVycm9yIiwiY29udGludWVPbkVycm9yIiwic3ludGF4IiwiZXJyb3IiLCJhbGxQYXJzZXJzIiwiZmlsdGVyZWRQYXJzZXJzIiwicGFyc2VycyIsImxlbmd0aCIsIm9uUGFyc2VkIiwiYWxsb3dFbXB0eSIsImlzRW1wdHkiLCJtZXNzYWdlIiwidW5kZWZpbmVkIiwiT2JqZWN0Iiwia2V5cyIsInRyaW0iLCJCdWZmZXIiLCJpc0J1ZmZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/binary.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/binary.js ***!
  \********************************************************************************/
/***/ ((module) => {

eval("\nlet BINARY_REGEXP = /\\.(jpeg|jpg|gif|png|bmp|ico)$/i;\nmodule.exports = {\n    /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */ order: 400,\n    /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */ allowEmpty: true,\n    /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */ canParse (file) {\n        // Use this parser if the file is a Buffer, and has a known binary extension\n        return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);\n    },\n    /**\n   * Parses the given data as a Buffer (byte array).\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Buffer}\n   */ parse (file) {\n        if (Buffer.isBuffer(file.data)) {\n            return file.data;\n        } else {\n            // This will reject if data is anything other than a string or typed array\n            return Buffer.from(file.data);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3BhcnNlcnMvYmluYXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsZ0JBQWdCO0FBRXBCQyxPQUFPQyxPQUFPLEdBQUc7SUFDZjs7OztHQUlDLEdBQ0RDLE9BQU87SUFFUDs7OztHQUlDLEdBQ0RDLFlBQVk7SUFFWjs7Ozs7Ozs7Ozs7R0FXQyxHQUNEQyxVQUFVQyxJQUFJO1FBQ1osNEVBQTRFO1FBQzVFLE9BQU9DLE9BQU9DLFFBQVEsQ0FBQ0YsS0FBS0csSUFBSSxLQUFLVCxjQUFjVSxJQUFJLENBQUNKLEtBQUtLLEdBQUc7SUFDbEU7SUFFQTs7Ozs7Ozs7R0FRQyxHQUNEQyxPQUFPTixJQUFJO1FBQ1QsSUFBSUMsT0FBT0MsUUFBUSxDQUFDRixLQUFLRyxJQUFJLEdBQUc7WUFDOUIsT0FBT0gsS0FBS0csSUFBSTtRQUNsQixPQUNLO1lBQ0gsMEVBQTBFO1lBQzFFLE9BQU9GLE9BQU9NLElBQUksQ0FBQ1AsS0FBS0csSUFBSTtRQUM5QjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2xpYi9wYXJzZXJzL2JpbmFyeS5qcz9lNzc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5sZXQgQklOQVJZX1JFR0VYUCA9IC9cXC4oanBlZ3xqcGd8Z2lmfHBuZ3xibXB8aWNvKSQvaTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBUaGUgb3JkZXIgdGhhdCB0aGlzIHBhcnNlciB3aWxsIHJ1biwgaW4gcmVsYXRpb24gdG8gb3RoZXIgcGFyc2Vycy5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG9yZGVyOiA0MDAsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYWxsb3cgXCJlbXB0eVwiIGZpbGVzICh6ZXJvIGJ5dGVzKS5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBhbGxvd0VtcHR5OiB0cnVlLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBwYXJzZXIgY2FuIHBhcnNlIGEgZ2l2ZW4gZmlsZSByZWZlcmVuY2UuXG4gICAqIFBhcnNlcnMgdGhhdCByZXR1cm4gdHJ1ZSB3aWxsIGJlIHRyaWVkLCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSBwYXJzZXMgdGhlIGZpbGUuXG4gICAqIFBhcnNlcnMgdGhhdCByZXR1cm4gZmFsc2Ugd2lsbCBiZSBza2lwcGVkLCBVTkxFU1MgYWxsIHBhcnNlcnMgcmV0dXJuZWQgZmFsc2UsIGluIHdoaWNoIGNhc2VcbiAgICogZXZlcnkgcGFyc2VyIHdpbGwgYmUgdHJpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlICAgICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUuZXh0ZW5zaW9uIC0gVGhlIGxvd2VyY2FzZWQgZmlsZSBleHRlbnNpb24gKGUuZy4gXCIudHh0XCIsIFwiLmh0bWxcIiwgZXRjLilcbiAgICogQHBhcmFtIHsqfSAgICAgIGZpbGUuZGF0YSAgICAgIC0gVGhlIGZpbGUgY29udGVudHMuIFRoaXMgd2lsbCBiZSB3aGF0ZXZlciBkYXRhIHR5cGUgd2FzIHJldHVybmVkIGJ5IHRoZSByZXNvbHZlclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNhblBhcnNlIChmaWxlKSB7XG4gICAgLy8gVXNlIHRoaXMgcGFyc2VyIGlmIHRoZSBmaWxlIGlzIGEgQnVmZmVyLCBhbmQgaGFzIGEga25vd24gYmluYXJ5IGV4dGVuc2lvblxuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZmlsZS5kYXRhKSAmJiBCSU5BUllfUkVHRVhQLnRlc3QoZmlsZS51cmwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIGRhdGEgYXMgYSBCdWZmZXIgKGJ5dGUgYXJyYXkpLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZmlsZSAgICAgICAgICAgLSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlLnVybCAgICAgICAtIFRoZSBmdWxsIFVSTCBvZiB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlLmV4dGVuc2lvbiAtIFRoZSBsb3dlcmNhc2VkIGZpbGUgZXh0ZW5zaW9uIChlLmcuIFwiLnR4dFwiLCBcIi5odG1sXCIsIGV0Yy4pXG4gICAqIEBwYXJhbSB7Kn0gICAgICBmaWxlLmRhdGEgICAgICAtIFRoZSBmaWxlIGNvbnRlbnRzLiBUaGlzIHdpbGwgYmUgd2hhdGV2ZXIgZGF0YSB0eXBlIHdhcyByZXR1cm5lZCBieSB0aGUgcmVzb2x2ZXJcbiAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICovXG4gIHBhcnNlIChmaWxlKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihmaWxlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZmlsZS5kYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZWplY3QgaWYgZGF0YSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGEgc3RyaW5nIG9yIHR5cGVkIGFycmF5XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oZmlsZS5kYXRhKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOlsiQklOQVJZX1JFR0VYUCIsIm1vZHVsZSIsImV4cG9ydHMiLCJvcmRlciIsImFsbG93RW1wdHkiLCJjYW5QYXJzZSIsImZpbGUiLCJCdWZmZXIiLCJpc0J1ZmZlciIsImRhdGEiLCJ0ZXN0IiwidXJsIiwicGFyc2UiLCJmcm9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/binary.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/json.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/json.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { ParserError } = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\");\nmodule.exports = {\n    /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */ order: 100,\n    /**\n   * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n   *\n   * @type {boolean}\n   */ allowEmpty: true,\n    /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that match will be tried, in order, until one successfully parses the file.\n   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n   * every parser will be tried.\n   *\n   * @type {RegExp|string|string[]|function}\n   */ canParse: \".json\",\n    /**\n   * Parses the given file as JSON\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise}\n   */ async parse (file) {\n        let data = file.data;\n        if (Buffer.isBuffer(data)) {\n            data = data.toString();\n        }\n        if (typeof data === \"string\") {\n            if (data.trim().length === 0) {\n                return; // This mirrors the YAML behavior\n            } else {\n                try {\n                    return JSON.parse(data);\n                } catch (e) {\n                    throw new ParserError(e.message, file.url);\n                }\n            }\n        } else {\n            // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n            return data;\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3BhcnNlcnMvanNvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLE1BQU0sRUFBRUEsV0FBVyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLG1HQUFnQjtBQUVoREMsT0FBT0MsT0FBTyxHQUFHO0lBQ2Y7Ozs7R0FJQyxHQUNEQyxPQUFPO0lBRVA7Ozs7R0FJQyxHQUNEQyxZQUFZO0lBRVo7Ozs7Ozs7R0FPQyxHQUNEQyxVQUFVO0lBRVY7Ozs7Ozs7O0dBUUMsR0FDRCxNQUFNQyxPQUFPQyxJQUFJO1FBQ2YsSUFBSUMsT0FBT0QsS0FBS0MsSUFBSTtRQUNwQixJQUFJQyxPQUFPQyxRQUFRLENBQUNGLE9BQU87WUFDekJBLE9BQU9BLEtBQUtHLFFBQVE7UUFDdEI7UUFFQSxJQUFJLE9BQU9ILFNBQVMsVUFBVTtZQUM1QixJQUFJQSxLQUFLSSxJQUFJLEdBQUdDLE1BQU0sS0FBSyxHQUFHO2dCQUM1QixRQUFRLGlDQUFpQztZQUMzQyxPQUNLO2dCQUNILElBQUk7b0JBQ0YsT0FBT0MsS0FBS1IsS0FBSyxDQUFDRTtnQkFDcEIsRUFDQSxPQUFPTyxHQUFHO29CQUNSLE1BQU0sSUFBSWhCLFlBQVlnQixFQUFFQyxPQUFPLEVBQUVULEtBQUtVLEdBQUc7Z0JBQzNDO1lBQ0Y7UUFDRixPQUNLO1lBQ0gsOEVBQThFO1lBQzlFLE9BQU9UO1FBQ1Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvcGFyc2Vycy9qc29uLmpzPzRiOWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHsgUGFyc2VyRXJyb3IgfSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9yc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBUaGUgb3JkZXIgdGhhdCB0aGlzIHBhcnNlciB3aWxsIHJ1biwgaW4gcmVsYXRpb24gdG8gb3RoZXIgcGFyc2Vycy5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG9yZGVyOiAxMDAsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYWxsb3cgXCJlbXB0eVwiIGZpbGVzLiBUaGlzIGluY2x1ZGVzIHplcm8tYnl0ZSBmaWxlcywgYXMgd2VsbCBhcyBlbXB0eSBKU09OIG9iamVjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgYWxsb3dFbXB0eTogdHJ1ZSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgcGFyc2VyIGNhbiBwYXJzZSBhIGdpdmVuIGZpbGUgcmVmZXJlbmNlLlxuICAgKiBQYXJzZXJzIHRoYXQgbWF0Y2ggd2lsbCBiZSB0cmllZCwgaW4gb3JkZXIsIHVudGlsIG9uZSBzdWNjZXNzZnVsbHkgcGFyc2VzIHRoZSBmaWxlLlxuICAgKiBQYXJzZXJzIHRoYXQgZG9uJ3QgbWF0Y2ggd2lsbCBiZSBza2lwcGVkLCBVTkxFU1Mgbm9uZSBvZiB0aGUgcGFyc2VycyBtYXRjaCwgaW4gd2hpY2ggY2FzZVxuICAgKiBldmVyeSBwYXJzZXIgd2lsbCBiZSB0cmllZC5cbiAgICpcbiAgICogQHR5cGUge1JlZ0V4cHxzdHJpbmd8c3RyaW5nW118ZnVuY3Rpb259XG4gICAqL1xuICBjYW5QYXJzZTogXCIuanNvblwiLFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIGZpbGUgYXMgSlNPTlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZmlsZSAgICAgICAgICAgLSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlLnVybCAgICAgICAtIFRoZSBmdWxsIFVSTCBvZiB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlLmV4dGVuc2lvbiAtIFRoZSBsb3dlcmNhc2VkIGZpbGUgZXh0ZW5zaW9uIChlLmcuIFwiLnR4dFwiLCBcIi5odG1sXCIsIGV0Yy4pXG4gICAqIEBwYXJhbSB7Kn0gICAgICBmaWxlLmRhdGEgICAgICAtIFRoZSBmaWxlIGNvbnRlbnRzLiBUaGlzIHdpbGwgYmUgd2hhdGV2ZXIgZGF0YSB0eXBlIHdhcyByZXR1cm5lZCBieSB0aGUgcmVzb2x2ZXJcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBwYXJzZSAoZmlsZSkgeyAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1hd2FpdFxuICAgIGxldCBkYXRhID0gZmlsZS5kYXRhO1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoZGF0YS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjsgLy8gVGhpcyBtaXJyb3JzIHRoZSBZQU1MIGJlaGF2aW9yXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihlLm1lc3NhZ2UsIGZpbGUudXJsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGRhdGEgaXMgYWxyZWFkeSBhIEphdmFTY3JpcHQgdmFsdWUgKG9iamVjdCwgYXJyYXksIG51bWJlciwgbnVsbCwgTmFOLCBldGMuKVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbIlBhcnNlckVycm9yIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJvcmRlciIsImFsbG93RW1wdHkiLCJjYW5QYXJzZSIsInBhcnNlIiwiZmlsZSIsImRhdGEiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInRvU3RyaW5nIiwidHJpbSIsImxlbmd0aCIsIkpTT04iLCJlIiwibWVzc2FnZSIsInVybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/text.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/text.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { ParserError } = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\");\nlet TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\nmodule.exports = {\n    /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */ order: 300,\n    /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */ allowEmpty: true,\n    /**\n   * The encoding that the text is expected to be in.\n   *\n   * @type {string}\n   */ encoding: \"utf8\",\n    /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */ canParse (file) {\n        // Use this parser if the file is a string or Buffer, and has a known text-based extension\n        return (typeof file.data === \"string\" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n    },\n    /**\n   * Parses the given file as text\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {string}\n   */ parse (file) {\n        if (typeof file.data === \"string\") {\n            return file.data;\n        } else if (Buffer.isBuffer(file.data)) {\n            return file.data.toString(this.encoding);\n        } else {\n            throw new ParserError(\"data is not text\", file.url);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3BhcnNlcnMvdGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLE1BQU0sRUFBRUEsV0FBVyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLG1HQUFnQjtBQUVoRCxJQUFJQyxjQUFjO0FBRWxCQyxPQUFPQyxPQUFPLEdBQUc7SUFDZjs7OztHQUlDLEdBQ0RDLE9BQU87SUFFUDs7OztHQUlDLEdBQ0RDLFlBQVk7SUFFWjs7OztHQUlDLEdBQ0RDLFVBQVU7SUFFVjs7Ozs7Ozs7Ozs7R0FXQyxHQUNEQyxVQUFVQyxJQUFJO1FBQ1osMEZBQTBGO1FBQzFGLE9BQU8sQ0FBQyxPQUFPQSxLQUFLQyxJQUFJLEtBQUssWUFBWUMsT0FBT0MsUUFBUSxDQUFDSCxLQUFLQyxJQUFJLE1BQU1SLFlBQVlXLElBQUksQ0FBQ0osS0FBS0ssR0FBRztJQUNuRztJQUVBOzs7Ozs7OztHQVFDLEdBQ0RDLE9BQU9OLElBQUk7UUFDVCxJQUFJLE9BQU9BLEtBQUtDLElBQUksS0FBSyxVQUFVO1lBQ2pDLE9BQU9ELEtBQUtDLElBQUk7UUFDbEIsT0FDSyxJQUFJQyxPQUFPQyxRQUFRLENBQUNILEtBQUtDLElBQUksR0FBRztZQUNuQyxPQUFPRCxLQUFLQyxJQUFJLENBQUNNLFFBQVEsQ0FBQyxJQUFJLENBQUNULFFBQVE7UUFDekMsT0FDSztZQUNILE1BQU0sSUFBSVAsWUFBWSxvQkFBb0JTLEtBQUtLLEdBQUc7UUFDcEQ7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvcGFyc2Vycy90ZXh0LmpzP2QxMTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHsgUGFyc2VyRXJyb3IgfSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9yc1wiKTtcblxubGV0IFRFWFRfUkVHRVhQID0gL1xcLih0eHR8aHRtfGh0bWx8bWR8eG1sfGpzfG1pbnxtYXB8Y3NzfHNjc3N8bGVzc3xzdmcpJC9pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIFRoZSBvcmRlciB0aGF0IHRoaXMgcGFyc2VyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciBwYXJzZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgb3JkZXI6IDMwMCxcblxuICAvKipcbiAgICogV2hldGhlciB0byBhbGxvdyBcImVtcHR5XCIgZmlsZXMgKHplcm8gYnl0ZXMpLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGFsbG93RW1wdHk6IHRydWUsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyB0aGF0IHRoZSB0ZXh0IGlzIGV4cGVjdGVkIHRvIGJlIGluLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZW5jb2Rpbmc6IFwidXRmOFwiLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBwYXJzZXIgY2FuIHBhcnNlIGEgZ2l2ZW4gZmlsZSByZWZlcmVuY2UuXG4gICAqIFBhcnNlcnMgdGhhdCByZXR1cm4gdHJ1ZSB3aWxsIGJlIHRyaWVkLCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSBwYXJzZXMgdGhlIGZpbGUuXG4gICAqIFBhcnNlcnMgdGhhdCByZXR1cm4gZmFsc2Ugd2lsbCBiZSBza2lwcGVkLCBVTkxFU1MgYWxsIHBhcnNlcnMgcmV0dXJuZWQgZmFsc2UsIGluIHdoaWNoIGNhc2VcbiAgICogZXZlcnkgcGFyc2VyIHdpbGwgYmUgdHJpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlICAgICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUuZXh0ZW5zaW9uIC0gVGhlIGxvd2VyY2FzZWQgZmlsZSBleHRlbnNpb24gKGUuZy4gXCIudHh0XCIsIFwiLmh0bWxcIiwgZXRjLilcbiAgICogQHBhcmFtIHsqfSAgICAgIGZpbGUuZGF0YSAgICAgIC0gVGhlIGZpbGUgY29udGVudHMuIFRoaXMgd2lsbCBiZSB3aGF0ZXZlciBkYXRhIHR5cGUgd2FzIHJldHVybmVkIGJ5IHRoZSByZXNvbHZlclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNhblBhcnNlIChmaWxlKSB7XG4gICAgLy8gVXNlIHRoaXMgcGFyc2VyIGlmIHRoZSBmaWxlIGlzIGEgc3RyaW5nIG9yIEJ1ZmZlciwgYW5kIGhhcyBhIGtub3duIHRleHQtYmFzZWQgZXh0ZW5zaW9uXG4gICAgcmV0dXJuICh0eXBlb2YgZmlsZS5kYXRhID09PSBcInN0cmluZ1wiIHx8IEJ1ZmZlci5pc0J1ZmZlcihmaWxlLmRhdGEpKSAmJiBURVhUX1JFR0VYUC50ZXN0KGZpbGUudXJsKTtcbiAgfSxcblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBmaWxlIGFzIHRleHRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGZpbGUgICAgICAgICAgIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZS51cmwgICAgICAgLSBUaGUgZnVsbCBVUkwgb2YgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZS5leHRlbnNpb24gLSBUaGUgbG93ZXJjYXNlZCBmaWxlIGV4dGVuc2lvbiAoZS5nLiBcIi50eHRcIiwgXCIuaHRtbFwiLCBldGMuKVxuICAgKiBAcGFyYW0geyp9ICAgICAgZmlsZS5kYXRhICAgICAgLSBUaGUgZmlsZSBjb250ZW50cy4gVGhpcyB3aWxsIGJlIHdoYXRldmVyIGRhdGEgdHlwZSB3YXMgcmV0dXJuZWQgYnkgdGhlIHJlc29sdmVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBwYXJzZSAoZmlsZSkge1xuICAgIGlmICh0eXBlb2YgZmlsZS5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmlsZS5kYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoZmlsZS5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZpbGUuZGF0YS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXCJkYXRhIGlzIG5vdCB0ZXh0XCIsIGZpbGUudXJsKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOlsiUGFyc2VyRXJyb3IiLCJyZXF1aXJlIiwiVEVYVF9SRUdFWFAiLCJtb2R1bGUiLCJleHBvcnRzIiwib3JkZXIiLCJhbGxvd0VtcHR5IiwiZW5jb2RpbmciLCJjYW5QYXJzZSIsImZpbGUiLCJkYXRhIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJ0ZXN0IiwidXJsIiwicGFyc2UiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/text.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/yaml.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/yaml.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { ParserError } = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\");\nconst yaml = __webpack_require__(/*! js-yaml */ \"(rsc)/./node_modules/js-yaml/index.js\");\nconst { JSON_SCHEMA } = __webpack_require__(/*! js-yaml */ \"(rsc)/./node_modules/js-yaml/index.js\");\nmodule.exports = {\n    /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */ order: 200,\n    /**\n   * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n   *\n   * @type {boolean}\n   */ allowEmpty: true,\n    /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that match will be tried, in order, until one successfully parses the file.\n   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n   * every parser will be tried.\n   *\n   * @type {RegExp|string[]|function}\n   */ canParse: [\n        \".yaml\",\n        \".yml\",\n        \".json\"\n    ],\n    /**\n   * Parses the given file as YAML\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise}\n   */ async parse (file) {\n        let data = file.data;\n        if (Buffer.isBuffer(data)) {\n            data = data.toString();\n        }\n        if (typeof data === \"string\") {\n            try {\n                return yaml.load(data, {\n                    schema: JSON_SCHEMA\n                });\n            } catch (e) {\n                throw new ParserError(e.message, file.url);\n            }\n        } else {\n            // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n            return data;\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3BhcnNlcnMveWFtbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLE1BQU0sRUFBRUEsV0FBVyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLG1HQUFnQjtBQUNoRCxNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQyxzREFBUztBQUM5QixNQUFNLEVBQUVFLFdBQVcsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQyxzREFBUztBQUV6Q0csT0FBT0MsT0FBTyxHQUFHO0lBQ2Y7Ozs7R0FJQyxHQUNEQyxPQUFPO0lBRVA7Ozs7R0FJQyxHQUNEQyxZQUFZO0lBRVo7Ozs7Ozs7R0FPQyxHQUNEQyxVQUFVO1FBQUM7UUFBUztRQUFRO0tBQVE7SUFFcEM7Ozs7Ozs7O0dBUUMsR0FDRCxNQUFNQyxPQUFPQyxJQUFJO1FBQ2YsSUFBSUMsT0FBT0QsS0FBS0MsSUFBSTtRQUNwQixJQUFJQyxPQUFPQyxRQUFRLENBQUNGLE9BQU87WUFDekJBLE9BQU9BLEtBQUtHLFFBQVE7UUFDdEI7UUFFQSxJQUFJLE9BQU9ILFNBQVMsVUFBVTtZQUM1QixJQUFJO2dCQUNGLE9BQU9ULEtBQUthLElBQUksQ0FBQ0osTUFBTTtvQkFBRUssUUFBUWI7Z0JBQVk7WUFDL0MsRUFDQSxPQUFPYyxHQUFHO2dCQUNSLE1BQU0sSUFBSWpCLFlBQVlpQixFQUFFQyxPQUFPLEVBQUVSLEtBQUtTLEdBQUc7WUFDM0M7UUFDRixPQUNLO1lBQ0gsOEVBQThFO1lBQzlFLE9BQU9SO1FBQ1Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvcGFyc2Vycy95YW1sLmpzP2JhNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHsgUGFyc2VyRXJyb3IgfSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9yc1wiKTtcbmNvbnN0IHlhbWwgPSByZXF1aXJlKFwianMteWFtbFwiKTtcbmNvbnN0IHsgSlNPTl9TQ0hFTUEgfSA9IHJlcXVpcmUoXCJqcy15YW1sXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIFRoZSBvcmRlciB0aGF0IHRoaXMgcGFyc2VyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciBwYXJzZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgb3JkZXI6IDIwMCxcblxuICAvKipcbiAgICogV2hldGhlciB0byBhbGxvdyBcImVtcHR5XCIgZmlsZXMuIFRoaXMgaW5jbHVkZXMgemVyby1ieXRlIGZpbGVzLCBhcyB3ZWxsIGFzIGVtcHR5IEpTT04gb2JqZWN0cy5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBhbGxvd0VtcHR5OiB0cnVlLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBwYXJzZXIgY2FuIHBhcnNlIGEgZ2l2ZW4gZmlsZSByZWZlcmVuY2UuXG4gICAqIFBhcnNlcnMgdGhhdCBtYXRjaCB3aWxsIGJlIHRyaWVkLCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSBwYXJzZXMgdGhlIGZpbGUuXG4gICAqIFBhcnNlcnMgdGhhdCBkb24ndCBtYXRjaCB3aWxsIGJlIHNraXBwZWQsIFVOTEVTUyBub25lIG9mIHRoZSBwYXJzZXJzIG1hdGNoLCBpbiB3aGljaCBjYXNlXG4gICAqIGV2ZXJ5IHBhcnNlciB3aWxsIGJlIHRyaWVkLlxuICAgKlxuICAgKiBAdHlwZSB7UmVnRXhwfHN0cmluZ1tdfGZ1bmN0aW9ufVxuICAgKi9cbiAgY2FuUGFyc2U6IFtcIi55YW1sXCIsIFwiLnltbFwiLCBcIi5qc29uXCJdLCAgLy8gSlNPTiBpcyB2YWxpZCBZQU1MXG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gZmlsZSBhcyBZQU1MXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlICAgICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUuZXh0ZW5zaW9uIC0gVGhlIGxvd2VyY2FzZWQgZmlsZSBleHRlbnNpb24gKGUuZy4gXCIudHh0XCIsIFwiLmh0bWxcIiwgZXRjLilcbiAgICogQHBhcmFtIHsqfSAgICAgIGZpbGUuZGF0YSAgICAgIC0gVGhlIGZpbGUgY29udGVudHMuIFRoaXMgd2lsbCBiZSB3aGF0ZXZlciBkYXRhIHR5cGUgd2FzIHJldHVybmVkIGJ5IHRoZSByZXNvbHZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHBhcnNlIChmaWxlKSB7ICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWF3YWl0XG4gICAgbGV0IGRhdGEgPSBmaWxlLmRhdGE7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB5YW1sLmxvYWQoZGF0YSwgeyBzY2hlbWE6IEpTT05fU0NIRU1BIH0pO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKGUubWVzc2FnZSwgZmlsZS51cmwpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGRhdGEgaXMgYWxyZWFkeSBhIEphdmFTY3JpcHQgdmFsdWUgKG9iamVjdCwgYXJyYXksIG51bWJlciwgbnVsbCwgTmFOLCBldGMuKVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbIlBhcnNlckVycm9yIiwicmVxdWlyZSIsInlhbWwiLCJKU09OX1NDSEVNQSIsIm1vZHVsZSIsImV4cG9ydHMiLCJvcmRlciIsImFsbG93RW1wdHkiLCJjYW5QYXJzZSIsInBhcnNlIiwiZmlsZSIsImRhdGEiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInRvU3RyaW5nIiwibG9hZCIsInNjaGVtYSIsImUiLCJtZXNzYWdlIiwidXJsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/yaml.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/pointer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/pointer.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Pointer;\nconst $Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js\");\nconst url = __webpack_require__(/*! ./util/url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\nconst { JSONParserError, InvalidPointerError, MissingPointerError, isHandledError } = __webpack_require__(/*! ./util/errors */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\");\nconst slashes = /\\//g;\nconst tildes = /~/g;\nconst escapedSlash = /~1/g;\nconst escapedTilde = /~0/g;\n/**\n * This class represents a single JSON pointer and its resolved value.\n *\n * @param {$Ref} $ref\n * @param {string} path\n * @param {string} [friendlyPath] - The original user-specified path (used for error messages)\n * @constructor\n */ function Pointer($ref, path, friendlyPath) {\n    /**\n   * The {@link $Ref} object that contains this {@link Pointer} object.\n   * @type {$Ref}\n   */ this.$ref = $ref;\n    /**\n   * The file path or URL, containing the JSON pointer in the hash.\n   * This path is relative to the path of the main JSON schema file.\n   * @type {string}\n   */ this.path = path;\n    /**\n   * The original path or URL, used for error messages.\n   * @type {string}\n   */ this.originalPath = friendlyPath || path;\n    /**\n   * The value of the JSON pointer.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   * @type {?*}\n   */ this.value = undefined;\n    /**\n   * Indicates whether the pointer references itself.\n   * @type {boolean}\n   */ this.circular = false;\n    /**\n   * The number of indirect references that were traversed to resolve the value.\n   * Resolving a single pointer may require resolving multiple $Refs.\n   * @type {number}\n   */ this.indirections = 0;\n}\n/**\n * Resolves the value of a nested property within the given object.\n *\n * @param {*} obj - The object that will be crawled\n * @param {$RefParserOptions} options\n * @param {string} pathFromRoot - the path of place that initiated resolving\n *\n * @returns {Pointer}\n * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.\n * If resolving this value required resolving other JSON references, then\n * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path\n * of the resolved value.\n */ Pointer.prototype.resolve = function(obj, options, pathFromRoot) {\n    let tokens = Pointer.parse(this.path, this.originalPath);\n    // Crawl the object, one token at a time\n    this.value = unwrapOrThrow(obj);\n    for(let i = 0; i < tokens.length; i++){\n        if (resolveIf$Ref(this, options)) {\n            // The $ref path has changed, so append the remaining tokens to the path\n            this.path = Pointer.join(this.path, tokens.slice(i));\n        }\n        if (typeof this.value === \"object\" && this.value !== null && \"$ref\" in this.value) {\n            return this;\n        }\n        let token = tokens[i];\n        if (this.value[token] === undefined || this.value[token] === null) {\n            this.value = null;\n            throw new MissingPointerError(token, decodeURI(this.originalPath));\n        } else {\n            this.value = this.value[token];\n        }\n    }\n    // Resolve the final value\n    if (!this.value || this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot) {\n        resolveIf$Ref(this, options);\n    }\n    return this;\n};\n/**\n * Sets the value of a nested property within the given object.\n *\n * @param {*} obj - The object that will be crawled\n * @param {*} value - the value to assign\n * @param {$RefParserOptions} options\n *\n * @returns {*}\n * Returns the modified object, or an entirely new object if the entire object is overwritten.\n */ Pointer.prototype.set = function(obj, value, options) {\n    let tokens = Pointer.parse(this.path);\n    let token;\n    if (tokens.length === 0) {\n        // There are no tokens, replace the entire object with the new value\n        this.value = value;\n        return value;\n    }\n    // Crawl the object, one token at a time\n    this.value = unwrapOrThrow(obj);\n    for(let i = 0; i < tokens.length - 1; i++){\n        resolveIf$Ref(this, options);\n        token = tokens[i];\n        if (this.value && this.value[token] !== undefined) {\n            // The token exists\n            this.value = this.value[token];\n        } else {\n            // The token doesn't exist, so create it\n            this.value = setValue(this, token, {});\n        }\n    }\n    // Set the value of the final token\n    resolveIf$Ref(this, options);\n    token = tokens[tokens.length - 1];\n    setValue(this, token, value);\n    // Return the updated object\n    return obj;\n};\n/**\n * Parses a JSON pointer (or a path containing a JSON pointer in the hash)\n * and returns an array of the pointer's tokens.\n * (e.g. \"schema.json#/definitions/person/name\" => [\"definitions\", \"person\", \"name\"])\n *\n * The pointer is parsed according to RFC 6901\n * {@link https://tools.ietf.org/html/rfc6901#section-3}\n *\n * @param {string} path\n * @param {string} [originalPath]\n * @returns {string[]}\n */ Pointer.parse = function(path, originalPath) {\n    // Get the JSON pointer from the path's hash\n    let pointer = url.getHash(path).substr(1);\n    // If there's no pointer, then there are no tokens,\n    // so return an empty array\n    if (!pointer) {\n        return [];\n    }\n    // Split into an array\n    pointer = pointer.split(\"/\");\n    // Decode each part, according to RFC 6901\n    for(let i = 0; i < pointer.length; i++){\n        pointer[i] = decodeURIComponent(pointer[i].replace(escapedSlash, \"/\").replace(escapedTilde, \"~\"));\n    }\n    if (pointer[0] !== \"\") {\n        throw new InvalidPointerError(pointer, originalPath === undefined ? path : originalPath);\n    }\n    return pointer.slice(1);\n};\n/**\n * Creates a JSON pointer path, by joining one or more tokens to a base path.\n *\n * @param {string} base - The base path (e.g. \"schema.json#/definitions/person\")\n * @param {string|string[]} tokens - The token(s) to append (e.g. [\"name\", \"first\"])\n * @returns {string}\n */ Pointer.join = function(base, tokens) {\n    // Ensure that the base path contains a hash\n    if (base.indexOf(\"#\") === -1) {\n        base += \"#\";\n    }\n    // Append each token to the base path\n    tokens = Array.isArray(tokens) ? tokens : [\n        tokens\n    ];\n    for(let i = 0; i < tokens.length; i++){\n        let token = tokens[i];\n        // Encode the token, according to RFC 6901\n        base += \"/\" + encodeURIComponent(token.replace(tildes, \"~0\").replace(slashes, \"~1\"));\n    }\n    return base;\n};\n/**\n * If the given pointer's {@link Pointer#value} is a JSON reference,\n * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.\n * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the\n * resolution path of the new value.\n *\n * @param {Pointer} pointer\n * @param {$RefParserOptions} options\n * @returns {boolean} - Returns `true` if the resolution path changed\n */ function resolveIf$Ref(pointer, options) {\n    // Is the value a JSON reference? (and allowed?)\n    if ($Ref.isAllowed$Ref(pointer.value, options)) {\n        let $refPath = url.resolve(pointer.path, pointer.value.$ref);\n        if ($refPath === pointer.path) {\n            // The value is a reference to itself, so there's nothing to do.\n            pointer.circular = true;\n        } else {\n            let resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);\n            if (resolved === null) {\n                return false;\n            }\n            pointer.indirections += resolved.indirections + 1;\n            if ($Ref.isExtended$Ref(pointer.value)) {\n                // This JSON reference \"extends\" the resolved value, rather than simply pointing to it.\n                // So the resolved path does NOT change.  Just the value does.\n                pointer.value = $Ref.dereference(pointer.value, resolved.value);\n                return false;\n            } else {\n                // Resolve the reference\n                pointer.$ref = resolved.$ref;\n                pointer.path = resolved.path;\n                pointer.value = resolved.value;\n            }\n            return true;\n        }\n    }\n}\n/**\n * Sets the specified token value of the {@link Pointer#value}.\n *\n * The token is evaluated according to RFC 6901.\n * {@link https://tools.ietf.org/html/rfc6901#section-4}\n *\n * @param {Pointer} pointer - The JSON Pointer whose value will be modified\n * @param {string} token - A JSON Pointer token that indicates how to modify `obj`\n * @param {*} value - The value to assign\n * @returns {*} - Returns the assigned value\n */ function setValue(pointer, token, value) {\n    if (pointer.value && typeof pointer.value === \"object\") {\n        if (token === \"-\" && Array.isArray(pointer.value)) {\n            pointer.value.push(value);\n        } else {\n            pointer.value[token] = value;\n        }\n    } else {\n        throw new JSONParserError(`Error assigning $ref pointer \"${pointer.path}\". \\nCannot set \"${token}\" of a non-object.`);\n    }\n    return value;\n}\nfunction unwrapOrThrow(value) {\n    if (isHandledError(value)) {\n        throw value;\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3BvaW50ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixNQUFNQyxPQUFPQyxtQkFBT0EsQ0FBQyxrRkFBTztBQUM1QixNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQyw0RkFBWTtBQUNoQyxNQUFNLEVBQUVFLGVBQWUsRUFBRUMsbUJBQW1CLEVBQUVDLG1CQUFtQixFQUFFQyxjQUFjLEVBQUUsR0FBR0wsbUJBQU9BLENBQUMsa0dBQWU7QUFDN0csTUFBTU0sVUFBVTtBQUNoQixNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsZUFBZTtBQUNyQixNQUFNQyxlQUFlO0FBRXJCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTWCxRQUFTWSxJQUFJLEVBQUVDLElBQUksRUFBRUMsWUFBWTtJQUN4Qzs7O0dBR0MsR0FDRCxJQUFJLENBQUNGLElBQUksR0FBR0E7SUFFWjs7OztHQUlDLEdBQ0QsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO0lBRVo7OztHQUdDLEdBQ0QsSUFBSSxDQUFDRSxZQUFZLEdBQUdELGdCQUFnQkQ7SUFFcEM7Ozs7R0FJQyxHQUNELElBQUksQ0FBQ0csS0FBSyxHQUFHQztJQUViOzs7R0FHQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBRWhCOzs7O0dBSUMsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBRztBQUN0QjtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNEbkIsUUFBUW9CLFNBQVMsQ0FBQ0MsT0FBTyxHQUFHLFNBQVVDLEdBQUcsRUFBRUMsT0FBTyxFQUFFQyxZQUFZO0lBQzlELElBQUlDLFNBQVN6QixRQUFRMEIsS0FBSyxDQUFDLElBQUksQ0FBQ2IsSUFBSSxFQUFFLElBQUksQ0FBQ0UsWUFBWTtJQUV2RCx3Q0FBd0M7SUFDeEMsSUFBSSxDQUFDQyxLQUFLLEdBQUdXLGNBQWNMO0lBRTNCLElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJSCxPQUFPSSxNQUFNLEVBQUVELElBQUs7UUFDdEMsSUFBSUUsY0FBYyxJQUFJLEVBQUVQLFVBQVU7WUFDaEMsd0VBQXdFO1lBQ3hFLElBQUksQ0FBQ1YsSUFBSSxHQUFHYixRQUFRK0IsSUFBSSxDQUFDLElBQUksQ0FBQ2xCLElBQUksRUFBRVksT0FBT08sS0FBSyxDQUFDSjtRQUNuRDtRQUVBLElBQUksT0FBTyxJQUFJLENBQUNaLEtBQUssS0FBSyxZQUFZLElBQUksQ0FBQ0EsS0FBSyxLQUFLLFFBQVEsVUFBVSxJQUFJLENBQUNBLEtBQUssRUFBRTtZQUNqRixPQUFPLElBQUk7UUFDYjtRQUVBLElBQUlpQixRQUFRUixNQUFNLENBQUNHLEVBQUU7UUFDckIsSUFBSSxJQUFJLENBQUNaLEtBQUssQ0FBQ2lCLE1BQU0sS0FBS2hCLGFBQWEsSUFBSSxDQUFDRCxLQUFLLENBQUNpQixNQUFNLEtBQUssTUFBTTtZQUNqRSxJQUFJLENBQUNqQixLQUFLLEdBQUc7WUFDYixNQUFNLElBQUlWLG9CQUFvQjJCLE9BQU9DLFVBQVUsSUFBSSxDQUFDbkIsWUFBWTtRQUNsRSxPQUNLO1lBQ0gsSUFBSSxDQUFDQyxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLENBQUNpQixNQUFNO1FBQ2hDO0lBQ0Y7SUFFQSwwQkFBMEI7SUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQ2pCLEtBQUssSUFBSSxJQUFJLENBQUNBLEtBQUssQ0FBQ0osSUFBSSxJQUFJVCxJQUFJa0IsT0FBTyxDQUFDLElBQUksQ0FBQ1IsSUFBSSxFQUFFLElBQUksQ0FBQ0csS0FBSyxDQUFDSixJQUFJLE1BQU1ZLGNBQWM7UUFDOUZNLGNBQWMsSUFBSSxFQUFFUDtJQUN0QjtJQUVBLE9BQU8sSUFBSTtBQUNiO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0R2QixRQUFRb0IsU0FBUyxDQUFDZSxHQUFHLEdBQUcsU0FBVWIsR0FBRyxFQUFFTixLQUFLLEVBQUVPLE9BQU87SUFDbkQsSUFBSUUsU0FBU3pCLFFBQVEwQixLQUFLLENBQUMsSUFBSSxDQUFDYixJQUFJO0lBQ3BDLElBQUlvQjtJQUVKLElBQUlSLE9BQU9JLE1BQU0sS0FBSyxHQUFHO1FBQ3ZCLG9FQUFvRTtRQUNwRSxJQUFJLENBQUNiLEtBQUssR0FBR0E7UUFDYixPQUFPQTtJQUNUO0lBRUEsd0NBQXdDO0lBQ3hDLElBQUksQ0FBQ0EsS0FBSyxHQUFHVyxjQUFjTDtJQUUzQixJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSUgsT0FBT0ksTUFBTSxHQUFHLEdBQUdELElBQUs7UUFDMUNFLGNBQWMsSUFBSSxFQUFFUDtRQUVwQlUsUUFBUVIsTUFBTSxDQUFDRyxFQUFFO1FBQ2pCLElBQUksSUFBSSxDQUFDWixLQUFLLElBQUksSUFBSSxDQUFDQSxLQUFLLENBQUNpQixNQUFNLEtBQUtoQixXQUFXO1lBQ2pELG1CQUFtQjtZQUNuQixJQUFJLENBQUNELEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQ2lCLE1BQU07UUFDaEMsT0FDSztZQUNILHdDQUF3QztZQUN4QyxJQUFJLENBQUNqQixLQUFLLEdBQUdvQixTQUFTLElBQUksRUFBRUgsT0FBTyxDQUFDO1FBQ3RDO0lBQ0Y7SUFFQSxtQ0FBbUM7SUFDbkNILGNBQWMsSUFBSSxFQUFFUDtJQUNwQlUsUUFBUVIsTUFBTSxDQUFDQSxPQUFPSSxNQUFNLEdBQUcsRUFBRTtJQUNqQ08sU0FBUyxJQUFJLEVBQUVILE9BQU9qQjtJQUV0Qiw0QkFBNEI7SUFDNUIsT0FBT007QUFDVDtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ0R0QixRQUFRMEIsS0FBSyxHQUFHLFNBQVViLElBQUksRUFBRUUsWUFBWTtJQUMxQyw0Q0FBNEM7SUFDNUMsSUFBSXNCLFVBQVVsQyxJQUFJbUMsT0FBTyxDQUFDekIsTUFBTTBCLE1BQU0sQ0FBQztJQUV2QyxtREFBbUQ7SUFDbkQsMkJBQTJCO0lBQzNCLElBQUksQ0FBQ0YsU0FBUztRQUNaLE9BQU8sRUFBRTtJQUNYO0lBRUEsc0JBQXNCO0lBQ3RCQSxVQUFVQSxRQUFRRyxLQUFLLENBQUM7SUFFeEIsMENBQTBDO0lBQzFDLElBQUssSUFBSVosSUFBSSxHQUFHQSxJQUFJUyxRQUFRUixNQUFNLEVBQUVELElBQUs7UUFDdkNTLE9BQU8sQ0FBQ1QsRUFBRSxHQUFHYSxtQkFBbUJKLE9BQU8sQ0FBQ1QsRUFBRSxDQUFDYyxPQUFPLENBQUNoQyxjQUFjLEtBQUtnQyxPQUFPLENBQUMvQixjQUFjO0lBQzlGO0lBRUEsSUFBSTBCLE9BQU8sQ0FBQyxFQUFFLEtBQUssSUFBSTtRQUNyQixNQUFNLElBQUloQyxvQkFBb0JnQyxTQUFTdEIsaUJBQWlCRSxZQUFZSixPQUFPRTtJQUM3RTtJQUVBLE9BQU9zQixRQUFRTCxLQUFLLENBQUM7QUFDdkI7QUFFQTs7Ozs7O0NBTUMsR0FDRGhDLFFBQVErQixJQUFJLEdBQUcsU0FBVVksSUFBSSxFQUFFbEIsTUFBTTtJQUNuQyw0Q0FBNEM7SUFDNUMsSUFBSWtCLEtBQUtDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRztRQUM1QkQsUUFBUTtJQUNWO0lBRUEscUNBQXFDO0lBQ3JDbEIsU0FBU29CLE1BQU1DLE9BQU8sQ0FBQ3JCLFVBQVVBLFNBQVM7UUFBQ0E7S0FBTztJQUNsRCxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUgsT0FBT0ksTUFBTSxFQUFFRCxJQUFLO1FBQ3RDLElBQUlLLFFBQVFSLE1BQU0sQ0FBQ0csRUFBRTtRQUNyQiwwQ0FBMEM7UUFDMUNlLFFBQVEsTUFBTUksbUJBQW1CZCxNQUFNUyxPQUFPLENBQUNqQyxRQUFRLE1BQU1pQyxPQUFPLENBQUNsQyxTQUFTO0lBQ2hGO0lBRUEsT0FBT21DO0FBQ1Q7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTYixjQUFlTyxPQUFPLEVBQUVkLE9BQU87SUFDdEMsZ0RBQWdEO0lBRWhELElBQUl0QixLQUFLK0MsYUFBYSxDQUFDWCxRQUFRckIsS0FBSyxFQUFFTyxVQUFVO1FBQzlDLElBQUkwQixXQUFXOUMsSUFBSWtCLE9BQU8sQ0FBQ2dCLFFBQVF4QixJQUFJLEVBQUV3QixRQUFRckIsS0FBSyxDQUFDSixJQUFJO1FBRTNELElBQUlxQyxhQUFhWixRQUFReEIsSUFBSSxFQUFFO1lBQzdCLGdFQUFnRTtZQUNoRXdCLFFBQVFuQixRQUFRLEdBQUc7UUFDckIsT0FDSztZQUNILElBQUlnQyxXQUFXYixRQUFRekIsSUFBSSxDQUFDdUMsS0FBSyxDQUFDQyxRQUFRLENBQUNILFVBQVVaLFFBQVF4QixJQUFJLEVBQUVVO1lBQ25FLElBQUkyQixhQUFhLE1BQU07Z0JBQ3JCLE9BQU87WUFDVDtZQUVBYixRQUFRbEIsWUFBWSxJQUFJK0IsU0FBUy9CLFlBQVksR0FBRztZQUVoRCxJQUFJbEIsS0FBS29ELGNBQWMsQ0FBQ2hCLFFBQVFyQixLQUFLLEdBQUc7Z0JBQ3RDLHVGQUF1RjtnQkFDdkYsOERBQThEO2dCQUM5RHFCLFFBQVFyQixLQUFLLEdBQUdmLEtBQUtxRCxXQUFXLENBQUNqQixRQUFRckIsS0FBSyxFQUFFa0MsU0FBU2xDLEtBQUs7Z0JBQzlELE9BQU87WUFDVCxPQUNLO2dCQUNILHdCQUF3QjtnQkFDeEJxQixRQUFRekIsSUFBSSxHQUFHc0MsU0FBU3RDLElBQUk7Z0JBQzVCeUIsUUFBUXhCLElBQUksR0FBR3FDLFNBQVNyQyxJQUFJO2dCQUM1QndCLFFBQVFyQixLQUFLLEdBQUdrQyxTQUFTbEMsS0FBSztZQUNoQztZQUVBLE9BQU87UUFDVDtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU29CLFNBQVVDLE9BQU8sRUFBRUosS0FBSyxFQUFFakIsS0FBSztJQUN0QyxJQUFJcUIsUUFBUXJCLEtBQUssSUFBSSxPQUFPcUIsUUFBUXJCLEtBQUssS0FBSyxVQUFVO1FBQ3RELElBQUlpQixVQUFVLE9BQU9ZLE1BQU1DLE9BQU8sQ0FBQ1QsUUFBUXJCLEtBQUssR0FBRztZQUNqRHFCLFFBQVFyQixLQUFLLENBQUN1QyxJQUFJLENBQUN2QztRQUNyQixPQUNLO1lBQ0hxQixRQUFRckIsS0FBSyxDQUFDaUIsTUFBTSxHQUFHakI7UUFDekI7SUFDRixPQUNLO1FBQ0gsTUFBTSxJQUFJWixnQkFBZ0IsQ0FBQyw4QkFBOEIsRUFBRWlDLFFBQVF4QixJQUFJLENBQUMsaUJBQWlCLEVBQUVvQixNQUFNLGtCQUFrQixDQUFDO0lBQ3RIO0lBQ0EsT0FBT2pCO0FBQ1Q7QUFHQSxTQUFTVyxjQUFlWCxLQUFLO0lBQzNCLElBQUlULGVBQWVTLFFBQVE7UUFDekIsTUFBTUE7SUFDUjtJQUVBLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2xpYi9wb2ludGVyLmpzPzBjZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRlcjtcblxuY29uc3QgJFJlZiA9IHJlcXVpcmUoXCIuL3JlZlwiKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCIuL3V0aWwvdXJsXCIpO1xuY29uc3QgeyBKU09OUGFyc2VyRXJyb3IsIEludmFsaWRQb2ludGVyRXJyb3IsIE1pc3NpbmdQb2ludGVyRXJyb3IsIGlzSGFuZGxlZEVycm9yIH0gPSByZXF1aXJlKFwiLi91dGlsL2Vycm9yc1wiKTtcbmNvbnN0IHNsYXNoZXMgPSAvXFwvL2c7XG5jb25zdCB0aWxkZXMgPSAvfi9nO1xuY29uc3QgZXNjYXBlZFNsYXNoID0gL34xL2c7XG5jb25zdCBlc2NhcGVkVGlsZGUgPSAvfjAvZztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBzaW5nbGUgSlNPTiBwb2ludGVyIGFuZCBpdHMgcmVzb2x2ZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHskUmVmfSAkcmVmXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFtmcmllbmRseVBhdGhdIC0gVGhlIG9yaWdpbmFsIHVzZXItc3BlY2lmaWVkIHBhdGggKHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzKVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBvaW50ZXIgKCRyZWYsIHBhdGgsIGZyaWVuZGx5UGF0aCkge1xuICAvKipcbiAgICogVGhlIHtAbGluayAkUmVmfSBvYmplY3QgdGhhdCBjb250YWlucyB0aGlzIHtAbGluayBQb2ludGVyfSBvYmplY3QuXG4gICAqIEB0eXBlIHskUmVmfVxuICAgKi9cbiAgdGhpcy4kcmVmID0gJHJlZjtcblxuICAvKipcbiAgICogVGhlIGZpbGUgcGF0aCBvciBVUkwsIGNvbnRhaW5pbmcgdGhlIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaC5cbiAgICogVGhpcyBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBwYXRoIG9mIHRoZSBtYWluIEpTT04gc2NoZW1hIGZpbGUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLnBhdGggPSBwYXRoO1xuXG4gIC8qKlxuICAgKiBUaGUgb3JpZ2luYWwgcGF0aCBvciBVUkwsIHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5vcmlnaW5hbFBhdGggPSBmcmllbmRseVBhdGggfHwgcGF0aDtcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBKU09OIHBvaW50ZXIuXG4gICAqIENhbiBiZSBhbnkgSlNPTiB0eXBlLCBub3QganVzdCBvYmplY3RzLiBVbmtub3duIGZpbGUgdHlwZXMgYXJlIHJlcHJlc2VudGVkIGFzIEJ1ZmZlcnMgKGJ5dGUgYXJyYXlzKS5cbiAgICogQHR5cGUgez8qfVxuICAgKi9cbiAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBvaW50ZXIgcmVmZXJlbmNlcyBpdHNlbGYuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5jaXJjdWxhciA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGluZGlyZWN0IHJlZmVyZW5jZXMgdGhhdCB3ZXJlIHRyYXZlcnNlZCB0byByZXNvbHZlIHRoZSB2YWx1ZS5cbiAgICogUmVzb2x2aW5nIGEgc2luZ2xlIHBvaW50ZXIgbWF5IHJlcXVpcmUgcmVzb2x2aW5nIG11bHRpcGxlICRSZWZzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5pbmRpcmVjdGlvbnMgPSAwO1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSB2YWx1ZSBvZiBhIG5lc3RlZCBwcm9wZXJ0eSB3aXRoaW4gdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGNyYXdsZWRcbiAqIEBwYXJhbSB7JFJlZlBhcnNlck9wdGlvbnN9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoRnJvbVJvb3QgLSB0aGUgcGF0aCBvZiBwbGFjZSB0aGF0IGluaXRpYXRlZCByZXNvbHZpbmdcbiAqXG4gKiBAcmV0dXJucyB7UG9pbnRlcn1cbiAqIFJldHVybnMgYSBKU09OIHBvaW50ZXIgd2hvc2Uge0BsaW5rIFBvaW50ZXIjdmFsdWV9IGlzIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIElmIHJlc29sdmluZyB0aGlzIHZhbHVlIHJlcXVpcmVkIHJlc29sdmluZyBvdGhlciBKU09OIHJlZmVyZW5jZXMsIHRoZW5cbiAqIHRoZSB7QGxpbmsgUG9pbnRlciMkcmVmfSBhbmQge0BsaW5rIFBvaW50ZXIjcGF0aH0gd2lsbCByZWZsZWN0IHRoZSByZXNvbHV0aW9uIHBhdGhcbiAqIG9mIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuUG9pbnRlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMsIHBhdGhGcm9tUm9vdCkge1xuICBsZXQgdG9rZW5zID0gUG9pbnRlci5wYXJzZSh0aGlzLnBhdGgsIHRoaXMub3JpZ2luYWxQYXRoKTtcblxuICAvLyBDcmF3bCB0aGUgb2JqZWN0LCBvbmUgdG9rZW4gYXQgYSB0aW1lXG4gIHRoaXMudmFsdWUgPSB1bndyYXBPclRocm93KG9iaik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzb2x2ZUlmJFJlZih0aGlzLCBvcHRpb25zKSkge1xuICAgICAgLy8gVGhlICRyZWYgcGF0aCBoYXMgY2hhbmdlZCwgc28gYXBwZW5kIHRoZSByZW1haW5pbmcgdG9rZW5zIHRvIHRoZSBwYXRoXG4gICAgICB0aGlzLnBhdGggPSBQb2ludGVyLmpvaW4odGhpcy5wYXRoLCB0b2tlbnMuc2xpY2UoaSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLnZhbHVlICE9PSBudWxsICYmIFwiJHJlZlwiIGluIHRoaXMudmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBpZiAodGhpcy52YWx1ZVt0b2tlbl0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlW3Rva2VuXSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICB0aHJvdyBuZXcgTWlzc2luZ1BvaW50ZXJFcnJvcih0b2tlbiwgZGVjb2RlVVJJKHRoaXMub3JpZ2luYWxQYXRoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWVbdG9rZW5dO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlc29sdmUgdGhlIGZpbmFsIHZhbHVlXG4gIGlmICghdGhpcy52YWx1ZSB8fCB0aGlzLnZhbHVlLiRyZWYgJiYgdXJsLnJlc29sdmUodGhpcy5wYXRoLCB0aGlzLnZhbHVlLiRyZWYpICE9PSBwYXRoRnJvbVJvb3QpIHtcbiAgICByZXNvbHZlSWYkUmVmKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgbmVzdGVkIHByb3BlcnR5IHdpdGhpbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgY3Jhd2xlZFxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBhc3NpZ25cbiAqIEBwYXJhbSB7JFJlZlBhcnNlck9wdGlvbnN9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqIFJldHVybnMgdGhlIG1vZGlmaWVkIG9iamVjdCwgb3IgYW4gZW50aXJlbHkgbmV3IG9iamVjdCBpZiB0aGUgZW50aXJlIG9iamVjdCBpcyBvdmVyd3JpdHRlbi5cbiAqL1xuUG9pbnRlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9iaiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgbGV0IHRva2VucyA9IFBvaW50ZXIucGFyc2UodGhpcy5wYXRoKTtcbiAgbGV0IHRva2VuO1xuXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gVGhlcmUgYXJlIG5vIHRva2VucywgcmVwbGFjZSB0aGUgZW50aXJlIG9iamVjdCB3aXRoIHRoZSBuZXcgdmFsdWVcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gQ3Jhd2wgdGhlIG9iamVjdCwgb25lIHRva2VuIGF0IGEgdGltZVxuICB0aGlzLnZhbHVlID0gdW53cmFwT3JUaHJvdyhvYmopO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHJlc29sdmVJZiRSZWYodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBpZiAodGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlW3Rva2VuXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGUgdG9rZW4gZXhpc3RzXG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0b2tlbl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gVGhlIHRva2VuIGRvZXNuJ3QgZXhpc3QsIHNvIGNyZWF0ZSBpdFxuICAgICAgdGhpcy52YWx1ZSA9IHNldFZhbHVlKHRoaXMsIHRva2VuLCB7fSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IHRoZSB2YWx1ZSBvZiB0aGUgZmluYWwgdG9rZW5cbiAgcmVzb2x2ZUlmJFJlZih0aGlzLCBvcHRpb25zKTtcbiAgdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICBzZXRWYWx1ZSh0aGlzLCB0b2tlbiwgdmFsdWUpO1xuXG4gIC8vIFJldHVybiB0aGUgdXBkYXRlZCBvYmplY3RcbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgSlNPTiBwb2ludGVyIChvciBhIHBhdGggY29udGFpbmluZyBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaClcbiAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludGVyJ3MgdG9rZW5zLlxuICogKGUuZy4gXCJzY2hlbWEuanNvbiMvZGVmaW5pdGlvbnMvcGVyc29uL25hbWVcIiA9PiBbXCJkZWZpbml0aW9uc1wiLCBcInBlcnNvblwiLCBcIm5hbWVcIl0pXG4gKlxuICogVGhlIHBvaW50ZXIgaXMgcGFyc2VkIGFjY29yZGluZyB0byBSRkMgNjkwMVxuICoge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxI3NlY3Rpb24tM31cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcmlnaW5hbFBhdGhdXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cblBvaW50ZXIucGFyc2UgPSBmdW5jdGlvbiAocGF0aCwgb3JpZ2luYWxQYXRoKSB7XG4gIC8vIEdldCB0aGUgSlNPTiBwb2ludGVyIGZyb20gdGhlIHBhdGgncyBoYXNoXG4gIGxldCBwb2ludGVyID0gdXJsLmdldEhhc2gocGF0aCkuc3Vic3RyKDEpO1xuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gcG9pbnRlciwgdGhlbiB0aGVyZSBhcmUgbm8gdG9rZW5zLFxuICAvLyBzbyByZXR1cm4gYW4gZW1wdHkgYXJyYXlcbiAgaWYgKCFwb2ludGVyKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gU3BsaXQgaW50byBhbiBhcnJheVxuICBwb2ludGVyID0gcG9pbnRlci5zcGxpdChcIi9cIik7XG5cbiAgLy8gRGVjb2RlIGVhY2ggcGFydCwgYWNjb3JkaW5nIHRvIFJGQyA2OTAxXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRlci5sZW5ndGg7IGkrKykge1xuICAgIHBvaW50ZXJbaV0gPSBkZWNvZGVVUklDb21wb25lbnQocG9pbnRlcltpXS5yZXBsYWNlKGVzY2FwZWRTbGFzaCwgXCIvXCIpLnJlcGxhY2UoZXNjYXBlZFRpbGRlLCBcIn5cIikpO1xuICB9XG5cbiAgaWYgKHBvaW50ZXJbMF0gIT09IFwiXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFBvaW50ZXJFcnJvcihwb2ludGVyLCBvcmlnaW5hbFBhdGggPT09IHVuZGVmaW5lZCA/IHBhdGggOiBvcmlnaW5hbFBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50ZXIuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBKU09OIHBvaW50ZXIgcGF0aCwgYnkgam9pbmluZyBvbmUgb3IgbW9yZSB0b2tlbnMgdG8gYSBiYXNlIHBhdGguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgLSBUaGUgYmFzZSBwYXRoIChlLmcuIFwic2NoZW1hLmpzb24jL2RlZmluaXRpb25zL3BlcnNvblwiKVxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHRva2VucyAtIFRoZSB0b2tlbihzKSB0byBhcHBlbmQgKGUuZy4gW1wibmFtZVwiLCBcImZpcnN0XCJdKVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUG9pbnRlci5qb2luID0gZnVuY3Rpb24gKGJhc2UsIHRva2Vucykge1xuICAvLyBFbnN1cmUgdGhhdCB0aGUgYmFzZSBwYXRoIGNvbnRhaW5zIGEgaGFzaFxuICBpZiAoYmFzZS5pbmRleE9mKFwiI1wiKSA9PT0gLTEpIHtcbiAgICBiYXNlICs9IFwiI1wiO1xuICB9XG5cbiAgLy8gQXBwZW5kIGVhY2ggdG9rZW4gdG8gdGhlIGJhc2UgcGF0aFxuICB0b2tlbnMgPSBBcnJheS5pc0FycmF5KHRva2VucykgPyB0b2tlbnMgOiBbdG9rZW5zXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgLy8gRW5jb2RlIHRoZSB0b2tlbiwgYWNjb3JkaW5nIHRvIFJGQyA2OTAxXG4gICAgYmFzZSArPSBcIi9cIiArIGVuY29kZVVSSUNvbXBvbmVudCh0b2tlbi5yZXBsYWNlKHRpbGRlcywgXCJ+MFwiKS5yZXBsYWNlKHNsYXNoZXMsIFwifjFcIikpO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIElmIHRoZSBnaXZlbiBwb2ludGVyJ3Mge0BsaW5rIFBvaW50ZXIjdmFsdWV9IGlzIGEgSlNPTiByZWZlcmVuY2UsXG4gKiB0aGVuIHRoZSByZWZlcmVuY2UgaXMgcmVzb2x2ZWQgYW5kIHtAbGluayBQb2ludGVyI3ZhbHVlfSBpcyByZXBsYWNlZCB3aXRoIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEluIGFkZGl0aW9uLCB7QGxpbmsgUG9pbnRlciNwYXRofSBhbmQge0BsaW5rIFBvaW50ZXIjJHJlZn0gYXJlIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGVcbiAqIHJlc29sdXRpb24gcGF0aCBvZiB0aGUgbmV3IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7UG9pbnRlcn0gcG9pbnRlclxuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlc29sdXRpb24gcGF0aCBjaGFuZ2VkXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVJZiRSZWYgKHBvaW50ZXIsIG9wdGlvbnMpIHtcbiAgLy8gSXMgdGhlIHZhbHVlIGEgSlNPTiByZWZlcmVuY2U/IChhbmQgYWxsb3dlZD8pXG5cbiAgaWYgKCRSZWYuaXNBbGxvd2VkJFJlZihwb2ludGVyLnZhbHVlLCBvcHRpb25zKSkge1xuICAgIGxldCAkcmVmUGF0aCA9IHVybC5yZXNvbHZlKHBvaW50ZXIucGF0aCwgcG9pbnRlci52YWx1ZS4kcmVmKTtcblxuICAgIGlmICgkcmVmUGF0aCA9PT0gcG9pbnRlci5wYXRoKSB7XG4gICAgICAvLyBUaGUgdmFsdWUgaXMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLCBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uXG4gICAgICBwb2ludGVyLmNpcmN1bGFyID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsZXQgcmVzb2x2ZWQgPSBwb2ludGVyLiRyZWYuJHJlZnMuX3Jlc29sdmUoJHJlZlBhdGgsIHBvaW50ZXIucGF0aCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzb2x2ZWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBwb2ludGVyLmluZGlyZWN0aW9ucyArPSByZXNvbHZlZC5pbmRpcmVjdGlvbnMgKyAxO1xuXG4gICAgICBpZiAoJFJlZi5pc0V4dGVuZGVkJFJlZihwb2ludGVyLnZhbHVlKSkge1xuICAgICAgICAvLyBUaGlzIEpTT04gcmVmZXJlbmNlIFwiZXh0ZW5kc1wiIHRoZSByZXNvbHZlZCB2YWx1ZSwgcmF0aGVyIHRoYW4gc2ltcGx5IHBvaW50aW5nIHRvIGl0LlxuICAgICAgICAvLyBTbyB0aGUgcmVzb2x2ZWQgcGF0aCBkb2VzIE5PVCBjaGFuZ2UuICBKdXN0IHRoZSB2YWx1ZSBkb2VzLlxuICAgICAgICBwb2ludGVyLnZhbHVlID0gJFJlZi5kZXJlZmVyZW5jZShwb2ludGVyLnZhbHVlLCByZXNvbHZlZC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBSZXNvbHZlIHRoZSByZWZlcmVuY2VcbiAgICAgICAgcG9pbnRlci4kcmVmID0gcmVzb2x2ZWQuJHJlZjtcbiAgICAgICAgcG9pbnRlci5wYXRoID0gcmVzb2x2ZWQucGF0aDtcbiAgICAgICAgcG9pbnRlci52YWx1ZSA9IHJlc29sdmVkLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgdG9rZW4gdmFsdWUgb2YgdGhlIHtAbGluayBQb2ludGVyI3ZhbHVlfS5cbiAqXG4gKiBUaGUgdG9rZW4gaXMgZXZhbHVhdGVkIGFjY29yZGluZyB0byBSRkMgNjkwMS5cbiAqIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMSNzZWN0aW9uLTR9XG4gKlxuICogQHBhcmFtIHtQb2ludGVyfSBwb2ludGVyIC0gVGhlIEpTT04gUG9pbnRlciB3aG9zZSB2YWx1ZSB3aWxsIGJlIG1vZGlmaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBBIEpTT04gUG9pbnRlciB0b2tlbiB0aGF0IGluZGljYXRlcyBob3cgdG8gbW9kaWZ5IGBvYmpgXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFzc2lnblxuICogQHJldHVybnMgeyp9IC0gUmV0dXJucyB0aGUgYXNzaWduZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWUgKHBvaW50ZXIsIHRva2VuLCB2YWx1ZSkge1xuICBpZiAocG9pbnRlci52YWx1ZSAmJiB0eXBlb2YgcG9pbnRlci52YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmICh0b2tlbiA9PT0gXCItXCIgJiYgQXJyYXkuaXNBcnJheShwb2ludGVyLnZhbHVlKSkge1xuICAgICAgcG9pbnRlci52YWx1ZS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwb2ludGVyLnZhbHVlW3Rva2VuXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSlNPTlBhcnNlckVycm9yKGBFcnJvciBhc3NpZ25pbmcgJHJlZiBwb2ludGVyIFwiJHtwb2ludGVyLnBhdGh9XCIuIFxcbkNhbm5vdCBzZXQgXCIke3Rva2VufVwiIG9mIGEgbm9uLW9iamVjdC5gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cblxuZnVuY3Rpb24gdW53cmFwT3JUaHJvdyAodmFsdWUpIHtcbiAgaWYgKGlzSGFuZGxlZEVycm9yKHZhbHVlKSkge1xuICAgIHRocm93IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJQb2ludGVyIiwiJFJlZiIsInJlcXVpcmUiLCJ1cmwiLCJKU09OUGFyc2VyRXJyb3IiLCJJbnZhbGlkUG9pbnRlckVycm9yIiwiTWlzc2luZ1BvaW50ZXJFcnJvciIsImlzSGFuZGxlZEVycm9yIiwic2xhc2hlcyIsInRpbGRlcyIsImVzY2FwZWRTbGFzaCIsImVzY2FwZWRUaWxkZSIsIiRyZWYiLCJwYXRoIiwiZnJpZW5kbHlQYXRoIiwib3JpZ2luYWxQYXRoIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJjaXJjdWxhciIsImluZGlyZWN0aW9ucyIsInByb3RvdHlwZSIsInJlc29sdmUiLCJvYmoiLCJvcHRpb25zIiwicGF0aEZyb21Sb290IiwidG9rZW5zIiwicGFyc2UiLCJ1bndyYXBPclRocm93IiwiaSIsImxlbmd0aCIsInJlc29sdmVJZiRSZWYiLCJqb2luIiwic2xpY2UiLCJ0b2tlbiIsImRlY29kZVVSSSIsInNldCIsInNldFZhbHVlIiwicG9pbnRlciIsImdldEhhc2giLCJzdWJzdHIiLCJzcGxpdCIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJiYXNlIiwiaW5kZXhPZiIsIkFycmF5IiwiaXNBcnJheSIsImVuY29kZVVSSUNvbXBvbmVudCIsImlzQWxsb3dlZCRSZWYiLCIkcmVmUGF0aCIsInJlc29sdmVkIiwiJHJlZnMiLCJfcmVzb2x2ZSIsImlzRXh0ZW5kZWQkUmVmIiwiZGVyZWZlcmVuY2UiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/pointer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = $Ref;\nconst Pointer = __webpack_require__(/*! ./pointer */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/pointer.js\");\nconst { InvalidPointerError, isHandledError, normalizeError } = __webpack_require__(/*! ./util/errors */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\");\nconst { safePointerToPath, stripHash, getHash } = __webpack_require__(/*! ./util/url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @class\n */ function $Ref() {\n    /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */ this.path = undefined;\n    /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   *\n   * @type {?*}\n   */ this.value = undefined;\n    /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   *\n   * @type {$Refs}\n   */ this.$refs = undefined;\n    /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   *\n   * @type {?string}\n   */ this.pathType = undefined;\n    /**\n   * List of all errors. Undefined if no errors.\n   *\n   * @type {Array<JSONParserError | ResolverError | ParserError | MissingPointerError>}\n   */ this.errors = undefined;\n}\n/**\n * Pushes an error to errors array.\n *\n * @param {Array<JSONParserError | JSONParserErrorGroup>} err - The error to be pushed\n * @returns {void}\n */ $Ref.prototype.addError = function(err) {\n    if (this.errors === undefined) {\n        this.errors = [];\n    }\n    const existingErrors = this.errors.map(({ footprint })=>footprint);\n    // the path has been almost certainly set at this point,\n    // but just in case something went wrong, normalizeError injects path if necessary\n    // moreover, certain errors might point at the same spot, so filter them out to reduce noise\n    if (Array.isArray(err.errors)) {\n        this.errors.push(...err.errors.map(normalizeError).filter(({ footprint })=>!existingErrors.includes(footprint)));\n    } else if (!existingErrors.includes(err.footprint)) {\n        this.errors.push(normalizeError(err));\n    }\n};\n/**\n * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */ $Ref.prototype.exists = function(path, options) {\n    try {\n        this.resolve(path, options);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n/**\n * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {*} - Returns the resolved value\n */ $Ref.prototype.get = function(path, options) {\n    return this.resolve(path, options).value;\n};\n/**\n * Resolves the given JSON reference within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @param {string} friendlyPath - The original user-specified path (used for error messages)\n *  @param {string} pathFromRoot - The path of `obj` from the schema root\n * @returns {Pointer | null}\n */ $Ref.prototype.resolve = function(path, options, friendlyPath, pathFromRoot) {\n    let pointer = new Pointer(this, path, friendlyPath);\n    try {\n        return pointer.resolve(this.value, options, pathFromRoot);\n    } catch (err) {\n        if (!options || !options.continueOnError || !isHandledError(err)) {\n            throw err;\n        }\n        if (err.path === null) {\n            err.path = safePointerToPath(getHash(pathFromRoot));\n        }\n        if (err instanceof InvalidPointerError) {\n            // this is a special case - InvalidPointerError is thrown when dereferencing external file,\n            // but the issue is caused by the source file that referenced the file that undergoes dereferencing\n            err.source = decodeURI(stripHash(pathFromRoot));\n        }\n        this.addError(err);\n        return null;\n    }\n};\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */ $Ref.prototype.set = function(path, value) {\n    let pointer = new Pointer(this, path);\n    this.value = pointer.set(this.value, value);\n};\n/**\n * Determines whether the given value is a JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */ $Ref.is$Ref = function(value) {\n    return value && typeof value === \"object\" && typeof value.$ref === \"string\" && value.$ref.length > 0;\n};\n/**\n * Determines whether the given value is an external JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */ $Ref.isExternal$Ref = function(value) {\n    return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n};\n/**\n * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n * For example, if it references an external file, then options.resolve.external must be true.\n *\n * @param {*} value - The value to inspect\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */ $Ref.isAllowed$Ref = function(value, options) {\n    if ($Ref.is$Ref(value)) {\n        if (value.$ref.substr(0, 2) === \"#/\" || value.$ref === \"#\") {\n            // It's a JSON Pointer reference, which is always allowed\n            return true;\n        } else if (value.$ref[0] !== \"#\" && (!options || options.resolve.external)) {\n            // It's an external reference, which is allowed by the options\n            return true;\n        }\n    }\n};\n/**\n * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n * value, plus the extra properties.\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n *  property (salary).  The result is a NEW value that looks like this:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */ $Ref.isExtended$Ref = function(value) {\n    return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n};\n/**\n * Returns the resolved value of a JSON Reference.\n * If necessary, the resolved value is merged with the JSON Reference to create a new object\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  When \"person\" and \"employee\" are merged, you end up with the following object:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {object} $ref - The JSON reference object (the one with the \"$ref\" property)\n * @param {*} resolvedValue - The resolved value, which can be any type\n * @returns {*} - Returns the dereferenced value\n */ $Ref.dereference = function($ref, resolvedValue) {\n    if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n        let merged = {};\n        for (let key of Object.keys($ref)){\n            if (key !== \"$ref\") {\n                merged[key] = $ref[key];\n            }\n        }\n        for (let key of Object.keys(resolvedValue)){\n            if (!(key in merged)) {\n                merged[key] = resolvedValue[key];\n            }\n        }\n        return merged;\n    } else {\n        // Completely replace the original reference with the resolved value\n        return resolvedValue;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3JlZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLDBGQUFXO0FBQ25DLE1BQU0sRUFBRUMsbUJBQW1CLEVBQUVDLGNBQWMsRUFBRUMsY0FBYyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDLGtHQUFlO0FBQ3ZGLE1BQU0sRUFBRUksaUJBQWlCLEVBQUVDLFNBQVMsRUFBRUMsT0FBTyxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDLDRGQUFZO0FBRXRFOzs7O0NBSUMsR0FDRCxTQUFTRjtJQUNQOzs7Ozs7Ozs7R0FTQyxHQUNELElBQUksQ0FBQ1MsSUFBSSxHQUFHQztJQUVaOzs7OztHQUtDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUdEO0lBRWI7Ozs7R0FJQyxHQUNELElBQUksQ0FBQ0UsS0FBSyxHQUFHRjtJQUViOzs7O0dBSUMsR0FDRCxJQUFJLENBQUNHLFFBQVEsR0FBR0g7SUFFaEI7Ozs7R0FJQyxHQUNELElBQUksQ0FBQ0ksTUFBTSxHQUFHSjtBQUNoQjtBQUVBOzs7OztDQUtDLEdBQ0RWLEtBQUtlLFNBQVMsQ0FBQ0MsUUFBUSxHQUFHLFNBQVVDLEdBQUc7SUFDckMsSUFBSSxJQUFJLENBQUNILE1BQU0sS0FBS0osV0FBVztRQUM3QixJQUFJLENBQUNJLE1BQU0sR0FBRyxFQUFFO0lBQ2xCO0lBRUEsTUFBTUksaUJBQWlCLElBQUksQ0FBQ0osTUFBTSxDQUFDSyxHQUFHLENBQUMsQ0FBQyxFQUFFQyxTQUFTLEVBQUUsR0FBS0E7SUFFMUQsd0RBQXdEO0lBQ3hELGtGQUFrRjtJQUNsRiw0RkFBNEY7SUFDNUYsSUFBSUMsTUFBTUMsT0FBTyxDQUFDTCxJQUFJSCxNQUFNLEdBQUc7UUFDN0IsSUFBSSxDQUFDQSxNQUFNLENBQUNTLElBQUksSUFBSU4sSUFBSUgsTUFBTSxD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O1FBQ1Q7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUNDLEdBQ0Q1QyxLQUFLNkMsY0FBYyxHQUFHLFNBQVVsQyxLQUFLO0lBQ25DLE9BQU9YLEtBQUtzQyxNQUFNLENBQUMzQixVQUFVbUMsT0FBT0MsSUFBSSxDQUFDcEMsT0FBTzZCLE1BQU0sR0FBRztBQUMzRDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQ0MsR0FDRHhDLEtBQUtnRCxXQUFXLEdBQUcsU0FBVVQsSUFBSSxFQUFFVSxhQUFhO0lBQzlDLElBQUlBLGlCQUFpQixPQUFPQSxrQkFBa0IsWUFBWWpELEtBQUs2QyxjQUFjLENBQUNOLE9BQU87UUFDbkYsSUFBSVcsU0FBUyxDQUFDO1FBQ2QsS0FBSyxJQUFJQyxPQUFPTCxPQUFPQyxJQUFJLENBQUNSLE1BQU87WUFDakMsSUFBSVksUUFBUSxRQUFRO2dCQUNsQkQsTUFBTSxDQUFDQyxJQUFJLEdBQUdaLElBQUksQ0FBQ1ksSUFBSTtZQUN6QjtRQUNGO1FBRUEsS0FBSyxJQUFJQSxPQUFPTCxPQUFPQyxJQUFJLENBQUNFLGVBQWdCO1lBQzFDLElBQUksQ0FBRUUsQ0FBQUEsT0FBT0QsTUFBSyxHQUFJO2dCQUNwQkEsTUFBTSxDQUFDQyxJQUFJLEdBQUdGLGFBQWEsQ0FBQ0UsSUFBSTtZQUNsQztRQUNGO1FBRUEsT0FBT0Q7SUFDVCxPQUNLO1FBQ0gsb0VBQW9FO1FBQ3BFLE9BQU9EO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25hbnRlcy1wdWJsaWMtZGF0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3JlZi5qcz9hYzdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRSZWY7XG5cbmNvbnN0IFBvaW50ZXIgPSByZXF1aXJlKFwiLi9wb2ludGVyXCIpO1xuY29uc3QgeyBJbnZhbGlkUG9pbnRlckVycm9yLCBpc0hhbmRsZWRFcnJvciwgbm9ybWFsaXplRXJyb3IgfSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzXCIpO1xuY29uc3QgeyBzYWZlUG9pbnRlclRvUGF0aCwgc3RyaXBIYXNoLCBnZXRIYXNoIH0gPSByZXF1aXJlKFwiLi91dGlsL3VybFwiKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBzaW5nbGUgSlNPTiByZWZlcmVuY2UgYW5kIGl0cyByZXNvbHZlZCB2YWx1ZS5cbiAqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gJFJlZiAoKSB7XG4gIC8qKlxuICAgKiBUaGUgZmlsZSBwYXRoIG9yIFVSTCBvZiB0aGUgcmVmZXJlbmNlZCBmaWxlLlxuICAgKiBUaGlzIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIHBhdGggb2YgdGhlIG1haW4gSlNPTiBzY2hlbWEgZmlsZS5cbiAgICpcbiAgICogVGhpcyBwYXRoIGRvZXMgTk9UIGNvbnRhaW4gZG9jdW1lbnQgZnJhZ21lbnRzIChKU09OIHBvaW50ZXJzKS4gSXQgYWx3YXlzIHJlZmVyZW5jZXMgYW4gRU5USVJFIGZpbGUuXG4gICAqIFVzZSBtZXRob2RzIHN1Y2ggYXMge0BsaW5rICRSZWYjZ2V0fSwge0BsaW5rICRSZWYjcmVzb2x2ZX0sIGFuZCB7QGxpbmsgJFJlZiNleGlzdHN9IHRvIGdldFxuICAgKiBzcGVjaWZpYyBKU09OIHBvaW50ZXJzIHdpdGhpbiB0aGUgZmlsZS5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMucGF0aCA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIHJlc29sdmVkIHZhbHVlIG9mIHRoZSBKU09OIHJlZmVyZW5jZS5cbiAgICogQ2FuIGJlIGFueSBKU09OIHR5cGUsIG5vdCBqdXN0IG9iamVjdHMuIFVua25vd24gZmlsZSB0eXBlcyBhcmUgcmVwcmVzZW50ZWQgYXMgQnVmZmVycyAoYnl0ZSBhcnJheXMpLlxuICAgKlxuICAgKiBAdHlwZSB7Pyp9XG4gICAqL1xuICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUge0BsaW5rICRSZWZzfSBvYmplY3QgdGhhdCBjb250YWlucyB0aGlzIHtAbGluayAkUmVmfSBvYmplY3QuXG4gICAqXG4gICAqIEB0eXBlIHskUmVmc31cbiAgICovXG4gIHRoaXMuJHJlZnMgPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgdHlwZSBvZiB7QGxpbmsgJFJlZiNwYXRofSAoZS5nLiBcImZpbGVcIiwgXCJodHRwXCIsIGV0Yy4pXG4gICAqXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5wYXRoVHlwZSA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogTGlzdCBvZiBhbGwgZXJyb3JzLiBVbmRlZmluZWQgaWYgbm8gZXJyb3JzLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8SlNPTlBhcnNlckVycm9yIHwgUmVzb2x2ZXJFcnJvciB8IFBhcnNlckVycm9yIHwgTWlzc2luZ1BvaW50ZXJFcnJvcj59XG4gICAqL1xuICB0aGlzLmVycm9ycyA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBQdXNoZXMgYW4gZXJyb3IgdG8gZXJyb3JzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8SlNPTlBhcnNlckVycm9yIHwgSlNPTlBhcnNlckVycm9yR3JvdXA+fSBlcnIgLSBUaGUgZXJyb3IgdG8gYmUgcHVzaGVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuJFJlZi5wcm90b3R5cGUuYWRkRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICh0aGlzLmVycm9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nRXJyb3JzID0gdGhpcy5lcnJvcnMubWFwKCh7IGZvb3RwcmludCB9KSA9PiBmb290cHJpbnQpO1xuXG4gIC8vIHRoZSBwYXRoIGhhcyBiZWVuIGFsbW9zdCBjZXJ0YWlubHkgc2V0IGF0IHRoaXMgcG9pbnQsXG4gIC8vIGJ1dCBqdXN0IGluIGNhc2Ugc29tZXRoaW5nIHdlbnQgd3JvbmcsIG5vcm1hbGl6ZUVycm9yIGluamVjdHMgcGF0aCBpZiBuZWNlc3NhcnlcbiAgLy8gbW9yZW92ZXIsIGNlcnRhaW4gZXJyb3JzIG1pZ2h0IHBvaW50IGF0IHRoZSBzYW1lIHNwb3QsIHNvIGZpbHRlciB0aGVtIG91dCB0byByZWR1Y2Ugbm9pc2VcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXJyLmVycm9ycykpIHtcbiAgICB0aGlzLmVycm9ycy5wdXNoKC4uLmVyci5lcnJvcnNcbiAgICAgIC5tYXAobm9ybWFsaXplRXJyb3IpXG4gICAgICAuZmlsdGVyKCh7IGZvb3RwcmludCB9KSA9PiAhZXhpc3RpbmdFcnJvcnMuaW5jbHVkZXMoZm9vdHByaW50KSksXG4gICAgKTtcbiAgfVxuICBlbHNlIGlmICghZXhpc3RpbmdFcnJvcnMuaW5jbHVkZXMoZXJyLmZvb3RwcmludCkpIHtcbiAgICB0aGlzLmVycm9ycy5wdXNoKG5vcm1hbGl6ZUVycm9yKGVycikpO1xuICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gSlNPTiByZWZlcmVuY2UgZXhpc3RzIHdpdGhpbiB0aGlzIHtAbGluayAkUmVmI3ZhbHVlfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBmdWxsIHBhdGggYmVpbmcgcmVzb2x2ZWQsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbiRSZWYucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5yZXNvbHZlKHBhdGgsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBnaXZlbiBKU09OIHJlZmVyZW5jZSB3aXRoaW4gdGhpcyB7QGxpbmsgJFJlZiN2YWx1ZX0gYW5kIHJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBiZWluZyByZXNvbHZlZCwgb3B0aW9uYWxseSB3aXRoIGEgSlNPTiBwb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0geyRSZWZQYXJzZXJPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7Kn0gLSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZVxuICovXG4kUmVmLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlKHBhdGgsIG9wdGlvbnMpLnZhbHVlO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gSlNPTiByZWZlcmVuY2Ugd2l0aGluIHRoaXMge0BsaW5rICRSZWYjdmFsdWV9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBiZWluZyByZXNvbHZlZCwgb3B0aW9uYWxseSB3aXRoIGEgSlNPTiBwb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0geyRSZWZQYXJzZXJPcHRpb25zfSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gZnJpZW5kbHlQYXRoIC0gVGhlIG9yaWdpbmFsIHVzZXItc3BlY2lmaWVkIHBhdGggKHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzKVxuICogIEBwYXJhbSB7c3RyaW5nfSBwYXRoRnJvbVJvb3QgLSBUaGUgcGF0aCBvZiBgb2JqYCBmcm9tIHRoZSBzY2hlbWEgcm9vdFxuICogQHJldHVybnMge1BvaW50ZXIgfCBudWxsfVxuICovXG4kUmVmLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMsIGZyaWVuZGx5UGF0aCwgcGF0aEZyb21Sb290KSB7XG4gIGxldCBwb2ludGVyID0gbmV3IFBvaW50ZXIodGhpcywgcGF0aCwgZnJpZW5kbHlQYXRoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcG9pbnRlci5yZXNvbHZlKHRoaXMudmFsdWUsIG9wdGlvbnMsIHBhdGhGcm9tUm9vdCk7XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5jb250aW51ZU9uRXJyb3IgfHwgIWlzSGFuZGxlZEVycm9yKGVycikpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpZiAoZXJyLnBhdGggPT09IG51bGwpIHtcbiAgICAgIGVyci5wYXRoID0gc2FmZVBvaW50ZXJUb1BhdGgoZ2V0SGFzaChwYXRoRnJvbVJvb3QpKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgSW52YWxpZFBvaW50ZXJFcnJvcikge1xuICAgICAgLy8gdGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIEludmFsaWRQb2ludGVyRXJyb3IgaXMgdGhyb3duIHdoZW4gZGVyZWZlcmVuY2luZyBleHRlcm5hbCBmaWxlLFxuICAgICAgLy8gYnV0IHRoZSBpc3N1ZSBpcyBjYXVzZWQgYnkgdGhlIHNvdXJjZSBmaWxlIHRoYXQgcmVmZXJlbmNlZCB0aGUgZmlsZSB0aGF0IHVuZGVyZ29lcyBkZXJlZmVyZW5jaW5nXG4gICAgICBlcnIuc291cmNlID0gZGVjb2RlVVJJKHN0cmlwSGFzaChwYXRoRnJvbVJvb3QpKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZEVycm9yKGVycik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBuZXN0ZWQgcHJvcGVydHkgd2l0aGluIHRoaXMge0BsaW5rICRSZWYjdmFsdWV9LlxuICogSWYgdGhlIHByb3BlcnR5LCBvciBhbnkgb2YgaXRzIHBhcmVudHMgZG9uJ3QgZXhpc3QsIHRoZXkgd2lsbCBiZSBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzaWduXG4gKi9cbiRSZWYucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkge1xuICBsZXQgcG9pbnRlciA9IG5ldyBQb2ludGVyKHRoaXMsIHBhdGgpO1xuICB0aGlzLnZhbHVlID0gcG9pbnRlci5zZXQodGhpcy52YWx1ZSwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgSlNPTiByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBpbnNwZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuJFJlZi5pcyRSZWYgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUuJHJlZiA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS4kcmVmLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXh0ZXJuYWwgSlNPTiByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBpbnNwZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuJFJlZi5pc0V4dGVybmFsJFJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gJFJlZi5pcyRSZWYodmFsdWUpICYmIHZhbHVlLiRyZWZbMF0gIT09IFwiI1wiO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgSlNPTiByZWZlcmVuY2UsIGFuZCB3aGV0aGVyIGl0IGlzIGFsbG93ZWQgYnkgdGhlIG9wdGlvbnMuXG4gKiBGb3IgZXhhbXBsZSwgaWYgaXQgcmVmZXJlbmNlcyBhbiBleHRlcm5hbCBmaWxlLCB0aGVuIG9wdGlvbnMucmVzb2x2ZS5leHRlcm5hbCBtdXN0IGJlIHRydWUuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBpbnNwZWN0XG4gKiBAcGFyYW0geyRSZWZQYXJzZXJPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuJFJlZi5pc0FsbG93ZWQkUmVmID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICgkUmVmLmlzJFJlZih2YWx1ZSkpIHtcbiAgICBpZiAodmFsdWUuJHJlZi5zdWJzdHIoMCwgMikgPT09IFwiIy9cIiB8fCB2YWx1ZS4kcmVmID09PSBcIiNcIikge1xuICAgICAgLy8gSXQncyBhIEpTT04gUG9pbnRlciByZWZlcmVuY2UsIHdoaWNoIGlzIGFsd2F5cyBhbGxvd2VkXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUuJHJlZlswXSAhPT0gXCIjXCIgJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMucmVzb2x2ZS5leHRlcm5hbCkpIHtcbiAgICAgIC8vIEl0J3MgYW4gZXh0ZXJuYWwgcmVmZXJlbmNlLCB3aGljaCBpcyBhbGxvd2VkIGJ5IHRoZSBvcHRpb25zXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIEpTT04gcmVmZXJlbmNlIHRoYXQgXCJleHRlbmRzXCIgaXRzIHJlc29sdmVkIHZhbHVlLlxuICogVGhhdCBpcywgaXQgaGFzIGV4dHJhIHByb3BlcnRpZXMgKGluIGFkZGl0aW9uIHRvIFwiJHJlZlwiKSwgc28gcmF0aGVyIHRoYW4gc2ltcGx5IHBvaW50aW5nIHRvXG4gKiBhbiBleGlzdGluZyB2YWx1ZSwgdGhpcyAkcmVmIGFjdHVhbGx5IGNyZWF0ZXMgYSBORVcgdmFsdWUgdGhhdCBpcyBhIHNoYWxsb3cgY29weSBvZiB0aGUgcmVzb2x2ZWRcbiAqIHZhbHVlLCBwbHVzIHRoZSBleHRyYSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlOlxuICogIHtcbiAqICAgIHBlcnNvbjoge1xuICogICAgICBwcm9wZXJ0aWVzOiB7XG4gKiAgICAgICAgZmlyc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gKiAgICAgICAgbGFzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAqICAgICAgfVxuICogICAgfVxuICogICAgZW1wbG95ZWU6IHtcbiAqICAgICAgcHJvcGVydGllczoge1xuICogICAgICAgICRyZWY6ICMvcGVyc29uL3Byb3BlcnRpZXNcbiAqICAgICAgICBzYWxhcnk6IHsgdHlwZTogbnVtYmVyIH1cbiAqICAgICAgfVxuICogICAgfVxuICogIH1cbiAqXG4gKiAgSW4gdGhpcyBleGFtcGxlLCBcImVtcGxveWVlXCIgaXMgYW4gZXh0ZW5kZWQgJHJlZiwgc2luY2UgaXQgZXh0ZW5kcyBcInBlcnNvblwiIHdpdGggYW4gYWRkaXRpb25hbFxuICogIHByb3BlcnR5IChzYWxhcnkpLiAgVGhlIHJlc3VsdCBpcyBhIE5FVyB2YWx1ZSB0aGF0IGxvb2tzIGxpa2UgdGhpczpcbiAqXG4gKiAge1xuICogICAgcHJvcGVydGllczoge1xuICogICAgICBmaXJzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAqICAgICAgbGFzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAqICAgICAgc2FsYXJ5OiB7IHR5cGU6IG51bWJlciB9XG4gKiAgICB9XG4gKiAgfVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gaW5zcGVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbiRSZWYuaXNFeHRlbmRlZCRSZWYgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuICRSZWYuaXMkUmVmKHZhbHVlKSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUgb2YgYSBKU09OIFJlZmVyZW5jZS5cbiAqIElmIG5lY2Vzc2FyeSwgdGhlIHJlc29sdmVkIHZhbHVlIGlzIG1lcmdlZCB3aXRoIHRoZSBKU09OIFJlZmVyZW5jZSB0byBjcmVhdGUgYSBuZXcgb2JqZWN0XG4gKlxuICogQGV4YW1wbGU6XG4gKiAge1xuICogICAgcGVyc29uOiB7XG4gKiAgICAgIHByb3BlcnRpZXM6IHtcbiAqICAgICAgICBmaXJzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAqICAgICAgICBsYXN0TmFtZTogeyB0eXBlOiBzdHJpbmcgfVxuICogICAgICB9XG4gKiAgICB9XG4gKiAgICBlbXBsb3llZToge1xuICogICAgICBwcm9wZXJ0aWVzOiB7XG4gKiAgICAgICAgJHJlZjogIy9wZXJzb24vcHJvcGVydGllc1xuICogICAgICAgIHNhbGFyeTogeyB0eXBlOiBudW1iZXIgfVxuICogICAgICB9XG4gKiAgICB9XG4gKiAgfVxuICpcbiAqICBXaGVuIFwicGVyc29uXCIgYW5kIFwiZW1wbG95ZWVcIiBhcmUgbWVyZ2VkLCB5b3UgZW5kIHVwIHdpdGggdGhlIGZvbGxvd2luZyBvYmplY3Q6XG4gKlxuICogIHtcbiAqICAgIHByb3BlcnRpZXM6IHtcbiAqICAgICAgZmlyc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gKiAgICAgIGxhc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gKiAgICAgIHNhbGFyeTogeyB0eXBlOiBudW1iZXIgfVxuICogICAgfVxuICogIH1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gJHJlZiAtIFRoZSBKU09OIHJlZmVyZW5jZSBvYmplY3QgKHRoZSBvbmUgd2l0aCB0aGUgXCIkcmVmXCIgcHJvcGVydHkpXG4gKiBAcGFyYW0geyp9IHJlc29sdmVkVmFsdWUgLSBUaGUgcmVzb2x2ZWQgdmFsdWUsIHdoaWNoIGNhbiBiZSBhbnkgdHlwZVxuICogQHJldHVybnMgeyp9IC0gUmV0dXJucyB0aGUgZGVyZWZlcmVuY2VkIHZhbHVlXG4gKi9cbiRSZWYuZGVyZWZlcmVuY2UgPSBmdW5jdGlvbiAoJHJlZiwgcmVzb2x2ZWRWYWx1ZSkge1xuICBpZiAocmVzb2x2ZWRWYWx1ZSAmJiB0eXBlb2YgcmVzb2x2ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAkUmVmLmlzRXh0ZW5kZWQkUmVmKCRyZWYpKSB7XG4gICAgbGV0IG1lcmdlZCA9IHt9O1xuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cygkcmVmKSkge1xuICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIpIHtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSAkcmVmW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHJlc29sdmVkVmFsdWUpKSB7XG4gICAgICBpZiAoIShrZXkgaW4gbWVyZ2VkKSkge1xuICAgICAgICBtZXJnZWRba2V5XSA9IHJlc29sdmVkVmFsdWVba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIENvbXBsZXRlbHkgcmVwbGFjZSB0aGUgb3JpZ2luYWwgcmVmZXJlbmNlIHdpdGggdGhlIHJlc29sdmVkIHZhbHVlXG4gICAgcmV0dXJuIHJlc29sdmVkVmFsdWU7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIiRSZWYiLCJQb2ludGVyIiwicmVxdWlyZSIsIkludmFsaWRQb2ludGVyRXJyb3IiLCJpc0hhbmRsZWRFcnJvciIsIm5vcm1hbGl6ZUVycm9yIiwic2FmZVBvaW50ZXJUb1BhdGgiLCJzdHJpcEhhc2giLCJnZXRIYXNoIiwicGF0aCIsInVuZGVmaW5lZCIsInZhbHVlIiwiJHJlZnMiLCJwYXRoVHlwZSIsImVycm9ycyIsInByb3RvdHlwZSIsImFkZEVycm9yIiwiZXJyIiwiZXhpc3RpbmdFcnJvcnMiLCJtYXAiLCJmb290cHJpbnQiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJleGlzdHMiLCJvcHRpb25zIiwicmVzb2x2ZSIsImUiLCJnZXQiLCJmcmllbmRseVBhdGgiLCJwYXRoRnJvbVJvb3QiLCJwb2ludGVyIiwiY29udGludWVPbkVycm9yIiwic291cmNlIiwiZGVjb2RlVVJJIiwic2V0IiwiaXMkUmVmIiwiJHJlZiIsImxlbmd0aCIsImlzRXh0ZXJuYWwkUmVmIiwiaXNBbGxvd2VkJFJlZiIsInN1YnN0ciIsImV4dGVybmFsIiwiaXNFeHRlbmRlZCRSZWYiLCJPYmplY3QiLCJrZXlzIiwiZGVyZWZlcmVuY2UiLCJyZXNvbHZlZFZhbHVlIiwibWVyZ2VkIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/refs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/refs.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { ono } = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst $Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js\");\nconst url = __webpack_require__(/*! ./util/url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\nmodule.exports = $Refs;\n/**\n * This class is a map of JSON references and their resolved values.\n */ function $Refs() {\n    /**\n   * Indicates whether the schema contains any circular references.\n   *\n   * @type {boolean}\n   */ this.circular = false;\n    /**\n   * A map of paths/urls to {@link $Ref} objects\n   *\n   * @type {object}\n   * @protected\n   */ this._$refs = {};\n    /**\n   * The {@link $Ref} object that is the root of the JSON schema.\n   *\n   * @type {$Ref}\n   * @protected\n   */ this._root$Ref = null;\n}\n/**\n * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n * including the schema itself.\n *\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {string[]}\n */ $Refs.prototype.paths = function(types) {\n    let paths = getPaths(this._$refs, arguments);\n    return paths.map((path)=>{\n        return path.decoded;\n    });\n};\n/**\n * Returns the map of JSON references and their resolved values.\n *\n * @param {...string|string[]} [types] - Only return references of the given types (\"file\", \"http\", etc.)\n * @returns {object}\n */ $Refs.prototype.values = function(types) {\n    let $refs = this._$refs;\n    let paths = getPaths($refs, arguments);\n    return paths.reduce((obj, path)=>{\n        obj[path.decoded] = $refs[path.encoded].value;\n        return obj;\n    }, {});\n};\n/**\n * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n *\n * @returns {object}\n */ $Refs.prototype.toJSON = $Refs.prototype.values;\n/**\n * Determines whether the given JSON reference exists.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {boolean}\n */ $Refs.prototype.exists = function(path, options) {\n    try {\n        this._resolve(path, \"\", options);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n/**\n * Resolves the given JSON reference and returns the resolved value.\n *\n * @param {string} path - The path being resolved, with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {*} - Returns the resolved value\n */ $Refs.prototype.get = function(path, options) {\n    return this._resolve(path, \"\", options).value;\n};\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */ $Refs.prototype.set = function(path, value) {\n    let absPath = url.resolve(this._root$Ref.path, path);\n    let withoutHash = url.stripHash(absPath);\n    let $ref = this._$refs[withoutHash];\n    if (!$ref) {\n        throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n    }\n    $ref.set(absPath, value);\n};\n/**\n * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n *\n * @param {string} path  - The file path or URL of the referenced file\n */ $Refs.prototype._add = function(path) {\n    let withoutHash = url.stripHash(path);\n    let $ref = new $Ref();\n    $ref.path = withoutHash;\n    $ref.$refs = this;\n    this._$refs[withoutHash] = $ref;\n    this._root$Ref = this._root$Ref || $ref;\n    return $ref;\n};\n/**\n * Resolves the given JSON reference.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {$RefParserOptions} [options]\n * @returns {Pointer}\n * @protected\n */ $Refs.prototype._resolve = function(path, pathFromRoot, options) {\n    let absPath = url.resolve(this._root$Ref.path, path);\n    let withoutHash = url.stripHash(absPath);\n    let $ref = this._$refs[withoutHash];\n    if (!$ref) {\n        throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n    }\n    return $ref.resolve(absPath, options, path, pathFromRoot);\n};\n/**\n * Returns the specified {@link $Ref} object, or undefined.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @returns {$Ref|undefined}\n * @protected\n */ $Refs.prototype._get$Ref = function(path) {\n    path = url.resolve(this._root$Ref.path, path);\n    let withoutHash = url.stripHash(path);\n    return this._$refs[withoutHash];\n};\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param {object} $refs - The object whose keys are URL-encoded paths\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {object[]}\n */ function getPaths($refs, types) {\n    let paths = Object.keys($refs);\n    // Filter the paths by type\n    types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n    if (types.length > 0 && types[0]) {\n        paths = paths.filter((key)=>{\n            return types.indexOf($refs[key].pathType) !== -1;\n        });\n    }\n    // Decode local filesystem paths\n    return paths.map((path)=>{\n        return {\n            encoded: path,\n            decoded: $refs[path].pathType === \"file\" ? url.toFileSystemPath(path, true) : path\n        };\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3JlZnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixNQUFNLEVBQUVBLEdBQUcsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQywwRUFBaUI7QUFDekMsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUMsa0ZBQU87QUFDNUIsTUFBTUUsTUFBTUYsbUJBQU9BLENBQUMsNEZBQVk7QUFFaENHLE9BQU9DLE9BQU8sR0FBR0M7QUFFakI7O0NBRUMsR0FDRCxTQUFTQTtJQUNQOzs7O0dBSUMsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBRztJQUVoQjs7Ozs7R0FLQyxHQUNELElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUM7SUFFZjs7Ozs7R0FLQyxHQUNELElBQUksQ0FBQ0MsU0FBUyxHQUFHO0FBQ25CO0FBRUE7Ozs7OztDQU1DLEdBQ0RILE1BQU1JLFNBQVMsQ0FBQ0MsS0FBSyxHQUFHLFNBQVVDLEtBQUs7SUFDckMsSUFBSUQsUUFBUUUsU0FBUyxJQUFJLENBQUNMLE1BQU0sRUFBRU07SUFDbEMsT0FBT0gsTUFBTUksR0FBRyxDQUFDLENBQUNDO1FBQ2hCLE9BQU9BLEtBQUtDLE9BQU87SUFDckI7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0RYLE1BQU1JLFNBQVMsQ0FBQ1EsTUFBTSxHQUFHLFNBQVVOLEtBQUs7SUFDdEMsSUFBSU8sUUFBUSxJQUFJLENBQUNYLE1BQU07SUFDdkIsSUFBSUcsUUFBUUUsU0FBU00sT0FBT0w7SUFDNUIsT0FBT0gsTUFBTVMsTUFBTSxDQUFDLENBQUNDLEtBQUtMO1FBQ3hCSyxHQUFHLENBQUNMLEtBQUtDLE9BQU8sQ0FBQyxHQUFHRSxLQUFLLENBQUNILEtBQUtNLE9BQU8sQ0FBQyxDQUFDQyxLQUFLO1FBQzdDLE9BQU9GO0lBQ1QsR0FBRyxDQUFDO0FBQ047QUFFQTs7OztDQUlDLEdBQ0RmLE1BQU1JLFNBQVMsQ0FBQ2MsTUFBTSxHQUFHbEIs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TWlDLE1BQU0sR0FBRyxLQUFLakMsS0FBSyxDQUFDLEVBQUUsRUFBRTtRQUNoQ0QsUUFBUUEsTUFBTW1DLE1BQU0sQ0FBQyxDQUFDQztZQUNwQixPQUFPbkMsTUFBTW9DLE9BQU8sQ0FBQzdCLEtBQUssQ0FBQzRCLElBQUksQ0FBQ0UsUUFBUSxNQUFNLENBQUM7UUFDakQ7SUFDRjtJQUVBLGdDQUFnQztJQUNoQyxPQUFPdEMsTUFBTUksR0FBRyxDQUFDLENBQUNDO1FBQ2hCLE9BQU87WUFDTE0sU0FBU047WUFDVEMsU0FBU0UsS0FBSyxDQUFDSCxLQUFLLENBQUNpQyxRQUFRLEtBQUssU0FBUzlDLElBQUkrQyxnQkFBZ0IsQ0FBQ2xDLE1BQU0sUUFBUUE7UUFDaEY7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvcmVmcy5qcz9iZjA3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB7IG9ubyB9ID0gcmVxdWlyZShcIkBqc2RldnRvb2xzL29ub1wiKTtcbmNvbnN0ICRSZWYgPSByZXF1aXJlKFwiLi9yZWZcIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwiLi91dGlsL3VybFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSAkUmVmcztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIGEgbWFwIG9mIEpTT04gcmVmZXJlbmNlcyBhbmQgdGhlaXIgcmVzb2x2ZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiAkUmVmcyAoKSB7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2NoZW1hIGNvbnRhaW5zIGFueSBjaXJjdWxhciByZWZlcmVuY2VzLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuY2lyY3VsYXIgPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBtYXAgb2YgcGF0aHMvdXJscyB0byB7QGxpbmsgJFJlZn0gb2JqZWN0c1xuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB0aGlzLl8kcmVmcyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUaGUge0BsaW5rICRSZWZ9IG9iamVjdCB0aGF0IGlzIHRoZSByb290IG9mIHRoZSBKU09OIHNjaGVtYS5cbiAgICpcbiAgICogQHR5cGUgeyRSZWZ9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHRoaXMuX3Jvb3QkUmVmID0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXRocyBvZiBhbGwgdGhlIGZpbGVzL1VSTHMgdGhhdCBhcmUgcmVmZXJlbmNlZCBieSB0aGUgSlNPTiBzY2hlbWEsXG4gKiBpbmNsdWRpbmcgdGhlIHNjaGVtYSBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHsuLi5zdHJpbmd8c3RyaW5nW119IFt0eXBlc10gLSBPbmx5IHJldHVybiBwYXRocyBvZiB0aGUgZ2l2ZW4gdHlwZXMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuJFJlZnMucHJvdG90eXBlLnBhdGhzID0gZnVuY3Rpb24gKHR5cGVzKSB7ICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgbGV0IHBhdGhzID0gZ2V0UGF0aHModGhpcy5fJHJlZnMsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBwYXRocy5tYXAoKHBhdGgpID0+IHtcbiAgICByZXR1cm4gcGF0aC5kZWNvZGVkO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWFwIG9mIEpTT04gcmVmZXJlbmNlcyBhbmQgdGhlaXIgcmVzb2x2ZWQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfHN0cmluZ1tdfSBbdHlwZXNdIC0gT25seSByZXR1cm4gcmVmZXJlbmNlcyBvZiB0aGUgZ2l2ZW4gdHlwZXMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbiRSZWZzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAodHlwZXMpIHsgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGxldCAkcmVmcyA9IHRoaXMuXyRyZWZzO1xuICBsZXQgcGF0aHMgPSBnZXRQYXRocygkcmVmcywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHBhdGhzLnJlZHVjZSgob2JqLCBwYXRoKSA9PiB7XG4gICAgb2JqW3BhdGguZGVjb2RlZF0gPSAkcmVmc1twYXRoLmVuY29kZWRdLnZhbHVlO1xuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIFBPSk8gKHBsYWluIG9sZCBKYXZhU2NyaXB0IG9iamVjdCkgZm9yIHNlcmlhbGl6YXRpb24gYXMgSlNPTi5cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG4kUmVmcy5wcm90b3R5cGUudG9KU09OID0gJFJlZnMucHJvdG90eXBlLnZhbHVlcztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIEpTT04gcmVmZXJlbmNlIGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIGJlaW5nIHJlc29sdmVkLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAqIEBwYXJhbSB7JFJlZlBhcnNlck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbiRSZWZzLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIHRoaXMuX3Jlc29sdmUocGF0aCwgXCJcIiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIGdpdmVuIEpTT04gcmVmZXJlbmNlIGFuZCByZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIGJlaW5nIHJlc29sdmVkLCB3aXRoIGEgSlNPTiBwb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0geyRSZWZQYXJzZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHsqfSAtIFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlXG4gKi9cbiRSZWZzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5fcmVzb2x2ZShwYXRoLCBcIlwiLCBvcHRpb25zKS52YWx1ZTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBuZXN0ZWQgcHJvcGVydHkgd2l0aGluIHRoaXMge0BsaW5rICRSZWYjdmFsdWV9LlxuICogSWYgdGhlIHByb3BlcnR5LCBvciBhbnkgb2YgaXRzIHBhcmVudHMgZG9uJ3QgZXhpc3QsIHRoZXkgd2lsbCBiZSBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldCwgb3B0aW9uYWxseSB3aXRoIGEgSlNPTiBwb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFzc2lnblxuICovXG4kUmVmcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlKSB7XG4gIGxldCBhYnNQYXRoID0gdXJsLnJlc29sdmUodGhpcy5fcm9vdCRSZWYucGF0aCwgcGF0aCk7XG4gIGxldCB3aXRob3V0SGFzaCA9IHVybC5zdHJpcEhhc2goYWJzUGF0aCk7XG4gIGxldCAkcmVmID0gdGhpcy5fJHJlZnNbd2l0aG91dEhhc2hdO1xuXG4gIGlmICghJHJlZikge1xuICAgIHRocm93IG9ubyhgRXJyb3IgcmVzb2x2aW5nICRyZWYgcG9pbnRlciBcIiR7cGF0aH1cIi4gXFxuXCIke3dpdGhvdXRIYXNofVwiIG5vdCBmb3VuZC5gKTtcbiAgfVxuXG4gICRyZWYuc2V0KGFic1BhdGgsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgJFJlZn0gb2JqZWN0IGFuZCBhZGRzIGl0IHRvIHRoaXMge0BsaW5rICRSZWZzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggIC0gVGhlIGZpbGUgcGF0aCBvciBVUkwgb2YgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICovXG4kUmVmcy5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGxldCB3aXRob3V0SGFzaCA9IHVybC5zdHJpcEhhc2gocGF0aCk7XG5cbiAgbGV0ICRyZWYgPSBuZXcgJFJlZigpO1xuICAkcmVmLnBhdGggPSB3aXRob3V0SGFzaDtcbiAgJHJlZi4kcmVmcyA9IHRoaXM7XG5cbiAgdGhpcy5fJHJlZnNbd2l0aG91dEhhc2hdID0gJHJlZjtcbiAgdGhpcy5fcm9vdCRSZWYgPSB0aGlzLl9yb290JFJlZiB8fCAkcmVmO1xuXG4gIHJldHVybiAkcmVmO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gSlNPTiByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCBiZWluZyByZXNvbHZlZCwgb3B0aW9uYWxseSB3aXRoIGEgSlNPTiBwb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aEZyb21Sb290IC0gVGhlIHBhdGggb2YgYG9iamAgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAqIEBwYXJhbSB7JFJlZlBhcnNlck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1BvaW50ZXJ9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbiRSZWZzLnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uIChwYXRoLCBwYXRoRnJvbVJvb3QsIG9wdGlvbnMpIHtcbiAgbGV0IGFic1BhdGggPSB1cmwucmVzb2x2ZSh0aGlzLl9yb290JFJlZi5wYXRoLCBwYXRoKTtcbiAgbGV0IHdpdGhvdXRIYXNoID0gdXJsLnN0cmlwSGFzaChhYnNQYXRoKTtcbiAgbGV0ICRyZWYgPSB0aGlzLl8kcmVmc1t3aXRob3V0SGFzaF07XG5cbiAgaWYgKCEkcmVmKSB7XG4gICAgdGhyb3cgb25vKGBFcnJvciByZXNvbHZpbmcgJHJlZiBwb2ludGVyIFwiJHtwYXRofVwiLiBcXG5cIiR7d2l0aG91dEhhc2h9XCIgbm90IGZvdW5kLmApO1xuICB9XG5cbiAgcmV0dXJuICRyZWYucmVzb2x2ZShhYnNQYXRoLCBvcHRpb25zLCBwYXRoLCBwYXRoRnJvbVJvb3QpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcGVjaWZpZWQge0BsaW5rICRSZWZ9IG9iamVjdCwgb3IgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggYmVpbmcgcmVzb2x2ZWQsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHJldHVybnMgeyRSZWZ8dW5kZWZpbmVkfVxuICogQHByb3RlY3RlZFxuICovXG4kUmVmcy5wcm90b3R5cGUuX2dldCRSZWYgPSBmdW5jdGlvbiAocGF0aCkge1xuICBwYXRoID0gdXJsLnJlc29sdmUodGhpcy5fcm9vdCRSZWYucGF0aCwgcGF0aCk7XG4gIGxldCB3aXRob3V0SGFzaCA9IHVybC5zdHJpcEhhc2gocGF0aCk7XG4gIHJldHVybiB0aGlzLl8kcmVmc1t3aXRob3V0SGFzaF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGVuY29kZWQgYW5kIGRlY29kZWQgcGF0aHMga2V5cyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSAkcmVmcyAtIFRoZSBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgVVJMLWVuY29kZWQgcGF0aHNcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfHN0cmluZ1tdfSBbdHlwZXNdIC0gT25seSByZXR1cm4gcGF0aHMgb2YgdGhlIGdpdmVuIHR5cGVzIChcImZpbGVcIiwgXCJodHRwXCIsIGV0Yy4pXG4gKiBAcmV0dXJucyB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhzICgkcmVmcywgdHlwZXMpIHtcbiAgbGV0IHBhdGhzID0gT2JqZWN0LmtleXMoJHJlZnMpO1xuXG4gIC8vIEZpbHRlciB0aGUgcGF0aHMgYnkgdHlwZVxuICB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHlwZXNbMF0pID8gdHlwZXNbMF0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0eXBlcyk7XG4gIGlmICh0eXBlcy5sZW5ndGggPiAwICYmIHR5cGVzWzBdKSB7XG4gICAgcGF0aHMgPSBwYXRocy5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVzLmluZGV4T2YoJHJlZnNba2V5XS5wYXRoVHlwZSkgIT09IC0xO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRGVjb2RlIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHNcbiAgcmV0dXJuIHBhdGhzLm1hcCgocGF0aCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGVkOiBwYXRoLFxuICAgICAgZGVjb2RlZDogJHJlZnNbcGF0aF0ucGF0aFR5cGUgPT09IFwiZmlsZVwiID8gdXJsLnRvRmlsZVN5c3RlbVBhdGgocGF0aCwgdHJ1ZSkgOiBwYXRoXG4gICAgfTtcbiAgfSk7XG59XG4iXSwibmFtZXMiOlsib25vIiwicmVxdWlyZSIsIiRSZWYiLCJ1cmwiLCJtb2R1bGUiLCJleHBvcnRzIiwiJFJlZnMiLCJjaXJjdWxhciIsIl8kcmVmcyIsIl9yb290JFJlZiIsInByb3RvdHlwZSIsInBhdGhzIiwidHlwZXMiLCJnZXRQYXRocyIsImFyZ3VtZW50cyIsIm1hcCIsInBhdGgiLCJkZWNvZGVkIiwidmFsdWVzIiwiJHJlZnMiLCJyZWR1Y2UiLCJvYmoiLCJlbmNvZGVkIiwidmFsdWUiLCJ0b0pTT04iLCJleGlzdHMiLCJvcHRpb25zIiwiX3Jlc29sdmUiLCJlIiwiZ2V0Iiwic2V0IiwiYWJzUGF0aCIsInJlc29sdmUiLCJ3aXRob3V0SGFzaCIsInN0cmlwSGFzaCIsIiRyZWYiLCJfYWRkIiwicGF0aEZyb21Sb290IiwiX2dldCRSZWYiLCJPYmplY3QiLCJrZXlzIiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJjYWxsIiwibGVuZ3RoIiwiZmlsdGVyIiwia2V5IiwiaW5kZXhPZiIsInBhdGhUeXBlIiwidG9GaWxlU3lzdGVtUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/refs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/resolve-external.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/resolve-external.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst $Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js\");\nconst Pointer = __webpack_require__(/*! ./pointer */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/pointer.js\");\nconst parse = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/parse.js\");\nconst url = __webpack_require__(/*! ./util/url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\nconst { isHandledError } = __webpack_require__(/*! ./util/errors */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\");\nmodule.exports = resolveExternal;\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */ function resolveExternal(parser, options) {\n    if (!options.resolve.external) {\n        // Nothing to resolve, so exit early\n        return Promise.resolve();\n    }\n    try {\n        // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n        let promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n        return Promise.all(promises);\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @param {Set} seen - Internal.\n *\n * @returns {Promise[]}\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */ function crawl(obj, path, $refs, options, seen) {\n    seen = seen || new Set();\n    let promises = [];\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {\n        seen.add(obj); // Track previously seen objects to avoid infinite recursion\n        if ($Ref.isExternal$Ref(obj)) {\n            promises.push(resolve$Ref(obj, path, $refs, options));\n        } else {\n            for (let key of Object.keys(obj)){\n                let keyPath = Pointer.join(path, key);\n                let value = obj[key];\n                if ($Ref.isExternal$Ref(value)) {\n                    promises.push(resolve$Ref(value, keyPath, $refs, options));\n                } else {\n                    promises = promises.concat(crawl(value, keyPath, $refs, options, seen));\n                }\n            }\n        }\n    }\n    return promises;\n}\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */ async function resolve$Ref($ref, path, $refs, options) {\n    // console.log('Resolving $ref pointer \"%s\" at %s', $ref.$ref, path);\n    let resolvedPath = url.resolve(path, $ref.$ref);\n    let withoutHash = url.stripHash(resolvedPath);\n    // Do we already have this $ref?\n    $ref = $refs._$refs[withoutHash];\n    if ($ref) {\n        // We've already parsed this $ref, so use the existing value\n        return Promise.resolve($ref.value);\n    }\n    // Parse the $referenced file/url\n    try {\n        const result = await parse(resolvedPath, $refs, options);\n        // Crawl the parsed value\n        // console.log('Resolving $ref pointers in %s', withoutHash);\n        let promises = crawl(result, withoutHash + \"#\", $refs, options);\n        return Promise.all(promises);\n    } catch (err) {\n        if (!options.continueOnError || !isHandledError(err)) {\n            throw err;\n        }\n        if ($refs._$refs[withoutHash]) {\n            err.source = decodeURI(url.stripHash(path));\n            err.path = url.safePointerToPath(url.getHash(path));\n        }\n        return [];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3Jlc29sdmUtZXh0ZXJuYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQyxrRkFBTztBQUM1QixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQywwRkFBVztBQUNuQyxNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQyxzRkFBUztBQUMvQixNQUFNRyxNQUFNSCxtQkFBT0EsQ0FBQyw0RkFBWTtBQUNoQyxNQUFNLEVBQUVJLGNBQWMsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQyxrR0FBZTtBQUVsREssT0FBT0MsT0FBTyxHQUFHQztBQUVqQjs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTQSxnQkFBaUJDLE1BQU0sRUFBRUMsT0FBTztJQUN2QyxJQUFJLENBQUNBLFFBQVFDLE9BQU8sQ0FBQ0MsUUFBUSxFQUFFO1FBQzdCLG9DQUFvQztRQUNwQyxPQUFPQyxRQUFRRixPQUFPO0lBQ3hCO0lBRUEsSUFBSTtRQUNGLDZFQUE2RTtRQUM3RSxJQUFJRyxXQUFXQyxNQUFNTixPQUFPTyxNQUFNLEVBQUVQLE9BQU9RLEtBQUssQ0FBQ0MsU0FBUyxDQUFDQyxJQUFJLEdBQUcsS0FBS1YsT0FBT1EsS0FBSyxFQUFFUDtRQUNyRixPQUFPRyxRQUFRTyxHQUFHLENBQUNOO0lBQ3JCLEVBQ0EsT0FBT08sR0FBRztRQUNSLE9BQU9SLFFBQVFTLE1BQU0sQ0FBQ0Q7SUFDeEI7QUFDRjtBQUVBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0QsU0FBU04sTUFBT1EsR0FBRyxFQUFFSixJQUFJLEVBQUVGLEtBQUssRUFBRVAsT0FBTyxFQUFFYyxJQUFJO0lBQzdDQSxPQUFPQSxRQUFRLElBQUlDO0lBQ25CLElBQUlYLFdBQVcsRUFBRTtJQUVqQixJQUFJUyxPQUFPLE9BQU9BLFFBQVEsWUFBWSxDQUFDRyxZQUFZQyxNQUFNLENBQUNKLFFBQVEsQ0FBQ0MsS0FBS0ksR0FBRyxDQUFDTCxNQUFNO1FBQ2hGQyxLQUFLSyxHQUFHLENBQUNOLE1BQU0sNERBQTREO1FBQzNFLElBQUl2QixLQUFLOEIsY0FBYyxDQUFDUCxNQUFNO1lBQzVCVCxTQUFTaUIsSUFBSSxDQUFDQyxZQUFZVCxLQUFLSixNQUFNRixPQUFPUDtRQUM5QyxPQUNLO1lBQ0gsS0FBSyxJQUFJdUIsT0FBT0MsT0FBT0MsSUFBSSxDQUFDWixLQUFNO2dCQUNoQyxJQUFJYSxVQUFVbEMsUUFBUW1DLElBQUksQ0FBQ2xCLE1BQU1jO2dCQUNqQyxJQUFJSyxRQUFRZixHQUFHLENBQUNVLElBQUk7Z0JBRXBCLElBQUlqQyxLQUFLOEIsY0FBYyxDQUFDUSxRQUFRO29CQUM5QnhCLFNBQVNpQixJQUFJLENBQUNDLFlBQVlNLE9BQU9GLFNBQVNuQixPQUFPUDtnQkFDbkQsT0FDSztvQkFDSEksV0FBV0EsU0FBU3lCLE1BQU0sQ0FBQ3hCLE1BQU11QixPQUFPRixTQUFTbkIsT0FBT1AsU0FBU2M7Z0JBQ25FO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBT1Y7QUFDVDtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsZUFBZWtCLFlBQWFRLElBQUksRUFBRXJCLElBQUksRUFBRUYsS0FBSyxFQUFFUCxPQUFPO0lBQ3BELHFFQUFxRTtJQUVyRSxJQUFJK0IsZUFBZXJDLElBQUlPLE9BQU8sQ0FBQ1EsTUFBTXFCLEtBQUtBLElBQUk7SUFDOUMsSUFBSUUsY0FBY3RDLElBQUl1QyxTQUFTLENBQUNGO0lBRWhDLGdDQUFnQztJQUNoQ0QsT0FBT3ZCLE1BQU0yQixNQUFNLENBQUNGLFlBQVk7SUFDaEMsSUFBSUYsTUFBTTtRQUNSLDREQUE0RDtRQUM1RCxPQUFPM0IsUUFBUUYsT0FBTyxDQUFDNkIsS0FBS0YsS0FBSztJQUNuQztJQUVBLGlDQUFpQztJQUNqQyxJQUFJO1FBQ0YsTUFBTU8sU0FBUyxNQUFNMUMsTUFBTXNDLGNBQWN4QixPQUFPUDtRQUVoRCx5QkFBeUI7UUFDekIsNkRBQTZEO1FBQzdELElBQUlJLFdBQVdDLE1BQU04QixRQUFRSCxjQUFjLEtBQUt6QixPQUFPUDtRQUV2RCxPQUFPRyxRQUFRTyxHQUFHLENBQUNOO0lBQ3JCLEVBQ0EsT0FBT2dDLEtBQUs7UUFDVixJQUFJLENBQUNwQyxRQUFRcUMsZUFBZSxJQUFJLENBQUMxQyxlQUFleUMsTUFBTTtZQUNwRCxNQUFNQTtRQUNSO1FBRUEsSUFBSTdCLE1BQU0yQixNQUFNLENBQUNGLFlBQVksRUFBRTtZQUM3QkksSUFBSUUsTUFBTSxHQUFHQyxVQUFVN0MsSUFBSXVDLFNBQVMsQ0FBQ3hCO1lBQ3JDMkIsSUFBSTNCLElBQUksR0FBR2YsSUFBSThDLGlCQUFpQixDQUFDOUMsSUFBSStDLE9BQU8sQ0FBQ2hDO1FBQy9DO1FBRUEsT0FBTyxFQUFFO0lBQ1g7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25hbnRlcy1wdWJsaWMtZGF0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3Jlc29sdmUtZXh0ZXJuYWwuanM/NTRmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgJFJlZiA9IHJlcXVpcmUoXCIuL3JlZlwiKTtcbmNvbnN0IFBvaW50ZXIgPSByZXF1aXJlKFwiLi9wb2ludGVyXCIpO1xuY29uc3QgcGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzZVwiKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCIuL3V0aWwvdXJsXCIpO1xuY29uc3QgeyBpc0hhbmRsZWRFcnJvciB9ID0gcmVxdWlyZShcIi4vdXRpbC9lcnJvcnNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZUV4dGVybmFsO1xuXG4vKipcbiAqIENyYXdscyB0aGUgSlNPTiBzY2hlbWEsIGZpbmRzIGFsbCBleHRlcm5hbCBKU09OIHJlZmVyZW5jZXMsIGFuZCByZXNvbHZlcyB0aGVpciB2YWx1ZXMuXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBtdXRhdGUgdGhlIEpTT04gc2NoZW1hLiBUaGUgcmVzb2x2ZWQgdmFsdWVzIGFyZSBhZGRlZCB0byB7QGxpbmsgJFJlZlBhcnNlciMkcmVmc30uXG4gKlxuICogTk9URTogV2Ugb25seSBjYXJlIGFib3V0IEVYVEVSTkFMIHJlZmVyZW5jZXMgaGVyZS4gSU5URVJOQUwgcmVmZXJlbmNlcyBhcmUgb25seSByZWxldmFudCB3aGVuIGRlcmVmZXJlbmNpbmcuXG4gKlxuICogQHBhcmFtIHskUmVmUGFyc2VyfSBwYXJzZXJcbiAqIEBwYXJhbSB7JFJlZlBhcnNlck9wdGlvbnN9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqIFRoZSBwcm9taXNlIHJlc29sdmVzIG9uY2UgYWxsIEpTT04gcmVmZXJlbmNlcyBpbiB0aGUgc2NoZW1hIGhhdmUgYmVlbiByZXNvbHZlZCxcbiAqIGluY2x1ZGluZyBuZXN0ZWQgcmVmZXJlbmNlcyB0aGF0IGFyZSBjb250YWluZWQgaW4gZXh0ZXJuYWxseS1yZWZlcmVuY2VkIGZpbGVzLlxuICovXG5mdW5jdGlvbiByZXNvbHZlRXh0ZXJuYWwgKHBhcnNlciwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMucmVzb2x2ZS5leHRlcm5hbCkge1xuICAgIC8vIE5vdGhpbmcgdG8gcmVzb2x2ZSwgc28gZXhpdCBlYXJseVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Jlc29sdmluZyAkcmVmIHBvaW50ZXJzIGluICVzJywgcGFyc2VyLiRyZWZzLl9yb290JFJlZi5wYXRoKTtcbiAgICBsZXQgcHJvbWlzZXMgPSBjcmF3bChwYXJzZXIuc2NoZW1hLCBwYXJzZXIuJHJlZnMuX3Jvb3QkUmVmLnBhdGggKyBcIiNcIiwgcGFyc2VyLiRyZWZzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgY3Jhd2xzIHRoZSBnaXZlbiB2YWx1ZSwgYW5kIHJlc29sdmVzIGFueSBleHRlcm5hbCBKU09OIHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIHsqfSBvYmogLSBUaGUgdmFsdWUgdG8gY3Jhd2wuIElmIGl0J3Mgbm90IGFuIG9iamVjdCBvciBhcnJheSwgaXQgd2lsbCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgZnVsbCBwYXRoIG9mIGBvYmpgLCBwb3NzaWJseSB3aXRoIGEgSlNPTiBQb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0geyRSZWZzfSAkcmVmc1xuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICogQHBhcmFtIHtTZXR9IHNlZW4gLSBJbnRlcm5hbC5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZVtdfVxuICogUmV0dXJucyBhbiBhcnJheSBvZiBwcm9taXNlcy4gVGhlcmUgd2lsbCBiZSBvbmUgcHJvbWlzZSBmb3IgZWFjaCBKU09OIHJlZmVyZW5jZSBpbiBgb2JqYC5cbiAqIElmIGBvYmpgIGRvZXMgbm90IGNvbnRhaW4gYW55IEpTT04gcmVmZXJlbmNlcywgdGhlbiB0aGUgYXJyYXkgd2lsbCBiZSBlbXB0eS5cbiAqIElmIGFueSBvZiB0aGUgSlNPTiByZWZlcmVuY2VzIHBvaW50IHRvIGZpbGVzIHRoYXQgY29udGFpbiBhZGRpdGlvbmFsIEpTT04gcmVmZXJlbmNlcyxcbiAqIHRoZW4gdGhlIGNvcnJlc3BvbmRpbmcgcHJvbWlzZSB3aWxsIGludGVybmFsbHkgcmVmZXJlbmNlIGFuIGFycmF5IG9mIHByb21pc2VzLlxuICovXG5mdW5jdGlvbiBjcmF3bCAob2JqLCBwYXRoLCAkcmVmcywgb3B0aW9ucywgc2Vlbikge1xuICBzZWVuID0gc2VlbiB8fCBuZXcgU2V0KCk7XG4gIGxldCBwcm9taXNlcyA9IFtdO1xuXG4gIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgJiYgIXNlZW4uaGFzKG9iaikpIHtcbiAgICBzZWVuLmFkZChvYmopOyAvLyBUcmFjayBwcmV2aW91c2x5IHNlZW4gb2JqZWN0cyB0byBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb25cbiAgICBpZiAoJFJlZi5pc0V4dGVybmFsJFJlZihvYmopKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKHJlc29sdmUkUmVmKG9iaiwgcGF0aCwgJHJlZnMsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICBsZXQga2V5UGF0aCA9IFBvaW50ZXIuam9pbihwYXRoLCBrZXkpO1xuICAgICAgICBsZXQgdmFsdWUgPSBvYmpba2V5XTtcblxuICAgICAgICBpZiAoJFJlZi5pc0V4dGVybmFsJFJlZih2YWx1ZSkpIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHJlc29sdmUkUmVmKHZhbHVlLCBrZXlQYXRoLCAkcmVmcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHByb21pc2VzID0gcHJvbWlzZXMuY29uY2F0KGNyYXdsKHZhbHVlLCBrZXlQYXRoLCAkcmVmcywgb3B0aW9ucywgc2VlbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb21pc2VzO1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBnaXZlbiBKU09OIFJlZmVyZW5jZSwgYW5kIHRoZW4gY3Jhd2xzIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKlxuICogQHBhcmFtIHt7JHJlZjogc3RyaW5nfX0gJHJlZiAtIFRoZSBKU09OIFJlZmVyZW5jZSB0byByZXNvbHZlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBmdWxsIHBhdGggb2YgYCRyZWZgLCBwb3NzaWJseSB3aXRoIGEgSlNPTiBQb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0geyRSZWZzfSAkcmVmc1xuICogQHBhcmFtIHskUmVmUGFyc2VyT3B0aW9uc30gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgb25jZSBhbGwgSlNPTiByZWZlcmVuY2VzIGluIHRoZSBvYmplY3QgaGF2ZSBiZWVuIHJlc29sdmVkLFxuICogaW5jbHVkaW5nIG5lc3RlZCByZWZlcmVuY2VzIHRoYXQgYXJlIGNvbnRhaW5lZCBpbiBleHRlcm5hbGx5LXJlZmVyZW5jZWQgZmlsZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmUkUmVmICgkcmVmLCBwYXRoLCAkcmVmcywgb3B0aW9ucykge1xuICAvLyBjb25zb2xlLmxvZygnUmVzb2x2aW5nICRyZWYgcG9pbnRlciBcIiVzXCIgYXQgJXMnLCAkcmVmLiRyZWYsIHBhdGgpO1xuXG4gIGxldCByZXNvbHZlZFBhdGggPSB1cmwucmVzb2x2ZShwYXRoLCAkcmVmLiRyZWYpO1xuICBsZXQgd2l0aG91dEhhc2ggPSB1cmwuc3RyaXBIYXNoKHJlc29sdmVkUGF0aCk7XG5cbiAgLy8gRG8gd2UgYWxyZWFkeSBoYXZlIHRoaXMgJHJlZj9cbiAgJHJlZiA9ICRyZWZzLl8kcmVmc1t3aXRob3V0SGFzaF07XG4gIGlmICgkcmVmKSB7XG4gICAgLy8gV2UndmUgYWxyZWFkeSBwYXJzZWQgdGhpcyAkcmVmLCBzbyB1c2UgdGhlIGV4aXN0aW5nIHZhbHVlXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgkcmVmLnZhbHVlKTtcbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSAkcmVmZXJlbmNlZCBmaWxlL3VybFxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlKHJlc29sdmVkUGF0aCwgJHJlZnMsIG9wdGlvbnMpO1xuXG4gICAgLy8gQ3Jhd2wgdGhlIHBhcnNlZCB2YWx1ZVxuICAgIC8vIGNvbnNvbGUubG9nKCdSZXNvbHZpbmcgJHJlZiBwb2ludGVycyBpbiAlcycsIHdpdGhvdXRIYXNoKTtcbiAgICBsZXQgcHJvbWlzZXMgPSBjcmF3bChyZXN1bHQsIHdpdGhvdXRIYXNoICsgXCIjXCIsICRyZWZzLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIGlmICghb3B0aW9ucy5jb250aW51ZU9uRXJyb3IgfHwgIWlzSGFuZGxlZEVycm9yKGVycikpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpZiAoJHJlZnMuXyRyZWZzW3dpdGhvdXRIYXNoXSkge1xuICAgICAgZXJyLnNvdXJjZSA9IGRlY29kZVVSSSh1cmwuc3RyaXBIYXNoKHBhdGgpKTtcbiAgICAgIGVyci5wYXRoID0gdXJsLnNhZmVQb2ludGVyVG9QYXRoKHVybC5nZXRIYXNoKHBhdGgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyIkUmVmIiwicmVxdWlyZSIsIlBvaW50ZXIiLCJwYXJzZSIsInVybCIsImlzSGFuZGxlZEVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlc29sdmVFeHRlcm5hbCIsInBhcnNlciIsIm9wdGlvbnMiLCJyZXNvbHZlIiwiZXh0ZXJuYWwiLCJQcm9taXNlIiwicHJvbWlzZXMiLCJjcmF3bCIsInNjaGVtYSIsIiRyZWZzIiwiX3Jvb3QkUmVmIiwicGF0aCIsImFsbCIsImUiLCJyZWplY3QiLCJvYmoiLCJzZWVuIiwiU2V0IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJoYXMiLCJhZGQiLCJpc0V4dGVybmFsJFJlZiIsInB1c2giLCJyZXNvbHZlJFJlZiIsImtleSIsIk9iamVjdCIsImtleXMiLCJrZXlQYXRoIiwiam9pbiIsInZhbHVlIiwiY29uY2F0IiwiJHJlZiIsInJlc29sdmVkUGF0aCIsIndpdGhvdXRIYXNoIiwic3RyaXBIYXNoIiwiXyRyZWZzIiwicmVzdWx0IiwiZXJyIiwiY29udGludWVPbkVycm9yIiwic291cmNlIiwiZGVjb2RlVVJJIiwic2FmZVBvaW50ZXJUb1BhdGgiLCJnZXRIYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/resolve-external.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/file.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/file.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { ono } = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __webpack_require__(/*! ../util/url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\nconst { ResolverError } = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\");\nmodule.exports = {\n    /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */ order: 100,\n    /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */ canRead (file) {\n        return url.isFileSystemPath(file.url);\n    },\n    /**\n   * Reads the given file and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */ read (file) {\n        return new Promise((resolve, reject)=>{\n            let path;\n            try {\n                path = url.toFileSystemPath(file.url);\n            } catch (err) {\n                reject(new ResolverError(ono.uri(err, `Malformed URI: ${file.url}`), file.url));\n            }\n            // console.log('Opening file: %s', path);\n            try {\n                fs.readFile(path, (err, data)=>{\n                    if (err) {\n                        reject(new ResolverError(ono(err, `Error opening file \"${path}\"`), path));\n                    } else {\n                        resolve(data);\n                    }\n                });\n            } catch (err) {\n                reject(new ResolverError(ono(err, `Error opening file \"${path}\"`), path));\n            }\n        });\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3Jlc29sdmVycy9maWxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsTUFBTUEsS0FBS0MsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNLEVBQUVDLEdBQUcsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQywwRUFBaUI7QUFDekMsTUFBTUUsTUFBTUYsbUJBQU9BLENBQUMsNkZBQWE7QUFDakMsTUFBTSxFQUFFRyxhQUFhLEVBQUUsR0FBR0gsbUJBQU9BLENBQUMsbUdBQWdCO0FBRWxESSxPQUFPQyxPQUFPLEdBQUc7SUFDZjs7OztHQUlDLEdBQ0RDLE9BQU87SUFFUDs7Ozs7Ozs7O0dBU0MsR0FDREMsU0FBU0MsSUFBSTtRQUNYLE9BQU9OLElBQUlPLGdCQUFnQixDQUFDRCxLQUFLTixHQUFHO0lBQ3RDO0lBRUE7Ozs7Ozs7R0FPQyxHQUNEUSxNQUFNRixJQUFJO1FBQ1IsT0FBTyxJQUFJRyxRQUFTLENBQUNDLFNBQVNDO1lBQzVCLElBQUlDO1lBQ0osSUFBSTtnQkFDRkEsT0FBT1osSUFBSWEsZ0JBQWdCLENBQUNQLEtBQUtOLEdBQUc7WUFDdEMsRUFDQSxPQUFPYyxLQUFLO2dCQUNWSCxPQUFPLElBQUlWLGNBQWNGLElBQUlnQixHQUFHLENBQUNELEtBQUssQ0FBQyxlQUFlLEVBQUVSLEtBQUtOLEdBQUcsQ0FBQyxDQUFDLEdBQUdNLEtBQUtOLEdBQUc7WUFDL0U7WUFFQSx5Q0FBeUM7WUFFekMsSUFBSTtnQkFDRkgsR0FBR21CLFFBQVEsQ0FBQ0osTUFBTSxDQUFDRSxLQUFLRztvQkFDdEIsSUFBSUgsS0FBSzt3QkFDUEgsT0FBTyxJQUFJVixjQUFjRixJQUFJZSxLQUFLLENBQUMsb0JBQW9CLEVBQUVGLEtBQUssQ0FBQyxDQUFDLEdBQUdBO29CQUNyRSxPQUNLO3dCQUNIRixRQUFRTztvQkFDVjtnQkFDRjtZQUNGLEVBQ0EsT0FBT0gsS0FBSztnQkFDVkgsT0FBTyxJQUFJVixjQUFjRixJQUFJZSxLQUFLLENBQUMsb0JBQW9CLEVBQUVGLEtBQUssQ0FBQyxDQUFDLEdBQUdBO1lBQ3JFO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvcmVzb2x2ZXJzL2ZpbGUuanM/MDM3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgeyBvbm8gfSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwiLi4vdXRpbC91cmxcIik7XG5jb25zdCB7IFJlc29sdmVyRXJyb3IgfSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9yc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBUaGUgb3JkZXIgdGhhdCB0aGlzIHJlc29sdmVyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciByZXNvbHZlcnMuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBvcmRlcjogMTAwLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyByZXNvbHZlciBjYW4gcmVhZCBhIGdpdmVuIGZpbGUgcmVmZXJlbmNlLlxuICAgKiBSZXNvbHZlcnMgdGhhdCByZXR1cm4gdHJ1ZSB3aWxsIGJlIHRyaWVkLCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSByZXNvbHZlcyB0aGUgZmlsZS5cbiAgICogUmVzb2x2ZXJzIHRoYXQgcmV0dXJuIGZhbHNlIHdpbGwgbm90IGJlIGdpdmVuIGEgY2hhbmNlIHRvIHJlc29sdmUgdGhlIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlICAgICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUuZXh0ZW5zaW9uIC0gVGhlIGxvd2VyY2FzZWQgZmlsZSBleHRlbnNpb24gKGUuZy4gXCIudHh0XCIsIFwiLmh0bWxcIiwgZXRjLilcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjYW5SZWFkIChmaWxlKSB7XG4gICAgcmV0dXJuIHVybC5pc0ZpbGVTeXN0ZW1QYXRoKGZpbGUudXJsKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgdGhlIGdpdmVuIGZpbGUgYW5kIHJldHVybnMgaXRzIHJhdyBjb250ZW50cyBhcyBhIEJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGZpbGUgICAgICAgICAgIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZS51cmwgICAgICAgLSBUaGUgZnVsbCBVUkwgb2YgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZS5leHRlbnNpb24gLSBUaGUgbG93ZXJjYXNlZCBmaWxlIGV4dGVuc2lvbiAoZS5nLiBcIi50eHRcIiwgXCIuaHRtbFwiLCBldGMuKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fVxuICAgKi9cbiAgcmVhZCAoZmlsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHBhdGg7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gdXJsLnRvRmlsZVN5c3RlbVBhdGgoZmlsZS51cmwpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QobmV3IFJlc29sdmVyRXJyb3Iob25vLnVyaShlcnIsIGBNYWxmb3JtZWQgVVJJOiAke2ZpbGUudXJsfWApLCBmaWxlLnVybCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmxvZygnT3BlbmluZyBmaWxlOiAlcycsIHBhdGgpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmcy5yZWFkRmlsZShwYXRoLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBSZXNvbHZlckVycm9yKG9ubyhlcnIsIGBFcnJvciBvcGVuaW5nIGZpbGUgXCIke3BhdGh9XCJgKSwgcGF0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBSZXNvbHZlckVycm9yKG9ubyhlcnIsIGBFcnJvciBvcGVuaW5nIGZpbGUgXCIke3BhdGh9XCJgKSwgcGF0aCkpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJvbm8iLCJ1cmwiLCJSZXNvbHZlckVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsIm9yZGVyIiwiY2FuUmVhZCIsImZpbGUiLCJpc0ZpbGVTeXN0ZW1QYXRoIiwicmVhZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicGF0aCIsInRvRmlsZVN5c3RlbVBhdGgiLCJlcnIiLCJ1cmkiLCJyZWFkRmlsZSIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/http.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/http.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst { ono } = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __webpack_require__(/*! ../util/url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\nconst { ResolverError } = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\");\nmodule.exports = {\n    /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */ order: 200,\n    /**\n   * HTTP headers to send when downloading files.\n   *\n   * @example:\n   * {\n   *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n   *   Accept: \"application/json\"\n   * }\n   *\n   * @type {object}\n   */ headers: null,\n    /**\n   * HTTP request timeout (in milliseconds).\n   *\n   * @type {number}\n   */ timeout: 5000,\n    /**\n   * The maximum number of HTTP redirects to follow.\n   * To disable automatic following of redirects, set this to zero.\n   *\n   * @type {number}\n   */ redirects: 5,\n    /**\n   * The `withCredentials` option of XMLHttpRequest.\n   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n   *\n   * @type {boolean}\n   */ withCredentials: false,\n    /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */ canRead (file) {\n        return url.isHttp(file.url);\n    },\n    /**\n   * Reads the given URL and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */ read (file) {\n        let u = url.parse(file.url);\n        if (false) {}\n        return download(u, this);\n    }\n};\n/**\n * Downloads the given file.\n *\n * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)\n * @param {object} httpOptions  - The `options.resolve.http` object\n * @param {number} [redirects]  - The redirect URLs that have already been followed\n *\n * @returns {Promise<Buffer>}\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */ function download(u, httpOptions, redirects) {\n    return new Promise((resolve, reject)=>{\n        u = url.parse(u);\n        redirects = redirects || [];\n        redirects.push(u.href);\n        get(u, httpOptions).then((res)=>{\n            if (res.statusCode >= 400) {\n                throw ono({\n                    status: res.statusCode\n                }, `HTTP ERROR ${res.statusCode}`);\n            } else if (res.statusCode >= 300) {\n                if (redirects.length > httpOptions.redirects) {\n                    reject(new ResolverError(ono({\n                        status: res.statusCode\n                    }, `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`)));\n                } else if (!res.headers.location) {\n                    throw ono({\n                        status: res.statusCode\n                    }, `HTTP ${res.statusCode} redirect with no location header`);\n                } else {\n                    // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);\n                    let redirectTo = url.resolve(u, res.headers.location);\n                    download(redirectTo, httpOptions, redirects).then(resolve, reject);\n                }\n            } else {\n                resolve(res.body || Buffer.alloc(0));\n            }\n        }).catch((err)=>{\n            reject(new ResolverError(ono(err, `Error downloading ${u.href}`), u.href));\n        });\n    });\n}\n/**\n * Sends an HTTP GET request.\n *\n * @param {Url} u - A parsed {@link Url} object\n * @param {object} httpOptions - The `options.resolve.http` object\n *\n * @returns {Promise<Response>}\n * The promise resolves with the HTTP Response object.\n */ function get(u, httpOptions) {\n    return new Promise((resolve, reject)=>{\n        // console.log('GET', u.href);\n        let protocol = u.protocol === \"https:\" ? https : http;\n        let req = protocol.get({\n            hostname: u.hostname,\n            port: u.port,\n            path: u.path,\n            auth: u.auth,\n            protocol: u.protocol,\n            headers: httpOptions.headers || {},\n            withCredentials: httpOptions.withCredentials\n        });\n        if (typeof req.setTimeout === \"function\") {\n            req.setTimeout(httpOptions.timeout);\n        }\n        req.on(\"timeout\", ()=>{\n            req.abort();\n        });\n        req.on(\"error\", reject);\n        req.once(\"response\", (res)=>{\n            res.body = Buffer.alloc(0);\n            res.on(\"data\", (data)=>{\n                res.body = Buffer.concat([\n                    res.body,\n                    Buffer.from(data)\n                ]);\n            });\n            res.on(\"error\", reject);\n            res.on(\"end\", ()=>{\n                resolve(res);\n            });\n        });\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3Jlc29sdmVycy9odHRwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUMsa0JBQU07QUFDM0IsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsb0JBQU87QUFDN0IsTUFBTSxFQUFFRSxHQUFHLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMsMEVBQWlCO0FBQ3pDLE1BQU1HLE1BQU1ILG1CQUFPQSxDQUFDLDZGQUFhO0FBQ2pDLE1BQU0sRUFBRUksYUFBYSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDLG1HQUFnQjtBQUVsREssT0FBT0MsT0FBTyxHQUFHO0lBQ2Y7Ozs7R0FJQyxHQUNEQyxPQUFPO0lBRVA7Ozs7Ozs7Ozs7R0FVQyxHQUNEQyxTQUFTO0lBRVQ7Ozs7R0FJQyxHQUNEQyxTQUFTO0lBRVQ7Ozs7O0dBS0MsR0FDREMsV0FBVztJQUVYOzs7OztHQUtDLEdBQ0RDLGlCQUFpQjtJQUVqQjs7Ozs7Ozs7O0dBU0MsR0FDREMsU0FBU0MsSUFBSTtRQUNYLE9BQU9WLElBQUlXLE1BQU0sQ0FBQ0QsS0FBS1YsR0FBRztJQUM1QjtJQUVBOzs7Ozs7O0dBT0MsR0FDRFksTUFBTUYsSUFBSTtRQUNSLElBQUlHLElBQUliLElBQUljLEtBQUssQ0FBQ0osS0FBS1YsR0FBRztRQUUxQixJQUFJZSxLQUE4QixFQUFFLEVBR25DO1FBRUQsT0FBT0ssU0FBU1AsR0FBRyxJQUFJO0lBQ3pCO0FBQ0Y7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTTyxTQUFVUCxDQUFDLEVBQUVRLFdBQVcsRUFBRWQsU0FBUztJQUMxQyxPQUFPLElBQUllLFFBQVMsQ0FBQ0MsU0FBU0M7UUFDNUJYLElBQUliLElBQUljLEtBQUssQ0FBQ0Q7UUFDZE4sWUFBWUEsYUFBYSxFQUFFO1FBQzNCQSxVQUFVa0IsSUFBSSxDQUFDWixFQUFFTSxJQUFJO1FBRXJCTyxJQUFJYixHQUFHUSxhQUNKTSxJQUFJLENBQUMsQ0FBQ0M7WUFDTCxJQUFJQSxJQUFJQyxVQUFVLElBQUksS0FBSztnQkFDekIsTUFBTTlCLElBQUk7b0JBQUUrQixRQUFRRixJQUFJQyxVQUFVO2dCQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUVELElBQUlDLFVBQVUsQ0FBQyxDQUFDO1lBQ3RFLE9BQ0ssSUFBSUQsSUFBSUMsVUFBVSxJQUFJLEtBQUs7Z0JBQzlCLElBQUl0QixVQUFVd0IsTUFBTSxHQUFHVixZQUFZZCxTQUFTLEVBQUU7b0JBQzVDaUIsT0FBTyxJQUFJdkIsY0FBY0YsSUFBSTt3QkFBRStCLFFBQVFGLElBQUlDLFVBQVU7b0JBQUMsR0FDcEQsQ0FBQyxrQkFBa0IsRUFBRXRCLFNBQVMsQ0FBQyxFQUFFLENBQUMsNEJBQTRCLEVBQUVBLFVBQVV5QixJQUFJLENBQUMsU0FBUyxDQUFDO2dCQUM3RixPQUNLLElBQUksQ0FBQ0osSUFBSXZCLE9BQU8sQ0FBQ2EsUUFBUSxFQUFFO29CQUM5QixNQUFNbkIsSUFBSTt3QkFBRStCLFFBQVFGLElBQUlDLFVBQVU7b0JBQUMsR0FBRyxDQUFDLEtBQUssRUFBRUQsSUFBSUMsVUFBVSxDQUFDLGlDQUFpQyxDQUFDO2dCQUNqRyxPQUNLO29CQUNILDBGQUEwRjtvQkFDMUYsSUFBSUksYUFBYWpDLElBQUl1QixPQUFPLENBQUNWLEdBQUdlLElBQUl2QixPQUFPLENBQUNhLFFBQVE7b0JBQ3BERSxTQUFTYSxZQUFZWixhQUFhZCxXQUFXb0IsSUFBSSxDQUFDSixTQUFTQztnQkFDN0Q7WUFDRixPQUNLO2dCQUNIRCxRQUFRSyxJQUFJTSxJQUFJLElBQUlDLE9BQU9DLEtBQUssQ0FBQztZQUNuQztRQUNGLEdBQ0NDLEtBQUssQ0FBQyxDQUFDQztZQUNOZCxPQUFPLElBQUl2QixjQUFjRixJQUFJdUMsS0FBSyxDQUFDLGtCQUFrQixFQUFFekIsRUFBRU0sSUFBSSxDQUFDLENBQUMsR0FBR04sRUFBRU0sSUFBSTtRQUMxRTtJQUNKO0FBQ0Y7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNPLElBQUtiLENBQUMsRUFBRVEsV0FBVztJQUMxQixPQUFPLElBQUlDLFFBQVMsQ0FBQ0MsU0FBU0M7UUFDNUIsOEJBQThCO1FBRTlCLElBQUlQLFdBQVdKLEVBQUVJLFFBQVEsS0FBSyxXQUFXbkIsUUFBUUY7UUFDakQsSUFBSTJDLE1BQU10QixTQUFTUyxHQUFHLENBQUM7WUFDckJjLFVBQVUzQixFQUFFMkIsUUFBUTtZQUNwQkMsTUFBTTVCLEVBQUU0QixJQUFJO1lBQ1pDLE1BQU03QixFQUFFNkIsSUFBSTtZQUNaQyxNQUFNOUIsRUFBRThCLElBQUk7WUFDWjFCLFVBQVVKLEVBQUVJLFFBQVE7WUFDcEJaLFNBQVNnQixZQUFZaEIsT0FBTyxJQUFJLENBQUM7WUFDakNHLGlCQUFpQmEsWUFBWWIsZUFBZTtRQUM5QztRQUVBLElBQUksT0FBTytCLElBQUlLLFVBQVUsS0FBSyxZQUFZO1lBQ3hDTCxJQUFJSyxVQUFVLENBQUN2QixZQUFZZixPQUFPO1FBQ3BDO1FBRUFpQyxJQUFJTSxFQUFFLENBQUMsV0FBVztZQUNoQk4sSUFBSU8sS0FBSztRQUNYO1FBRUFQLElBQUlNLEVBQUUsQ0FBQyxTQUFTckI7UUFFaEJlLElBQUlRLElBQUksQ0FBQyxZQUFZLENBQUNuQjtZQUNwQkEsSUFBSU0sSUFBSSxHQUFHQyxPQUFPQyxLQUFLLENBQUM7WUFFeEJSLElBQUlpQixFQUFFLENBQUMsUUFBUSxDQUFDRztnQkFDZHBCLElBQUlNLElBQUksR0FBR0MsT0FBT2MsTUFBTSxDQUFDO29CQUFDckIsSUFBSU0sSUFBSTtvQkFBRUMsT0FBT2UsSUFBSSxDQUFDRjtpQkFBTTtZQUN4RDtZQUVBcEIsSUFBSWlCLEVBQUUsQ0FBQyxTQUFTckI7WUFFaEJJLElBQUlpQixFQUFFLENBQUMsT0FBTztnQkFDWnRCLFFBQVFLO1lBQ1Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2xpYi9yZXNvbHZlcnMvaHR0cC5qcz83YTgxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbmNvbnN0IHsgb25vIH0gPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgdXJsID0gcmVxdWlyZShcIi4uL3V0aWwvdXJsXCIpO1xuY29uc3QgeyBSZXNvbHZlckVycm9yIH0gPSByZXF1aXJlKFwiLi4vdXRpbC9lcnJvcnNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVGhlIG9yZGVyIHRoYXQgdGhpcyByZXNvbHZlciB3aWxsIHJ1biwgaW4gcmVsYXRpb24gdG8gb3RoZXIgcmVzb2x2ZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgb3JkZXI6IDIwMCxcblxuICAvKipcbiAgICogSFRUUCBoZWFkZXJzIHRvIHNlbmQgd2hlbiBkb3dubG9hZGluZyBmaWxlcy5cbiAgICpcbiAgICogQGV4YW1wbGU6XG4gICAqIHtcbiAgICogICBcIlVzZXItQWdlbnRcIjogXCJKU09OIFNjaGVtYSAkUmVmIFBhcnNlclwiLFxuICAgKiAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICogfVxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cbiAgaGVhZGVyczogbnVsbCxcblxuICAvKipcbiAgICogSFRUUCByZXF1ZXN0IHRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aW1lb3V0OiA1MDAwLCAvLyA1IHNlY29uZHNcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIEhUVFAgcmVkaXJlY3RzIHRvIGZvbGxvdy5cbiAgICogVG8gZGlzYWJsZSBhdXRvbWF0aWMgZm9sbG93aW5nIG9mIHJlZGlyZWN0cywgc2V0IHRoaXMgdG8gemVyby5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHJlZGlyZWN0czogNSxcblxuICAvKipcbiAgICogVGhlIGB3aXRoQ3JlZGVudGlhbHNgIG9wdGlvbiBvZiBYTUxIdHRwUmVxdWVzdC5cbiAgICogU2V0IHRoaXMgdG8gYHRydWVgIGlmIHlvdSdyZSBkb3dubG9hZGluZyBmaWxlcyBmcm9tIGEgQ09SUy1lbmFibGVkIHNlcnZlciB0aGF0IHJlcXVpcmVzIGF1dGhlbnRpY2F0aW9uXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgcmVzb2x2ZXIgY2FuIHJlYWQgYSBnaXZlbiBmaWxlIHJlZmVyZW5jZS5cbiAgICogUmVzb2x2ZXJzIHRoYXQgcmV0dXJuIHRydWUgd2lsbCBiZSB0cmllZCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSByZXNvbHZlcyB0aGUgZmlsZS5cbiAgICogUmVzb2x2ZXJzIHRoYXQgcmV0dXJuIGZhbHNlIHdpbGwgbm90IGJlIGdpdmVuIGEgY2hhbmNlIHRvIHJlc29sdmUgdGhlIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlICAgICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUuZXh0ZW5zaW9uIC0gVGhlIGxvd2VyY2FzZWQgZmlsZSBleHRlbnNpb24gKGUuZy4gXCIudHh0XCIsIFwiLmh0bWxcIiwgZXRjLilcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjYW5SZWFkIChmaWxlKSB7XG4gICAgcmV0dXJuIHVybC5pc0h0dHAoZmlsZS51cmwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZ2l2ZW4gVVJMIGFuZCByZXR1cm5zIGl0cyByYXcgY29udGVudHMgYXMgYSBCdWZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlICAgICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUuZXh0ZW5zaW9uIC0gVGhlIGxvd2VyY2FzZWQgZmlsZSBleHRlbnNpb24gKGUuZy4gXCIudHh0XCIsIFwiLmh0bWxcIiwgZXRjLilcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn1cbiAgICovXG4gIHJlYWQgKGZpbGUpIHtcbiAgICBsZXQgdSA9IHVybC5wYXJzZShmaWxlLnVybCk7XG5cbiAgICBpZiAocHJvY2Vzcy5icm93c2VyICYmICF1LnByb3RvY29sKSB7XG4gICAgICAvLyBVc2UgdGhlIHByb3RvY29sIG9mIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgIHUucHJvdG9jb2wgPSB1cmwucGFyc2UobG9jYXRpb24uaHJlZikucHJvdG9jb2w7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvd25sb2FkKHUsIHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIERvd25sb2FkcyB0aGUgZ2l2ZW4gZmlsZS5cbiAqXG4gKiBAcGFyYW0ge1VybHxzdHJpbmd9IHUgICAgICAgIC0gVGhlIHVybCB0byBkb3dubG9hZCAoY2FuIGJlIGEgcGFyc2VkIHtAbGluayBVcmx9IG9iamVjdClcbiAqIEBwYXJhbSB7b2JqZWN0fSBodHRwT3B0aW9ucyAgLSBUaGUgYG9wdGlvbnMucmVzb2x2ZS5odHRwYCBvYmplY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmVkaXJlY3RzXSAgLSBUaGUgcmVkaXJlY3QgVVJMcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGZvbGxvd2VkXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn1cbiAqIFRoZSBwcm9taXNlIHJlc29sdmVzIHdpdGggdGhlIHJhdyBkb3dubG9hZGVkIGRhdGEsIG9yIHJlamVjdHMgaWYgdGhlcmUgaXMgYW4gSFRUUCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gZG93bmxvYWQgKHUsIGh0dHBPcHRpb25zLCByZWRpcmVjdHMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdSA9IHVybC5wYXJzZSh1KTtcbiAgICByZWRpcmVjdHMgPSByZWRpcmVjdHMgfHwgW107XG4gICAgcmVkaXJlY3RzLnB1c2godS5ocmVmKTtcblxuICAgIGdldCh1LCBodHRwT3B0aW9ucylcbiAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgIHRocm93IG9ubyh7IHN0YXR1czogcmVzLnN0YXR1c0NvZGUgfSwgYEhUVFAgRVJST1IgJHtyZXMuc3RhdHVzQ29kZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXMuc3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICAgICAgICBpZiAocmVkaXJlY3RzLmxlbmd0aCA+IGh0dHBPcHRpb25zLnJlZGlyZWN0cykge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBSZXNvbHZlckVycm9yKG9ubyh7IHN0YXR1czogcmVzLnN0YXR1c0NvZGUgfSxcbiAgICAgICAgICAgICAgYEVycm9yIGRvd25sb2FkaW5nICR7cmVkaXJlY3RzWzBdfS4gXFxuVG9vIG1hbnkgcmVkaXJlY3RzOiBcXG4gICR7cmVkaXJlY3RzLmpvaW4oXCIgXFxuICBcIil9YCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIXJlcy5oZWFkZXJzLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBvbm8oeyBzdGF0dXM6IHJlcy5zdGF0dXNDb2RlIH0sIGBIVFRQICR7cmVzLnN0YXR1c0NvZGV9IHJlZGlyZWN0IHdpdGggbm8gbG9jYXRpb24gaGVhZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0hUVFAgJWQgcmVkaXJlY3QgJXMgLT4gJXMnLCByZXMuc3RhdHVzQ29kZSwgdS5ocmVmLCByZXMuaGVhZGVycy5sb2NhdGlvbik7XG4gICAgICAgICAgICBsZXQgcmVkaXJlY3RUbyA9IHVybC5yZXNvbHZlKHUsIHJlcy5oZWFkZXJzLmxvY2F0aW9uKTtcbiAgICAgICAgICAgIGRvd25sb2FkKHJlZGlyZWN0VG8sIGh0dHBPcHRpb25zLCByZWRpcmVjdHMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXMuYm9keSB8fCBCdWZmZXIuYWxsb2MoMCkpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBSZXNvbHZlckVycm9yKG9ubyhlcnIsIGBFcnJvciBkb3dubG9hZGluZyAke3UuaHJlZn1gKSwgdS5ocmVmKSk7XG4gICAgICB9KTtcbiAgfSkpO1xufVxuXG4vKipcbiAqIFNlbmRzIGFuIEhUVFAgR0VUIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtVcmx9IHUgLSBBIHBhcnNlZCB7QGxpbmsgVXJsfSBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBodHRwT3B0aW9ucyAtIFRoZSBgb3B0aW9ucy5yZXNvbHZlLmh0dHBgIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAqIFRoZSBwcm9taXNlIHJlc29sdmVzIHdpdGggdGhlIEhUVFAgUmVzcG9uc2Ugb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXQgKHUsIGh0dHBPcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdHRVQnLCB1LmhyZWYpO1xuXG4gICAgbGV0IHByb3RvY29sID0gdS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IGh0dHBzIDogaHR0cDtcbiAgICBsZXQgcmVxID0gcHJvdG9jb2wuZ2V0KHtcbiAgICAgIGhvc3RuYW1lOiB1Lmhvc3RuYW1lLFxuICAgICAgcG9ydDogdS5wb3J0LFxuICAgICAgcGF0aDogdS5wYXRoLFxuICAgICAgYXV0aDogdS5hdXRoLFxuICAgICAgcHJvdG9jb2w6IHUucHJvdG9jb2wsXG4gICAgICBoZWFkZXJzOiBodHRwT3B0aW9ucy5oZWFkZXJzIHx8IHt9LFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBodHRwT3B0aW9ucy53aXRoQ3JlZGVudGlhbHNcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgcmVxLnNldFRpbWVvdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmVxLnNldFRpbWVvdXQoaHR0cE9wdGlvbnMudGltZW91dCk7XG4gICAgfVxuXG4gICAgcmVxLm9uKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICByZXEuYWJvcnQoKTtcbiAgICB9KTtcblxuICAgIHJlcS5vbihcImVycm9yXCIsIHJlamVjdCk7XG5cbiAgICByZXEub25jZShcInJlc3BvbnNlXCIsIChyZXMpID0+IHtcbiAgICAgIHJlcy5ib2R5ID0gQnVmZmVyLmFsbG9jKDApO1xuXG4gICAgICByZXMub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICAgIHJlcy5ib2R5ID0gQnVmZmVyLmNvbmNhdChbcmVzLmJvZHksIEJ1ZmZlci5mcm9tKGRhdGEpXSk7XG4gICAgICB9KTtcblxuICAgICAgcmVzLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcblxuICAgICAgcmVzLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pKTtcbn1cbiJdLCJuYW1lcyI6WyJodHRwIiwicmVxdWlyZSIsImh0dHBzIiwib25vIiwidXJsIiwiUmVzb2x2ZXJFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJvcmRlciIsImhlYWRlcnMiLCJ0aW1lb3V0IiwicmVkaXJlY3RzIiwid2l0aENyZWRlbnRpYWxzIiwiY2FuUmVhZCIsImZpbGUiLCJpc0h0dHAiLCJyZWFkIiwidSIsInBhcnNlIiwicHJvY2VzcyIsImJyb3dzZXIiLCJwcm90b2NvbCIsImxvY2F0aW9uIiwiaHJlZiIsImRvd25sb2FkIiwiaHR0cE9wdGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInB1c2giLCJnZXQiLCJ0aGVuIiwicmVzIiwic3RhdHVzQ29kZSIsInN0YXR1cyIsImxlbmd0aCIsImpvaW4iLCJyZWRpcmVjdFRvIiwiYm9keSIsIkJ1ZmZlciIsImFsbG9jIiwiY2F0Y2giLCJlcnIiLCJyZXEiLCJob3N0bmFtZSIsInBvcnQiLCJwYXRoIiwiYXV0aCIsInNldFRpbWVvdXQiLCJvbiIsImFib3J0Iiwib25jZSIsImRhdGEiLCJjb25jYXQiLCJmcm9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/http.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst { Ono } = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst { stripHash, toFileSystemPath } = __webpack_require__(/*! ./url */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\");\nconst JSONParserError = exports.JSONParserError = class JSONParserError extends Error {\n    constructor(message, source){\n        super();\n        this.code = \"EUNKNOWN\";\n        this.message = message;\n        this.source = source;\n        this.path = null;\n        Ono.extend(this);\n    }\n    get footprint() {\n        return `${this.path}+${this.source}+${this.code}+${this.message}`;\n    }\n};\nsetErrorName(JSONParserError);\nconst JSONParserErrorGroup = exports.JSONParserErrorGroup = class JSONParserErrorGroup extends Error {\n    constructor(parser){\n        super();\n        this.files = parser;\n        this.message = `${this.errors.length} error${this.errors.length > 1 ? \"s\" : \"\"} occurred while reading '${toFileSystemPath(parser.$refs._root$Ref.path)}'`;\n        Ono.extend(this);\n    }\n    static getParserErrors(parser) {\n        const errors = [];\n        for (const $ref of Object.values(parser.$refs._$refs)){\n            if ($ref.errors) {\n                errors.push(...$ref.errors);\n            }\n        }\n        return errors;\n    }\n    get errors() {\n        return JSONParserErrorGroup.getParserErrors(this.files);\n    }\n};\nsetErrorName(JSONParserErrorGroup);\nconst ParserError = exports.ParserError = class ParserError extends JSONParserError {\n    constructor(message, source){\n        super(`Error parsing ${source}: ${message}`, source);\n        this.code = \"EPARSER\";\n    }\n};\nsetErrorName(ParserError);\nconst UnmatchedParserError = exports.UnmatchedParserError = class UnmatchedParserError extends JSONParserError {\n    constructor(source){\n        super(`Could not find parser for \"${source}\"`, source);\n        this.code = \"EUNMATCHEDPARSER\";\n    }\n};\nsetErrorName(UnmatchedParserError);\nconst ResolverError = exports.ResolverError = class ResolverError extends JSONParserError {\n    constructor(ex, source){\n        super(ex.message || `Error reading file \"${source}\"`, source);\n        this.code = \"ERESOLVER\";\n        if (\"code\" in ex) {\n            this.ioErrorCode = String(ex.code);\n        }\n    }\n};\nsetErrorName(ResolverError);\nconst UnmatchedResolverError = exports.UnmatchedResolverError = class UnmatchedResolverError extends JSONParserError {\n    constructor(source){\n        super(`Could not find resolver for \"${source}\"`, source);\n        this.code = \"EUNMATCHEDRESOLVER\";\n    }\n};\nsetErrorName(UnmatchedResolverError);\nconst MissingPointerError = exports.MissingPointerError = class MissingPointerError extends JSONParserError {\n    constructor(token, path){\n        super(`Token \"${token}\" does not exist.`, stripHash(path));\n        this.code = \"EMISSINGPOINTER\";\n    }\n};\nsetErrorName(MissingPointerError);\nconst InvalidPointerError = exports.InvalidPointerError = class InvalidPointerError extends JSONParserError {\n    constructor(pointer, path){\n        super(`Invalid $ref pointer \"${pointer}\". Pointers must begin with \"#/\"`, stripHash(path));\n        this.code = \"EINVALIDPOINTER\";\n    }\n};\nsetErrorName(InvalidPointerError);\nfunction setErrorName(err) {\n    Object.defineProperty(err.prototype, \"name\", {\n        value: err.name,\n        enumerable: true\n    });\n}\nexports.isHandledError = function(err) {\n    return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;\n};\nexports.normalizeError = function(err) {\n    if (err.path === null) {\n        err.path = [];\n    }\n    return err;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3V0aWwvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsTUFBTSxFQUFFQSxHQUFHLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsMEVBQWlCO0FBRXpDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxnQkFBZ0IsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQyx1RkFBTztBQUV2RCxNQUFNRyxrQkFBa0JDLHVCQUF1QixHQUFHLE1BQU1ELHdCQUF3QkU7SUFDOUVDLFlBQWFDLE9BQU8sRUFBRUMsTUFBTSxDQUFFO1FBQzVCLEtBQUs7UUFFTCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0YsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBRVpYLElBQUlZLE1BQU0sQ0FBQyxJQUFJO0lBQ2pCO0lBRUEsSUFBSUMsWUFBYTtRQUNmLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQ0YsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNGLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ0YsT0FBTyxDQUFDLENBQUM7SUFDbkU7QUFDRjtBQUVBTSxhQUFhVjtBQUViLE1BQU1XLHVCQUF1QlYsNEJBQTRCLEdBQUcsTUFBTVUsNkJBQTZCVDtJQUM3RkMsWUFBYVMsTUFBTSxDQUFFO1FBQ25CLEtBQUs7UUFFTCxJQUFJLENBQUNDLEtBQUssR0FBR0Q7UUFDYixJQUFJLENBQUNSLE9BQU8sR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDVSxNQUFNLENBQUNDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDRCxNQUFNLENBQUNDLE1BQU0sR0FBRyxJQUFJLE1BQU0sR0FBRyx5QkFBeUIsRUFBRWhCLGlCQUFpQmEsT0FBT0ksS0FB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QUFHO0lBQ3BDLElBQUlBLElBQUk1QixJQUFJLEtBQUssTUFBTTtRQUNyQjRCLElBQUk1QixJQUFJLEdBQUcsRUFBRTtJQUNmO0lBRUEsT0FBTzRCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2xpYi91dGlsL2Vycm9ycy5qcz9hOTA1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB7IE9ubyB9ID0gcmVxdWlyZShcIkBqc2RldnRvb2xzL29ub1wiKTtcblxuY29uc3QgeyBzdHJpcEhhc2gsIHRvRmlsZVN5c3RlbVBhdGggfSA9IHJlcXVpcmUoXCIuL3VybFwiKTtcblxuY29uc3QgSlNPTlBhcnNlckVycm9yID0gZXhwb3J0cy5KU09OUGFyc2VyRXJyb3IgPSBjbGFzcyBKU09OUGFyc2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBzb3VyY2UpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5jb2RlID0gXCJFVU5LTk9XTlwiO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5wYXRoID0gbnVsbDtcblxuICAgIE9uby5leHRlbmQodGhpcyk7XG4gIH1cblxuICBnZXQgZm9vdHByaW50ICgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5wYXRofSske3RoaXMuc291cmNlfSske3RoaXMuY29kZX0rJHt0aGlzLm1lc3NhZ2V9YDtcbiAgfVxufTtcblxuc2V0RXJyb3JOYW1lKEpTT05QYXJzZXJFcnJvcik7XG5cbmNvbnN0IEpTT05QYXJzZXJFcnJvckdyb3VwID0gZXhwb3J0cy5KU09OUGFyc2VyRXJyb3JHcm91cCA9IGNsYXNzIEpTT05QYXJzZXJFcnJvckdyb3VwIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAocGFyc2VyKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZmlsZXMgPSBwYXJzZXI7XG4gICAgdGhpcy5tZXNzYWdlID0gYCR7dGhpcy5lcnJvcnMubGVuZ3RofSBlcnJvciR7dGhpcy5lcnJvcnMubGVuZ3RoID4gMSA/IFwic1wiIDogXCJcIn0gb2NjdXJyZWQgd2hpbGUgcmVhZGluZyAnJHt0b0ZpbGVTeXN0ZW1QYXRoKHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCl9J2A7XG5cbiAgICBPbm8uZXh0ZW5kKHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIGdldFBhcnNlckVycm9ycyAocGFyc2VyKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICBmb3IgKGNvbnN0ICRyZWYgb2YgT2JqZWN0LnZhbHVlcyhwYXJzZXIuJHJlZnMuXyRyZWZzKSkge1xuICAgICAgaWYgKCRyZWYuZXJyb3JzKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKC4uLiRyZWYuZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgZ2V0IGVycm9ycyAoKSB7XG4gICAgcmV0dXJuIEpTT05QYXJzZXJFcnJvckdyb3VwLmdldFBhcnNlckVycm9ycyh0aGlzLmZpbGVzKTtcbiAgfVxufTtcblxuc2V0RXJyb3JOYW1lKEpTT05QYXJzZXJFcnJvckdyb3VwKTtcblxuY29uc3QgUGFyc2VyRXJyb3IgPSBleHBvcnRzLlBhcnNlckVycm9yID0gY2xhc3MgUGFyc2VyRXJyb3IgZXh0ZW5kcyBKU09OUGFyc2VyRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc291cmNlKSB7XG4gICAgc3VwZXIoYEVycm9yIHBhcnNpbmcgJHtzb3VyY2V9OiAke21lc3NhZ2V9YCwgc291cmNlKTtcblxuICAgIHRoaXMuY29kZSA9IFwiRVBBUlNFUlwiO1xuICB9XG59O1xuXG5zZXRFcnJvck5hbWUoUGFyc2VyRXJyb3IpO1xuXG5jb25zdCBVbm1hdGNoZWRQYXJzZXJFcnJvciA9IGV4cG9ydHMuVW5tYXRjaGVkUGFyc2VyRXJyb3IgPSBjbGFzcyBVbm1hdGNoZWRQYXJzZXJFcnJvciBleHRlbmRzIEpTT05QYXJzZXJFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChzb3VyY2UpIHtcbiAgICBzdXBlcihgQ291bGQgbm90IGZpbmQgcGFyc2VyIGZvciBcIiR7c291cmNlfVwiYCwgc291cmNlKTtcblxuICAgIHRoaXMuY29kZSA9IFwiRVVOTUFUQ0hFRFBBUlNFUlwiO1xuICB9XG59O1xuXG5zZXRFcnJvck5hbWUoVW5tYXRjaGVkUGFyc2VyRXJyb3IpO1xuXG5jb25zdCBSZXNvbHZlckVycm9yID0gZXhwb3J0cy5SZXNvbHZlckVycm9yID0gY2xhc3MgUmVzb2x2ZXJFcnJvciBleHRlbmRzIEpTT05QYXJzZXJFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChleCwgc291cmNlKSB7XG4gICAgc3VwZXIoZXgubWVzc2FnZSB8fCBgRXJyb3IgcmVhZGluZyBmaWxlIFwiJHtzb3VyY2V9XCJgLCBzb3VyY2UpO1xuXG4gICAgdGhpcy5jb2RlID0gXCJFUkVTT0xWRVJcIjtcblxuICAgIGlmIChcImNvZGVcIiBpbiBleCkge1xuICAgICAgdGhpcy5pb0Vycm9yQ29kZSA9IFN0cmluZyhleC5jb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbnNldEVycm9yTmFtZShSZXNvbHZlckVycm9yKTtcblxuY29uc3QgVW5tYXRjaGVkUmVzb2x2ZXJFcnJvciA9IGV4cG9ydHMuVW5tYXRjaGVkUmVzb2x2ZXJFcnJvciA9IGNsYXNzIFVubWF0Y2hlZFJlc29sdmVyRXJyb3IgZXh0ZW5kcyBKU09OUGFyc2VyRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoc291cmNlKSB7XG4gICAgc3VwZXIoYENvdWxkIG5vdCBmaW5kIHJlc29sdmVyIGZvciBcIiR7c291cmNlfVwiYCwgc291cmNlKTtcblxuICAgIHRoaXMuY29kZSA9IFwiRVVOTUFUQ0hFRFJFU09MVkVSXCI7XG4gIH1cbn07XG5cbnNldEVycm9yTmFtZShVbm1hdGNoZWRSZXNvbHZlckVycm9yKTtcblxuY29uc3QgTWlzc2luZ1BvaW50ZXJFcnJvciA9IGV4cG9ydHMuTWlzc2luZ1BvaW50ZXJFcnJvciA9IGNsYXNzIE1pc3NpbmdQb2ludGVyRXJyb3IgZXh0ZW5kcyBKU09OUGFyc2VyRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAodG9rZW4sIHBhdGgpIHtcbiAgICBzdXBlcihgVG9rZW4gXCIke3Rva2VufVwiIGRvZXMgbm90IGV4aXN0LmAsIHN0cmlwSGFzaChwYXRoKSk7XG5cbiAgICB0aGlzLmNvZGUgPSBcIkVNSVNTSU5HUE9JTlRFUlwiO1xuICB9XG59O1xuXG5zZXRFcnJvck5hbWUoTWlzc2luZ1BvaW50ZXJFcnJvcik7XG5cbmNvbnN0IEludmFsaWRQb2ludGVyRXJyb3IgPSBleHBvcnRzLkludmFsaWRQb2ludGVyRXJyb3IgPSBjbGFzcyBJbnZhbGlkUG9pbnRlckVycm9yIGV4dGVuZHMgSlNPTlBhcnNlckVycm9yIHtcbiAgY29uc3RydWN0b3IgKHBvaW50ZXIsIHBhdGgpIHtcbiAgICBzdXBlcihgSW52YWxpZCAkcmVmIHBvaW50ZXIgXCIke3BvaW50ZXJ9XCIuIFBvaW50ZXJzIG11c3QgYmVnaW4gd2l0aCBcIiMvXCJgLCBzdHJpcEhhc2gocGF0aCkpO1xuXG4gICAgdGhpcy5jb2RlID0gXCJFSU5WQUxJRFBPSU5URVJcIjtcbiAgfVxufTtcblxuc2V0RXJyb3JOYW1lKEludmFsaWRQb2ludGVyRXJyb3IpO1xuXG5mdW5jdGlvbiBzZXRFcnJvck5hbWUgKGVycikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICB2YWx1ZTogZXJyLm5hbWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgfSk7XG59XG5cbmV4cG9ydHMuaXNIYW5kbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHJldHVybiBlcnIgaW5zdGFuY2VvZiBKU09OUGFyc2VyRXJyb3IgfHwgZXJyIGluc3RhbmNlb2YgSlNPTlBhcnNlckVycm9yR3JvdXA7XG59O1xuXG5leHBvcnRzLm5vcm1hbGl6ZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAoZXJyLnBhdGggPT09IG51bGwpIHtcbiAgICBlcnIucGF0aCA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGVycjtcbn07XG4iXSwibmFtZXMiOlsiT25vIiwicmVxdWlyZSIsInN0cmlwSGFzaCIsInRvRmlsZVN5c3RlbVBhdGgiLCJKU09OUGFyc2VyRXJyb3IiLCJleHBvcnRzIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJzb3VyY2UiLCJjb2RlIiwicGF0aCIsImV4dGVuZCIsImZvb3RwcmludCIsInNldEVycm9yTmFtZSIsIkpTT05QYXJzZXJFcnJvckdyb3VwIiwicGFyc2VyIiwiZmlsZXMiLCJlcnJvcnMiLCJsZW5ndGgiLCIkcmVmcyIsIl9yb290JFJlZiIsImdldFBhcnNlckVycm9ycyIsIiRyZWYiLCJPYmplY3QiLCJ2YWx1ZXMiLCJfJHJlZnMiLCJwdXNoIiwiUGFyc2VyRXJyb3IiLCJVbm1hdGNoZWRQYXJzZXJFcnJvciIsIlJlc29sdmVyRXJyb3IiLCJleCIsImlvRXJyb3JDb2RlIiwiU3RyaW5nIiwiVW5tYXRjaGVkUmVzb2x2ZXJFcnJvciIsIk1pc3NpbmdQb2ludGVyRXJyb3IiLCJ0b2tlbiIsIkludmFsaWRQb2ludGVyRXJyb3IiLCJwb2ludGVyIiwiZXJyIiwiZGVmaW5lUHJvcGVydHkiLCJwcm90b3R5cGUiLCJ2YWx1ZSIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiaXNIYW5kbGVkRXJyb3IiLCJub3JtYWxpemVFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/plugins.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/util/plugins.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @param  {object} plugins - A map of plugin objects\n * @return {object[]}\n */ exports.all = function(plugins) {\n    return Object.keys(plugins).filter((key)=>{\n        return typeof plugins[key] === \"object\";\n    }).map((key)=>{\n        plugins[key].name = key;\n        return plugins[key];\n    });\n};\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n *\n * @param  {object[]} plugins - An array of plugin objects\n * @param  {string}   method  - The name of the filter method to invoke for each plugin\n * @param  {object}   file    - A file info object, which will be passed to each method\n * @return {object[]}\n */ exports.filter = function(plugins, method, file) {\n    return plugins.filter((plugin)=>{\n        return !!getResult(plugin, method, file);\n    });\n};\n/**\n * Sorts the given plugins, in place, by their `order` property.\n *\n * @param {object[]} plugins - An array of plugin objects\n * @returns {object[]}\n */ exports.sort = function(plugins) {\n    for (let plugin of plugins){\n        plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n    }\n    return plugins.sort((a, b)=>{\n        return a.order - b.order;\n    });\n};\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n *\n * @param {object[]}  plugins - An array of plugin objects\n * @param {string}    method  - The name of the method to invoke for each plugin\n * @param {object}    file    - A file info object, which will be passed to each method\n * @returns {Promise}\n */ exports.run = function(plugins, method, file, $refs) {\n    let plugin, lastError, index = 0;\n    return new Promise((resolve, reject)=>{\n        runNextPlugin();\n        function runNextPlugin() {\n            plugin = plugins[index++];\n            if (!plugin) {\n                // There are no more functions, so re-throw the last error\n                return reject(lastError);\n            }\n            try {\n                // console.log('  %s', plugin.name);\n                let result = getResult(plugin, method, file, callback, $refs);\n                if (result && typeof result.then === \"function\") {\n                    // A promise was returned\n                    result.then(onSuccess, onError);\n                } else if (result !== undefined) {\n                    // A synchronous result was returned\n                    onSuccess(result);\n                } else if (index === plugins.length) {\n                    throw new Error(\"No promise has been returned or callback has been called.\");\n                }\n            } catch (e) {\n                onError(e);\n            }\n        }\n        function callback(err, result) {\n            if (err) {\n                onError(err);\n            } else {\n                onSuccess(result);\n            }\n        }\n        function onSuccess(result) {\n            // console.log('    success');\n            resolve({\n                plugin,\n                result\n            });\n        }\n        function onError(error) {\n            // console.log('    %s', err.message || err);\n            lastError = {\n                plugin,\n                error\n            };\n            runNextPlugin();\n        }\n    });\n};\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an aray, then it will be compared against the file extension.\n *\n * @param   {object}   obj        - The object whose property/method is called\n * @param   {string}   prop       - The name of the property/method to invoke\n * @param   {object}   file       - A file info object, which will be passed to the method\n * @param   {function} [callback] - A callback function, which will be passed to the method\n * @returns {*}\n */ function getResult(obj, prop, file, callback, $refs) {\n    let value = obj[prop];\n    if (typeof value === \"function\") {\n        return value.apply(obj, [\n            file,\n            callback,\n            $refs\n        ]);\n    }\n    if (!callback) {\n        // The synchronous plugin functions (canParse and canRead)\n        // allow a \"shorthand\" syntax, where the user can match\n        // files by RegExp or by file extension.\n        if (value instanceof RegExp) {\n            return value.test(file.url);\n        } else if (typeof value === \"string\") {\n            return value === file.extension;\n        } else if (Array.isArray(value)) {\n            return value.indexOf(file.extension) !== -1;\n        }\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3V0aWwvcGx1Z2lucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViOzs7Ozs7Q0FNQyxHQUNEQSxXQUFXLEdBQUcsU0FBVUUsT0FBTztJQUM3QixPQUFPQyxPQUFPQyxJQUFJLENBQUNGLFNBQ2hCRyxNQUFNLENBQUMsQ0FBQ0M7UUFDUCxPQUFPLE9BQU9KLE9BQU8sQ0FBQ0ksSUFBSSxLQUFLO0lBQ2pDLEdBQ0NDLEdBQUcsQ0FBQyxDQUFDRDtRQUNKSixPQUFPLENBQUNJLElBQUksQ0FBQ0UsSUFBSSxHQUFHRjtRQUNwQixPQUFPSixPQUFPLENBQUNJLElBQUk7SUFDckI7QUFDSjtBQUVBOzs7Ozs7O0NBT0MsR0FDRE4sY0FBYyxHQUFHLFNBQVVFLE9BQU8sRUFBRU8sTUFBTSxFQUFFQyxJQUFJO0lBQzlDLE9BQU9SLFFBQ0pHLE1BQU0sQ0FBQyxDQUFDTTtRQUNQLE9BQU8sQ0FBQyxDQUFDQyxVQUFVRCxRQUFRRixRQUFRQztJQUNyQztBQUNKO0FBRUE7Ozs7O0NBS0MsR0FDRFYsWUFBWSxHQUFHLFNBQVVFLE9BQU87SUFDOUIsS0FBSyxJQUFJUyxVQUFVVCxRQUFTO1FBQzFCUyxPQUFPRyxLQUFLLEdBQUdILE9BQU9HLEtBQUssSUFBSUMsT0FBT0MsZ0JBQWdCO0lBQ3hEO0lBRUEsT0FBT2QsUUFBUVcsSUFBSSxDQUFDLENBQUNJLEdBQUdDO1FBQVEsT0FBT0QsRUFBRUgsS0FBSyxHQUFHSSxFQUFFSixLQUFLO0lBQUU7QUFDNUQ7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRGQsV0FBVyxHQUFHLFNBQVVFLE9BQU8sRUFBRU8sTUFBTSxFQUFFQyxJQUFJLEVBQUVVLEtBQUs7SUFDbEQsSUFBSVQsUUFBUVUsV0FBV0MsUUFBUTtJQUUvQixPQUFPLElBQUlDLFFBQVMsQ0FBQ0MsU0FBU0M7UUFDNUJDO1FBRUEsU0FBU0E7WUFDUGYsU0FBU1QsT0FBTyxDQUFDb0IsUUFBUTtZQUN6QixJQUFJLENBQUNYLFFBQVE7Z0JBQ1gsMERBQTBEO2dCQUMxRCxPQUFPYyxPQUFPSjtZQUNoQjtZQUVBLElBQUk7Z0JBQ0Ysb0NBQW9DO2dCQUNwQyxJQUFJTSxTQUFTZixVQUFVRCxRQUFRRixRQUFRQyxNQUFNa0IsVUFBVVI7Z0JBQ3ZELElBQUlPLFVBQVUsT0FBT0EsT0FBT0UsSUFBSSxLQUFLLFlBQVk7b0JBQy9DLHlCQUF5QjtvQkFDekJGLE9BQU9FLElBQUksQ0FBQ0MsV0FBV0M7Z0JBQ3pCLE9BQ0ssSUFBSUosV0FBV0ssV0FBVztvQkFDN0Isb0NBQW9DO29CQUNwQ0YsVUFBVUg7Z0JBQ1osT0FDSyxJQUFJTCxVQUFVcEIsUUFBUStCLE1BQU0sRUFBRTtvQkFDakMsTUFBTSxJQUFJQyxNQUFNO2dCQUNsQjtZQUNGLEVBQ0EsT0FBT0MsR0FBRztnQkFDUkosUUFBUUk7WUFDVjtRQUNGO1FBRUEsU0FBU1AsU0FBVVEsR0FBRyxFQUFFVCxNQUFNO1lBQzVCLElBQUlTLEtBQUs7Z0JBQ1BMLFFBQVFLO1lBQ1YsT0FDSztnQkFDSE4sVUFBVUg7WUFDWjtRQUNGO1FBRUEsU0FBU0csVUFBV0gsTUFBTTtZQUN4Qiw4QkFBOEI7WUFDOUJILFFBQVE7Z0JBQ05iO2dCQUNBZ0I7WUFDRjtRQUNGO1FBRUEsU0FBU0ksUUFBU00sS0FBSztZQUNyQiw2Q0FBNkM7WUFDN0NoQixZQUFZO2dCQUNWVjtnQkFDQTBCO1lBQ0Y7WUFDQVg7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNkLFVBQVcwQixHQUFHLEVBQUVDLElBQUksRUFBRTdCLElBQUksRUFBRWtCLFFBQVEsRUFBRVIsS0FBSztJQUNsRCxJQUFJb0IsUUFBUUYsR0FBRyxDQUFDQyxLQUFLO0lBRXJCLElBQUksT0FBT0MsVUFBVSxZQUFZO1FBQy9CLE9BQU9BLE1BQU1DLEtBQUssQ0FBQ0gsS0FBSztZQUFDNUI7WUFBTWtCO1lBQVVSO1NBQU07SUFDakQ7SUFFQSxJQUFJLENBQUNRLFVBQVU7UUFDYiwwREFBMEQ7UUFDMUQsdURBQXVEO1FBQ3ZELHdDQUF3QztRQUN4QyxJQUFJWSxpQkFBaUJFLFFBQVE7WUFDM0IsT0FBT0YsTUFBTUcsSUFBSSxDQUFDakMsS0FBS2tDLEdBQUc7UUFDNUIsT0FDSyxJQUFJLE9BQU9KLFVBQVUsVUFBVTtZQUNsQyxPQUFPQSxVQUFVOUIsS0FBS21DLFNBQVM7UUFDakMsT0FDSyxJQUFJQyxNQUFNQyxPQUFPLENBQUNQLFFBQVE7WUFDN0IsT0FBT0EsTUFBTVEsT0FBTyxDQUFDdEMsS0FBS21DLFNBQVMsTUFBTSxDQUFDO1FBQzVDO0lBQ0Y7SUFFQSxPQUFPTDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvdXRpbC9wbHVnaW5zLmpzPzcxZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2l2ZW4gcGx1Z2lucyBhcyBhbiBhcnJheSwgcmF0aGVyIHRoYW4gYW4gb2JqZWN0IG1hcC5cbiAqIEFsbCBvdGhlciBtZXRob2RzIGluIHRoaXMgbW9kdWxlIGV4cGVjdCBhbiBhcnJheSBvZiBwbHVnaW5zIHJhdGhlciB0aGFuIGFuIG9iamVjdCBtYXAuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBwbHVnaW5zIC0gQSBtYXAgb2YgcGx1Z2luIG9iamVjdHNcbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5leHBvcnRzLmFsbCA9IGZ1bmN0aW9uIChwbHVnaW5zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhwbHVnaW5zKVxuICAgIC5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBwbHVnaW5zW2tleV0gPT09IFwib2JqZWN0XCI7XG4gICAgfSlcbiAgICAubWFwKChrZXkpID0+IHtcbiAgICAgIHBsdWdpbnNba2V5XS5uYW1lID0ga2V5O1xuICAgICAgcmV0dXJuIHBsdWdpbnNba2V5XTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRmlsdGVycyB0aGUgZ2l2ZW4gcGx1Z2lucywgcmV0dXJuaW5nIG9ubHkgdGhlIG9uZXMgcmV0dXJuIGB0cnVlYCBmb3IgdGhlIGdpdmVuIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3RbXX0gcGx1Z2lucyAtIEFuIGFycmF5IG9mIHBsdWdpbiBvYmplY3RzXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgbWV0aG9kICAtIFRoZSBuYW1lIG9mIHRoZSBmaWx0ZXIgbWV0aG9kIHRvIGludm9rZSBmb3IgZWFjaCBwbHVnaW5cbiAqIEBwYXJhbSAge29iamVjdH0gICBmaWxlICAgIC0gQSBmaWxlIGluZm8gb2JqZWN0LCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBlYWNoIG1ldGhvZFxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmV4cG9ydHMuZmlsdGVyID0gZnVuY3Rpb24gKHBsdWdpbnMsIG1ldGhvZCwgZmlsZSkge1xuICByZXR1cm4gcGx1Z2luc1xuICAgIC5maWx0ZXIoKHBsdWdpbikgPT4ge1xuICAgICAgcmV0dXJuICEhZ2V0UmVzdWx0KHBsdWdpbiwgbWV0aG9kLCBmaWxlKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU29ydHMgdGhlIGdpdmVuIHBsdWdpbnMsIGluIHBsYWNlLCBieSB0aGVpciBgb3JkZXJgIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0W119IHBsdWdpbnMgLSBBbiBhcnJheSBvZiBwbHVnaW4gb2JqZWN0c1xuICogQHJldHVybnMge29iamVjdFtdfVxuICovXG5leHBvcnRzLnNvcnQgPSBmdW5jdGlvbiAocGx1Z2lucykge1xuICBmb3IgKGxldCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIHBsdWdpbi5vcmRlciA9IHBsdWdpbi5vcmRlciB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgfVxuXG4gIHJldHVybiBwbHVnaW5zLnNvcnQoKGEsIGIpID0+IHsgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyOyB9KTtcbn07XG5cbi8qKlxuICogUnVucyB0aGUgc3BlY2lmaWVkIG1ldGhvZCBvZiB0aGUgZ2l2ZW4gcGx1Z2lucywgaW4gb3JkZXIsIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYSBzdWNjZXNzZnVsIHJlc3VsdC5cbiAqIEVhY2ggbWV0aG9kIGNhbiByZXR1cm4gYSBzeW5jaHJvbm91cyB2YWx1ZSwgYSBQcm9taXNlLCBvciBjYWxsIGFuIGVycm9yLWZpcnN0IGNhbGxiYWNrLlxuICogSWYgdGhlIHByb21pc2UgcmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5LCBvciB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGhvdXQgYW4gZXJyb3IsIHRoZW4gdGhlIHJlc3VsdFxuICogaXMgaW1tZWRpYXRlbHkgcmV0dXJuZWQgYW5kIG5vIGZ1cnRoZXIgcGx1Z2lucyBhcmUgY2FsbGVkLlxuICogSWYgdGhlIHByb21pc2UgcmVqZWN0cywgb3IgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIGFuIGVycm9yLCB0aGVuIHRoZSBuZXh0IHBsdWdpbiBpcyBjYWxsZWQuXG4gKiBJZiBBTEwgcGx1Z2lucyBmYWlsLCB0aGVuIHRoZSBsYXN0IGVycm9yIGlzIHRocm93bi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdFtdfSAgcGx1Z2lucyAtIEFuIGFycmF5IG9mIHBsdWdpbiBvYmplY3RzXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgbWV0aG9kICAtIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIGZvciBlYWNoIHBsdWdpblxuICogQHBhcmFtIHtvYmplY3R9ICAgIGZpbGUgICAgLSBBIGZpbGUgaW5mbyBvYmplY3QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGVhY2ggbWV0aG9kXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuZXhwb3J0cy5ydW4gPSBmdW5jdGlvbiAocGx1Z2lucywgbWV0aG9kLCBmaWxlLCAkcmVmcykge1xuICBsZXQgcGx1Z2luLCBsYXN0RXJyb3IsIGluZGV4ID0gMDtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBydW5OZXh0UGx1Z2luKCk7XG5cbiAgICBmdW5jdGlvbiBydW5OZXh0UGx1Z2luICgpIHtcbiAgICAgIHBsdWdpbiA9IHBsdWdpbnNbaW5kZXgrK107XG4gICAgICBpZiAoIXBsdWdpbikge1xuICAgICAgICAvLyBUaGVyZSBhcmUgbm8gbW9yZSBmdW5jdGlvbnMsIHNvIHJlLXRocm93IHRoZSBsYXN0IGVycm9yXG4gICAgICAgIHJldHVybiByZWplY3QobGFzdEVycm9yKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJyAgJXMnLCBwbHVnaW4ubmFtZSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBnZXRSZXN1bHQocGx1Z2luLCBtZXRob2QsIGZpbGUsIGNhbGxiYWNrLCAkcmVmcyk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBBIHByb21pc2Ugd2FzIHJldHVybmVkXG4gICAgICAgICAgcmVzdWx0LnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEEgc3luY2hyb25vdXMgcmVzdWx0IHdhcyByZXR1cm5lZFxuICAgICAgICAgIG9uU3VjY2VzcyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHByb21pc2UgaGFzIGJlZW4gcmV0dXJuZWQgb3IgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsYmFjayAoZXJyLCByZXN1bHQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9uU3VjY2VzcyhyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyAocmVzdWx0KSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnICAgIHN1Y2Nlc3MnKTtcbiAgICAgIHJlc29sdmUoe1xuICAgICAgICBwbHVnaW4sXG4gICAgICAgIHJlc3VsdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvciAoZXJyb3IpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCcgICAgJXMnLCBlcnIubWVzc2FnZSB8fCBlcnIpO1xuICAgICAgbGFzdEVycm9yID0ge1xuICAgICAgICBwbHVnaW4sXG4gICAgICAgIGVycm9yLFxuICAgICAgfTtcbiAgICAgIHJ1bk5leHRQbHVnaW4oKTtcbiAgICB9XG4gIH0pKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIHByb3BlcnR5LlxuICogSWYgdGhlIHByb3BlcnR5IGlzIGEgZnVuY3Rpb24sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gaXMgcmV0dXJuZWQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBSZWdFeHAsIHRoZW4gaXQgd2lsbCBiZSB0ZXN0ZWQgYWdhaW5zdCB0aGUgZmlsZSBVUkwuXG4gKiBJZiB0aGUgdmFsdWUgaXMgYW4gYXJheSwgdGhlbiBpdCB3aWxsIGJlIGNvbXBhcmVkIGFnYWluc3QgdGhlIGZpbGUgZXh0ZW5zaW9uLlxuICpcbiAqIEBwYXJhbSAgIHtvYmplY3R9ICAgb2JqICAgICAgICAtIFRoZSBvYmplY3Qgd2hvc2UgcHJvcGVydHkvbWV0aG9kIGlzIGNhbGxlZFxuICogQHBhcmFtICAge3N0cmluZ30gICBwcm9wICAgICAgIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5L21ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSAgIHtvYmplY3R9ICAgZmlsZSAgICAgICAtIEEgZmlsZSBpbmZvIG9iamVjdCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICogQHBhcmFtICAge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayBmdW5jdGlvbiwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGdldFJlc3VsdCAob2JqLCBwcm9wLCBmaWxlLCBjYWxsYmFjaywgJHJlZnMpIHtcbiAgbGV0IHZhbHVlID0gb2JqW3Byb3BdO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2YWx1ZS5hcHBseShvYmosIFtmaWxlLCBjYWxsYmFjaywgJHJlZnNdKTtcbiAgfVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICAvLyBUaGUgc3luY2hyb25vdXMgcGx1Z2luIGZ1bmN0aW9ucyAoY2FuUGFyc2UgYW5kIGNhblJlYWQpXG4gICAgLy8gYWxsb3cgYSBcInNob3J0aGFuZFwiIHN5bnRheCwgd2hlcmUgdGhlIHVzZXIgY2FuIG1hdGNoXG4gICAgLy8gZmlsZXMgYnkgUmVnRXhwIG9yIGJ5IGZpbGUgZXh0ZW5zaW9uLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRlc3QoZmlsZS51cmwpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmlsZS5leHRlbnNpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihmaWxlLmV4dGVuc2lvbikgIT09IC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiYWxsIiwicGx1Z2lucyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJtYXAiLCJuYW1lIiwibWV0aG9kIiwiZmlsZSIsInBsdWdpbiIsImdldFJlc3VsdCIsInNvcnQiLCJvcmRlciIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJhIiwiYiIsInJ1biIsIiRyZWZzIiwibGFzdEVycm9yIiwiaW5kZXgiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJ1bk5leHRQbHVnaW4iLCJyZXN1bHQiLCJjYWxsYmFjayIsInRoZW4iLCJvblN1Y2Nlc3MiLCJvbkVycm9yIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiRXJyb3IiLCJlIiwiZXJyIiwiZXJyb3IiLCJvYmoiLCJwcm9wIiwidmFsdWUiLCJhcHBseSIsIlJlZ0V4cCIsInRlc3QiLCJ1cmwiLCJleHRlbnNpb24iLCJBcnJheSIsImlzQXJyYXkiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/plugins.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nlet isWindows = /^win/.test(process.platform), forwardSlashPattern = /\\//g, protocolPattern = /^(\\w{2,}):\\/\\//i, url = module.exports, jsonPointerSlash = /~1/g, jsonPointerTilde = /~0/g;\n// RegExp patterns to URL-encode special characters in local filesystem paths\nlet urlEncodePatterns = [\n    /\\?/g,\n    \"%3F\",\n    /\\#/g,\n    \"%23\"\n];\n// RegExp patterns to URL-decode special characters for local filesystem paths\nlet urlDecodePatterns = [\n    /\\%23/g,\n    \"#\",\n    /\\%24/g,\n    \"$\",\n    /\\%26/g,\n    \"&\",\n    /\\%2C/g,\n    \",\",\n    /\\%40/g,\n    \"@\"\n];\nexports.parse = __webpack_require__(/*! url */ \"url\").parse;\nexports.resolve = __webpack_require__(/*! url */ \"url\").resolve;\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns {string}\n */ exports.cwd = function cwd() {\n    if (false) {}\n    let path = process.cwd();\n    let lastChar = path.slice(-1);\n    if (lastChar === \"/\" || lastChar === \"\\\\\") {\n        return path;\n    } else {\n        return path + \"/\";\n    }\n};\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param   {string} path\n * @returns {?string}\n */ exports.getProtocol = function getProtocol(path) {\n    let match = protocolPattern.exec(path);\n    if (match) {\n        return match[1].toLowerCase();\n    }\n};\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param   {string} path\n * @returns {string}\n */ exports.getExtension = function getExtension(path) {\n    let lastDot = path.lastIndexOf(\".\");\n    if (lastDot >= 0) {\n        return url.stripQuery(path.substr(lastDot).toLowerCase());\n    }\n    return \"\";\n};\n/**\n * Removes the query, if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */ exports.stripQuery = function stripQuery(path) {\n    let queryIndex = path.indexOf(\"?\");\n    if (queryIndex >= 0) {\n        path = path.substr(0, queryIndex);\n    }\n    return path;\n};\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param   {string} path\n * @returns {string}\n */ exports.getHash = function getHash(path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        return path.substr(hashIndex);\n    }\n    return \"#\";\n};\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */ exports.stripHash = function stripHash(path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        path = path.substr(0, hashIndex);\n    }\n    return path;\n};\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param   {string} path\n * @returns {boolean}\n */ exports.isHttp = function isHttp(path) {\n    let protocol = url.getProtocol(path);\n    if (protocol === \"http\" || protocol === \"https\") {\n        return true;\n    } else if (protocol === undefined) {\n        // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n        return false;\n    } else {\n        // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n        return false;\n    }\n};\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param   {string} path\n * @returns {boolean}\n */ exports.isFileSystemPath = function isFileSystemPath(path) {\n    if (false) {}\n    let protocol = url.getProtocol(path);\n    return protocol === undefined || protocol === \"file\";\n};\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param {string} path\n * @returns {string}\n */ exports.fromFileSystemPath = function fromFileSystemPath(path) {\n    // Step 1: On Windows, replace backslashes with forward slashes,\n    // rather than encoding them as \"%5C\"\n    if (isWindows) {\n        path = path.replace(/\\\\/g, \"/\");\n    }\n    // Step 2: `encodeURI` will take care of MOST characters\n    path = encodeURI(path);\n    // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n    // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n    // but are just normal characters in a filesystem path.\n    for(let i = 0; i < urlEncodePatterns.length; i += 2){\n        path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n    }\n    return path;\n};\n/**\n * Converts a URL to a local filesystem path.\n *\n * @param {string}  path\n * @param {boolean} [keepFileProtocol] - If true, then \"file://\" will NOT be stripped\n * @returns {string}\n */ exports.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {\n    // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n    path = decodeURI(path);\n    // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n    // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n    // but are just normal characters in a filesystem path.\n    for(let i = 0; i < urlDecodePatterns.length; i += 2){\n        path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n    }\n    // Step 3: If it's a \"file://\" URL, then format it consistently\n    // or convert it to a local filesystem path\n    let isFileUrl = path.substr(0, 7).toLowerCase() === \"file://\";\n    if (isFileUrl) {\n        // Strip-off the protocol, and the initial \"/\", if there is one\n        path = path[7] === \"/\" ? path.substr(8) : path.substr(7);\n        // insert a colon (\":\") after the drive letter on Windows\n        if (isWindows && path[1] === \"/\") {\n            path = path[0] + \":\" + path.substr(1);\n        }\n        if (keepFileProtocol) {\n            // Return the consistently-formatted \"file://\" URL\n            path = \"file:///\" + path;\n        } else {\n            // Convert the \"file://\" URL to a local filesystem path.\n            // On Windows, it will start with something like \"C:/\".\n            // On Posix, it will start with \"/\"\n            isFileUrl = false;\n            path = isWindows ? path : \"/\" + path;\n        }\n    }\n    // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n    if (isWindows && !isFileUrl) {\n        // Replace forward slashes with backslashes\n        path = path.replace(forwardSlashPattern, \"\\\\\");\n        // Capitalize the drive letter\n        if (path.substr(1, 2) === \":\\\\\") {\n            path = path[0].toUpperCase() + path.substr(1);\n        }\n    }\n    return path;\n};\n/**\n * Converts a $ref pointer to a valid JSON Path.\n *\n * @param {string}  pointer\n * @returns {Array<number | string>}\n */ exports.safePointerToPath = function safePointerToPath(pointer) {\n    if (pointer.length <= 1 || pointer[0] !== \"#\" || pointer[1] !== \"/\") {\n        return [];\n    }\n    return pointer.slice(2).split(\"/\").map((value)=>{\n        return decodeURIComponent(value).replace(jsonPointerSlash, \"/\").replace(jsonPointerTilde, \"~\");\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL3V0aWwvdXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsWUFBWSxPQUFPQyxJQUFJLENBQUNDLFFBQVFDLFFBQVEsR0FDeENDLHNCQUFzQixPQUN0QkMsa0JBQWtCLG1CQUNsQkMsTUFBTUMsT0FBT0MsT0FBTyxFQUNwQkMsbUJBQW1CLE9BQ25CQyxtQkFBbUI7QUFFdkIsNkVBQTZFO0FBQzdFLElBQUlDLG9CQUFvQjtJQUN0QjtJQUFPO0lBQ1A7SUFBTztDQUNSO0FBRUQsOEVBQThFO0FBQzlFLElBQUlDLG9CQUFvQjtJQUN0QjtJQUFTO0lBQ1Q7SUFBUztJQUNUO0lBQVM7SUFDVDtJQUFTO0lBQ1Q7SUFBUztDQUNWO0FBRURKLDJEQUFvQztBQUNwQ0EsK0RBQXdDO0FBRXhDOzs7O0NBSUMsR0FDREEsV0FBVyxHQUFHLFNBQVNRO0lBQ3JCLElBQUlkLEtBQWUsRUFBRSxFQUVwQjtJQUVELElBQUlrQixPQUFPbEIsUUFBUWMsR0FBRztJQUV0QixJQUFJSyxXQUFXRCxLQUFLRSxLQUFLLENBQUMsQ0FBQztJQUMzQixJQUFJRCxhQUFhLE9BQU9BLGFBQWEsTUFBTTtRQUN6QyxPQUFPRDtJQUNULE9BQ0s7UUFDSCxPQUFPQSxPQUFPO0lBQ2hCO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNEWixtQkFBbUIsR0FBRyxTQUFTZSxZQUFhSCxJQUFJO0lBQzlDLElBQUlJLFFBQVFuQixnQkFBZ0JvQixJQUFJLENBQUNMO0lBQ2pDLElBQUlJLE9BQU87UUFDVCxPQUFPQSxLQUFLLENBQUMsRUFBRSxDQUFDRSxXQUFXO0lBQzdCO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRGxCLG9CQUFvQixHQUFHLFNBQVNtQixhQUFjUCxJQUFJO0lBQ2hELElBQUlRLFVBQVVSLEtBQUtTLFdBQVcsQ0FBQztJQUMvQixJQUFJRCxXQUFXLEdBQUc7UUFDaEIsT0FBT3RCLElBQUl3QixVQUFVLENBQUNWLEtBQUtXLE1BQU0sQ0FBQ0gsU0FBU0YsV0FBVztJQUN4RDtJQUNBLE9BQU87QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0RsQixrQkFBa0IsR0FBRyxTQUFTc0IsV0FBWVYsSUFBSTtJQUM1QyxJQUFJWSxhQUFhWixLQUFLYSxPQUFPLENBQUM7SUFDOUIsSUFBSUQsY0FBYyxHQUFHO1FBQ25CWixPQUFPQSxLQUFLVyxNQUFNLENBQUMsR0FBR0M7SUFDeEI7SUFDQSxPQUFPWjtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ0RaLGVBQWUsR0FBRyxTQUFTMEIsUUFBU2QsSUFBSTtJQUN0QyxJQUFJZSxZQUFZZixLQUFLYSxPQUFPLENBQUM7SUFDN0IsSUFBSUUsYUFBYSxHQUFHO1FBQ2xCLE9BQU9mLEtBQUtXLE1BQU0sQ0FBQ0k7SUFDckI7SUFDQSxPQUFPO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNEM0IsaUJBQWlCLEdBQUcsU0FBUzRCLFVBQVdoQixJQUFJO0lBQzFDLElBQUllLFlBQVlmLEtBQUthLE9BQU8sQ0FBQztJQUM3QixJQUFJRSxhQUFhLEdBQUc7UUFDbEJmLE9BQU9BLEtBQUtXLE1BQU0sQ0FBQyxHQUFHSTtJQUN4QjtJQUNBLE9BQU9mO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNEWixjQUFjLEdBQUcsU0FBUzZCLE9BQVFqQixJQUFJO0lBQ3BDLElBQUlrQixXQUFXaEMsSUFBSWlCLFdBQVcsQ0FBQ0g7SUFDL0IsSUFBSWtCLGFBQWEsVUFBVUEsYUFBYSxTQUFTO1FBQy9DLE9BQU87SUFDVCxPQUNLLElBQUlBLGFBQWFDLFdBQVc7UUFDL0IsK0VBQStFO1FBQy9FLE9BQU9yQyxLQUFlO0lBQ3hCLE9BQ0s7UUFDSCxpRUFBaUU7UUFDakUsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRE0sd0JBQXdCLEdBQUcsU0FBU2dDLGlCQUFrQnBCLElBQUk7SUFDeEQsSUFBSWxCLEtBQWUsRUFBRSxFQUlwQjtJQUVELElBQUlvQyxXQUFXaEMsSUFBSWlCLFdBQVcsQ0FBQ0g7SUFDL0IsT0FBT2tCLGFBQWFDLGFBQWFELGFBQWE7QUFDaEQ7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDlCLDBCQUEwQixHQUFHLFNBQVNpQyxtQkFBb0JyQixJQUFJO0lBQzVELGdFQUFnRTtJQUNoRSxxQ0FBcUM7SUFDckMsSUFBSXBCLFdBQVc7UUFDYm9CLE9BQU9BLEtBQUtzQixPQUFPLENBQUMsT0FBTztJQUM3QjtJQUVBLHdEQUF3RDtJQUN4RHRCLE9BQU91QixVQUFVdkI7SUFFakIsMEVBQTBFO0lBQzFFLG9GQUFvRjtJQUNwRix1REFBdUQ7SUFDdkQsSUFBSyxJQUFJd0IsSUFBSSxHQUFHQSxJQUFJakMsa0JBQWtCa0MsTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDcER4QixPQUFPQSxLQUFLc0IsT0FBTyxDQUFDL0IsaUJBQWlCLENBQUNpQyxFQUFFLEVBQUVqQyxpQkFBaUIsQ0FBQ2lDLElBQUksRUFBRTtJQUNwRTtJQUVBLE9BQU94QjtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ0RaLHdCQUF3QixHQUFHLFNBQVNzQyxpQkFBa0IxQixJQUFJLEVBQUUyQixnQkFBZ0I7SUFDMUUsdUZBQXVGO0lBQ3ZGM0IsT0FBTzRCLFVBQVU1QjtJQUVqQiwwRUFBMEU7SUFDMUUsb0ZBQW9GO0lBQ3BGLHVEQUF1RDtJQUN2RCxJQUFLLElBQUl3QixJQUFJLEdBQUdBLElBQUloQyxrQkFBa0JpQyxNQUFNLEVBQUVELEtBQUssRUFBRztRQUNwRHhCLE9BQU9BLEtBQUtzQixPQUFPLENBQUM5QixpQkFBaUIsQ0FBQ2dDLEVBQUUsRUFBRWhDLGlCQUFpQixDQUFDZ0MsSUFBSSxFQUFFO0lBQ3BFO0lBRUEsK0RBQStEO0lBQy9ELDJDQUEyQztJQUMzQyxJQUFJSyxZQUFZN0IsS0FBS1csTUFBTSxDQUFDLEdBQUcsR0FBR0wsV0FBVyxPQUFPO0lBQ3BELElBQUl1QixXQUFXO1FBQ2IsK0RBQStEO1FBQy9EN0IsT0FBT0EsSUFBSSxDQUFDLEVBQUUsS0FBSyxNQUFNQSxLQUFLVyxNQUFNLENBQUMsS0FBS1gsS0FBS1csTUFBTSxDQUFDO1FBRXRELHlEQUF5RDtRQUN6RCxJQUFJL0IsYUFBYW9CLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBSztZQUNoQ0EsT0FBT0EsSUFBSSxDQUFDLEVBQUUsR0FBRyxNQUFNQSxLQUFLVyxNQUFNLENBQUM7UUFDckM7UUFFQSxJQUFJZ0Isa0JBQWtCO1lBQ3BCLGtEQUFrRDtZQUNsRDNCLE9BQU8sYUFBYUE7UUFDdEIsT0FDSztZQUNILHdEQUF3RDtZQUN4RCx1REFBdUQ7WUFDdkQsbUNBQW1DO1lBQ25DNkIsWUFBWTtZQUNaN0IsT0FBT3BCLFlBQVlvQixPQUFPLE1BQU1BO1FBQ2xDO0lBQ0Y7SUFFQSxnRUFBZ0U7SUFDaEUsSUFBSXBCLGFBQWEsQ0FBQ2lELFdBQVc7UUFDM0IsMkNBQTJDO1FBQzNDN0IsT0FBT0EsS0FBS3NCLE9BQU8sQ0FBQ3RDLHFCQUFxQjtRQUV6Qyw4QkFBOEI7UUFDOUIsSUFBSWdCLEtBQUtXLE1BQU0sQ0FBQyxHQUFHLE9BQU8sT0FBTztZQUMvQlgsT0FBT0EsSUFBSSxDQUFDLEVBQUUsQ0FBQzhCLFdBQVcsS0FBSzlCLEtBQUtXLE1BQU0sQ0FBQztRQUM3QztJQUNGO0lBRUEsT0FBT1g7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0RaLHlCQUF5QixHQUFHLFNBQVMyQyxrQkFBbUJDLE9BQU87SUFDN0QsSUFBSUEsUUFBUVAsTUFBTSxJQUFJLEtBQUtPLE9BQU8sQ0FBQyxFQUFFLEtBQUssT0FBT0EsT0FBTyxDQUFDLEVBQUUsS0FBSyxLQUFLO1FBQ25FLE9BQU8sRUFBRTtJQUNYO0lBRUEsT0FBT0EsUUFDSjlCLEtBQUssQ0FBQyxHQUNOK0IsS0FBSyxDQUFDLEtBQ05DLEdBQUcsQ0FBQyxDQUFDQztRQUNKLE9BQU9DLG1CQUFtQkQsT0FDdkJiLE9BQU8sQ0FBQ2pDLGtCQUFrQixLQUMxQmlDLE9BQU8sQ0FBQ2hDLGtCQUFrQjtJQUMvQjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvdXRpbC91cmwuanM/NzJhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubGV0IGlzV2luZG93cyA9IC9ed2luLy50ZXN0KHByb2Nlc3MucGxhdGZvcm0pLFxuICAgIGZvcndhcmRTbGFzaFBhdHRlcm4gPSAvXFwvL2csXG4gICAgcHJvdG9jb2xQYXR0ZXJuID0gL14oXFx3ezIsfSk6XFwvXFwvL2ksXG4gICAgdXJsID0gbW9kdWxlLmV4cG9ydHMsXG4gICAganNvblBvaW50ZXJTbGFzaCA9IC9+MS9nLFxuICAgIGpzb25Qb2ludGVyVGlsZGUgPSAvfjAvZztcblxuLy8gUmVnRXhwIHBhdHRlcm5zIHRvIFVSTC1lbmNvZGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHNcbmxldCB1cmxFbmNvZGVQYXR0ZXJucyA9IFtcbiAgL1xcPy9nLCBcIiUzRlwiLFxuICAvXFwjL2csIFwiJTIzXCIsXG5dO1xuXG4vLyBSZWdFeHAgcGF0dGVybnMgdG8gVVJMLWRlY29kZSBzcGVjaWFsIGNoYXJhY3RlcnMgZm9yIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHNcbmxldCB1cmxEZWNvZGVQYXR0ZXJucyA9IFtcbiAgL1xcJTIzL2csIFwiI1wiLFxuICAvXFwlMjQvZywgXCIkXCIsXG4gIC9cXCUyNi9nLCBcIiZcIixcbiAgL1xcJTJDL2csIFwiLFwiLFxuICAvXFwlNDAvZywgXCJAXCJcbl07XG5cbmV4cG9ydHMucGFyc2UgPSByZXF1aXJlKFwidXJsXCIpLnBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gcmVxdWlyZShcInVybFwiKS5yZXNvbHZlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkgKGluIE5vZGUpIG9yIHRoZSBjdXJyZW50IHBhZ2UgVVJMIChpbiBicm93c2VycykuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5jd2QgPSBmdW5jdGlvbiBjd2QgKCkge1xuICBpZiAocHJvY2Vzcy5icm93c2VyKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLmhyZWY7XG4gIH1cblxuICBsZXQgcGF0aCA9IHByb2Nlc3MuY3dkKCk7XG5cbiAgbGV0IGxhc3RDaGFyID0gcGF0aC5zbGljZSgtMSk7XG4gIGlmIChsYXN0Q2hhciA9PT0gXCIvXCIgfHwgbGFzdENoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHBhdGggKyBcIi9cIjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm90b2NvbCBvZiB0aGUgZ2l2ZW4gVVJMLCBvciBgdW5kZWZpbmVkYCBpZiBpdCBoYXMgbm8gcHJvdG9jb2wuXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gcGF0aFxuICogQHJldHVybnMgez9zdHJpbmd9XG4gKi9cbmV4cG9ydHMuZ2V0UHJvdG9jb2wgPSBmdW5jdGlvbiBnZXRQcm90b2NvbCAocGF0aCkge1xuICBsZXQgbWF0Y2ggPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhwYXRoKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG93ZXJjYXNlZCBmaWxlIGV4dGVuc2lvbiBvZiB0aGUgZ2l2ZW4gVVJMLFxuICogb3IgYW4gZW1wdHkgc3RyaW5nIGlmIGl0IGhhcyBubyBleHRlbnNpb24uXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gcGF0aFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbiBnZXRFeHRlbnNpb24gKHBhdGgpIHtcbiAgbGV0IGxhc3REb3QgPSBwYXRoLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgaWYgKGxhc3REb3QgPj0gMCkge1xuICAgIHJldHVybiB1cmwuc3RyaXBRdWVyeShwYXRoLnN1YnN0cihsYXN0RG90KS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgcXVlcnksIGlmIGFueSwgZnJvbSB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnN0cmlwUXVlcnkgPSBmdW5jdGlvbiBzdHJpcFF1ZXJ5IChwYXRoKSB7XG4gIGxldCBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcbiAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBxdWVyeUluZGV4KTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaGFzaCAoVVJMIGZyYWdtZW50KSwgb2YgdGhlIGdpdmVuIHBhdGguXG4gKiBJZiB0aGVyZSBpcyBubyBoYXNoLCB0aGVuIHRoZSByb290IGhhc2ggKFwiI1wiKSBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLmdldEhhc2ggPSBmdW5jdGlvbiBnZXRIYXNoIChwYXRoKSB7XG4gIGxldCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICByZXR1cm4gcGF0aC5zdWJzdHIoaGFzaEluZGV4KTtcbiAgfVxuICByZXR1cm4gXCIjXCI7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGhhc2ggKFVSTCBmcmFnbWVudCksIGlmIGFueSwgZnJvbSB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnN0cmlwSGFzaCA9IGZ1bmN0aW9uIHN0cmlwSGFzaCAocGF0aCkge1xuICBsZXQgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKTtcbiAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gcGF0aCBpcyBhbiBIVFRQKFMpIFVSTC5cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0h0dHAgPSBmdW5jdGlvbiBpc0h0dHAgKHBhdGgpIHtcbiAgbGV0IHByb3RvY29sID0gdXJsLmdldFByb3RvY29sKHBhdGgpO1xuICBpZiAocHJvdG9jb2wgPT09IFwiaHR0cFwiIHx8IHByb3RvY29sID09PSBcImh0dHBzXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIGlmIChwcm90b2NvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gcHJvdG9jb2wuICBJZiB3ZSdyZSBydW5uaW5nIGluIGEgYnJvd3NlciwgdGhlbiBhc3N1bWUgaXQncyBIVFRQLlxuICAgIHJldHVybiBwcm9jZXNzLmJyb3dzZXI7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gSXQncyBzb21lIG90aGVyIHByb3RvY29sLCBzdWNoIGFzIFwiZnRwOi8vXCIsIFwibW9uZ29kYjovL1wiLCBldGMuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gcGF0aCBpcyBhIGZpbGVzeXN0ZW0gcGF0aC5cbiAqIFRoaXMgaW5jbHVkZXMgXCJmaWxlOi8vXCIgVVJMcy5cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0ZpbGVTeXN0ZW1QYXRoID0gZnVuY3Rpb24gaXNGaWxlU3lzdGVtUGF0aCAocGF0aCkge1xuICBpZiAocHJvY2Vzcy5icm93c2VyKSB7XG4gICAgLy8gV2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXIsIHNvIGFzc3VtZSB0aGF0IGFsbCBwYXRocyBhcmUgVVJMcy5cbiAgICAvLyBUaGlzIHdheSwgZXZlbiByZWxhdGl2ZSBwYXRocyB3aWxsIGJlIHRyZWF0ZWQgYXMgVVJMcyByYXRoZXIgdGhhbiBhcyBmaWxlc3lzdGVtIHBhdGhzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IHByb3RvY29sID0gdXJsLmdldFByb3RvY29sKHBhdGgpO1xuICByZXR1cm4gcHJvdG9jb2wgPT09IHVuZGVmaW5lZCB8fCBwcm90b2NvbCA9PT0gXCJmaWxlXCI7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZmlsZXN5c3RlbSBwYXRoIHRvIGEgcHJvcGVybHktZW5jb2RlZCBVUkwuXG4gKlxuICogVGhpcyBpcyBpbnRlbmRlZCB0byBoYW5kbGUgc2l0dWF0aW9ucyB3aGVyZSBKU09OIFNjaGVtYSAkUmVmIFBhcnNlciBpcyBjYWxsZWRcbiAqIHdpdGggYSBmaWxlc3lzdGVtIHBhdGggdGhhdCBjb250YWlucyBjaGFyYWN0ZXJzIHdoaWNoIGFyZSBub3QgYWxsb3dlZCBpbiBVUkxzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgZm9sbG93aW5nIGZpbGVzeXN0ZW0gcGF0aHMgd291bGQgYmUgY29udmVydGVkIHRvIHRoZSBmb2xsb3dpbmcgVVJMczpcbiAqXG4gKiAgICA8XCIhQCMkJV4mKis9Pyc+Lmpzb24gICAgICAgICAgICAgID09PiAgICUzQyUyMiFAJTIzJCUyNSU1RSYqKz0lM0ZcXCclM0UuanNvblxuICogICAgQzpcXFxcTXkgRG9jdW1lbnRzXFxcXEZpbGUgKDEpLmpzb24gICA9PT4gICBDOi9NeSUyMERvY3VtZW50cy9GaWxlJTIwKDEpLmpzb25cbiAqICAgIGZpbGU6Ly9Qcm9qZWN0ICM0Mi9maWxlLmpzb24gICAgICA9PT4gICBmaWxlOi8vUHJvamVjdCUyMCUyMzQyL2ZpbGUuanNvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLmZyb21GaWxlU3lzdGVtUGF0aCA9IGZ1bmN0aW9uIGZyb21GaWxlU3lzdGVtUGF0aCAocGF0aCkge1xuICAvLyBTdGVwIDE6IE9uIFdpbmRvd3MsIHJlcGxhY2UgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkIHNsYXNoZXMsXG4gIC8vIHJhdGhlciB0aGFuIGVuY29kaW5nIHRoZW0gYXMgXCIlNUNcIlxuICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG4gIH1cblxuICAvLyBTdGVwIDI6IGBlbmNvZGVVUklgIHdpbGwgdGFrZSBjYXJlIG9mIE1PU1QgY2hhcmFjdGVyc1xuICBwYXRoID0gZW5jb2RlVVJJKHBhdGgpO1xuXG4gIC8vIFN0ZXAgMzogTWFudWFsbHkgZW5jb2RlIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGVuY29kZWQgYnkgYGVuY29kZVVSSWAuXG4gIC8vIFRoaXMgaW5jbHVkZXMgY2hhcmFjdGVycyBzdWNoIGFzIFwiI1wiIGFuZCBcIj9cIiwgd2hpY2ggaGF2ZSBzcGVjaWFsIG1lYW5pbmcgaW4gVVJMcyxcbiAgLy8gYnV0IGFyZSBqdXN0IG5vcm1hbCBjaGFyYWN0ZXJzIGluIGEgZmlsZXN5c3RlbSBwYXRoLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IHVybEVuY29kZVBhdHRlcm5zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSh1cmxFbmNvZGVQYXR0ZXJuc1tpXSwgdXJsRW5jb2RlUGF0dGVybnNbaSArIDFdKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVSTCB0byBhIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBGaWxlUHJvdG9jb2xdIC0gSWYgdHJ1ZSwgdGhlbiBcImZpbGU6Ly9cIiB3aWxsIE5PVCBiZSBzdHJpcHBlZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0ZpbGVTeXN0ZW1QYXRoID0gZnVuY3Rpb24gdG9GaWxlU3lzdGVtUGF0aCAocGF0aCwga2VlcEZpbGVQcm90b2NvbCkge1xuICAvLyBTdGVwIDE6IGBkZWNvZGVVUklgIHdpbGwgZGVjb2RlIGNoYXJhY3RlcnMgc3VjaCBhcyBDeXJpbGxpYyBjaGFyYWN0ZXJzLCBzcGFjZXMsIGV0Yy5cbiAgcGF0aCA9IGRlY29kZVVSSShwYXRoKTtcblxuICAvLyBTdGVwIDI6IE1hbnVhbGx5IGRlY29kZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBkZWNvZGVkIGJ5IGBkZWNvZGVVUklgLlxuICAvLyBUaGlzIGluY2x1ZGVzIGNoYXJhY3RlcnMgc3VjaCBhcyBcIiNcIiBhbmQgXCI/XCIsIHdoaWNoIGhhdmUgc3BlY2lhbCBtZWFuaW5nIGluIFVSTHMsXG4gIC8vIGJ1dCBhcmUganVzdCBub3JtYWwgY2hhcmFjdGVycyBpbiBhIGZpbGVzeXN0ZW0gcGF0aC5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxEZWNvZGVQYXR0ZXJucy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UodXJsRGVjb2RlUGF0dGVybnNbaV0sIHVybERlY29kZVBhdHRlcm5zW2kgKyAxXSk7XG4gIH1cblxuICAvLyBTdGVwIDM6IElmIGl0J3MgYSBcImZpbGU6Ly9cIiBVUkwsIHRoZW4gZm9ybWF0IGl0IGNvbnNpc3RlbnRseVxuICAvLyBvciBjb252ZXJ0IGl0IHRvIGEgbG9jYWwgZmlsZXN5c3RlbSBwYXRoXG4gIGxldCBpc0ZpbGVVcmwgPSBwYXRoLnN1YnN0cigwLCA3KS50b0xvd2VyQ2FzZSgpID09PSBcImZpbGU6Ly9cIjtcbiAgaWYgKGlzRmlsZVVybCkge1xuICAgIC8vIFN0cmlwLW9mZiB0aGUgcHJvdG9jb2wsIGFuZCB0aGUgaW5pdGlhbCBcIi9cIiwgaWYgdGhlcmUgaXMgb25lXG4gICAgcGF0aCA9IHBhdGhbN10gPT09IFwiL1wiID8gcGF0aC5zdWJzdHIoOCkgOiBwYXRoLnN1YnN0cig3KTtcblxuICAgIC8vIGluc2VydCBhIGNvbG9uIChcIjpcIikgYWZ0ZXIgdGhlIGRyaXZlIGxldHRlciBvbiBXaW5kb3dzXG4gICAgaWYgKGlzV2luZG93cyAmJiBwYXRoWzFdID09PSBcIi9cIikge1xuICAgICAgcGF0aCA9IHBhdGhbMF0gKyBcIjpcIiArIHBhdGguc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIGlmIChrZWVwRmlsZVByb3RvY29sKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGNvbnNpc3RlbnRseS1mb3JtYXR0ZWQgXCJmaWxlOi8vXCIgVVJMXG4gICAgICBwYXRoID0gXCJmaWxlOi8vL1wiICsgcGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBDb252ZXJ0IHRoZSBcImZpbGU6Ly9cIiBVUkwgdG8gYSBsb2NhbCBmaWxlc3lzdGVtIHBhdGguXG4gICAgICAvLyBPbiBXaW5kb3dzLCBpdCB3aWxsIHN0YXJ0IHdpdGggc29tZXRoaW5nIGxpa2UgXCJDOi9cIi5cbiAgICAgIC8vIE9uIFBvc2l4LCBpdCB3aWxsIHN0YXJ0IHdpdGggXCIvXCJcbiAgICAgIGlzRmlsZVVybCA9IGZhbHNlO1xuICAgICAgcGF0aCA9IGlzV2luZG93cyA/IHBhdGggOiBcIi9cIiArIHBhdGg7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RlcCA0OiBOb3JtYWxpemUgV2luZG93cyBwYXRocyAodW5sZXNzIGl0J3MgYSBcImZpbGU6Ly9cIiBVUkwpXG4gIGlmIChpc1dpbmRvd3MgJiYgIWlzRmlsZVVybCkge1xuICAgIC8vIFJlcGxhY2UgZm9yd2FyZCBzbGFzaGVzIHdpdGggYmFja3NsYXNoZXNcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKGZvcndhcmRTbGFzaFBhdHRlcm4sIFwiXFxcXFwiKTtcblxuICAgIC8vIENhcGl0YWxpemUgdGhlIGRyaXZlIGxldHRlclxuICAgIGlmIChwYXRoLnN1YnN0cigxLCAyKSA9PT0gXCI6XFxcXFwiKSB7XG4gICAgICBwYXRoID0gcGF0aFswXS50b1VwcGVyQ2FzZSgpICsgcGF0aC5zdWJzdHIoMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgJHJlZiBwb2ludGVyIHRvIGEgdmFsaWQgSlNPTiBQYXRoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgcG9pbnRlclxuICogQHJldHVybnMge0FycmF5PG51bWJlciB8IHN0cmluZz59XG4gKi9cbmV4cG9ydHMuc2FmZVBvaW50ZXJUb1BhdGggPSBmdW5jdGlvbiBzYWZlUG9pbnRlclRvUGF0aCAocG9pbnRlcikge1xuICBpZiAocG9pbnRlci5sZW5ndGggPD0gMSB8fCBwb2ludGVyWzBdICE9PSBcIiNcIiB8fCBwb2ludGVyWzFdICE9PSBcIi9cIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBwb2ludGVyXG4gICAgLnNsaWNlKDIpXG4gICAgLnNwbGl0KFwiL1wiKVxuICAgIC5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKVxuICAgICAgICAucmVwbGFjZShqc29uUG9pbnRlclNsYXNoLCBcIi9cIilcbiAgICAgICAgLnJlcGxhY2UoanNvblBvaW50ZXJUaWxkZSwgXCJ+XCIpO1xuICAgIH0pO1xufTtcbiJdLCJuYW1lcyI6WyJpc1dpbmRvd3MiLCJ0ZXN0IiwicHJvY2VzcyIsInBsYXRmb3JtIiwiZm9yd2FyZFNsYXNoUGF0dGVybiIsInByb3RvY29sUGF0dGVybiIsInVybCIsIm1vZHVsZSIsImV4cG9ydHMiLCJqc29uUG9pbnRlclNsYXNoIiwianNvblBvaW50ZXJUaWxkZSIsInVybEVuY29kZVBhdHRlcm5zIiwidXJsRGVjb2RlUGF0dGVybnMiLCJwYXJzZSIsInJlcXVpcmUiLCJyZXNvbHZlIiwiY3dkIiwiYnJvd3NlciIsImxvY2F0aW9uIiwiaHJlZiIsInBhdGgiLCJsYXN0Q2hhciIsInNsaWNlIiwiZ2V0UHJvdG9jb2wiLCJtYXRjaCIsImV4ZWMiLCJ0b0xvd2VyQ2FzZSIsImdldEV4dGVuc2lvbiIsImxhc3REb3QiLCJsYXN0SW5kZXhPZiIsInN0cmlwUXVlcnkiLCJzdWJzdHIiLCJxdWVyeUluZGV4IiwiaW5kZXhPZiIsImdldEhhc2giLCJoYXNoSW5kZXgiLCJzdHJpcEhhc2giLCJpc0h0dHAiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsImlzRmlsZVN5c3RlbVBhdGgiLCJmcm9tRmlsZVN5c3RlbVBhdGgiLCJyZXBsYWNlIiwiZW5jb2RlVVJJIiwiaSIsImxlbmd0aCIsInRvRmlsZVN5c3RlbVBhdGgiLCJrZWVwRmlsZVByb3RvY29sIiwiZGVjb2RlVVJJIiwiaXNGaWxlVXJsIiwidG9VcHBlckNhc2UiLCJzYWZlUG9pbnRlclRvUGF0aCIsInBvaW50ZXIiLCJzcGxpdCIsIm1hcCIsInZhbHVlIiwiZGVjb2RlVVJJQ29tcG9uZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/util/url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/openapi-schemas/lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apidevtools/openapi-schemas/lib/index.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.openapi = exports.openapiV31 = exports.openapiV3 = exports.openapiV2 = exports.openapiV1 = void 0;\n/**\n * JSON Schema for OpenAPI Specification v1.2\n */ exports.openapiV1 = __webpack_require__(/*! ../schemas/v1.2/apiDeclaration.json */ \"(rsc)/./node_modules/@apidevtools/openapi-schemas/schemas/v1.2/apiDeclaration.json\");\n/**\n * JSON Schema for OpenAPI Specification v2.0\n */ exports.openapiV2 = __webpack_require__(/*! ../schemas/v2.0/schema.json */ \"(rsc)/./node_modules/@apidevtools/openapi-schemas/schemas/v2.0/schema.json\");\n/**\n * JSON Schema for OpenAPI Specification v3.0\n */ exports.openapiV3 = __webpack_require__(/*! ../schemas/v3.0/schema.json */ \"(rsc)/./node_modules/@apidevtools/openapi-schemas/schemas/v3.0/schema.json\");\n/**\n * JSON Schema for OpenAPI Specification v3.1\n */ exports.openapiV31 = __webpack_require__(/*! ../schemas/v3.1/schema.json */ \"(rsc)/./node_modules/@apidevtools/openapi-schemas/schemas/v3.1/schema.json\");\n/**\n * JSON Schemas for every version of the OpenAPI Specification\n */ exports.openapi = {\n    v1: exports.openapiV1,\n    v2: exports.openapiV2,\n    v3: exports.openapiV3,\n    v31: exports.openapiV31\n};\n// Export `openapi` as the default export\nexports[\"default\"] = exports.openapi;\n// CommonJS default export hack\n/* eslint-env commonjs */ if ( true && typeof module.exports === \"object\") {\n    module.exports = Object.assign(module.exports.default, module.exports);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL29wZW5hcGktc2NoZW1hcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBR0Esa0JBQWtCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUN4Rzs7Q0FFQyxHQUNEQSx3S0FBa0U7QUFDbEU7O0NBRUMsR0FDREEsd0pBQTBEO0FBQzFEOztDQUVDLEdBQ0RBLHdKQUEwRDtBQUMxRDs7Q0FFQyxHQUNEQSx5SkFBMkQ7QUFDM0Q7O0NBRUMsR0FDREEsZUFBZSxHQUFHO0lBQ2RRLElBQUlSLFFBQVFNLFNBQVM7SUFDckJHLElBQUlULFFBQVFLLFNBQVM7SUFDckJLLElBQUlWLFFBQVFJLFNBQVM7SUFDckJPLEtBQUtYLFFBQVFHLFVBQVU7QUFDM0I7QUFDQSx5Q0FBeUM7QUFDekNILGtCQUFlLEdBQUdBLFFBQVFFLE9BQU87QUFDakMsK0JBQStCO0FBQy9CLHVCQUF1QixHQUN2QixJQUFJLEtBQTBCLElBQUksT0FBT1csT0FBT2IsT0FBTyxLQUFLLFVBQVU7SUFDbEVhLE9BQU9iLE9BQU8sR0FBR0YsT0FBT2dCLE1BQU0sQ0FBQ0QsT0FBT2IsT0FBTyxDQUFDWSxPQUFPLEVBQUVDLE9BQU9iLE9BQU87QUFDekUsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9vcGVuYXBpLXNjaGVtYXMvbGliL2luZGV4LmpzPzM4OTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9wZW5hcGkgPSBleHBvcnRzLm9wZW5hcGlWMzEgPSBleHBvcnRzLm9wZW5hcGlWMyA9IGV4cG9ydHMub3BlbmFwaVYyID0gZXhwb3J0cy5vcGVuYXBpVjEgPSB2b2lkIDA7XG4vKipcbiAqIEpTT04gU2NoZW1hIGZvciBPcGVuQVBJIFNwZWNpZmljYXRpb24gdjEuMlxuICovXG5leHBvcnRzLm9wZW5hcGlWMSA9IHJlcXVpcmUoXCIuLi9zY2hlbWFzL3YxLjIvYXBpRGVjbGFyYXRpb24uanNvblwiKTtcbi8qKlxuICogSlNPTiBTY2hlbWEgZm9yIE9wZW5BUEkgU3BlY2lmaWNhdGlvbiB2Mi4wXG4gKi9cbmV4cG9ydHMub3BlbmFwaVYyID0gcmVxdWlyZShcIi4uL3NjaGVtYXMvdjIuMC9zY2hlbWEuanNvblwiKTtcbi8qKlxuICogSlNPTiBTY2hlbWEgZm9yIE9wZW5BUEkgU3BlY2lmaWNhdGlvbiB2My4wXG4gKi9cbmV4cG9ydHMub3BlbmFwaVYzID0gcmVxdWlyZShcIi4uL3NjaGVtYXMvdjMuMC9zY2hlbWEuanNvblwiKTtcbi8qKlxuICogSlNPTiBTY2hlbWEgZm9yIE9wZW5BUEkgU3BlY2lmaWNhdGlvbiB2My4xXG4gKi9cbmV4cG9ydHMub3BlbmFwaVYzMSA9IHJlcXVpcmUoXCIuLi9zY2hlbWFzL3YzLjEvc2NoZW1hLmpzb25cIik7XG4vKipcbiAqIEpTT04gU2NoZW1hcyBmb3IgZXZlcnkgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBTcGVjaWZpY2F0aW9uXG4gKi9cbmV4cG9ydHMub3BlbmFwaSA9IHtcbiAgICB2MTogZXhwb3J0cy5vcGVuYXBpVjEsXG4gICAgdjI6IGV4cG9ydHMub3BlbmFwaVYyLFxuICAgIHYzOiBleHBvcnRzLm9wZW5hcGlWMyxcbiAgICB2MzE6IGV4cG9ydHMub3BlbmFwaVYzMSxcbn07XG4vLyBFeHBvcnQgYG9wZW5hcGlgIGFzIHRoZSBkZWZhdWx0IGV4cG9ydFxuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5vcGVuYXBpO1xuLy8gQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgaGFja1xuLyogZXNsaW50LWVudiBjb21tb25qcyAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKG1vZHVsZS5leHBvcnRzLmRlZmF1bHQsIG1vZHVsZS5leHBvcnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm9wZW5hcGkiLCJvcGVuYXBpVjMxIiwib3BlbmFwaVYzIiwib3BlbmFwaVYyIiwib3BlbmFwaVYxIiwicmVxdWlyZSIsInYxIiwidjIiLCJ2MyIsInYzMSIsImRlZmF1bHQiLCJtb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/openapi-schemas/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/swagger-methods/lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apidevtools/swagger-methods/lib/index.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = [\n    \"get\",\n    \"put\",\n    \"post\",\n    \"delete\",\n    \"options\",\n    \"head\",\n    \"patch\"\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL3N3YWdnZXItbWV0aG9kcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsT0FBT0MsT0FBTyxHQUFHO0lBQ2Y7SUFBTztJQUFPO0lBQVE7SUFBVTtJQUFXO0lBQVE7Q0FDcEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9zd2FnZ2VyLW1ldGhvZHMvbGliL2luZGV4LmpzP2MyZjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICBcImdldFwiLCBcInB1dFwiLCBcInBvc3RcIiwgXCJkZWxldGVcIiwgXCJvcHRpb25zXCIsIFwiaGVhZFwiLCBcInBhdGNoXCJcbl07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/swagger-methods/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/swagger-parser/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@apidevtools/swagger-parser/lib/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable no-unused-vars */ \nconst validateSchema = __webpack_require__(/*! ./validators/schema */ \"(rsc)/./node_modules/@apidevtools/swagger-parser/lib/validators/schema.js\");\nconst validateSpec = __webpack_require__(/*! ./validators/spec */ \"(rsc)/./node_modules/@apidevtools/swagger-parser/lib/validators/spec.js\");\nconst normalizeArgs = __webpack_require__(/*! @apidevtools/json-schema-ref-parser/lib/normalize-args */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/normalize-args.js\");\nconst util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/@apidevtools/swagger-parser/lib/util.js\");\nconst Options = __webpack_require__(/*! ./options */ \"(rsc)/./node_modules/@apidevtools/swagger-parser/lib/options.js\");\nconst maybe = __webpack_require__(/*! call-me-maybe */ \"(rsc)/./node_modules/call-me-maybe/src/maybe.js\");\nconst { ono } = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst $RefParser = __webpack_require__(/*! @apidevtools/json-schema-ref-parser */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/index.js\");\nconst dereference = __webpack_require__(/*! @apidevtools/json-schema-ref-parser/lib/dereference */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/dereference.js\");\nmodule.exports = SwaggerParser;\n/**\n * This class parses a Swagger 2.0 or 3.0 API, resolves its JSON references and their resolved values,\n * and provides methods for traversing, dereferencing, and validating the API.\n *\n * @class\n * @augments $RefParser\n */ function SwaggerParser() {\n    $RefParser.apply(this, arguments);\n}\nutil.inherits(SwaggerParser, $RefParser);\nSwaggerParser.parse = $RefParser.parse;\nSwaggerParser.resolve = $RefParser.resolve;\nSwaggerParser.bundle = $RefParser.bundle;\nSwaggerParser.dereference = $RefParser.dereference;\n/**\n * Alias {@link $RefParser#schema} as {@link SwaggerParser#api}\n */ Object.defineProperty(SwaggerParser.prototype, \"api\", {\n    configurable: true,\n    enumerable: true,\n    get () {\n        return this.schema;\n    }\n});\n/**\n * Parses the given Swagger API.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed\n * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */ SwaggerParser.prototype.parse = async function(path, api, options, callback) {\n    let args = normalizeArgs(arguments);\n    args.options = new Options(args.options);\n    try {\n        let schema = await $RefParser.prototype.parse.call(this, args.path, args.schema, args.options);\n        if (schema.swagger) {\n            // Verify that the parsed object is a Swagger API\n            if (schema.swagger === undefined || schema.info === undefined || schema.paths === undefined) {\n                throw ono.syntax(`${args.path || args.schema} is not a valid Swagger API definition`);\n            } else if (typeof schema.swagger === \"number\") {\n                // This is a very common mistake, so give a helpful error message\n                throw ono.syntax('Swagger version number must be a string (e.g. \"2.0\") not a number.');\n            } else if (typeof schema.info.version === \"number\") {\n                // This is a very common mistake, so give a helpful error message\n                throw ono.syntax('API version number must be a string (e.g. \"1.0.0\") not a number.');\n            } else if (schema.swagger !== \"2.0\") {\n                throw ono.syntax(`Unrecognized Swagger version: ${schema.swagger}. Expected 2.0`);\n            }\n        } else {\n            let supportedVersions = [\n                \"3.0.0\",\n                \"3.0.1\",\n                \"3.0.2\",\n                \"3.0.3\"\n            ];\n            // Verify that the parsed object is a Openapi API\n            if (schema.openapi === undefined || schema.info === undefined || schema.paths === undefined) {\n                throw ono.syntax(`${args.path || args.schema} is not a valid Openapi API definition`);\n            } else if (typeof schema.openapi === \"number\") {\n                // This is a very common mistake, so give a helpful error message\n                throw ono.syntax('Openapi version number must be a string (e.g. \"3.0.0\") not a number.');\n            } else if (typeof schema.info.version === \"number\") {\n                // This is a very common mistake, so give a helpful error message\n                throw ono.syntax('API version number must be a string (e.g. \"1.0.0\") not a number.');\n            } else if (supportedVersions.indexOf(schema.openapi) === -1) {\n                throw ono.syntax(`Unsupported OpenAPI version: ${schema.openapi}. ` + `Swagger Parser only supports versions ${supportedVersions.join(\", \")}`);\n            }\n        }\n        // Looks good!\n        return maybe(args.callback, Promise.resolve(schema));\n    } catch (err) {\n        return maybe(args.callback, Promise.reject(err));\n    }\n};\n/**\n * Parses, dereferences, and validates the given Swagger API.\n * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated\n * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */ SwaggerParser.validate = function(path, api, options, callback) {\n    let Class = this; // eslint-disable-line consistent-this\n    let instance = new Class();\n    return instance.validate.apply(instance, arguments);\n};\n/**\n * Parses, dereferences, and validates the given Swagger API.\n * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated\n * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */ SwaggerParser.prototype.validate = async function(path, api, options, callback) {\n    let me = this;\n    let args = normalizeArgs(arguments);\n    args.options = new Options(args.options);\n    // ZSchema doesn't support circular objects, so don't dereference circular $refs yet\n    // (see https://github.com/zaggino/z-schema/issues/137)\n    let circular$RefOption = args.options.dereference.circular;\n    args.options.validate.schema && (args.options.dereference.circular = \"ignore\");\n    try {\n        await this.dereference(args.path, args.schema, args.options);\n        // Restore the original options, now that we're done dereferencing\n        args.options.dereference.circular = circular$RefOption;\n        if (args.options.validate.schema) {\n            // Validate the API against the Swagger schema\n            // NOTE: This is safe to do, because we haven't dereferenced circular $refs yet\n            validateSchema(me.api);\n            if (me.$refs.circular) {\n                if (circular$RefOption === true) {\n                    // The API has circular references,\n                    // so we need to do a second-pass to fully-dereference it\n                    dereference(me, args.options);\n                } else if (circular$RefOption === false) {\n                    // The API has circular references, and they're not allowed, so throw an error\n                    throw ono.reference(\"The API contains circular references\");\n                }\n            }\n        }\n        if (args.options.validate.spec) {\n            // Validate the API against the Swagger spec\n            validateSpec(me.api);\n        }\n        return maybe(args.callback, Promise.resolve(me.schema));\n    } catch (err) {\n        return maybe(args.callback, Promise.reject(err));\n    }\n}; /**\n * The Swagger object\n * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#swagger-object\n *\n * @typedef {{swagger: string, info: {}, paths: {}}} SwaggerObject\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL3N3YWdnZXItcGFyc2VyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUMsR0FDcEI7QUFFYixNQUFNQSxpQkFBaUJDLG1CQUFPQSxDQUFDLHNHQUFxQjtBQUNwRCxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyxrR0FBbUI7QUFDaEQsTUFBTUUsZ0JBQWdCRixtQkFBT0EsQ0FBQyw4SUFBd0Q7QUFDdEYsTUFBTUcsT0FBT0gsbUJBQU9BLENBQUMsNEVBQVE7QUFDN0IsTUFBTUksVUFBVUosbUJBQU9BLENBQUMsa0ZBQVc7QUFDbkMsTUFBTUssUUFBUUwsbUJBQU9BLENBQUMsc0VBQWU7QUFDckMsTUFBTSxFQUFFTSxHQUFHLEVBQUUsR0FBR04sbUJBQU9BLENBQUMsMEVBQWlCO0FBQ3pDLE1BQU1PLGFBQWFQLG1CQUFPQSxDQUFDLGtIQUFxQztBQUNoRSxNQUFNUSxjQUFjUixtQkFBT0EsQ0FBQyx3SUFBcUQ7QUFFakZTLE9BQU9DLE9BQU8sR0FBR0M7QUFFakI7Ozs7OztDQU1DLEdBQ0QsU0FBU0E7SUFDUEosV0FBV0ssS0FBSyxDQUFDLElBQUksRUFBRUM7QUFDekI7QUFFQVYsS0FBS1csUUFBUSxDQUFDSCxlQUFlSjtBQUM3QkksY0FBY0ksS0FBSyxHQUFHUixXQUFXUSxLQUFLO0FBQ3RDSixjQUFjSyxPQUFPLEdBQUdULFdBQVdTLE9BQU87QUFDMUNMLGNBQWNNLE1BQU0sR0FBR1YsV0FBV1UsTUFBTTtBQUN4Q04sY0FBY0gsV0FBVyxHQUFHRCxXQUFXQyxXQUFXO0FBRWxEOztDQUVDLEdBQ0RVLE9BQU9DLGNBQWMsQ0FBQ1IsY0FBY1MsU0FBUyxFQUFFLE9BQU87SUFDcERDLGNBQWM7SUFDZEMsWUFBWTtJQUNaQztRQUNFLE9BQU8sSUFBSSxDQUFDQyxNQUFNO0lBQ3BCO0FBQ0Y7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0RiLGNBQWNTLFNBQVMsQ0FBQ0wsS0FBSyxHQUFHLGVBQWdC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QixLQUFLRCxRQUFRLEVBQUVhLFFBQVF6QixPQUFPLENBQUMrQixHQUFHdkIsTUFBTTtJQUN2RCxFQUNBLE9BQU9rQixLQUFLO1FBQ1YsT0FBT3JDLE1BQU13QixLQUFLRCxRQUFRLEVBQUVhLFFBQVFFLE1BQU0sQ0FBQ0Q7SUFDN0M7QUFDRixHQUVBOzs7OztDQUtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvc3dhZ2dlci1wYXJzZXIvbGliL2luZGV4LmpzPzJlMmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB2YWxpZGF0ZVNjaGVtYSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvc2NoZW1hXCIpO1xuY29uc3QgdmFsaWRhdGVTcGVjID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9zcGVjXCIpO1xuY29uc3Qgbm9ybWFsaXplQXJncyA9IHJlcXVpcmUoXCJAYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9saWIvbm9ybWFsaXplLWFyZ3NcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IE9wdGlvbnMgPSByZXF1aXJlKFwiLi9vcHRpb25zXCIpO1xuY29uc3QgbWF5YmUgPSByZXF1aXJlKFwiY2FsbC1tZS1tYXliZVwiKTtcbmNvbnN0IHsgb25vIH0gPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgJFJlZlBhcnNlciA9IHJlcXVpcmUoXCJAYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlclwiKTtcbmNvbnN0IGRlcmVmZXJlbmNlID0gcmVxdWlyZShcIkBhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2xpYi9kZXJlZmVyZW5jZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTd2FnZ2VyUGFyc2VyO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgcGFyc2VzIGEgU3dhZ2dlciAyLjAgb3IgMy4wIEFQSSwgcmVzb2x2ZXMgaXRzIEpTT04gcmVmZXJlbmNlcyBhbmQgdGhlaXIgcmVzb2x2ZWQgdmFsdWVzLFxuICogYW5kIHByb3ZpZGVzIG1ldGhvZHMgZm9yIHRyYXZlcnNpbmcsIGRlcmVmZXJlbmNpbmcsIGFuZCB2YWxpZGF0aW5nIHRoZSBBUEkuXG4gKlxuICogQGNsYXNzXG4gKiBAYXVnbWVudHMgJFJlZlBhcnNlclxuICovXG5mdW5jdGlvbiBTd2FnZ2VyUGFyc2VyICgpIHtcbiAgJFJlZlBhcnNlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG51dGlsLmluaGVyaXRzKFN3YWdnZXJQYXJzZXIsICRSZWZQYXJzZXIpO1xuU3dhZ2dlclBhcnNlci5wYXJzZSA9ICRSZWZQYXJzZXIucGFyc2U7XG5Td2FnZ2VyUGFyc2VyLnJlc29sdmUgPSAkUmVmUGFyc2VyLnJlc29sdmU7XG5Td2FnZ2VyUGFyc2VyLmJ1bmRsZSA9ICRSZWZQYXJzZXIuYnVuZGxlO1xuU3dhZ2dlclBhcnNlci5kZXJlZmVyZW5jZSA9ICRSZWZQYXJzZXIuZGVyZWZlcmVuY2U7XG5cbi8qKlxuICogQWxpYXMge0BsaW5rICRSZWZQYXJzZXIjc2NoZW1hfSBhcyB7QGxpbmsgU3dhZ2dlclBhcnNlciNhcGl9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTd2FnZ2VyUGFyc2VyLnByb3RvdHlwZSwgXCJhcGlcIiwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hO1xuICB9XG59KTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIFN3YWdnZXIgQVBJLlxuICogVGhpcyBtZXRob2QgZG9lcyBub3QgcmVzb2x2ZSBhbnkgSlNPTiByZWZlcmVuY2VzLlxuICogSXQganVzdCByZWFkcyBhIHNpbmdsZSBmaWxlIGluIEpTT04gb3IgWUFNTCBmb3JtYXQsIGFuZCBwYXJzZSBpdCBhcyBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aF0gLSBUaGUgZmlsZSBwYXRoIG9yIFVSTCBvZiB0aGUgSlNPTiBzY2hlbWFcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXBpXSAtIFRoZSBTd2FnZ2VyIEFQSSBvYmplY3QuIFRoaXMgb2JqZWN0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHJlYWRpbmcgZnJvbSBgcGF0aGAuXG4gKiBAcGFyYW0ge1BhcnNlck9wdGlvbnN9IFtvcHRpb25zXSAtIE9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBBUEkgaXMgcGFyc2VkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gZXJyb3ItZmlyc3QgY2FsbGJhY2suIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBwYXJzZWQgQVBJIG9iamVjdC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHdpdGggdGhlIHBhcnNlZCBBUEkgb2JqZWN0LlxuICovXG5Td2FnZ2VyUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGFzeW5jIGZ1bmN0aW9uIChwYXRoLCBhcGksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGxldCBhcmdzID0gbm9ybWFsaXplQXJncyhhcmd1bWVudHMpO1xuICBhcmdzLm9wdGlvbnMgPSBuZXcgT3B0aW9ucyhhcmdzLm9wdGlvbnMpO1xuXG4gIHRyeSB7XG4gICAgbGV0IHNjaGVtYSA9IGF3YWl0ICRSZWZQYXJzZXIucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgYXJncy5wYXRoLCBhcmdzLnNjaGVtYSwgYXJncy5vcHRpb25zKTtcblxuICAgIGlmIChzY2hlbWEuc3dhZ2dlcikge1xuICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIHBhcnNlZCBvYmplY3QgaXMgYSBTd2FnZ2VyIEFQSVxuICAgICAgaWYgKHNjaGVtYS5zd2FnZ2VyID09PSB1bmRlZmluZWQgfHwgc2NoZW1hLmluZm8gPT09IHVuZGVmaW5lZCB8fCBzY2hlbWEucGF0aHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBvbm8uc3ludGF4KGAke2FyZ3MucGF0aCB8fCBhcmdzLnNjaGVtYX0gaXMgbm90IGEgdmFsaWQgU3dhZ2dlciBBUEkgZGVmaW5pdGlvbmApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYS5zd2FnZ2VyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSB2ZXJ5IGNvbW1vbiBtaXN0YWtlLCBzbyBnaXZlIGEgaGVscGZ1bCBlcnJvciBtZXNzYWdlXG4gICAgICAgIHRocm93IG9uby5zeW50YXgoJ1N3YWdnZXIgdmVyc2lvbiBudW1iZXIgbXVzdCBiZSBhIHN0cmluZyAoZS5nLiBcIjIuMFwiKSBub3QgYSBudW1iZXIuJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hLmluZm8udmVyc2lvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvLyBUaGlzIGlzIGEgdmVyeSBjb21tb24gbWlzdGFrZSwgc28gZ2l2ZSBhIGhlbHBmdWwgZXJyb3IgbWVzc2FnZVxuICAgICAgICB0aHJvdyBvbm8uc3ludGF4KCdBUEkgdmVyc2lvbiBudW1iZXIgbXVzdCBiZSBhIHN0cmluZyAoZS5nLiBcIjEuMC4wXCIpIG5vdCBhIG51bWJlci4nKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNjaGVtYS5zd2FnZ2VyICE9PSBcIjIuMFwiKSB7XG4gICAgICAgIHRocm93IG9uby5zeW50YXgoYFVucmVjb2duaXplZCBTd2FnZ2VyIHZlcnNpb246ICR7c2NoZW1hLnN3YWdnZXJ9LiBFeHBlY3RlZCAyLjBgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsZXQgc3VwcG9ydGVkVmVyc2lvbnMgPSBbXCIzLjAuMFwiLCBcIjMuMC4xXCIsIFwiMy4wLjJcIiwgXCIzLjAuM1wiXTtcblxuICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIHBhcnNlZCBvYmplY3QgaXMgYSBPcGVuYXBpIEFQSVxuICAgICAgaWYgKHNjaGVtYS5vcGVuYXBpID09PSB1bmRlZmluZWQgfHwgc2NoZW1hLmluZm8gPT09IHVuZGVmaW5lZCB8fCBzY2hlbWEucGF0aHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBvbm8uc3ludGF4KGAke2FyZ3MucGF0aCB8fCBhcmdzLnNjaGVtYX0gaXMgbm90IGEgdmFsaWQgT3BlbmFwaSBBUEkgZGVmaW5pdGlvbmApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYS5vcGVuYXBpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSB2ZXJ5IGNvbW1vbiBtaXN0YWtlLCBzbyBnaXZlIGEgaGVscGZ1bCBlcnJvciBtZXNzYWdlXG4gICAgICAgIHRocm93IG9uby5zeW50YXgoJ09wZW5hcGkgdmVyc2lvbiBudW1iZXIgbXVzdCBiZSBhIHN0cmluZyAoZS5nLiBcIjMuMC4wXCIpIG5vdCBhIG51bWJlci4nKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEuaW5mby52ZXJzaW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSB2ZXJ5IGNvbW1vbiBtaXN0YWtlLCBzbyBnaXZlIGEgaGVscGZ1bCBlcnJvciBtZXNzYWdlXG4gICAgICAgIHRocm93IG9uby5zeW50YXgoJ0FQSSB2ZXJzaW9uIG51bWJlciBtdXN0IGJlIGEgc3RyaW5nIChlLmcuIFwiMS4wLjBcIikgbm90IGEgbnVtYmVyLicpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3VwcG9ydGVkVmVyc2lvbnMuaW5kZXhPZihzY2hlbWEub3BlbmFwaSkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG9uby5zeW50YXgoXG4gICAgICAgICAgYFVuc3VwcG9ydGVkIE9wZW5BUEkgdmVyc2lvbjogJHtzY2hlbWEub3BlbmFwaX0uIGAgK1xuICAgICAgICAgIGBTd2FnZ2VyIFBhcnNlciBvbmx5IHN1cHBvcnRzIHZlcnNpb25zICR7c3VwcG9ydGVkVmVyc2lvbnMuam9pbihcIiwgXCIpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMb29rcyBnb29kIVxuICAgIHJldHVybiBtYXliZShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUoc2NoZW1hKSk7XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBtYXliZShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlamVjdChlcnIpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZXMsIGRlcmVmZXJlbmNlcywgYW5kIHZhbGlkYXRlcyB0aGUgZ2l2ZW4gU3dhZ2dlciBBUEkuXG4gKiBEZXBlbmRpbmcgb24gdGhlIG9wdGlvbnMsIHZhbGlkYXRpb24gY2FuIGluY2x1ZGUgSlNPTiBTY2hlbWEgdmFsaWRhdGlvbiBhbmQvb3IgU3dhZ2dlciBTcGVjIHZhbGlkYXRpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoXSAtIFRoZSBmaWxlIHBhdGggb3IgVVJMIG9mIHRoZSBKU09OIHNjaGVtYVxuICogQHBhcmFtIHtvYmplY3R9IFthcGldIC0gVGhlIFN3YWdnZXIgQVBJIG9iamVjdC4gVGhpcyBvYmplY3Qgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgcmVhZGluZyBmcm9tIGBwYXRoYC5cbiAqIEBwYXJhbSB7UGFyc2VyT3B0aW9uc30gW29wdGlvbnNdIC0gT3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIEFQSSBpcyBwYXJzZWQsIGRlcmVmZXJlbmNlZCwgYW5kIHZhbGlkYXRlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIGVycm9yLWZpcnN0IGNhbGxiYWNrLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0aGUgcGFyc2VkIEFQSSBvYmplY3QuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB3aXRoIHRoZSBwYXJzZWQgQVBJIG9iamVjdC5cbiAqL1xuU3dhZ2dlclBhcnNlci52YWxpZGF0ZSA9IGZ1bmN0aW9uIChwYXRoLCBhcGksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGxldCBDbGFzcyA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gIGxldCBpbnN0YW5jZSA9IG5ldyBDbGFzcygpO1xuICByZXR1cm4gaW5zdGFuY2UudmFsaWRhdGUuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFBhcnNlcywgZGVyZWZlcmVuY2VzLCBhbmQgdmFsaWRhdGVzIHRoZSBnaXZlbiBTd2FnZ2VyIEFQSS5cbiAqIERlcGVuZGluZyBvbiB0aGUgb3B0aW9ucywgdmFsaWRhdGlvbiBjYW4gaW5jbHVkZSBKU09OIFNjaGVtYSB2YWxpZGF0aW9uIGFuZC9vciBTd2FnZ2VyIFNwZWMgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhdGhdIC0gVGhlIGZpbGUgcGF0aCBvciBVUkwgb2YgdGhlIEpTT04gc2NoZW1hXG4gKiBAcGFyYW0ge29iamVjdH0gW2FwaV0gLSBUaGUgU3dhZ2dlciBBUEkgb2JqZWN0LiBUaGlzIG9iamVjdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiByZWFkaW5nIGZyb20gYHBhdGhgLlxuICogQHBhcmFtIHtQYXJzZXJPcHRpb25zfSBbb3B0aW9uc10gLSBPcHRpb25zIHRoYXQgZGV0ZXJtaW5lIGhvdyB0aGUgQVBJIGlzIHBhcnNlZCwgZGVyZWZlcmVuY2VkLCBhbmQgdmFsaWRhdGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gZXJyb3ItZmlyc3QgY2FsbGJhY2suIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBwYXJzZWQgQVBJIG9iamVjdC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHdpdGggdGhlIHBhcnNlZCBBUEkgb2JqZWN0LlxuICovXG5Td2FnZ2VyUGFyc2VyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIChwYXRoLCBhcGksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGxldCBtZSA9IHRoaXM7XG4gIGxldCBhcmdzID0gbm9ybWFsaXplQXJncyhhcmd1bWVudHMpO1xuICBhcmdzLm9wdGlvbnMgPSBuZXcgT3B0aW9ucyhhcmdzLm9wdGlvbnMpO1xuXG4gIC8vIFpTY2hlbWEgZG9lc24ndCBzdXBwb3J0IGNpcmN1bGFyIG9iamVjdHMsIHNvIGRvbid0IGRlcmVmZXJlbmNlIGNpcmN1bGFyICRyZWZzIHlldFxuICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS96YWdnaW5vL3otc2NoZW1hL2lzc3Vlcy8xMzcpXG4gIGxldCBjaXJjdWxhciRSZWZPcHRpb24gPSBhcmdzLm9wdGlvbnMuZGVyZWZlcmVuY2UuY2lyY3VsYXI7XG4gIGFyZ3Mub3B0aW9ucy52YWxpZGF0ZS5zY2hlbWEgJiYgKGFyZ3Mub3B0aW9ucy5kZXJlZmVyZW5jZS5jaXJjdWxhciA9IFwiaWdub3JlXCIpO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5kZXJlZmVyZW5jZShhcmdzLnBhdGgsIGFyZ3Muc2NoZW1hLCBhcmdzLm9wdGlvbnMpO1xuXG4gICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgb3B0aW9ucywgbm93IHRoYXQgd2UncmUgZG9uZSBkZXJlZmVyZW5jaW5nXG4gICAgYXJncy5vcHRpb25zLmRlcmVmZXJlbmNlLmNpcmN1bGFyID0gY2lyY3VsYXIkUmVmT3B0aW9uO1xuXG4gICAgaWYgKGFyZ3Mub3B0aW9ucy52YWxpZGF0ZS5zY2hlbWEpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBBUEkgYWdhaW5zdCB0aGUgU3dhZ2dlciBzY2hlbWFcbiAgICAgIC8vIE5PVEU6IFRoaXMgaXMgc2FmZSB0byBkbywgYmVjYXVzZSB3ZSBoYXZlbid0IGRlcmVmZXJlbmNlZCBjaXJjdWxhciAkcmVmcyB5ZXRcbiAgICAgIHZhbGlkYXRlU2NoZW1hKG1lLmFwaSk7XG5cbiAgICAgIGlmIChtZS4kcmVmcy5jaXJjdWxhcikge1xuICAgICAgICBpZiAoY2lyY3VsYXIkUmVmT3B0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gVGhlIEFQSSBoYXMgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGRvIGEgc2Vjb25kLXBhc3MgdG8gZnVsbHktZGVyZWZlcmVuY2UgaXRcbiAgICAgICAgICBkZXJlZmVyZW5jZShtZSwgYXJncy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaXJjdWxhciRSZWZPcHRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gVGhlIEFQSSBoYXMgY2lyY3VsYXIgcmVmZXJlbmNlcywgYW5kIHRoZXkncmUgbm90IGFsbG93ZWQsIHNvIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgdGhyb3cgb25vLnJlZmVyZW5jZShcIlRoZSBBUEkgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlc1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcmdzLm9wdGlvbnMudmFsaWRhdGUuc3BlYykge1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIEFQSSBhZ2FpbnN0IHRoZSBTd2FnZ2VyIHNwZWNcbiAgICAgIHZhbGlkYXRlU3BlYyhtZS5hcGkpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUobWUuc2NoZW1hKSk7XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBtYXliZShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlamVjdChlcnIpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgU3dhZ2dlciBvYmplY3RcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9PQUkvT3BlbkFQSS1TcGVjaWZpY2F0aW9uL2Jsb2IvbWFzdGVyL3ZlcnNpb25zLzIuMC5tZCNzd2FnZ2VyLW9iamVjdFxuICpcbiAqIEB0eXBlZGVmIHt7c3dhZ2dlcjogc3RyaW5nLCBpbmZvOiB7fSwgcGF0aHM6IHt9fX0gU3dhZ2dlck9iamVjdFxuICovXG4iXSwibmFtZXMiOlsidmFsaWRhdGVTY2hlbWEiLCJyZXF1aXJlIiwidmFsaWRhdGVTcGVjIiwibm9ybWFsaXplQXJncyIsInV0aWwiLCJPcHRpb25zIiwibWF5YmUiLCJvbm8iLCIkUmVmUGFyc2VyIiwiZGVyZWZlcmVuY2UiLCJtb2R1bGUiLCJleHBvcnRzIiwiU3dhZ2dlclBhcnNlciIsImFwcGx5IiwiYXJndW1lbnRzIiwiaW5oZXJpdHMiLCJwYXJzZSIsInJlc29sdmUiLCJidW5kbGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJzY2hlbWEiLCJwYXRoIiwiYXBpIiwib3B0aW9ucyIsImNhbGxiYWNrIiwiYXJncyIsImNhbGwiLCJzd2FnZ2VyIiwidW5kZWZpbmVkIiwiaW5mbyIsInBhdGhzIiwic3ludGF4IiwidmVyc2lvbiIsInN1cHBvcnRlZFZlcnNpb25zIiwib3BlbmFwaSIsImluZGV4T2YiLCJqb2luIiwiUHJvbWlzZSIsImVyciIsInJlamVjdCIsInZhbGlkYXRlIiwiQ2xhc3MiLCJpbnN0YW5jZSIsIm1lIiwiY2lyY3VsYXIkUmVmT3B0aW9uIiwiY2lyY3VsYXIiLCIkcmVmcyIsInJlZmVyZW5jZSIsInNwZWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/swagger-parser/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/swagger-parser/lib/options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@apidevtools/swagger-parser/lib/options.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst $RefParserOptions = __webpack_require__(/*! @apidevtools/json-schema-ref-parser/lib/options */ \"(rsc)/./node_modules/@apidevtools/json-schema-ref-parser/lib/options.js\");\nconst schemaValidator = __webpack_require__(/*! ./validators/schema */ \"(rsc)/./node_modules/@apidevtools/swagger-parser/lib/validators/schema.js\");\nconst specValidator = __webpack_require__(/*! ./validators/spec */ \"(rsc)/./node_modules/@apidevtools/swagger-parser/lib/validators/spec.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nmodule.exports = ParserOptions;\n/**\n * Options that determine how Swagger APIs are parsed, resolved, dereferenced, and validated.\n *\n * @param {object|ParserOptions} [_options] - Overridden options\n * @class\n * @augments $RefParserOptions\n */ function ParserOptions(_options) {\n    $RefParserOptions.call(this, ParserOptions.defaults);\n    $RefParserOptions.apply(this, arguments);\n}\nParserOptions.defaults = {\n    /**\n   * Determines how the API definition will be validated.\n   *\n   * You can add additional validators of your own, replace an existing one with\n   * your own implemenation, or disable any validator by setting it to false.\n   */ validate: {\n        schema: schemaValidator,\n        spec: specValidator\n    }\n};\nutil.inherits(ParserOptions, $RefParserOptions);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL3N3YWdnZXItcGFyc2VyL2xpYi9vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsTUFBTUEsb0JBQW9CQyxtQkFBT0EsQ0FBQyxnSUFBaUQ7QUFDbkYsTUFBTUMsa0JBQWtCRCxtQkFBT0EsQ0FBQyxzR0FBcUI7QUFDckQsTUFBTUUsZ0JBQWdCRixtQkFBT0EsQ0FBQyxrR0FBbUI7QUFDakQsTUFBTUcsT0FBT0gsbUJBQU9BLENBQUMsa0JBQU07QUFFM0JJLE9BQU9DLE9BQU8sR0FBR0M7QUFFakI7Ozs7OztDQU1DLEdBQ0QsU0FBU0EsY0FBZUMsUUFBUTtJQUM5QlIsa0JBQWtCUyxJQUFJLENBQUMsSUFBSSxFQUFFRixjQUFjRyxRQUFRO0lBQ25EVixrQkFBa0JXLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0FBQ2hDO0FBRUFMLGNBQWNHLFFBQVEsR0FBRztJQUN2Qjs7Ozs7R0FLQyxHQUNERyxVQUFVO1FBQ1JDLFFBQVFaO1FBQ1JhLE1BQU1aO0lBQ1I7QUFDRjtBQUVBQyxLQUFLWSxRQUFRLENBQUNULGVBQWVQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvc3dhZ2dlci1wYXJzZXIvbGliL29wdGlvbnMuanM/OTgzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgJFJlZlBhcnNlck9wdGlvbnMgPSByZXF1aXJlKFwiQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvbGliL29wdGlvbnNcIik7XG5jb25zdCBzY2hlbWFWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL3NjaGVtYVwiKTtcbmNvbnN0IHNwZWNWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL3NwZWNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyT3B0aW9ucztcblxuLyoqXG4gKiBPcHRpb25zIHRoYXQgZGV0ZXJtaW5lIGhvdyBTd2FnZ2VyIEFQSXMgYXJlIHBhcnNlZCwgcmVzb2x2ZWQsIGRlcmVmZXJlbmNlZCwgYW5kIHZhbGlkYXRlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxQYXJzZXJPcHRpb25zfSBbX29wdGlvbnNdIC0gT3ZlcnJpZGRlbiBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBhdWdtZW50cyAkUmVmUGFyc2VyT3B0aW9uc1xuICovXG5mdW5jdGlvbiBQYXJzZXJPcHRpb25zIChfb3B0aW9ucykge1xuICAkUmVmUGFyc2VyT3B0aW9ucy5jYWxsKHRoaXMsIFBhcnNlck9wdGlvbnMuZGVmYXVsdHMpO1xuICAkUmVmUGFyc2VyT3B0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5QYXJzZXJPcHRpb25zLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogRGV0ZXJtaW5lcyBob3cgdGhlIEFQSSBkZWZpbml0aW9uIHdpbGwgYmUgdmFsaWRhdGVkLlxuICAgKlxuICAgKiBZb3UgY2FuIGFkZCBhZGRpdGlvbmFsIHZhbGlkYXRvcnMgb2YgeW91ciBvd24sIHJlcGxhY2UgYW4gZXhpc3Rpbmcgb25lIHdpdGhcbiAgICogeW91ciBvd24gaW1wbGVtZW5hdGlvbiwgb3IgZGlzYWJsZSBhbnkgdmFsaWRhdG9yIGJ5IHNldHRpbmcgaXQgdG8gZmFsc2UuXG4gICAqL1xuICB2YWxpZGF0ZToge1xuICAgIHNjaGVtYTogc2NoZW1hVmFsaWRhdG9yLFxuICAgIHNwZWM6IHNwZWNWYWxpZGF0b3IsXG4gIH0sXG59O1xuXG51dGlsLmluaGVyaXRzKFBhcnNlck9wdGlvbnMsICRSZWZQYXJzZXJPcHRpb25zKTtcbiJdLCJuYW1lcyI6WyIkUmVmUGFyc2VyT3B0aW9ucyIsInJlcXVpcmUiLCJzY2hlbWFWYWxpZGF0b3IiLCJzcGVjVmFsaWRhdG9yIiwidXRpbCIsIm1vZHVsZSIsImV4cG9ydHMiLCJQYXJzZXJPcHRpb25zIiwiX29wdGlvbnMiLCJjYWxsIiwiZGVmYXVsdHMiLCJhcHBseSIsImFyZ3VtZW50cyIsInZhbGlkYXRlIiwic2NoZW1hIiwic3BlYyIsImluaGVyaXRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/swagger-parser/lib/options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/swagger-parser/lib/util.js":
/*!**************************************************************!*\
  !*** ./node_modules/@apidevtools/swagger-parser/lib/util.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nexports.format = util.format;\nexports.inherits = util.inherits;\n/**\n * Regular Expression that matches Swagger path params.\n */ exports.swaggerParamRegExp = /\\{([^/}]+)}/g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL3N3YWdnZXItcGFyc2VyL2xpYi91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUMsa0JBQU07QUFFM0JDLGNBQWMsR0FBR0YsS0FBS0csTUFBTTtBQUM1QkQsZ0JBQWdCLEdBQUdGLEtBQUtJLFFBQVE7QUFFaEM7O0NBRUMsR0FDREYsMEJBQTBCLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9zd2FnZ2VyLXBhcnNlci9saWIvdXRpbC5qcz83OTNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5cbmV4cG9ydHMuZm9ybWF0ID0gdXRpbC5mb3JtYXQ7XG5leHBvcnRzLmluaGVyaXRzID0gdXRpbC5pbmhlcml0cztcblxuLyoqXG4gKiBSZWd1bGFyIEV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIFN3YWdnZXIgcGF0aCBwYXJhbXMuXG4gKi9cbmV4cG9ydHMuc3dhZ2dlclBhcmFtUmVnRXhwID0gL1xceyhbXi99XSspfS9nO1xuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiZXhwb3J0cyIsImZvcm1hdCIsImluaGVyaXRzIiwic3dhZ2dlclBhcmFtUmVnRXhwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/swagger-parser/lib/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/swagger-parser/lib/validators/schema.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@apidevtools/swagger-parser/lib/validators/schema.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/@apidevtools/swagger-parser/lib/util.js\");\nconst { ono } = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst ZSchema = __webpack_require__(/*! z-schema */ \"(rsc)/./node_modules/z-schema/src/ZSchema.js\");\nconst { openapi } = __webpack_require__(/*! @apidevtools/openapi-schemas */ \"(rsc)/./node_modules/@apidevtools/openapi-schemas/lib/index.js\");\nmodule.exports = validateSchema;\nlet zSchema = initializeZSchema();\n/**\n * Validates the given Swagger API against the Swagger 2.0 or 3.0 schema.\n *\n * @param {SwaggerObject} api\n */ function validateSchema(api) {\n    // Choose the appropriate schema (Swagger or OpenAPI)\n    let schema = api.swagger ? openapi.v2 : openapi.v3;\n    // Validate against the schema\n    let isValid = zSchema.validate(api, schema);\n    if (!isValid) {\n        let err = zSchema.getLastError();\n        let message = \"Swagger schema validation failed. \\n\" + formatZSchemaError(err.details);\n        throw ono.syntax(err, {\n            details: err.details\n        }, message);\n    }\n}\n/**\n * Performs one-time initialization logic to prepare for Swagger Schema validation.\n */ function initializeZSchema() {\n    // HACK: Delete the OpenAPI schema IDs because ZSchema can't resolve them\n    delete openapi.v2.id;\n    delete openapi.v3.id;\n    // The OpenAPI 3.0 schema uses \"uri-reference\" formats.\n    // Assume that any non-whitespace string is valid.\n    ZSchema.registerFormat(\"uri-reference\", (value)=>value.trim().length > 0);\n    // Configure ZSchema\n    return new ZSchema({\n        breakOnFirstError: true,\n        noExtraKeywords: true,\n        ignoreUnknownFormats: false,\n        reportPathAsArray: true\n    });\n}\n/**\n * Z-Schema validation errors are a nested tree structure.\n * This function crawls that tree and builds an error message string.\n *\n * @param {object[]}  errors     - The Z-Schema error details\n * @param {string}    [indent]   - The whitespace used to indent the error message\n * @returns {string}\n */ function formatZSchemaError(errors, indent) {\n    indent = indent || \"  \";\n    let message = \"\";\n    for (let error of errors){\n        message += util.format(`${indent}${error.message} at #/${error.path.join(\"/\")}\\n`);\n        if (error.inner) {\n            message += formatZSchemaError(error.inner, indent + \"  \");\n        }\n    }\n    return message;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL3N3YWdnZXItcGFyc2VyL2xpYi92YWxpZGF0b3JzL3NjaGVtYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDLDZFQUFTO0FBQzlCLE1BQU0sRUFBRUMsR0FBRyxFQUFFLEdBQUdELG1CQUFPQSxDQUFDLDBFQUFpQjtBQUN6QyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyw4REFBVTtBQUNsQyxNQUFNLEVBQUVHLE9BQU8sRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQyxvR0FBOEI7QUFFMURJLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsVUFBVUM7QUFFZDs7OztDQUlDLEdBQ0QsU0FBU0YsZUFBZ0JHLEdBQUc7SUFDMUIscURBQXFEO0lBQ3JELElBQUlDLFNBQVNELElBQUlFLE9BQU8sR0FBR1IsUUFBUVMsRUFBRSxHQUFHVCxRQUFRVSxFQUFFO0lBRWxELDhCQUE4QjtJQUM5QixJQUFJQyxVQUFVUCxRQUFRUSxRQUFRLENBQUNOLEtBQUtDO0lBRXBDLElBQUksQ0FBQ0ksU0FBUztRQUNaLElBQUlFLE1BQU1ULFFBQVFVLFlBQVk7UUFDOUIsSUFBSUMsVUFBVSx5Q0FBeUNDLG1CQUFtQkgsSUFBSUksT0FBTztRQUNyRixNQUFNbkIsSUFBSW9CLE1BQU0sQ0FBQ0wsS0FBSztZQUFFSSxTQUFTSixJQUFJSSxPQUFPO1FBQUMsR0FBR0Y7SUFDbEQ7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBU1Y7SUFDUCx5RUFBeUU7SUFDekUsT0FBT0wsUUFBUVMsRUFBRSxDQUFDVSxFQUFFO0lBQ3BCLE9BQU9uQixRQUFRVSxFQUFFLENBQUNTLEVBQUU7SUFFcEIsdURBQXVEO0lBQ3ZELGtEQUFrRDtJQUNsRHBCLFFBQVFxQixjQUFjLENBQUMsaUJBQWlCLENBQUNDLFFBQVVBLE1BQU1DLElBQUksR0FBR0MsTUFBTSxHQUFHO0lBRXpFLG9CQUFvQjtJQUNwQixPQUFPLElBQUl4QixRQUFRO1FBQ2pCeUIsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLHNCQUFzQjtRQUN0QkMsbUJBQW1CO0lBQ3JCO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1gsbUJBQW9CWSxNQUFNLEVBQUVDLE1BQU07SUFDekNBLFNBQVNBLFVBQVU7SUFDbkIsSUFBSWQsVUFBVTtJQUNkLEtBQUssSUFBSWUsU0FBU0YsT0FBUTtRQUN4QmIsV0FBV25CLEtBQUttQyxNQUFNLENBQUMsQ0FBQyxFQUFFRixPQUFPLEVBQUVDLE1BQU1mLE9BQU8sQ0FBQyxNQUFNLEVBQUVlLE1BQU1FLElBQUksQ0FBQ0MsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2pGLElBQUlILE1BQU1JLEtBQUssRUFBRTtZQUNmbkIsV0FBV0MsbUJBQW1CYyxNQUFNSSxLQUFLLEVBQUVMLFNBQVM7UUFDdEQ7SUFDRjtJQUNBLE9BQU9kO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9zd2FnZ2VyLXBhcnNlci9saWIvdmFsaWRhdG9ycy9zY2hlbWEuanM/ODdhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgeyBvbm8gfSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCBaU2NoZW1hID0gcmVxdWlyZShcInotc2NoZW1hXCIpO1xuY29uc3QgeyBvcGVuYXBpIH0gPSByZXF1aXJlKFwiQGFwaWRldnRvb2xzL29wZW5hcGktc2NoZW1hc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZVNjaGVtYTtcblxubGV0IHpTY2hlbWEgPSBpbml0aWFsaXplWlNjaGVtYSgpO1xuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gU3dhZ2dlciBBUEkgYWdhaW5zdCB0aGUgU3dhZ2dlciAyLjAgb3IgMy4wIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0ge1N3YWdnZXJPYmplY3R9IGFwaVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYSAoYXBpKSB7XG4gIC8vIENob29zZSB0aGUgYXBwcm9wcmlhdGUgc2NoZW1hIChTd2FnZ2VyIG9yIE9wZW5BUEkpXG4gIGxldCBzY2hlbWEgPSBhcGkuc3dhZ2dlciA/IG9wZW5hcGkudjIgOiBvcGVuYXBpLnYzO1xuXG4gIC8vIFZhbGlkYXRlIGFnYWluc3QgdGhlIHNjaGVtYVxuICBsZXQgaXNWYWxpZCA9IHpTY2hlbWEudmFsaWRhdGUoYXBpLCBzY2hlbWEpO1xuXG4gIGlmICghaXNWYWxpZCkge1xuICAgIGxldCBlcnIgPSB6U2NoZW1hLmdldExhc3RFcnJvcigpO1xuICAgIGxldCBtZXNzYWdlID0gXCJTd2FnZ2VyIHNjaGVtYSB2YWxpZGF0aW9uIGZhaWxlZC4gXFxuXCIgKyBmb3JtYXRaU2NoZW1hRXJyb3IoZXJyLmRldGFpbHMpO1xuICAgIHRocm93IG9uby5zeW50YXgoZXJyLCB7IGRldGFpbHM6IGVyci5kZXRhaWxzIH0sIG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgb25lLXRpbWUgaW5pdGlhbGl6YXRpb24gbG9naWMgdG8gcHJlcGFyZSBmb3IgU3dhZ2dlciBTY2hlbWEgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVpTY2hlbWEgKCkge1xuICAvLyBIQUNLOiBEZWxldGUgdGhlIE9wZW5BUEkgc2NoZW1hIElEcyBiZWNhdXNlIFpTY2hlbWEgY2FuJ3QgcmVzb2x2ZSB0aGVtXG4gIGRlbGV0ZSBvcGVuYXBpLnYyLmlkO1xuICBkZWxldGUgb3BlbmFwaS52My5pZDtcblxuICAvLyBUaGUgT3BlbkFQSSAzLjAgc2NoZW1hIHVzZXMgXCJ1cmktcmVmZXJlbmNlXCIgZm9ybWF0cy5cbiAgLy8gQXNzdW1lIHRoYXQgYW55IG5vbi13aGl0ZXNwYWNlIHN0cmluZyBpcyB2YWxpZC5cbiAgWlNjaGVtYS5yZWdpc3RlckZvcm1hdChcInVyaS1yZWZlcmVuY2VcIiwgKHZhbHVlKSA9PiB2YWx1ZS50cmltKCkubGVuZ3RoID4gMCk7XG5cbiAgLy8gQ29uZmlndXJlIFpTY2hlbWFcbiAgcmV0dXJuIG5ldyBaU2NoZW1hKHtcbiAgICBicmVha09uRmlyc3RFcnJvcjogdHJ1ZSxcbiAgICBub0V4dHJhS2V5d29yZHM6IHRydWUsXG4gICAgaWdub3JlVW5rbm93bkZvcm1hdHM6IGZhbHNlLFxuICAgIHJlcG9ydFBhdGhBc0FycmF5OiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFotU2NoZW1hIHZhbGlkYXRpb24gZXJyb3JzIGFyZSBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZS5cbiAqIFRoaXMgZnVuY3Rpb24gY3Jhd2xzIHRoYXQgdHJlZSBhbmQgYnVpbGRzIGFuIGVycm9yIG1lc3NhZ2Ugc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0W119ICBlcnJvcnMgICAgIC0gVGhlIFotU2NoZW1hIGVycm9yIGRldGFpbHNcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBbaW5kZW50XSAgIC0gVGhlIHdoaXRlc3BhY2UgdXNlZCB0byBpbmRlbnQgdGhlIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFpTY2hlbWFFcnJvciAoZXJyb3JzLCBpbmRlbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IFwiICBcIjtcbiAgbGV0IG1lc3NhZ2UgPSBcIlwiO1xuICBmb3IgKGxldCBlcnJvciBvZiBlcnJvcnMpIHtcbiAgICBtZXNzYWdlICs9IHV0aWwuZm9ybWF0KGAke2luZGVudH0ke2Vycm9yLm1lc3NhZ2V9IGF0ICMvJHtlcnJvci5wYXRoLmpvaW4oXCIvXCIpfVxcbmApO1xuICAgIGlmIChlcnJvci5pbm5lcikge1xuICAgICAgbWVzc2FnZSArPSBmb3JtYXRaU2NoZW1hRXJyb3IoZXJyb3IuaW5uZXIsIGluZGVudCArIFwiICBcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXNzYWdlO1xufVxuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwib25vIiwiWlNjaGVtYSIsIm9wZW5hcGkiLCJtb2R1bGUiLCJleHBvcnRzIiwidmFsaWRhdGVTY2hlbWEiLCJ6U2NoZW1hIiwiaW5pdGlhbGl6ZVpTY2hlbWEiLCJhcGkiLCJzY2hlbWEiLCJzd2FnZ2VyIiwidjIiLCJ2MyIsImlzVmFsaWQiLCJ2YWxpZGF0ZSIsImVyciIsImdldExhc3RFcnJvciIsIm1lc3NhZ2UiLCJmb3JtYXRaU2NoZW1hRXJyb3IiLCJkZXRhaWxzIiwic3ludGF4IiwiaWQiLCJyZWdpc3RlckZvcm1hdCIsInZhbHVlIiwidHJpbSIsImxlbmd0aCIsImJyZWFrT25GaXJzdEVycm9yIiwibm9FeHRyYUtleXdvcmRzIiwiaWdub3JlVW5rbm93bkZvcm1hdHMiLCJyZXBvcnRQYXRoQXNBcnJheSIsImVycm9ycyIsImluZGVudCIsImVycm9yIiwiZm9ybWF0IiwicGF0aCIsImpvaW4iLCJpbm5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/swagger-parser/lib/validators/schema.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/swagger-parser/lib/validators/spec.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@apidevtools/swagger-parser/lib/validators/spec.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/@apidevtools/swagger-parser/lib/util.js\");\nconst { ono } = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst swaggerMethods = __webpack_require__(/*! @apidevtools/swagger-methods */ \"(rsc)/./node_modules/@apidevtools/swagger-methods/lib/index.js\");\nconst primitiveTypes = [\n    \"array\",\n    \"boolean\",\n    \"integer\",\n    \"number\",\n    \"string\"\n];\nconst schemaTypes = [\n    \"array\",\n    \"boolean\",\n    \"integer\",\n    \"number\",\n    \"string\",\n    \"object\",\n    \"null\",\n    undefined\n];\nmodule.exports = validateSpec;\n/**\n * Validates parts of the Swagger 2.0 spec that aren't covered by the Swagger 2.0 JSON Schema.\n *\n * @param {SwaggerObject} api\n */ function validateSpec(api) {\n    if (api.openapi) {\n        // We don't (yet) support validating against the OpenAPI spec\n        return;\n    }\n    let paths = Object.keys(api.paths || {});\n    let operationIds = [];\n    for (let pathName of paths){\n        let path = api.paths[pathName];\n        let pathId = \"/paths\" + pathName;\n        if (path && pathName.indexOf(\"/\") === 0) {\n            validatePath(api, path, pathId, operationIds);\n        }\n    }\n    let definitions = Object.keys(api.definitions || {});\n    for (let definitionName of definitions){\n        let definition = api.definitions[definitionName];\n        let definitionId = \"/definitions/\" + definitionName;\n        validateRequiredPropertiesExist(definition, definitionId);\n    }\n}\n/**\n * Validates the given path.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {string}        operationIds  - An array of collected operationIds found in other paths\n */ function validatePath(api, path, pathId, operationIds) {\n    for (let operationName of swaggerMethods){\n        let operation = path[operationName];\n        let operationId = pathId + \"/\" + operationName;\n        if (operation) {\n            let declaredOperationId = operation.operationId;\n            if (declaredOperationId) {\n                if (operationIds.indexOf(declaredOperationId) === -1) {\n                    operationIds.push(declaredOperationId);\n                } else {\n                    throw ono.syntax(`Validation failed. Duplicate operation id '${declaredOperationId}'`);\n                }\n            }\n            validateParameters(api, path, pathId, operation, operationId);\n            let responses = Object.keys(operation.responses || {});\n            for (let responseName of responses){\n                let response = operation.responses[responseName];\n                let responseId = operationId + \"/responses/\" + responseName;\n                validateResponse(responseName, response || {}, responseId);\n            }\n        }\n    }\n}\n/**\n * Validates the parameters for the given operation.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {object}        operation     - An Operation object, from the Swagger API\n * @param {string}        operationId   - A value that uniquely identifies the operation\n */ function validateParameters(api, path, pathId, operation, operationId) {\n    let pathParams = path.parameters || [];\n    let operationParams = operation.parameters || [];\n    // Check for duplicate path parameters\n    try {\n        checkForDuplicates(pathParams);\n    } catch (e) {\n        throw ono.syntax(e, `Validation failed. ${pathId} has duplicate parameters`);\n    }\n    // Check for duplicate operation parameters\n    try {\n        checkForDuplicates(operationParams);\n    } catch (e) {\n        throw ono.syntax(e, `Validation failed. ${operationId} has duplicate parameters`);\n    }\n    // Combine the path and operation parameters,\n    // with the operation params taking precedence over the path params\n    let params = pathParams.reduce((combinedParams, value)=>{\n        let duplicate = combinedParams.some((param)=>{\n            return param.in === value.in && param.name === value.name;\n        });\n        if (!duplicate) {\n            combinedParams.push(value);\n        }\n        return combinedParams;\n    }, operationParams.slice());\n    validateBodyParameters(params, operationId);\n    validatePathParameters(params, pathId, operationId);\n    validateParameterTypes(params, api, operation, operationId);\n}\n/**\n * Validates body and formData parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */ function validateBodyParameters(params, operationId) {\n    let bodyParams = params.filter((param)=>{\n        return param.in === \"body\";\n    });\n    let formParams = params.filter((param)=>{\n        return param.in === \"formData\";\n    });\n    // There can only be one \"body\" parameter\n    if (bodyParams.length > 1) {\n        throw ono.syntax(`Validation failed. ${operationId} has ${bodyParams.length} body parameters. Only one is allowed.`);\n    } else if (bodyParams.length > 0 && formParams.length > 0) {\n        // \"body\" params and \"formData\" params are mutually exclusive\n        throw ono.syntax(`Validation failed. ${operationId} has body parameters and formData parameters. Only one or the other is allowed.`);\n    }\n}\n/**\n * Validates path parameters for the given path.\n *\n * @param   {object[]}  params        - An array of Parameter objects\n * @param   {string}    pathId        - A value that uniquely identifies the path\n * @param   {string}    operationId   - A value that uniquely identifies the operation\n */ function validatePathParameters(params, pathId, operationId) {\n    // Find all {placeholders} in the path string\n    let placeholders = pathId.match(util.swaggerParamRegExp) || [];\n    // Check for duplicates\n    for(let i = 0; i < placeholders.length; i++){\n        for(let j = i + 1; j < placeholders.length; j++){\n            if (placeholders[i] === placeholders[j]) {\n                throw ono.syntax(`Validation failed. ${operationId} has multiple path placeholders named ${placeholders[i]}`);\n            }\n        }\n    }\n    params = params.filter((param)=>{\n        return param.in === \"path\";\n    });\n    for (let param of params){\n        if (param.required !== true) {\n            throw ono.syntax(\"Validation failed. Path parameters cannot be optional. \" + `Set required=true for the \"${param.name}\" parameter at ${operationId}`);\n        }\n        let match = placeholders.indexOf(\"{\" + param.name + \"}\");\n        if (match === -1) {\n            throw ono.syntax(`Validation failed. ${operationId} has a path parameter named \"${param.name}\", ` + `but there is no corresponding {${param.name}} in the path string`);\n        }\n        placeholders.splice(match, 1);\n    }\n    if (placeholders.length > 0) {\n        throw ono.syntax(`Validation failed. ${operationId} is missing path parameter(s) for ${placeholders}`);\n    }\n}\n/**\n * Validates data types of parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {object}    api          -  The entire Swagger API object\n * @param   {object}    operation    -  An Operation object, from the Swagger API\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */ function validateParameterTypes(params, api, operation, operationId) {\n    for (let param of params){\n        let parameterId = operationId + \"/parameters/\" + param.name;\n        let schema, validTypes;\n        switch(param.in){\n            case \"body\":\n                schema = param.schema;\n                validTypes = schemaTypes;\n                break;\n            case \"formData\":\n                schema = param;\n                validTypes = primitiveTypes.concat(\"file\");\n                break;\n            default:\n                schema = param;\n                validTypes = primitiveTypes;\n        }\n        validateSchema(schema, parameterId, validTypes);\n        validateRequiredPropertiesExist(schema, parameterId);\n        if (schema.type === \"file\") {\n            // \"file\" params must consume at least one of these MIME types\n            let formData = /multipart\\/(.*\\+)?form-data/;\n            let urlEncoded = /application\\/(.*\\+)?x-www-form-urlencoded/;\n            let consumes = operation.consumes || api.consumes || [];\n            let hasValidMimeType = consumes.some((consume)=>{\n                return formData.test(consume) || urlEncoded.test(consume);\n            });\n            if (!hasValidMimeType) {\n                throw ono.syntax(`Validation failed. ${operationId} has a file parameter, so it must consume multipart/form-data ` + \"or application/x-www-form-urlencoded\");\n            }\n        }\n    }\n}\n/**\n * Checks the given parameter list for duplicates, and throws an error if found.\n *\n * @param   {object[]}  params  - An array of Parameter objects\n */ function checkForDuplicates(params) {\n    for(let i = 0; i < params.length - 1; i++){\n        let outer = params[i];\n        for(let j = i + 1; j < params.length; j++){\n            let inner = params[j];\n            if (outer.name === inner.name && outer.in === inner.in) {\n                throw ono.syntax(`Validation failed. Found multiple ${outer.in} parameters named \"${outer.name}\"`);\n            }\n        }\n    }\n}\n/**\n * Validates the given response object.\n *\n * @param   {string}    code        -  The HTTP response code (or \"default\")\n * @param   {object}    response    -  A Response object, from the Swagger API\n * @param   {string}    responseId  -  A value that uniquely identifies the response\n */ function validateResponse(code, response, responseId) {\n    if (code !== \"default\" && (code < 100 || code > 599)) {\n        throw ono.syntax(`Validation failed. ${responseId} has an invalid response code (${code})`);\n    }\n    let headers = Object.keys(response.headers || {});\n    for (let headerName of headers){\n        let header = response.headers[headerName];\n        let headerId = responseId + \"/headers/\" + headerName;\n        validateSchema(header, headerId, primitiveTypes);\n    }\n    if (response.schema) {\n        let validTypes = schemaTypes.concat(\"file\");\n        if (validTypes.indexOf(response.schema.type) === -1) {\n            throw ono.syntax(`Validation failed. ${responseId} has an invalid response schema type (${response.schema.type})`);\n        } else {\n            validateSchema(response.schema, responseId + \"/schema\", validTypes);\n        }\n    }\n}\n/**\n * Validates the given Swagger schema object.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n * @param {string[]}  validTypes  - An array of the allowed schema types\n */ function validateSchema(schema, schemaId, validTypes) {\n    if (validTypes.indexOf(schema.type) === -1) {\n        throw ono.syntax(`Validation failed. ${schemaId} has an invalid type (${schema.type})`);\n    }\n    if (schema.type === \"array\" && !schema.items) {\n        throw ono.syntax(`Validation failed. ${schemaId} is an array, so it must include an \"items\" schema`);\n    }\n}\n/**\n * Validates that the declared properties of the given Swagger schema object actually exist.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n */ function validateRequiredPropertiesExist(schema, schemaId) {\n    /**\n   * Recursively collects all properties of the schema and its ancestors. They are added to the props object.\n   */ function collectProperties(schemaObj, props) {\n        if (schemaObj.properties) {\n            for(let property in schemaObj.properties){\n                if (schemaObj.properties.hasOwnProperty(property)) {\n                    props[property] = schemaObj.properties[property];\n                }\n            }\n        }\n        if (schemaObj.allOf) {\n            for (let parent of schemaObj.allOf){\n                collectProperties(parent, props);\n            }\n        }\n    }\n    if (schema.required && Array.isArray(schema.required)) {\n        let props = {};\n        collectProperties(schema, props);\n        for (let requiredProperty of schema.required){\n            if (!props[requiredProperty]) {\n                throw ono.syntax(`Validation failed. Property '${requiredProperty}' listed as required but does not exist in '${schemaId}'`);\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL3N3YWdnZXItcGFyc2VyL2xpYi92YWxpZGF0b3JzL3NwZWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQyw2RUFBUztBQUM5QixNQUFNLEVBQUVDLEdBQUcsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQywwRUFBaUI7QUFDekMsTUFBTUUsaUJBQWlCRixtQkFBT0EsQ0FBQyxvR0FBOEI7QUFDN0QsTUFBTUcsaUJBQWlCO0lBQUM7SUFBUztJQUFXO0lBQVc7SUFBVTtDQUFTO0FBQzFFLE1BQU1DLGNBQWM7SUFBQztJQUFTO0lBQVc7SUFBVztJQUFVO0lBQVU7SUFBVTtJQUFRQztDQUFVO0FBRXBHQyxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCOzs7O0NBSUMsR0FDRCxTQUFTQSxhQUFjQyxHQUFHO0lBQ3hCLElBQUlBLElBQUlDLE9BQU8sRUFBRTtRQUNmLDZEQUE2RDtRQUM3RDtJQUNGO0lBRUEsSUFBSUMsUUFBUUMsT0FBT0MsSUFBSSxDQUFDSixJQUFJRSxLQUFLLElBQUksQ0FBQztJQUN0QyxJQUFJRyxlQUFlLEVBQUU7SUFDckIsS0FBSyxJQUFJQyxZQUFZSixNQUFPO1FBQzFCLElBQUlLLE9BQU9QLElBQUlFLEtBQUssQ0FBQ0ksU0FBUztRQUM5QixJQUFJRSxTQUFTLFdBQVdGO1FBRXhCLElBQUlDLFFBQVFELFNBQVNHLE9BQU8sQ0FBQyxTQUFTLEdBQUc7WUFDdkNDLGFBQWFWLEtBQUtPLE1BQU1DLFFBQVFIO1FBQ2xDO0lBQ0Y7SUFFQSxJQUFJTSxjQUFjUixPQUFPQyxJQUFJLENBQUNKLElBQUlXLFdBQVcsSUFBSSxDQUFDO0lBQ2xELEtBQUssSUFBSUMsa0JBQWtCRCxZQUFhO1FBQ3RDLElBQUlFLGFBQWFiLElBQUlXLFdBQVcsQ0FBQ0MsZUFBZTtRQUNoRCxJQUFJRSxlQUFlLGtCQUFrQkY7UUFDckNHLGdDQUFnQ0YsWUFBWUM7SUFDOUM7QUFDRjtBQUVB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QUFLLElBQUlDLFlBQVlILFVBQVVFLFVBQVUsQ0FBRTtnQkFDekMsSUFBSUYsVUFBVUUsVUFBVSxDQUFDRSxjQUFjLENBQUNELFdBQVc7b0JBQ2pERixLQUFLLENBQUNFLFNBQVMsR0FBR0gsVUFBVUUsVUFBVSxDQUFDQyxTQUFTO2dCQUNsRDtZQUNGO1FBQ0Y7UUFDQSxJQUFJSCxVQUFVSyxLQUFLLEVBQUU7WUFDbkIsS0FBSyxJQUFJQyxVQUFVTixVQUFVSyxLQUFLLENBQUU7Z0JBQ2xDTixrQkFBa0JPLFFBQVFMO1lBQzVCO1FBQ0Y7SUFDRjtJQUVBLElBQUl0QixPQUFPSCxRQUFRLElBQUkrQixNQUFNQyxPQUFPLENBQUM3QixPQUFPSCxRQUFRLEdBQUc7UUFDckQsSUFBSXlCLFFBQVEsQ0FBQztRQUNiRixrQkFBa0JwQixRQUFRc0I7UUFDMUIsS0FBSyxJQUFJUSxvQkFBb0I5QixPQUFPSCxRQUFRLENBQUU7WUFDNUMsSUFBSSxDQUFDeUIsS0FBSyxDQUFDUSxpQkFBaUIsRUFBRTtnQkFDNUIsTUFBTWhHLElBQUk2QixNQUFNLENBQ2QsQ0FBQyw2QkFBNkIsRUFBRW1FLGlCQUFpQiw0Q0FBNEMsRUFBRVosU0FBUyxDQUFDLENBQUM7WUFFOUc7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9zd2FnZ2VyLXBhcnNlci9saWIvdmFsaWRhdG9ycy9zcGVjLmpzP2UxYTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IHsgb25vIH0gPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3Qgc3dhZ2dlck1ldGhvZHMgPSByZXF1aXJlKFwiQGFwaWRldnRvb2xzL3N3YWdnZXItbWV0aG9kc1wiKTtcbmNvbnN0IHByaW1pdGl2ZVR5cGVzID0gW1wiYXJyYXlcIiwgXCJib29sZWFuXCIsIFwiaW50ZWdlclwiLCBcIm51bWJlclwiLCBcInN0cmluZ1wiXTtcbmNvbnN0IHNjaGVtYVR5cGVzID0gW1wiYXJyYXlcIiwgXCJib29sZWFuXCIsIFwiaW50ZWdlclwiLCBcIm51bWJlclwiLCBcInN0cmluZ1wiLCBcIm9iamVjdFwiLCBcIm51bGxcIiwgdW5kZWZpbmVkXTtcblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZVNwZWM7XG5cbi8qKlxuICogVmFsaWRhdGVzIHBhcnRzIG9mIHRoZSBTd2FnZ2VyIDIuMCBzcGVjIHRoYXQgYXJlbid0IGNvdmVyZWQgYnkgdGhlIFN3YWdnZXIgMi4wIEpTT04gU2NoZW1hLlxuICpcbiAqIEBwYXJhbSB7U3dhZ2dlck9iamVjdH0gYXBpXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3BlYyAoYXBpKSB7XG4gIGlmIChhcGkub3BlbmFwaSkge1xuICAgIC8vIFdlIGRvbid0ICh5ZXQpIHN1cHBvcnQgdmFsaWRhdGluZyBhZ2FpbnN0IHRoZSBPcGVuQVBJIHNwZWNcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgcGF0aHMgPSBPYmplY3Qua2V5cyhhcGkucGF0aHMgfHwge30pO1xuICBsZXQgb3BlcmF0aW9uSWRzID0gW107XG4gIGZvciAobGV0IHBhdGhOYW1lIG9mIHBhdGhzKSB7XG4gICAgbGV0IHBhdGggPSBhcGkucGF0aHNbcGF0aE5hbWVdO1xuICAgIGxldCBwYXRoSWQgPSBcIi9wYXRoc1wiICsgcGF0aE5hbWU7XG5cbiAgICBpZiAocGF0aCAmJiBwYXRoTmFtZS5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuICAgICAgdmFsaWRhdGVQYXRoKGFwaSwgcGF0aCwgcGF0aElkLCBvcGVyYXRpb25JZHMpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBkZWZpbml0aW9ucyA9IE9iamVjdC5rZXlzKGFwaS5kZWZpbml0aW9ucyB8fCB7fSk7XG4gIGZvciAobGV0IGRlZmluaXRpb25OYW1lIG9mIGRlZmluaXRpb25zKSB7XG4gICAgbGV0IGRlZmluaXRpb24gPSBhcGkuZGVmaW5pdGlvbnNbZGVmaW5pdGlvbk5hbWVdO1xuICAgIGxldCBkZWZpbml0aW9uSWQgPSBcIi9kZWZpbml0aW9ucy9cIiArIGRlZmluaXRpb25OYW1lO1xuICAgIHZhbGlkYXRlUmVxdWlyZWRQcm9wZXJ0aWVzRXhpc3QoZGVmaW5pdGlvbiwgZGVmaW5pdGlvbklkKTtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1N3YWdnZXJPYmplY3R9IGFwaSAgICAgICAgICAgLSBUaGUgZW50aXJlIFN3YWdnZXIgQVBJIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9ICAgICAgICBwYXRoICAgICAgICAgIC0gQSBQYXRoIG9iamVjdCwgZnJvbSB0aGUgU3dhZ2dlciBBUElcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgcGF0aElkICAgICAgICAtIEEgdmFsdWUgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIHRoZSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgIG9wZXJhdGlvbklkcyAgLSBBbiBhcnJheSBvZiBjb2xsZWN0ZWQgb3BlcmF0aW9uSWRzIGZvdW5kIGluIG90aGVyIHBhdGhzXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUGF0aCAoYXBpLCBwYXRoLCBwYXRoSWQsIG9wZXJhdGlvbklkcykge1xuICBmb3IgKGxldCBvcGVyYXRpb25OYW1lIG9mIHN3YWdnZXJNZXRob2RzKSB7XG4gICAgbGV0IG9wZXJhdGlvbiA9IHBhdGhbb3BlcmF0aW9uTmFtZV07XG4gICAgbGV0IG9wZXJhdGlvbklkID0gcGF0aElkICsgXCIvXCIgKyBvcGVyYXRpb25OYW1lO1xuXG4gICAgaWYgKG9wZXJhdGlvbikge1xuICAgICAgbGV0IGRlY2xhcmVkT3BlcmF0aW9uSWQgPSBvcGVyYXRpb24ub3BlcmF0aW9uSWQ7XG4gICAgICBpZiAoZGVjbGFyZWRPcGVyYXRpb25JZCkge1xuICAgICAgICBpZiAob3BlcmF0aW9uSWRzLmluZGV4T2YoZGVjbGFyZWRPcGVyYXRpb25JZCkgPT09IC0xKSB7XG4gICAgICAgICAgb3BlcmF0aW9uSWRzLnB1c2goZGVjbGFyZWRPcGVyYXRpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhyb3cgb25vLnN5bnRheChgVmFsaWRhdGlvbiBmYWlsZWQuIER1cGxpY2F0ZSBvcGVyYXRpb24gaWQgJyR7ZGVjbGFyZWRPcGVyYXRpb25JZH0nYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlUGFyYW1ldGVycyhhcGksIHBhdGgsIHBhdGhJZCwgb3BlcmF0aW9uLCBvcGVyYXRpb25JZCk7XG5cbiAgICAgIGxldCByZXNwb25zZXMgPSBPYmplY3Qua2V5cyhvcGVyYXRpb24ucmVzcG9uc2VzIHx8IHt9KTtcbiAgICAgIGZvciAobGV0IHJlc3BvbnNlTmFtZSBvZiByZXNwb25zZXMpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gb3BlcmF0aW9uLnJlc3BvbnNlc1tyZXNwb25zZU5hbWVdO1xuICAgICAgICBsZXQgcmVzcG9uc2VJZCA9IG9wZXJhdGlvbklkICsgXCIvcmVzcG9uc2VzL1wiICsgcmVzcG9uc2VOYW1lO1xuICAgICAgICB2YWxpZGF0ZVJlc3BvbnNlKHJlc3BvbnNlTmFtZSwgKHJlc3BvbnNlIHx8IHt9KSwgcmVzcG9uc2VJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2l2ZW4gb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3dhZ2dlck9iamVjdH0gYXBpICAgICAgICAgICAtIFRoZSBlbnRpcmUgU3dhZ2dlciBBUEkgb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gICAgICAgIHBhdGggICAgICAgICAgLSBBIFBhdGggb2JqZWN0LCBmcm9tIHRoZSBTd2FnZ2VyIEFQSVxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICBwYXRoSWQgICAgICAgIC0gQSB2YWx1ZSB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgb3BlcmF0aW9uICAgICAtIEFuIE9wZXJhdGlvbiBvYmplY3QsIGZyb20gdGhlIFN3YWdnZXIgQVBJXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgIG9wZXJhdGlvbklkICAgLSBBIHZhbHVlIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgb3BlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1ldGVycyAoYXBpLCBwYXRoLCBwYXRoSWQsIG9wZXJhdGlvbiwgb3BlcmF0aW9uSWQpIHtcbiAgbGV0IHBhdGhQYXJhbXMgPSBwYXRoLnBhcmFtZXRlcnMgfHwgW107XG4gIGxldCBvcGVyYXRpb25QYXJhbXMgPSBvcGVyYXRpb24ucGFyYW1ldGVycyB8fCBbXTtcblxuICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIHBhdGggcGFyYW1ldGVyc1xuICB0cnkge1xuICAgIGNoZWNrRm9yRHVwbGljYXRlcyhwYXRoUGFyYW1zKTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIHRocm93IG9uby5zeW50YXgoZSwgYFZhbGlkYXRpb24gZmFpbGVkLiAke3BhdGhJZH0gaGFzIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzYCk7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXG4gIHRyeSB7XG4gICAgY2hlY2tGb3JEdXBsaWNhdGVzKG9wZXJhdGlvblBhcmFtcyk7XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBvbm8uc3ludGF4KGUsIGBWYWxpZGF0aW9uIGZhaWxlZC4gJHtvcGVyYXRpb25JZH0gaGFzIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzYCk7XG4gIH1cblxuICAvLyBDb21iaW5lIHRoZSBwYXRoIGFuZCBvcGVyYXRpb24gcGFyYW1ldGVycyxcbiAgLy8gd2l0aCB0aGUgb3BlcmF0aW9uIHBhcmFtcyB0YWtpbmcgcHJlY2VkZW5jZSBvdmVyIHRoZSBwYXRoIHBhcmFtc1xuICBsZXQgcGFyYW1zID0gcGF0aFBhcmFtcy5yZWR1Y2UoKGNvbWJpbmVkUGFyYW1zLCB2YWx1ZSkgPT4ge1xuICAgIGxldCBkdXBsaWNhdGUgPSBjb21iaW5lZFBhcmFtcy5zb21lKChwYXJhbSkgPT4ge1xuICAgICAgcmV0dXJuIHBhcmFtLmluID09PSB2YWx1ZS5pbiAmJiBwYXJhbS5uYW1lID09PSB2YWx1ZS5uYW1lO1xuICAgIH0pO1xuICAgIGlmICghZHVwbGljYXRlKSB7XG4gICAgICBjb21iaW5lZFBhcmFtcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmVkUGFyYW1zO1xuICB9LCBvcGVyYXRpb25QYXJhbXMuc2xpY2UoKSk7XG5cbiAgdmFsaWRhdGVCb2R5UGFyYW1ldGVycyhwYXJhbXMsIG9wZXJhdGlvbklkKTtcbiAgdmFsaWRhdGVQYXRoUGFyYW1ldGVycyhwYXJhbXMsIHBhdGhJZCwgb3BlcmF0aW9uSWQpO1xuICB2YWxpZGF0ZVBhcmFtZXRlclR5cGVzKHBhcmFtcywgYXBpLCBvcGVyYXRpb24sIG9wZXJhdGlvbklkKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYm9keSBhbmQgZm9ybURhdGEgcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gICB7b2JqZWN0W119ICBwYXJhbXMgICAgICAgLSAgQW4gYXJyYXkgb2YgUGFyYW1ldGVyIG9iamVjdHNcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIG9wZXJhdGlvbklkICAtICBBIHZhbHVlIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgb3BlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQm9keVBhcmFtZXRlcnMgKHBhcmFtcywgb3BlcmF0aW9uSWQpIHtcbiAgbGV0IGJvZHlQYXJhbXMgPSBwYXJhbXMuZmlsdGVyKChwYXJhbSkgPT4geyByZXR1cm4gcGFyYW0uaW4gPT09IFwiYm9keVwiOyB9KTtcbiAgbGV0IGZvcm1QYXJhbXMgPSBwYXJhbXMuZmlsdGVyKChwYXJhbSkgPT4geyByZXR1cm4gcGFyYW0uaW4gPT09IFwiZm9ybURhdGFcIjsgfSk7XG5cbiAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIFwiYm9keVwiIHBhcmFtZXRlclxuICBpZiAoYm9keVBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgb25vLnN5bnRheChcbiAgICAgIGBWYWxpZGF0aW9uIGZhaWxlZC4gJHtvcGVyYXRpb25JZH0gaGFzICR7Ym9keVBhcmFtcy5sZW5ndGh9IGJvZHkgcGFyYW1ldGVycy4gT25seSBvbmUgaXMgYWxsb3dlZC5gLFxuICAgICk7XG4gIH1cbiAgZWxzZSBpZiAoYm9keVBhcmFtcy5sZW5ndGggPiAwICYmIGZvcm1QYXJhbXMubGVuZ3RoID4gMCkge1xuICAgIC8vIFwiYm9keVwiIHBhcmFtcyBhbmQgXCJmb3JtRGF0YVwiIHBhcmFtcyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlXG4gICAgdGhyb3cgb25vLnN5bnRheChcbiAgICAgIGBWYWxpZGF0aW9uIGZhaWxlZC4gJHtvcGVyYXRpb25JZH0gaGFzIGJvZHkgcGFyYW1ldGVycyBhbmQgZm9ybURhdGEgcGFyYW1ldGVycy4gT25seSBvbmUgb3IgdGhlIG90aGVyIGlzIGFsbG93ZWQuYCxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHBhdGggcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQHBhcmFtICAge29iamVjdFtdfSAgcGFyYW1zICAgICAgICAtIEFuIGFycmF5IG9mIFBhcmFtZXRlciBvYmplY3RzXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICBwYXRoSWQgICAgICAgIC0gQSB2YWx1ZSB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIHBhdGhcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIG9wZXJhdGlvbklkICAgLSBBIHZhbHVlIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgb3BlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUGF0aFBhcmFtZXRlcnMgKHBhcmFtcywgcGF0aElkLCBvcGVyYXRpb25JZCkge1xuICAvLyBGaW5kIGFsbCB7cGxhY2Vob2xkZXJzfSBpbiB0aGUgcGF0aCBzdHJpbmdcbiAgbGV0IHBsYWNlaG9sZGVycyA9IHBhdGhJZC5tYXRjaCh1dGlsLnN3YWdnZXJQYXJhbVJlZ0V4cCkgfHwgW107XG5cbiAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFjZWhvbGRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBwbGFjZWhvbGRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChwbGFjZWhvbGRlcnNbaV0gPT09IHBsYWNlaG9sZGVyc1tqXSkge1xuICAgICAgICB0aHJvdyBvbm8uc3ludGF4KFxuICAgICAgICAgIGBWYWxpZGF0aW9uIGZhaWxlZC4gJHtvcGVyYXRpb25JZH0gaGFzIG11bHRpcGxlIHBhdGggcGxhY2Vob2xkZXJzIG5hbWVkICR7cGxhY2Vob2xkZXJzW2ldfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcmFtcyA9IHBhcmFtcy5maWx0ZXIoKHBhcmFtKSA9PiB7IHJldHVybiBwYXJhbS5pbiA9PT0gXCJwYXRoXCI7IH0pO1xuXG4gIGZvciAobGV0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgIGlmIChwYXJhbS5yZXF1aXJlZCAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgb25vLnN5bnRheChcbiAgICAgICAgXCJWYWxpZGF0aW9uIGZhaWxlZC4gUGF0aCBwYXJhbWV0ZXJzIGNhbm5vdCBiZSBvcHRpb25hbC4gXCIgK1xuICAgICAgICBgU2V0IHJlcXVpcmVkPXRydWUgZm9yIHRoZSBcIiR7cGFyYW0ubmFtZX1cIiBwYXJhbWV0ZXIgYXQgJHtvcGVyYXRpb25JZH1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gcGxhY2Vob2xkZXJzLmluZGV4T2YoXCJ7XCIgKyBwYXJhbS5uYW1lICsgXCJ9XCIpO1xuICAgIGlmIChtYXRjaCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG9uby5zeW50YXgoXG4gICAgICAgIGBWYWxpZGF0aW9uIGZhaWxlZC4gJHtvcGVyYXRpb25JZH0gaGFzIGEgcGF0aCBwYXJhbWV0ZXIgbmFtZWQgXCIke3BhcmFtLm5hbWV9XCIsIGAgK1xuICAgICAgICBgYnV0IHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgeyR7cGFyYW0ubmFtZX19IGluIHRoZSBwYXRoIHN0cmluZ2BcbiAgICAgICk7XG4gICAgfVxuICAgIHBsYWNlaG9sZGVycy5zcGxpY2UobWF0Y2gsIDEpO1xuICB9XG5cbiAgaWYgKHBsYWNlaG9sZGVycy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgb25vLnN5bnRheChgVmFsaWRhdGlvbiBmYWlsZWQuICR7b3BlcmF0aW9uSWR9IGlzIG1pc3NpbmcgcGF0aCBwYXJhbWV0ZXIocykgZm9yICR7cGxhY2Vob2xkZXJzfWApO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGRhdGEgdHlwZXMgb2YgcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gICB7b2JqZWN0W119ICBwYXJhbXMgICAgICAgLSAgQW4gYXJyYXkgb2YgUGFyYW1ldGVyIG9iamVjdHNcbiAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIGFwaSAgICAgICAgICAtICBUaGUgZW50aXJlIFN3YWdnZXIgQVBJIG9iamVjdFxuICogQHBhcmFtICAge29iamVjdH0gICAgb3BlcmF0aW9uICAgIC0gIEFuIE9wZXJhdGlvbiBvYmplY3QsIGZyb20gdGhlIFN3YWdnZXIgQVBJXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICBvcGVyYXRpb25JZCAgLSAgQSB2YWx1ZSB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIG9wZXJhdGlvblxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVBhcmFtZXRlclR5cGVzIChwYXJhbXMsIGFwaSwgb3BlcmF0aW9uLCBvcGVyYXRpb25JZCkge1xuICBmb3IgKGxldCBwYXJhbSBvZiBwYXJhbXMpIHtcbiAgICBsZXQgcGFyYW1ldGVySWQgPSBvcGVyYXRpb25JZCArIFwiL3BhcmFtZXRlcnMvXCIgKyBwYXJhbS5uYW1lO1xuICAgIGxldCBzY2hlbWEsIHZhbGlkVHlwZXM7XG5cbiAgICBzd2l0Y2ggKHBhcmFtLmluKSB7XG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICBzY2hlbWEgPSBwYXJhbS5zY2hlbWE7XG4gICAgICAgIHZhbGlkVHlwZXMgPSBzY2hlbWFUeXBlcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZm9ybURhdGFcIjpcbiAgICAgICAgc2NoZW1hID0gcGFyYW07XG4gICAgICAgIHZhbGlkVHlwZXMgPSBwcmltaXRpdmVUeXBlcy5jb25jYXQoXCJmaWxlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNjaGVtYSA9IHBhcmFtO1xuICAgICAgICB2YWxpZFR5cGVzID0gcHJpbWl0aXZlVHlwZXM7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVTY2hlbWEoc2NoZW1hLCBwYXJhbWV0ZXJJZCwgdmFsaWRUeXBlcyk7XG4gICAgdmFsaWRhdGVSZXF1aXJlZFByb3BlcnRpZXNFeGlzdChzY2hlbWEsIHBhcmFtZXRlcklkKTtcblxuICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgIC8vIFwiZmlsZVwiIHBhcmFtcyBtdXN0IGNvbnN1bWUgYXQgbGVhc3Qgb25lIG9mIHRoZXNlIE1JTUUgdHlwZXNcbiAgICAgIGxldCBmb3JtRGF0YSA9IC9tdWx0aXBhcnRcXC8oLipcXCspP2Zvcm0tZGF0YS87XG4gICAgICBsZXQgdXJsRW5jb2RlZCA9IC9hcHBsaWNhdGlvblxcLyguKlxcKyk/eC13d3ctZm9ybS11cmxlbmNvZGVkLztcblxuICAgICAgbGV0IGNvbnN1bWVzID0gb3BlcmF0aW9uLmNvbnN1bWVzIHx8IGFwaS5jb25zdW1lcyB8fCBbXTtcblxuICAgICAgbGV0IGhhc1ZhbGlkTWltZVR5cGUgPSBjb25zdW1lcy5zb21lKChjb25zdW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBmb3JtRGF0YS50ZXN0KGNvbnN1bWUpIHx8IHVybEVuY29kZWQudGVzdChjb25zdW1lKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWhhc1ZhbGlkTWltZVR5cGUpIHtcbiAgICAgICAgdGhyb3cgb25vLnN5bnRheChcbiAgICAgICAgICBgVmFsaWRhdGlvbiBmYWlsZWQuICR7b3BlcmF0aW9uSWR9IGhhcyBhIGZpbGUgcGFyYW1ldGVyLCBzbyBpdCBtdXN0IGNvbnN1bWUgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBgICtcbiAgICAgICAgICBcIm9yIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyB0aGUgZ2l2ZW4gcGFyYW1ldGVyIGxpc3QgZm9yIGR1cGxpY2F0ZXMsIGFuZCB0aHJvd3MgYW4gZXJyb3IgaWYgZm91bmQuXG4gKlxuICogQHBhcmFtICAge29iamVjdFtdfSAgcGFyYW1zICAtIEFuIGFycmF5IG9mIFBhcmFtZXRlciBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRm9yRHVwbGljYXRlcyAocGFyYW1zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGxldCBvdXRlciA9IHBhcmFtc1tpXTtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBwYXJhbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBpbm5lciA9IHBhcmFtc1tqXTtcbiAgICAgIGlmIChvdXRlci5uYW1lID09PSBpbm5lci5uYW1lICYmIG91dGVyLmluID09PSBpbm5lci5pbikge1xuICAgICAgICB0aHJvdyBvbm8uc3ludGF4KGBWYWxpZGF0aW9uIGZhaWxlZC4gRm91bmQgbXVsdGlwbGUgJHtvdXRlci5pbn0gcGFyYW1ldGVycyBuYW1lZCBcIiR7b3V0ZXIubmFtZX1cImApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gcmVzcG9uc2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIGNvZGUgICAgICAgIC0gIFRoZSBIVFRQIHJlc3BvbnNlIGNvZGUgKG9yIFwiZGVmYXVsdFwiKVxuICogQHBhcmFtICAge29iamVjdH0gICAgcmVzcG9uc2UgICAgLSAgQSBSZXNwb25zZSBvYmplY3QsIGZyb20gdGhlIFN3YWdnZXIgQVBJXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICByZXNwb25zZUlkICAtICBBIHZhbHVlIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZSAoY29kZSwgcmVzcG9uc2UsIHJlc3BvbnNlSWQpIHtcbiAgaWYgKGNvZGUgIT09IFwiZGVmYXVsdFwiICYmIChjb2RlIDwgMTAwIHx8IGNvZGUgPiA1OTkpKSB7XG4gICAgdGhyb3cgb25vLnN5bnRheChgVmFsaWRhdGlvbiBmYWlsZWQuICR7cmVzcG9uc2VJZH0gaGFzIGFuIGludmFsaWQgcmVzcG9uc2UgY29kZSAoJHtjb2RlfSlgKTtcbiAgfVxuXG4gIGxldCBoZWFkZXJzID0gT2JqZWN0LmtleXMocmVzcG9uc2UuaGVhZGVycyB8fCB7fSk7XG4gIGZvciAobGV0IGhlYWRlck5hbWUgb2YgaGVhZGVycykge1xuICAgIGxldCBoZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzW2hlYWRlck5hbWVdO1xuICAgIGxldCBoZWFkZXJJZCA9IHJlc3BvbnNlSWQgKyBcIi9oZWFkZXJzL1wiICsgaGVhZGVyTmFtZTtcbiAgICB2YWxpZGF0ZVNjaGVtYShoZWFkZXIsIGhlYWRlcklkLCBwcmltaXRpdmVUeXBlcyk7XG4gIH1cblxuICBpZiAocmVzcG9uc2Uuc2NoZW1hKSB7XG4gICAgbGV0IHZhbGlkVHlwZXMgPSBzY2hlbWFUeXBlcy5jb25jYXQoXCJmaWxlXCIpO1xuICAgIGlmICh2YWxpZFR5cGVzLmluZGV4T2YocmVzcG9uc2Uuc2NoZW1hLnR5cGUpID09PSAtMSkge1xuICAgICAgdGhyb3cgb25vLnN5bnRheChcbiAgICAgICAgYFZhbGlkYXRpb24gZmFpbGVkLiAke3Jlc3BvbnNlSWR9IGhhcyBhbiBpbnZhbGlkIHJlc3BvbnNlIHNjaGVtYSB0eXBlICgke3Jlc3BvbnNlLnNjaGVtYS50eXBlfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YWxpZGF0ZVNjaGVtYShyZXNwb25zZS5zY2hlbWEsIHJlc3BvbnNlSWQgKyBcIi9zY2hlbWFcIiwgdmFsaWRUeXBlcyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBnaXZlbiBTd2FnZ2VyIHNjaGVtYSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9ICAgIHNjaGVtYSAgICAgIC0gQSBTY2hlbWEgb2JqZWN0LCBmcm9tIHRoZSBTd2FnZ2VyIEFQSVxuICogQHBhcmFtIHtzdHJpbmd9ICAgIHNjaGVtYUlkICAgIC0gQSB2YWx1ZSB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIHNjaGVtYSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nW119ICB2YWxpZFR5cGVzICAtIEFuIGFycmF5IG9mIHRoZSBhbGxvd2VkIHNjaGVtYSB0eXBlc1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYSAoc2NoZW1hLCBzY2hlbWFJZCwgdmFsaWRUeXBlcykge1xuICBpZiAodmFsaWRUeXBlcy5pbmRleE9mKHNjaGVtYS50eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBvbm8uc3ludGF4KFxuICAgICAgYFZhbGlkYXRpb24gZmFpbGVkLiAke3NjaGVtYUlkfSBoYXMgYW4gaW52YWxpZCB0eXBlICgke3NjaGVtYS50eXBlfSlgKTtcbiAgfVxuXG4gIGlmIChzY2hlbWEudHlwZSA9PT0gXCJhcnJheVwiICYmICFzY2hlbWEuaXRlbXMpIHtcbiAgICB0aHJvdyBvbm8uc3ludGF4KGBWYWxpZGF0aW9uIGZhaWxlZC4gJHtzY2hlbWFJZH0gaXMgYW4gYXJyYXksIHNvIGl0IG11c3QgaW5jbHVkZSBhbiBcIml0ZW1zXCIgc2NoZW1hYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgZGVjbGFyZWQgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gU3dhZ2dlciBzY2hlbWEgb2JqZWN0IGFjdHVhbGx5IGV4aXN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICBzY2hlbWEgICAgICAtIEEgU2NoZW1hIG9iamVjdCwgZnJvbSB0aGUgU3dhZ2dlciBBUElcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBzY2hlbWFJZCAgICAtIEEgdmFsdWUgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIHRoZSBzY2hlbWEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUmVxdWlyZWRQcm9wZXJ0aWVzRXhpc3QgKHNjaGVtYSwgc2NoZW1hSWQpIHtcbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGNvbGxlY3RzIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBzY2hlbWEgYW5kIGl0cyBhbmNlc3RvcnMuIFRoZXkgYXJlIGFkZGVkIHRvIHRoZSBwcm9wcyBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBjb2xsZWN0UHJvcGVydGllcyAoc2NoZW1hT2JqLCBwcm9wcykge1xuICAgIGlmIChzY2hlbWFPYmoucHJvcGVydGllcykge1xuICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gc2NoZW1hT2JqLnByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHNjaGVtYU9iai5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgIHByb3BzW3Byb3BlcnR5XSA9IHNjaGVtYU9iai5wcm9wZXJ0aWVzW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2NoZW1hT2JqLmFsbE9mKSB7XG4gICAgICBmb3IgKGxldCBwYXJlbnQgb2Ygc2NoZW1hT2JqLmFsbE9mKSB7XG4gICAgICAgIGNvbGxlY3RQcm9wZXJ0aWVzKHBhcmVudCwgcHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzY2hlbWEucmVxdWlyZWQgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEucmVxdWlyZWQpKSB7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgY29sbGVjdFByb3BlcnRpZXMoc2NoZW1hLCBwcm9wcyk7XG4gICAgZm9yIChsZXQgcmVxdWlyZWRQcm9wZXJ0eSBvZiBzY2hlbWEucmVxdWlyZWQpIHtcbiAgICAgIGlmICghcHJvcHNbcmVxdWlyZWRQcm9wZXJ0eV0pIHtcbiAgICAgICAgdGhyb3cgb25vLnN5bnRheChcbiAgICAgICAgICBgVmFsaWRhdGlvbiBmYWlsZWQuIFByb3BlcnR5ICcke3JlcXVpcmVkUHJvcGVydHl9JyBsaXN0ZWQgYXMgcmVxdWlyZWQgYnV0IGRvZXMgbm90IGV4aXN0IGluICcke3NjaGVtYUlkfSdgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJvbm8iLCJzd2FnZ2VyTWV0aG9kcyIsInByaW1pdGl2ZVR5cGVzIiwic2NoZW1hVHlwZXMiLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJleHBvcnRzIiwidmFsaWRhdGVTcGVjIiwiYXBpIiwib3BlbmFwaSIsInBhdGhzIiwiT2JqZWN0Iiwia2V5cyIsIm9wZXJhdGlvbklkcyIsInBhdGhOYW1lIiwicGF0aCIsInBhdGhJZCIsImluZGV4T2YiLCJ2YWxpZGF0ZVBhdGgiLCJkZWZpbml0aW9ucyIsImRlZmluaXRpb25OYW1lIiwiZGVmaW5pdGlvbiIsImRlZmluaXRpb25JZCIsInZhbGlkYXRlUmVxdWlyZWRQcm9wZXJ0aWVzRXhpc3QiLCJvcGVyYXRpb25OYW1lIiwib3BlcmF0aW9uIiwib3BlcmF0aW9uSWQiLCJkZWNsYXJlZE9wZXJhdGlvbklkIiwicHVzaCIsInN5bnRheCIsInZhbGlkYXRlUGFyYW1ldGVycyIsInJlc3BvbnNlcyIsInJlc3BvbnNlTmFtZSIsInJlc3BvbnNlIiwicmVzcG9uc2VJZCIsInZhbGlkYXRlUmVzcG9uc2UiLCJwYXRoUGFyYW1zIiwicGFyYW1ldGVycyIsIm9wZXJhdGlvblBhcmFtcyIsImNoZWNrRm9yRHVwbGljYXRlcyIsImUiLCJwYXJhbXMiLCJyZWR1Y2UiLCJjb21iaW5lZFBhcmFtcyIsInZhbHVlIiwiZHVwbGljYXRlIiwic29tZSIsInBhcmFtIiwiaW4iLCJuYW1lIiwic2xpY2UiLCJ2YWxpZGF0ZUJvZHlQYXJhbWV0ZXJzIiwidmFsaWRhdGVQYXRoUGFyYW1ldGVycyIsInZhbGlkYXRlUGFyYW1ldGVyVHlwZXMiLCJib2R5UGFyYW1zIiwiZmlsdGVyIiwiZm9ybVBhcmFtcyIsImxlbmd0aCIsInBsYWNlaG9sZGVycyIsIm1hdGNoIiwic3dhZ2dlclBhcmFtUmVnRXhwIiwiaSIsImoiLCJyZXF1aXJlZCIsInNwbGljZSIsInBhcmFtZXRlcklkIiwic2NoZW1hIiwidmFsaWRUeXBlcyIsImNvbmNhdCIsInZhbGlkYXRlU2NoZW1hIiwidHlwZSIsImZvcm1EYXRhIiwidXJsRW5jb2RlZCIsImNvbnN1bWVzIiwiaGFzVmFsaWRNaW1lVHlwZSIsImNvbnN1bWUiLCJ0ZXN0Iiwib3V0ZXIiLCJpbm5lciIsImNvZGUiLCJoZWFkZXJzIiwiaGVhZGVyTmFtZSIsImhlYWRlciIsImhlYWRlcklkIiwic2NoZW1hSWQiLCJpdGVtcyIsImNvbGxlY3RQcm9wZXJ0aWVzIiwic2NoZW1hT2JqIiwicHJvcHMiLCJwcm9wZXJ0aWVzIiwicHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsImFsbE9mIiwicGFyZW50IiwiQXJyYXkiLCJpc0FycmF5IiwicmVxdWlyZWRQcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@apidevtools/swagger-parser/lib/validators/spec.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/openapi-schemas/schemas/v1.2/apiDeclaration.json":
/*!************************************************************************************!*\
  !*** ./node_modules/@apidevtools/openapi-schemas/schemas/v1.2/apiDeclaration.json ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"id":"https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/schemas/v1.2/apiDeclaration.json#","$schema":"http://json-schema.org/draft-04/schema#","type":"object","required":["swaggerVersion","basePath","apis"],"properties":{"swaggerVersion":{"enum":["1.2"]},"apiVersion":{"type":"string"},"basePath":{"type":"string","format":"uri","pattern":"^https?://"},"resourcePath":{"type":"string","format":"uri","pattern":"^/"},"apis":{"type":"array","items":{"$ref":"#/definitions/apiObject"}},"models":{"type":"object","additionalProperties":{"$ref":"modelsObject.json#"}},"produces":{"$ref":"#/definitions/mimeTypeArray"},"consumes":{"$ref":"#/definitions/mimeTypeArray"},"authorizations":{"$ref":"authorizationObject.json#"}},"additionalProperties":false,"definitions":{"apiObject":{"type":"object","required":["path","operations"],"properties":{"path":{"type":"string","format":"uri-template","pattern":"^/"},"description":{"type":"string"},"operations":{"type":"array","items":{"$ref":"operationObject.json#"}}},"additionalProperties":false},"mimeTypeArray":{"type":"array","items":{"type":"string","format":"mime-type"},"uniqueItems":true}}}');

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/openapi-schemas/schemas/v2.0/schema.json":
/*!****************************************************************************!*\
  !*** ./node_modules/@apidevtools/openapi-schemas/schemas/v2.0/schema.json ***!
  \****************************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"title":"A JSON Schema for Swagger 2.0 API.","id":"http://swagger.io/v2/schema.json#","$schema":"http://json-schema.org/draft-04/schema#","type":"object","required":["swagger","info","paths"],"additionalProperties":false,"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"properties":{"swagger":{"type":"string","enum":["2.0"],"description":"The Swagger version of this document."},"info":{"$ref":"#/definitions/info"},"host":{"type":"string","pattern":"^[^{}/ :\\\\\\\\]+(?::\\\\d+)?$","description":"The host (name or ip) of the API. Example: \'swagger.io\'"},"basePath":{"type":"string","pattern":"^/","description":"The base path to the API. Example: \'/api\'."},"schemes":{"$ref":"#/definitions/schemesList"},"consumes":{"description":"A list of MIME types accepted by the API.","allOf":[{"$ref":"#/definitions/mediaTypeList"}]},"produces":{"description":"A list of MIME types the API can produce.","allOf":[{"$ref":"#/definitions/mediaTypeList"}]},"paths":{"$ref":"#/definitions/paths"},"definitions":{"$ref":"#/definitions/definitions"},"parameters":{"$ref":"#/definitions/parameterDefinitions"},"responses":{"$ref":"#/definitions/responseDefinitions"},"security":{"$ref":"#/definitions/security"},"securityDefinitions":{"$ref":"#/definitions/securityDefinitions"},"tags":{"type":"array","items":{"$ref":"#/definitions/tag"},"uniqueItems":true},"externalDocs":{"$ref":"#/definitions/externalDocs"}},"definitions":{"info":{"type":"object","description":"General information about the API.","required":["version","title"],"additionalProperties":false,"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"properties":{"title":{"type":"string","description":"A unique and precise title of the API."},"version":{"type":"string","description":"A semantic version number of the API."},"description":{"type":"string","description":"A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed."},"termsOfService":{"type":"string","description":"The terms of service for the API."},"contact":{"$ref":"#/definitions/contact"},"license":{"$ref":"#/definitions/license"}}},"contact":{"type":"object","description":"Contact information for the owners of the API.","additionalProperties":false,"properties":{"name":{"type":"string","description":"The identifying name of the contact person/organization."},"url":{"type":"string","description":"The URL pointing to the contact information.","format":"uri"},"email":{"type":"string","description":"The email address of the contact person/organization.","format":"email"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"license":{"type":"object","required":["name"],"additionalProperties":false,"properties":{"name":{"type":"string","description":"The name of the license type. It\'s encouraged to use an OSI compatible license."},"url":{"type":"string","description":"The URL pointing to the license.","format":"uri"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"paths":{"type":"object","description":"Relative paths to the individual endpoints. They must be relative to the \'basePath\'.","patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"},"^/":{"$ref":"#/definitions/pathItem"}},"additionalProperties":false},"definitions":{"type":"object","additionalProperties":{"$ref":"#/definitions/schema"},"description":"One or more JSON objects describing the schemas being consumed and produced by the API."},"parameterDefinitions":{"type":"object","additionalProperties":{"$ref":"#/definitions/parameter"},"description":"One or more JSON representations for parameters"},"responseDefinitions":{"type":"object","additionalProperties":{"$ref":"#/definitions/response"},"description":"One or more JSON representations for responses"},"externalDocs":{"type":"object","additionalProperties":false,"description":"information about external documentation","required":["url"],"properties":{"description":{"type":"string"},"url":{"type":"string","format":"uri"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"examples":{"type":"object","additionalProperties":true},"mimeType":{"type":"string","description":"The MIME type of the HTTP message."},"operation":{"type":"object","required":["responses"],"additionalProperties":false,"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"properties":{"tags":{"type":"array","items":{"type":"string"},"uniqueItems":true},"summary":{"type":"string","description":"A brief summary of the operation."},"description":{"type":"string","description":"A longer description of the operation, GitHub Flavored Markdown is allowed."},"externalDocs":{"$ref":"#/definitions/externalDocs"},"operationId":{"type":"string","description":"A unique identifier of the operation."},"produces":{"description":"A list of MIME types the API can produce.","allOf":[{"$ref":"#/definitions/mediaTypeList"}]},"consumes":{"description":"A list of MIME types the API can consume.","allOf":[{"$ref":"#/definitions/mediaTypeList"}]},"parameters":{"$ref":"#/definitions/parametersList"},"responses":{"$ref":"#/definitions/responses"},"schemes":{"$ref":"#/definitions/schemesList"},"deprecated":{"type":"boolean","default":false},"security":{"$ref":"#/definitions/security"}}},"pathItem":{"type":"object","additionalProperties":false,"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"properties":{"$ref":{"type":"string"},"get":{"$ref":"#/definitions/operation"},"put":{"$ref":"#/definitions/operation"},"post":{"$ref":"#/definitions/operation"},"delete":{"$ref":"#/definitions/operation"},"options":{"$ref":"#/definitions/operation"},"head":{"$ref":"#/definitions/operation"},"patch":{"$ref":"#/definitions/operation"},"parameters":{"$ref":"#/definitions/parametersList"}}},"responses":{"type":"object","description":"Response objects names can either be any valid HTTP status code or \'default\'.","minProperties":1,"additionalProperties":false,"patternProperties":{"^([0-9]{3})$|^(default)$":{"$ref":"#/definitions/responseValue"},"^x-":{"$ref":"#/definitions/vendorExtension"}},"not":{"type":"object","additionalProperties":false,"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}}},"responseValue":{"oneOf":[{"$ref":"#/definitions/response"},{"$ref":"#/definitions/jsonReference"}]},"response":{"type":"object","required":["description"],"properties":{"description":{"type":"string"},"schema":{"oneOf":[{"$ref":"#/definitions/schema"},{"$ref":"#/definitions/fileSchema"}]},"headers":{"$ref":"#/definitions/headers"},"examples":{"$ref":"#/definitions/examples"}},"additionalProperties":false,"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"headers":{"type":"object","additionalProperties":{"$ref":"#/definitions/header"}},"header":{"type":"object","additionalProperties":false,"required":["type"],"properties":{"type":{"type":"string","enum":["string","number","integer","boolean","array"]},"format":{"type":"string"},"items":{"$ref":"#/definitions/primitivesItems"},"collectionFormat":{"$ref":"#/definitions/collectionFormat"},"default":{"$ref":"#/definitions/default"},"maximum":{"$ref":"#/definitions/maximum"},"exclusiveMaximum":{"$ref":"#/definitions/exclusiveMaximum"},"minimum":{"$ref":"#/definitions/minimum"},"exclusiveMinimum":{"$ref":"#/definitions/exclusiveMinimum"},"maxLength":{"$ref":"#/definitions/maxLength"},"minLength":{"$ref":"#/definitions/minLength"},"pattern":{"$ref":"#/definitions/pattern"},"maxItems":{"$ref":"#/definitions/maxItems"},"minItems":{"$ref":"#/definitions/minItems"},"uniqueItems":{"$ref":"#/definitions/uniqueItems"},"enum":{"$ref":"#/definitions/enum"},"multipleOf":{"$ref":"#/definitions/multipleOf"},"description":{"type":"string"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"vendorExtension":{"description":"Any property starting with x- is valid.","additionalProperties":true,"additionalItems":true},"bodyParameter":{"type":"object","required":["name","in","schema"],"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"properties":{"description":{"type":"string","description":"A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."},"name":{"type":"string","description":"The name of the parameter."},"in":{"type":"string","description":"Determines the location of the parameter.","enum":["body"]},"required":{"type":"boolean","description":"Determines whether or not this parameter is required or optional.","default":false},"schema":{"$ref":"#/definitions/schema"}},"additionalProperties":false},"headerParameterSubSchema":{"additionalProperties":false,"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"properties":{"required":{"type":"boolean","description":"Determines whether or not this parameter is required or optional.","default":false},"in":{"type":"string","description":"Determines the location of the parameter.","enum":["header"]},"description":{"type":"string","description":"A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."},"name":{"type":"string","description":"The name of the parameter."},"type":{"type":"string","enum":["string","number","boolean","integer","array"]},"format":{"type":"string"},"items":{"$ref":"#/definitions/primitivesItems"},"collectionFormat":{"$ref":"#/definitions/collectionFormat"},"default":{"$ref":"#/definitions/default"},"maximum":{"$ref":"#/definitions/maximum"},"exclusiveMaximum":{"$ref":"#/definitions/exclusiveMaximum"},"minimum":{"$ref":"#/definitions/minimum"},"exclusiveMinimum":{"$ref":"#/definitions/exclusiveMinimum"},"maxLength":{"$ref":"#/definitions/maxLength"},"minLength":{"$ref":"#/definitions/minLength"},"pattern":{"$ref":"#/definitions/pattern"},"maxItems":{"$ref":"#/definitions/maxItems"},"minItems":{"$ref":"#/definitions/minItems"},"uniqueItems":{"$ref":"#/definitions/uniqueItems"},"enum":{"$ref":"#/definitions/enum"},"multipleOf":{"$ref":"#/definitions/multipleOf"}}},"queryParameterSubSchema":{"additionalProperties":false,"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"properties":{"required":{"type":"boolean","description":"Determines whether or not this parameter is required or optional.","default":false},"in":{"type":"string","description":"Determines the location of the parameter.","enum":["query"]},"description":{"type":"string","description":"A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."},"name":{"type":"string","description":"The name of the parameter."},"allowEmptyValue":{"type":"boolean","default":false,"description":"allows sending a parameter by name only or with an empty value."},"type":{"type":"string","enum":["string","number","boolean","integer","array"]},"format":{"type":"string"},"items":{"$ref":"#/definitions/primitivesItems"},"collectionFormat":{"$ref":"#/definitions/collectionFormatWithMulti"},"default":{"$ref":"#/definitions/default"},"maximum":{"$ref":"#/definitions/maximum"},"exclusiveMaximum":{"$ref":"#/definitions/exclusiveMaximum"},"minimum":{"$ref":"#/definitions/minimum"},"exclusiveMinimum":{"$ref":"#/definitions/exclusiveMinimum"},"maxLength":{"$ref":"#/definitions/maxLength"},"minLength":{"$ref":"#/definitions/minLength"},"pattern":{"$ref":"#/definitions/pattern"},"maxItems":{"$ref":"#/definitions/maxItems"},"minItems":{"$ref":"#/definitions/minItems"},"uniqueItems":{"$ref":"#/definitions/uniqueItems"},"enum":{"$ref":"#/definitions/enum"},"multipleOf":{"$ref":"#/definitions/multipleOf"}}},"formDataParameterSubSchema":{"additionalProperties":false,"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"properties":{"required":{"type":"boolean","description":"Determines whether or not this parameter is required or optional.","default":false},"in":{"type":"string","description":"Determines the location of the parameter.","enum":["formData"]},"description":{"type":"string","description":"A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."},"name":{"type":"string","description":"The name of the parameter."},"allowEmptyValue":{"type":"boolean","default":false,"description":"allows sending a parameter by name only or with an empty value."},"type":{"type":"string","enum":["string","number","boolean","integer","array","file"]},"format":{"type":"string"},"items":{"$ref":"#/definitions/primitivesItems"},"collectionFormat":{"$ref":"#/definitions/collectionFormatWithMulti"},"default":{"$ref":"#/definitions/default"},"maximum":{"$ref":"#/definitions/maximum"},"exclusiveMaximum":{"$ref":"#/definitions/exclusiveMaximum"},"minimum":{"$ref":"#/definitions/minimum"},"exclusiveMinimum":{"$ref":"#/definitions/exclusiveMinimum"},"maxLength":{"$ref":"#/definitions/maxLength"},"minLength":{"$ref":"#/definitions/minLength"},"pattern":{"$ref":"#/definitions/pattern"},"maxItems":{"$ref":"#/definitions/maxItems"},"minItems":{"$ref":"#/definitions/minItems"},"uniqueItems":{"$ref":"#/definitions/uniqueItems"},"enum":{"$ref":"#/definitions/enum"},"multipleOf":{"$ref":"#/definitions/multipleOf"}}},"pathParameterSubSchema":{"additionalProperties":false,"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"required":["required"],"properties":{"required":{"type":"boolean","enum":[true],"description":"Determines whether or not this parameter is required or optional."},"in":{"type":"string","description":"Determines the location of the parameter.","enum":["path"]},"description":{"type":"string","description":"A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."},"name":{"type":"string","description":"The name of the parameter."},"type":{"type":"string","enum":["string","number","boolean","integer","array"]},"format":{"type":"string"},"items":{"$ref":"#/definitions/primitivesItems"},"collectionFormat":{"$ref":"#/definitions/collectionFormat"},"default":{"$ref":"#/definitions/default"},"maximum":{"$ref":"#/definitions/maximum"},"exclusiveMaximum":{"$ref":"#/definitions/exclusiveMaximum"},"minimum":{"$ref":"#/definitions/minimum"},"exclusiveMinimum":{"$ref":"#/definitions/exclusiveMinimum"},"maxLength":{"$ref":"#/definitions/maxLength"},"minLength":{"$ref":"#/definitions/minLength"},"pattern":{"$ref":"#/definitions/pattern"},"maxItems":{"$ref":"#/definitions/maxItems"},"minItems":{"$ref":"#/definitions/minItems"},"uniqueItems":{"$ref":"#/definitions/uniqueItems"},"enum":{"$ref":"#/definitions/enum"},"multipleOf":{"$ref":"#/definitions/multipleOf"}}},"nonBodyParameter":{"type":"object","required":["name","in","type"],"oneOf":[{"$ref":"#/definitions/headerParameterSubSchema"},{"$ref":"#/definitions/formDataParameterSubSchema"},{"$ref":"#/definitions/queryParameterSubSchema"},{"$ref":"#/definitions/pathParameterSubSchema"}]},"parameter":{"oneOf":[{"$ref":"#/definitions/bodyParameter"},{"$ref":"#/definitions/nonBodyParameter"}]},"schema":{"type":"object","description":"A deterministic version of a JSON Schema object.","patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"properties":{"$ref":{"type":"string"},"format":{"type":"string"},"title":{"$ref":"http://json-schema.org/draft-04/schema#/properties/title"},"description":{"$ref":"http://json-schema.org/draft-04/schema#/properties/description"},"default":{"$ref":"http://json-schema.org/draft-04/schema#/properties/default"},"multipleOf":{"$ref":"http://json-schema.org/draft-04/schema#/properties/multipleOf"},"maximum":{"$ref":"http://json-schema.org/draft-04/schema#/properties/maximum"},"exclusiveMaximum":{"$ref":"http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"},"minimum":{"$ref":"http://json-schema.org/draft-04/schema#/properties/minimum"},"exclusiveMinimum":{"$ref":"http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"},"maxLength":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/positiveInteger"},"minLength":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"},"pattern":{"$ref":"http://json-schema.org/draft-04/schema#/properties/pattern"},"maxItems":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/positiveInteger"},"minItems":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"},"uniqueItems":{"$ref":"http://json-schema.org/draft-04/schema#/properties/uniqueItems"},"maxProperties":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/positiveInteger"},"minProperties":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"},"required":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/stringArray"},"enum":{"$ref":"http://json-schema.org/draft-04/schema#/properties/enum"},"additionalProperties":{"anyOf":[{"$ref":"#/definitions/schema"},{"type":"boolean"}],"default":{}},"type":{"$ref":"http://json-schema.org/draft-04/schema#/properties/type"},"items":{"anyOf":[{"$ref":"#/definitions/schema"},{"type":"array","minItems":1,"items":{"$ref":"#/definitions/schema"}}],"default":{}},"allOf":{"type":"array","minItems":1,"items":{"$ref":"#/definitions/schema"}},"properties":{"type":"object","additionalProperties":{"$ref":"#/definitions/schema"},"default":{}},"discriminator":{"type":"string"},"readOnly":{"type":"boolean","default":false},"xml":{"$ref":"#/definitions/xml"},"externalDocs":{"$ref":"#/definitions/externalDocs"},"example":{}},"additionalProperties":false},"fileSchema":{"type":"object","description":"A deterministic version of a JSON Schema object.","patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}},"required":["type"],"properties":{"format":{"type":"string"},"title":{"$ref":"http://json-schema.org/draft-04/schema#/properties/title"},"description":{"$ref":"http://json-schema.org/draft-04/schema#/properties/description"},"default":{"$ref":"http://json-schema.org/draft-04/schema#/properties/default"},"required":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/stringArray"},"type":{"type":"string","enum":["file"]},"readOnly":{"type":"boolean","default":false},"externalDocs":{"$ref":"#/definitions/externalDocs"},"example":{}},"additionalProperties":false},"primitivesItems":{"type":"object","additionalProperties":false,"properties":{"type":{"type":"string","enum":["string","number","integer","boolean","array"]},"format":{"type":"string"},"items":{"$ref":"#/definitions/primitivesItems"},"collectionFormat":{"$ref":"#/definitions/collectionFormat"},"default":{"$ref":"#/definitions/default"},"maximum":{"$ref":"#/definitions/maximum"},"exclusiveMaximum":{"$ref":"#/definitions/exclusiveMaximum"},"minimum":{"$ref":"#/definitions/minimum"},"exclusiveMinimum":{"$ref":"#/definitions/exclusiveMinimum"},"maxLength":{"$ref":"#/definitions/maxLength"},"minLength":{"$ref":"#/definitions/minLength"},"pattern":{"$ref":"#/definitions/pattern"},"maxItems":{"$ref":"#/definitions/maxItems"},"minItems":{"$ref":"#/definitions/minItems"},"uniqueItems":{"$ref":"#/definitions/uniqueItems"},"enum":{"$ref":"#/definitions/enum"},"multipleOf":{"$ref":"#/definitions/multipleOf"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"security":{"type":"array","items":{"$ref":"#/definitions/securityRequirement"},"uniqueItems":true},"securityRequirement":{"type":"object","additionalProperties":{"type":"array","items":{"type":"string"},"uniqueItems":true}},"xml":{"type":"object","additionalProperties":false,"properties":{"name":{"type":"string"},"namespace":{"type":"string"},"prefix":{"type":"string"},"attribute":{"type":"boolean","default":false},"wrapped":{"type":"boolean","default":false}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"tag":{"type":"object","additionalProperties":false,"required":["name"],"properties":{"name":{"type":"string"},"description":{"type":"string"},"externalDocs":{"$ref":"#/definitions/externalDocs"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"securityDefinitions":{"type":"object","additionalProperties":{"oneOf":[{"$ref":"#/definitions/basicAuthenticationSecurity"},{"$ref":"#/definitions/apiKeySecurity"},{"$ref":"#/definitions/oauth2ImplicitSecurity"},{"$ref":"#/definitions/oauth2PasswordSecurity"},{"$ref":"#/definitions/oauth2ApplicationSecurity"},{"$ref":"#/definitions/oauth2AccessCodeSecurity"}]}},"basicAuthenticationSecurity":{"type":"object","additionalProperties":false,"required":["type"],"properties":{"type":{"type":"string","enum":["basic"]},"description":{"type":"string"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"apiKeySecurity":{"type":"object","additionalProperties":false,"required":["type","name","in"],"properties":{"type":{"type":"string","enum":["apiKey"]},"name":{"type":"string"},"in":{"type":"string","enum":["header","query"]},"description":{"type":"string"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"oauth2ImplicitSecurity":{"type":"object","additionalProperties":false,"required":["type","flow","authorizationUrl"],"properties":{"type":{"type":"string","enum":["oauth2"]},"flow":{"type":"string","enum":["implicit"]},"scopes":{"$ref":"#/definitions/oauth2Scopes"},"authorizationUrl":{"type":"string","format":"uri"},"description":{"type":"string"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"oauth2PasswordSecurity":{"type":"object","additionalProperties":false,"required":["type","flow","tokenUrl"],"properties":{"type":{"type":"string","enum":["oauth2"]},"flow":{"type":"string","enum":["password"]},"scopes":{"$ref":"#/definitions/oauth2Scopes"},"tokenUrl":{"type":"string","format":"uri"},"description":{"type":"string"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"oauth2ApplicationSecurity":{"type":"object","additionalProperties":false,"required":["type","flow","tokenUrl"],"properties":{"type":{"type":"string","enum":["oauth2"]},"flow":{"type":"string","enum":["application"]},"scopes":{"$ref":"#/definitions/oauth2Scopes"},"tokenUrl":{"type":"string","format":"uri"},"description":{"type":"string"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"oauth2AccessCodeSecurity":{"type":"object","additionalProperties":false,"required":["type","flow","authorizationUrl","tokenUrl"],"properties":{"type":{"type":"string","enum":["oauth2"]},"flow":{"type":"string","enum":["accessCode"]},"scopes":{"$ref":"#/definitions/oauth2Scopes"},"authorizationUrl":{"type":"string","format":"uri"},"tokenUrl":{"type":"string","format":"uri"},"description":{"type":"string"}},"patternProperties":{"^x-":{"$ref":"#/definitions/vendorExtension"}}},"oauth2Scopes":{"type":"object","additionalProperties":{"type":"string"}},"mediaTypeList":{"type":"array","items":{"$ref":"#/definitions/mimeType"},"uniqueItems":true},"parametersList":{"type":"array","description":"The parameters needed to send a valid API call.","additionalItems":false,"items":{"oneOf":[{"$ref":"#/definitions/parameter"},{"$ref":"#/definitions/jsonReference"}]},"uniqueItems":true},"schemesList":{"type":"array","description":"The transfer protocol of the API.","items":{"type":"string","enum":["http","https","ws","wss"]},"uniqueItems":true},"collectionFormat":{"type":"string","enum":["csv","ssv","tsv","pipes"],"default":"csv"},"collectionFormatWithMulti":{"type":"string","enum":["csv","ssv","tsv","pipes","multi"],"default":"csv"},"title":{"$ref":"http://json-schema.org/draft-04/schema#/properties/title"},"description":{"$ref":"http://json-schema.org/draft-04/schema#/properties/description"},"default":{"$ref":"http://json-schema.org/draft-04/schema#/properties/default"},"multipleOf":{"$ref":"http://json-schema.org/draft-04/schema#/properties/multipleOf"},"maximum":{"$ref":"http://json-schema.org/draft-04/schema#/properties/maximum"},"exclusiveMaximum":{"$ref":"http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"},"minimum":{"$ref":"http://json-schema.org/draft-04/schema#/properties/minimum"},"exclusiveMinimum":{"$ref":"http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"},"maxLength":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/positiveInteger"},"minLength":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"},"pattern":{"$ref":"http://json-schema.org/draft-04/schema#/properties/pattern"},"maxItems":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/positiveInteger"},"minItems":{"$ref":"http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"},"uniqueItems":{"$ref":"http://json-schema.org/draft-04/schema#/properties/uniqueItems"},"enum":{"$ref":"http://json-schema.org/draft-04/schema#/properties/enum"},"jsonReference":{"type":"object","required":["$ref"],"additionalProperties":false,"properties":{"$ref":{"type":"string"}}}}}');

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/openapi-schemas/schemas/v3.0/schema.json":
/*!****************************************************************************!*\
  !*** ./node_modules/@apidevtools/openapi-schemas/schemas/v3.0/schema.json ***!
  \****************************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"id":"https://spec.openapis.org/oas/3.0/schema/2019-04-02","$schema":"http://json-schema.org/draft-04/schema#","description":"Validation schema for OpenAPI Specification 3.0.X.","type":"object","required":["openapi","info","paths"],"properties":{"openapi":{"type":"string","pattern":"^3\\\\.0\\\\.\\\\d(-.+)?$"},"info":{"$ref":"#/definitions/Info"},"externalDocs":{"$ref":"#/definitions/ExternalDocumentation"},"servers":{"type":"array","items":{"$ref":"#/definitions/Server"}},"security":{"type":"array","items":{"$ref":"#/definitions/SecurityRequirement"}},"tags":{"type":"array","items":{"$ref":"#/definitions/Tag"},"uniqueItems":true},"paths":{"$ref":"#/definitions/Paths"},"components":{"$ref":"#/definitions/Components"}},"patternProperties":{"^x-":{}},"additionalProperties":false,"definitions":{"Reference":{"type":"object","required":["$ref"],"patternProperties":{"^\\\\$ref$":{"type":"string","format":"uri-reference"}}},"Info":{"type":"object","required":["title","version"],"properties":{"title":{"type":"string"},"description":{"type":"string"},"termsOfService":{"type":"string","format":"uri-reference"},"contact":{"$ref":"#/definitions/Contact"},"license":{"$ref":"#/definitions/License"},"version":{"type":"string"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"Contact":{"type":"object","properties":{"name":{"type":"string"},"url":{"type":"string","format":"uri-reference"},"email":{"type":"string","format":"email"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"License":{"type":"object","required":["name"],"properties":{"name":{"type":"string"},"url":{"type":"string","format":"uri-reference"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"Server":{"type":"object","required":["url"],"properties":{"url":{"type":"string"},"description":{"type":"string"},"variables":{"type":"object","additionalProperties":{"$ref":"#/definitions/ServerVariable"}}},"patternProperties":{"^x-":{}},"additionalProperties":false},"ServerVariable":{"type":"object","required":["default"],"properties":{"enum":{"type":"array","items":{"type":"string"}},"default":{"type":"string"},"description":{"type":"string"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"Components":{"type":"object","properties":{"schemas":{"type":"object","patternProperties":{"^[a-zA-Z0-9\\\\.\\\\-_]+$":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"}]}}},"responses":{"type":"object","patternProperties":{"^[a-zA-Z0-9\\\\.\\\\-_]+$":{"oneOf":[{"$ref":"#/definitions/Reference"},{"$ref":"#/definitions/Response"}]}}},"parameters":{"type":"object","patternProperties":{"^[a-zA-Z0-9\\\\.\\\\-_]+$":{"oneOf":[{"$ref":"#/definitions/Reference"},{"$ref":"#/definitions/Parameter"}]}}},"examples":{"type":"object","patternProperties":{"^[a-zA-Z0-9\\\\.\\\\-_]+$":{"oneOf":[{"$ref":"#/definitions/Reference"},{"$ref":"#/definitions/Example"}]}}},"requestBodies":{"type":"object","patternProperties":{"^[a-zA-Z0-9\\\\.\\\\-_]+$":{"oneOf":[{"$ref":"#/definitions/Reference"},{"$ref":"#/definitions/RequestBody"}]}}},"headers":{"type":"object","patternProperties":{"^[a-zA-Z0-9\\\\.\\\\-_]+$":{"oneOf":[{"$ref":"#/definitions/Reference"},{"$ref":"#/definitions/Header"}]}}},"securitySchemes":{"type":"object","patternProperties":{"^[a-zA-Z0-9\\\\.\\\\-_]+$":{"oneOf":[{"$ref":"#/definitions/Reference"},{"$ref":"#/definitions/SecurityScheme"}]}}},"links":{"type":"object","patternProperties":{"^[a-zA-Z0-9\\\\.\\\\-_]+$":{"oneOf":[{"$ref":"#/definitions/Reference"},{"$ref":"#/definitions/Link"}]}}},"callbacks":{"type":"object","patternProperties":{"^[a-zA-Z0-9\\\\.\\\\-_]+$":{"oneOf":[{"$ref":"#/definitions/Reference"},{"$ref":"#/definitions/Callback"}]}}}},"patternProperties":{"^x-":{}},"additionalProperties":false},"Schema":{"type":"object","properties":{"title":{"type":"string"},"multipleOf":{"type":"number","minimum":0,"exclusiveMinimum":true},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"boolean","default":false},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"boolean","default":false},"maxLength":{"type":"integer","minimum":0},"minLength":{"type":"integer","minimum":0,"default":0},"pattern":{"type":"string","format":"regex"},"maxItems":{"type":"integer","minimum":0},"minItems":{"type":"integer","minimum":0,"default":0},"uniqueItems":{"type":"boolean","default":false},"maxProperties":{"type":"integer","minimum":0},"minProperties":{"type":"integer","minimum":0,"default":0},"required":{"type":"array","items":{"type":"string"},"minItems":1,"uniqueItems":true},"enum":{"type":"array","items":{},"minItems":1,"uniqueItems":false},"type":{"type":"string","enum":["array","boolean","integer","number","object","string"]},"not":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"}]},"allOf":{"type":"array","items":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"}]}},"oneOf":{"type":"array","items":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"}]}},"anyOf":{"type":"array","items":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"}]}},"items":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"}]},"properties":{"type":"object","additionalProperties":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"}]}},"additionalProperties":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"},{"type":"boolean"}],"default":true},"description":{"type":"string"},"format":{"type":"string"},"default":{},"nullable":{"type":"boolean","default":false},"discriminator":{"$ref":"#/definitions/Discriminator"},"readOnly":{"type":"boolean","default":false},"writeOnly":{"type":"boolean","default":false},"example":{},"externalDocs":{"$ref":"#/definitions/ExternalDocumentation"},"deprecated":{"type":"boolean","default":false},"xml":{"$ref":"#/definitions/XML"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"Discriminator":{"type":"object","required":["propertyName"],"properties":{"propertyName":{"type":"string"},"mapping":{"type":"object","additionalProperties":{"type":"string"}}}},"XML":{"type":"object","properties":{"name":{"type":"string"},"namespace":{"type":"string","format":"uri"},"prefix":{"type":"string"},"attribute":{"type":"boolean","default":false},"wrapped":{"type":"boolean","default":false}},"patternProperties":{"^x-":{}},"additionalProperties":false},"Response":{"type":"object","required":["description"],"properties":{"description":{"type":"string"},"headers":{"type":"object","additionalProperties":{"oneOf":[{"$ref":"#/definitions/Header"},{"$ref":"#/definitions/Reference"}]}},"content":{"type":"object","additionalProperties":{"$ref":"#/definitions/MediaType"}},"links":{"type":"object","additionalProperties":{"oneOf":[{"$ref":"#/definitions/Link"},{"$ref":"#/definitions/Reference"}]}}},"patternProperties":{"^x-":{}},"additionalProperties":false},"MediaType":{"type":"object","properties":{"schema":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"}]},"example":{},"examples":{"type":"object","additionalProperties":{"oneOf":[{"$ref":"#/definitions/Example"},{"$ref":"#/definitions/Reference"}]}},"encoding":{"type":"object","additionalProperties":{"$ref":"#/definitions/Encoding"}}},"patternProperties":{"^x-":{}},"additionalProperties":false,"allOf":[{"$ref":"#/definitions/ExampleXORExamples"}]},"Example":{"type":"object","properties":{"summary":{"type":"string"},"description":{"type":"string"},"value":{},"externalValue":{"type":"string","format":"uri-reference"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"Header":{"type":"object","properties":{"description":{"type":"string"},"required":{"type":"boolean","default":false},"deprecated":{"type":"boolean","default":false},"allowEmptyValue":{"type":"boolean","default":false},"style":{"type":"string","enum":["simple"],"default":"simple"},"explode":{"type":"boolean"},"allowReserved":{"type":"boolean","default":false},"schema":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"}]},"content":{"type":"object","additionalProperties":{"$ref":"#/definitions/MediaType"},"minProperties":1,"maxProperties":1},"example":{},"examples":{"type":"object","additionalProperties":{"oneOf":[{"$ref":"#/definitions/Example"},{"$ref":"#/definitions/Reference"}]}}},"patternProperties":{"^x-":{}},"additionalProperties":false,"allOf":[{"$ref":"#/definitions/ExampleXORExamples"},{"$ref":"#/definitions/SchemaXORContent"}]},"Paths":{"type":"object","patternProperties":{"^\\\\/":{"$ref":"#/definitions/PathItem"},"^x-":{}},"additionalProperties":false},"PathItem":{"type":"object","properties":{"$ref":{"type":"string"},"summary":{"type":"string"},"description":{"type":"string"},"servers":{"type":"array","items":{"$ref":"#/definitions/Server"}},"parameters":{"type":"array","items":{"oneOf":[{"$ref":"#/definitions/Parameter"},{"$ref":"#/definitions/Reference"}]},"uniqueItems":true}},"patternProperties":{"^(get|put|post|delete|options|head|patch|trace)$":{"$ref":"#/definitions/Operation"},"^x-":{}},"additionalProperties":false},"Operation":{"type":"object","required":["responses"],"properties":{"tags":{"type":"array","items":{"type":"string"}},"summary":{"type":"string"},"description":{"type":"string"},"externalDocs":{"$ref":"#/definitions/ExternalDocumentation"},"operationId":{"type":"string"},"parameters":{"type":"array","items":{"oneOf":[{"$ref":"#/definitions/Parameter"},{"$ref":"#/definitions/Reference"}]},"uniqueItems":true},"requestBody":{"oneOf":[{"$ref":"#/definitions/RequestBody"},{"$ref":"#/definitions/Reference"}]},"responses":{"$ref":"#/definitions/Responses"},"callbacks":{"type":"object","additionalProperties":{"oneOf":[{"$ref":"#/definitions/Callback"},{"$ref":"#/definitions/Reference"}]}},"deprecated":{"type":"boolean","default":false},"security":{"type":"array","items":{"$ref":"#/definitions/SecurityRequirement"}},"servers":{"type":"array","items":{"$ref":"#/definitions/Server"}}},"patternProperties":{"^x-":{}},"additionalProperties":false},"Responses":{"type":"object","properties":{"default":{"oneOf":[{"$ref":"#/definitions/Response"},{"$ref":"#/definitions/Reference"}]}},"patternProperties":{"^[1-5](?:\\\\d{2}|XX)$":{"oneOf":[{"$ref":"#/definitions/Response"},{"$ref":"#/definitions/Reference"}]},"^x-":{}},"minProperties":1,"additionalProperties":false},"SecurityRequirement":{"type":"object","additionalProperties":{"type":"array","items":{"type":"string"}}},"Tag":{"type":"object","required":["name"],"properties":{"name":{"type":"string"},"description":{"type":"string"},"externalDocs":{"$ref":"#/definitions/ExternalDocumentation"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"ExternalDocumentation":{"type":"object","required":["url"],"properties":{"description":{"type":"string"},"url":{"type":"string","format":"uri-reference"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"ExampleXORExamples":{"description":"Example and examples are mutually exclusive","not":{"required":["example","examples"]}},"SchemaXORContent":{"description":"Schema and content are mutually exclusive, at least one is required","not":{"required":["schema","content"]},"oneOf":[{"required":["schema"]},{"required":["content"],"description":"Some properties are not allowed if content is present","allOf":[{"not":{"required":["style"]}},{"not":{"required":["explode"]}},{"not":{"required":["allowReserved"]}},{"not":{"required":["example"]}},{"not":{"required":["examples"]}}]}]},"Parameter":{"type":"object","properties":{"name":{"type":"string"},"in":{"type":"string"},"description":{"type":"string"},"required":{"type":"boolean","default":false},"deprecated":{"type":"boolean","default":false},"allowEmptyValue":{"type":"boolean","default":false},"style":{"type":"string"},"explode":{"type":"boolean"},"allowReserved":{"type":"boolean","default":false},"schema":{"oneOf":[{"$ref":"#/definitions/Schema"},{"$ref":"#/definitions/Reference"}]},"content":{"type":"object","additionalProperties":{"$ref":"#/definitions/MediaType"},"minProperties":1,"maxProperties":1},"example":{},"examples":{"type":"object","additionalProperties":{"oneOf":[{"$ref":"#/definitions/Example"},{"$ref":"#/definitions/Reference"}]}}},"patternProperties":{"^x-":{}},"additionalProperties":false,"required":["name","in"],"allOf":[{"$ref":"#/definitions/ExampleXORExamples"},{"$ref":"#/definitions/SchemaXORContent"},{"$ref":"#/definitions/ParameterLocation"}]},"ParameterLocation":{"description":"Parameter location","oneOf":[{"description":"Parameter in path","required":["required"],"properties":{"in":{"enum":["path"]},"style":{"enum":["matrix","label","simple"],"default":"simple"},"required":{"enum":[true]}}},{"description":"Parameter in query","properties":{"in":{"enum":["query"]},"style":{"enum":["form","spaceDelimited","pipeDelimited","deepObject"],"default":"form"}}},{"description":"Parameter in header","properties":{"in":{"enum":["header"]},"style":{"enum":["simple"],"default":"simple"}}},{"description":"Parameter in cookie","properties":{"in":{"enum":["cookie"]},"style":{"enum":["form"],"default":"form"}}}]},"RequestBody":{"type":"object","required":["content"],"properties":{"description":{"type":"string"},"content":{"type":"object","additionalProperties":{"$ref":"#/definitions/MediaType"}},"required":{"type":"boolean","default":false}},"patternProperties":{"^x-":{}},"additionalProperties":false},"SecurityScheme":{"oneOf":[{"$ref":"#/definitions/APIKeySecurityScheme"},{"$ref":"#/definitions/HTTPSecurityScheme"},{"$ref":"#/definitions/OAuth2SecurityScheme"},{"$ref":"#/definitions/OpenIdConnectSecurityScheme"}]},"APIKeySecurityScheme":{"type":"object","required":["type","name","in"],"properties":{"type":{"type":"string","enum":["apiKey"]},"name":{"type":"string"},"in":{"type":"string","enum":["header","query","cookie"]},"description":{"type":"string"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"HTTPSecurityScheme":{"type":"object","required":["scheme","type"],"properties":{"scheme":{"type":"string"},"bearerFormat":{"type":"string"},"description":{"type":"string"},"type":{"type":"string","enum":["http"]}},"patternProperties":{"^x-":{}},"additionalProperties":false,"oneOf":[{"description":"Bearer","properties":{"scheme":{"enum":["bearer"]}}},{"description":"Non Bearer","not":{"required":["bearerFormat"]},"properties":{"scheme":{"not":{"enum":["bearer"]}}}}]},"OAuth2SecurityScheme":{"type":"object","required":["type","flows"],"properties":{"type":{"type":"string","enum":["oauth2"]},"flows":{"$ref":"#/definitions/OAuthFlows"},"description":{"type":"string"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"OpenIdConnectSecurityScheme":{"type":"object","required":["type","openIdConnectUrl"],"properties":{"type":{"type":"string","enum":["openIdConnect"]},"openIdConnectUrl":{"type":"string","format":"uri-reference"},"description":{"type":"string"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"OAuthFlows":{"type":"object","properties":{"implicit":{"$ref":"#/definitions/ImplicitOAuthFlow"},"password":{"$ref":"#/definitions/PasswordOAuthFlow"},"clientCredentials":{"$ref":"#/definitions/ClientCredentialsFlow"},"authorizationCode":{"$ref":"#/definitions/AuthorizationCodeOAuthFlow"}},"patternProperties":{"^x-":{}},"additionalProperties":false},"ImplicitOAuthFlow":{"type":"object","required":["authorizationUrl","scopes"],"properties":{"authorizationUrl":{"type":"string","format":"uri-reference"},"refreshUrl":{"type":"string","format":"uri-reference"},"scopes":{"type":"object","additionalProperties":{"type":"string"}}},"patternProperties":{"^x-":{}},"additionalProperties":false},"PasswordOAuthFlow":{"type":"object","required":["tokenUrl"],"properties":{"tokenUrl":{"type":"string","format":"uri-reference"},"refreshUrl":{"type":"string","format":"uri-reference"},"scopes":{"type":"object","additionalProperties":{"type":"string"}}},"patternProperties":{"^x-":{}},"additionalProperties":false},"ClientCredentialsFlow":{"type":"object","required":["tokenUrl"],"properties":{"tokenUrl":{"type":"string","format":"uri-reference"},"refreshUrl":{"type":"string","format":"uri-reference"},"scopes":{"type":"object","additionalProperties":{"type":"string"}}},"patternProperties":{"^x-":{}},"additionalProperties":false},"AuthorizationCodeOAuthFlow":{"type":"object","required":["authorizationUrl","tokenUrl"],"properties":{"authorizationUrl":{"type":"string","format":"uri-reference"},"tokenUrl":{"type":"string","format":"uri-reference"},"refreshUrl":{"type":"string","format":"uri-reference"},"scopes":{"type":"object","additionalProperties":{"type":"string"}}},"patternProperties":{"^x-":{}},"additionalProperties":false},"Link":{"type":"object","properties":{"operationId":{"type":"string"},"operationRef":{"type":"string","format":"uri-reference"},"parameters":{"type":"object","additionalProperties":{}},"requestBody":{},"description":{"type":"string"},"server":{"$ref":"#/definitions/Server"}},"patternProperties":{"^x-":{}},"additionalProperties":false,"not":{"description":"Operation Id and Operation Ref are mutually exclusive","required":["operationId","operationRef"]}},"Callback":{"type":"object","additionalProperties":{"$ref":"#/definitions/PathItem"},"patternProperties":{"^x-":{}}},"Encoding":{"type":"object","properties":{"contentType":{"type":"string"},"headers":{"type":"object","additionalProperties":{"$ref":"#/definitions/Header"}},"style":{"type":"string","enum":["form","spaceDelimited","pipeDelimited","deepObject"]},"explode":{"type":"boolean"},"allowReserved":{"type":"boolean","default":false}},"additionalProperties":false}}}');

/***/ }),

/***/ "(rsc)/./node_modules/@apidevtools/openapi-schemas/schemas/v3.1/schema.json":
/*!****************************************************************************!*\
  !*** ./node_modules/@apidevtools/openapi-schemas/schemas/v3.1/schema.json ***!
  \****************************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$id":"https://spec.openapis.org/oas/3.1/schema/2021-04-15","$schema":"https://json-schema.org/draft/2020-12/schema","type":"object","properties":{"openapi":{"type":"string","pattern":"^3\\\\.1\\\\.\\\\d+(-.+)?$"},"info":{"$ref":"#/$defs/info"},"jsonSchemaDialect":{"$ref":"#/$defs/uri","default":"https://spec.openapis.org/oas/3.1/dialect/base"},"servers":{"type":"array","items":{"$ref":"#/$defs/server"}},"paths":{"$ref":"#/$defs/paths"},"webhooks":{"type":"object","additionalProperties":{"$ref":"#/$defs/path-item-or-reference"}},"components":{"$ref":"#/$defs/components"},"security":{"type":"array","items":{"$ref":"#/$defs/security-requirement"}},"tags":{"type":"array","items":{"$ref":"#/$defs/tag"}},"externalDocs":{"$ref":"#/$defs/external-documentation"}},"required":["openapi","info"],"anyOf":[{"required":["paths"]},{"required":["components"]},{"required":["webhooks"]}],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false,"$defs":{"info":{"type":"object","properties":{"title":{"type":"string"},"summary":{"type":"string"},"description":{"type":"string"},"termsOfService":{"type":"string"},"contact":{"$ref":"#/$defs/contact"},"license":{"$ref":"#/$defs/license"},"version":{"type":"string"}},"required":["title","version"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"contact":{"type":"object","properties":{"name":{"type":"string"},"url":{"type":"string"},"email":{"type":"string"}},"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"license":{"type":"object","properties":{"name":{"type":"string"},"identifier":{"type":"string"},"url":{"$ref":"#/$defs/uri"}},"required":["name"],"oneOf":[{"required":["identifier"]},{"required":["url"]}],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"server":{"type":"object","properties":{"url":{"$ref":"#/$defs/uri"},"description":{"type":"string"},"variables":{"type":"object","additionalProperties":{"$ref":"#/$defs/server-variable"}}},"required":["url"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"server-variable":{"type":"object","properties":{"enum":{"type":"array","items":{"type":"string"},"minItems":1},"default":{"type":"string"},"descriptions":{"type":"string"}},"required":["default"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"components":{"type":"object","properties":{"schemas":{"type":"object","additionalProperties":{"$dynamicRef":"#meta"}},"responses":{"type":"object","additionalProperties":{"$ref":"#/$defs/response-or-reference"}},"parameters":{"type":"object","additionalProperties":{"$ref":"#/$defs/parameter-or-reference"}},"examples":{"type":"object","additionalProperties":{"$ref":"#/$defs/example-or-reference"}},"requestBodies":{"type":"object","additionalProperties":{"$ref":"#/$defs/request-body-or-reference"}},"headers":{"type":"object","additionalProperties":{"$ref":"#/$defs/header-or-reference"}},"securitySchemes":{"type":"object","additionalProperties":{"$ref":"#/$defs/security-scheme-or-reference"}},"links":{"type":"object","additionalProperties":{"$ref":"#/$defs/link-or-reference"}},"callbacks":{"type":"object","additionalProperties":{"$ref":"#/$defs/callbacks-or-reference"}},"pathItems":{"type":"object","additionalProperties":{"$ref":"#/$defs/path-item-or-reference"}}},"patternProperties":{"^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$":{"$comment":"Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected","propertyNames":{"pattern":"^[a-zA-Z0-9._-]+$"}}},"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"paths":{"type":"object","patternProperties":{"^/":{"$ref":"#/$defs/path-item"}},"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"path-item":{"type":"object","properties":{"summary":{"type":"string"},"description":{"type":"string"},"servers":{"type":"array","items":{"$ref":"#/$defs/server"}},"parameters":{"type":"array","items":{"$ref":"#/$defs/parameter-or-reference"}}},"patternProperties":{"^(get|put|post|delete|options|head|patch|trace)$":{"$ref":"#/$defs/operation"}},"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"path-item-or-reference":{"if":{"required":["$ref"]},"then":{"$ref":"#/$defs/reference"},"else":{"$ref":"#/$defs/path-item"}},"operation":{"type":"object","properties":{"tags":{"type":"array","items":{"type":"string"}},"summary":{"type":"string"},"description":{"type":"string"},"externalDocs":{"$ref":"#/$defs/external-documentation"},"operationId":{"type":"string"},"parameters":{"type":"array","items":{"$ref":"#/$defs/parameter-or-reference"}},"requestBody":{"$ref":"#/$defs/request-body-or-reference"},"responses":{"$ref":"#/$defs/responses"},"callbacks":{"type":"object","additionalProperties":{"$ref":"#/$defs/callbacks-or-reference"}},"deprecated":{"default":false,"type":"boolean"},"security":{"type":"array","items":{"$ref":"#/$defs/security-requirement"}},"servers":{"type":"array","items":{"$ref":"#/$defs/server"}}},"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"external-documentation":{"type":"object","properties":{"description":{"type":"string"},"url":{"$ref":"#/$defs/uri"}},"required":["url"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"parameter":{"type":"object","properties":{"name":{"type":"string"},"in":{"enum":["query","header","path","cookie"]},"description":{"type":"string"},"required":{"default":false,"type":"boolean"},"deprecated":{"default":false,"type":"boolean"},"allowEmptyValue":{"default":false,"type":"boolean"},"schema":{"$dynamicRef":"#meta"},"content":{"$ref":"#/$defs/content"}},"required":["in"],"oneOf":[{"required":["schema"]},{"required":["content"]}],"dependentSchemas":{"schema":{"properties":{"style":{"type":"string"},"explode":{"type":"boolean"},"allowReserved":{"default":false,"type":"boolean"}},"allOf":[{"$ref":"#/$defs/examples"},{"$ref":"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path"},{"$ref":"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header"},{"$ref":"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query"},{"$ref":"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie"},{"$ref":"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-form"}],"$defs":{"styles-for-path":{"if":{"properties":{"in":{"const":"path"}},"required":["in"]},"then":{"properties":{"style":{"default":"simple","enum":["matrix","label","simple"]},"required":{"const":true}},"required":["required"]}},"styles-for-header":{"if":{"properties":{"in":{"const":"header"}},"required":["in"]},"then":{"properties":{"style":{"default":"simple","enum":["simple"]}}}},"styles-for-query":{"if":{"properties":{"in":{"const":"query"}},"required":["in"]},"then":{"properties":{"style":{"default":"form","enum":["form","spaceDelimited","pipeDelimited","deepObject"]}}}},"styles-for-cookie":{"if":{"properties":{"in":{"const":"cookie"}},"required":["in"]},"then":{"properties":{"style":{"default":"form","enum":["form"]}}}},"styles-for-form":{"if":{"properties":{"style":{"const":"form"}},"required":["style"]},"then":{"properties":{"explode":{"default":true}}},"else":{"properties":{"explode":{"default":false}}}}}}},"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"parameter-or-reference":{"if":{"required":["$ref"]},"then":{"$ref":"#/$defs/reference"},"else":{"$ref":"#/$defs/parameter"}},"request-body":{"type":"object","properties":{"description":{"type":"string"},"content":{"$ref":"#/$defs/content"},"required":{"default":false,"type":"boolean"}},"required":["content"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"request-body-or-reference":{"if":{"required":["$ref"]},"then":{"$ref":"#/$defs/reference"},"else":{"$ref":"#/$defs/request-body"}},"content":{"type":"object","additionalProperties":{"$ref":"#/$defs/media-type"},"propertyNames":{"format":"media-range"}},"media-type":{"type":"object","properties":{"schema":{"$dynamicRef":"#meta"},"encoding":{"type":"object","additionalProperties":{"$ref":"#/$defs/encoding"}}},"allOf":[{"$ref":"#/$defs/specification-extensions"},{"$ref":"#/$defs/examples"}],"unevaluatedProperties":false},"encoding":{"type":"object","properties":{"contentType":{"type":"string","format":"media-range"},"headers":{"type":"object","additionalProperties":{"$ref":"#/$defs/header-or-reference"}},"style":{"default":"form","enum":["form","spaceDelimited","pipeDelimited","deepObject"]},"explode":{"type":"boolean"},"allowReserved":{"default":false,"type":"boolean"}},"allOf":[{"$ref":"#/$defs/specification-extensions"},{"$ref":"#/$defs/encoding/$defs/explode-default"}],"unevaluatedProperties":false,"$defs":{"explode-default":{"if":{"properties":{"style":{"const":"form"}},"required":["style"]},"then":{"properties":{"explode":{"default":true}}},"else":{"properties":{"explode":{"default":false}}}}}},"responses":{"type":"object","properties":{"default":{"$ref":"#/$defs/response-or-reference"}},"patternProperties":{"^[1-5][0-9X]{2}$":{"$ref":"#/$defs/response-or-reference"}},"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"response":{"type":"object","properties":{"description":{"type":"string"},"headers":{"type":"object","additionalProperties":{"$ref":"#/$defs/header-or-reference"}},"content":{"$ref":"#/$defs/content"},"links":{"type":"object","additionalProperties":{"$ref":"#/$defs/link-or-reference"}}},"required":["description"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"response-or-reference":{"if":{"required":["$ref"]},"then":{"$ref":"#/$defs/reference"},"else":{"$ref":"#/$defs/response"}},"callbacks":{"type":"object","$ref":"#/$defs/specification-extensions","additionalProperties":{"$ref":"#/$defs/path-item-or-reference"}},"callbacks-or-reference":{"if":{"required":["$ref"]},"then":{"$ref":"#/$defs/reference"},"else":{"$ref":"#/$defs/callbacks"}},"example":{"type":"object","properties":{"summary":{"type":"string"},"description":{"type":"string"},"value":true,"externalValue":{"$ref":"#/$defs/uri"}},"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"example-or-reference":{"if":{"required":["$ref"]},"then":{"$ref":"#/$defs/reference"},"else":{"$ref":"#/$defs/example"}},"link":{"type":"object","properties":{"operationRef":{"$ref":"#/$defs/uri"},"operationId":true,"parameters":{"$ref":"#/$defs/map-of-strings"},"requestBody":true,"description":{"type":"string"},"body":{"$ref":"#/$defs/server"}},"oneOf":[{"required":["operationRef"]},{"required":["operationId"]}],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"link-or-reference":{"if":{"required":["$ref"]},"then":{"$ref":"#/$defs/reference"},"else":{"$ref":"#/$defs/link"}},"header":{"type":"object","properties":{"description":{"type":"string"},"required":{"default":false,"type":"boolean"},"deprecated":{"default":false,"type":"boolean"},"allowEmptyValue":{"default":false,"type":"boolean"}},"dependentSchemas":{"schema":{"properties":{"style":{"default":"simple","enum":["simple"]},"explode":{"default":false,"type":"boolean"},"allowReserved":{"default":false,"type":"boolean"},"schema":{"$dynamicRef":"#meta"}},"$ref":"#/$defs/examples"},"content":{"properties":{"content":{"$ref":"#/$defs/content"}}}},"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"header-or-reference":{"if":{"required":["$ref"]},"then":{"$ref":"#/$defs/reference"},"else":{"$ref":"#/$defs/header"}},"tag":{"type":"object","properties":{"name":{"type":"string"},"description":{"type":"string"},"externalDocs":{"$ref":"#/$defs/external-documentation"}},"required":["name"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"reference":{"type":"object","properties":{"$ref":{"$ref":"#/$defs/uri"},"summary":{"type":"string"},"description":{"type":"string"}},"unevaluatedProperties":false},"schema":{"$dynamicAnchor":"meta","type":["object","boolean"]},"security-scheme":{"type":"object","properties":{"type":{"enum":["apiKey","http","mutualTLS","oauth2","openIdConnect"]},"description":{"type":"string"}},"required":["type"],"allOf":[{"$ref":"#/$defs/specification-extensions"},{"$ref":"#/$defs/security-scheme/$defs/type-apikey"},{"$ref":"#/$defs/security-scheme/$defs/type-http"},{"$ref":"#/$defs/security-scheme/$defs/type-http-bearer"},{"$ref":"#/$defs/security-scheme/$defs/type-oauth2"},{"$ref":"#/$defs/security-scheme/$defs/type-oidc"}],"unevaluatedProperties":false,"$defs":{"type-apikey":{"if":{"properties":{"type":{"const":"apiKey"}},"required":["type"]},"then":{"properties":{"name":{"type":"string"},"in":{"enum":["query","header","cookie"]}},"required":["name","in"]}},"type-http":{"if":{"properties":{"type":{"const":"http"}},"required":["type"]},"then":{"properties":{"scheme":{"type":"string"}},"required":["scheme"]}},"type-http-bearer":{"if":{"properties":{"type":{"const":"http"},"scheme":{"const":"bearer"}},"required":["type","scheme"]},"then":{"properties":{"bearerFormat":{"type":"string"}},"required":["scheme"]}},"type-oauth2":{"if":{"properties":{"type":{"const":"oauth2"}},"required":["type"]},"then":{"properties":{"flows":{"$ref":"#/$defs/oauth-flows"}},"required":["flows"]}},"type-oidc":{"if":{"properties":{"type":{"const":"openIdConnect"}},"required":["type"]},"then":{"properties":{"openIdConnectUrl":{"$ref":"#/$defs/uri"}},"required":["openIdConnectUrl"]}}}},"security-scheme-or-reference":{"if":{"required":["$ref"]},"then":{"$ref":"#/$defs/reference"},"else":{"$ref":"#/$defs/security-scheme"}},"oauth-flows":{"type":"object","properties":{"implicit":{"$ref":"#/$defs/oauth-flows/$defs/implicit"},"password":{"$ref":"#/$defs/oauth-flows/$defs/password"},"clientCredentials":{"$ref":"#/$defs/oauth-flows/$defs/client-credentials"},"authorizationCode":{"$ref":"#/$defs/oauth-flows/$defs/authorization-code"}},"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false,"$defs":{"implicit":{"type":"object","properties":{"authorizationUrl":{"type":"string"},"refreshUrl":{"type":"string"},"scopes":{"$ref":"#/$defs/map-of-strings"}},"required":["authorizationUrl","scopes"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"password":{"type":"object","properties":{"tokenUrl":{"type":"string"},"refreshUrl":{"type":"string"},"scopes":{"$ref":"#/$defs/map-of-strings"}},"required":["tokenUrl","scopes"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"client-credentials":{"type":"object","properties":{"tokenUrl":{"type":"string"},"refreshUrl":{"type":"string"},"scopes":{"$ref":"#/$defs/map-of-strings"}},"required":["tokenUrl","scopes"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false},"authorization-code":{"type":"object","properties":{"authorizationUrl":{"type":"string"},"tokenUrl":{"type":"string"},"refreshUrl":{"type":"string"},"scopes":{"$ref":"#/$defs/map-of-strings"}},"required":["authorizationUrl","tokenUrl","scopes"],"$ref":"#/$defs/specification-extensions","unevaluatedProperties":false}}},"security-requirement":{"type":"object","additionalProperties":{"type":"array","items":{"type":"string"}}},"specification-extensions":{"patternProperties":{"^x-":true}},"examples":{"properties":{"example":true,"examples":{"type":"object","additionalProperties":{"$ref":"#/$defs/example-or-reference"}}}},"uri":{"type":"string","format":"uri"},"map-of-strings":{"type":"object","additionalProperties":{"type":"string"}}}}');

/***/ })

};
;