"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/swagger-jsdoc";
exports.ids = ["vendor-chunks/swagger-jsdoc"];
exports.modules = {

/***/ "(rsc)/./node_modules/swagger-jsdoc/index.js":
/*!*********************************************!*\
  !*** ./node_modules/swagger-jsdoc/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./src/lib */ \"(rsc)/./node_modules/swagger-jsdoc/src/lib.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLHNHQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL25hbnRlcy1wdWJsaWMtZGF0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9pbmRleC5qcz9lNTFiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvbGliJyk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/src/lib.js":
/*!***********************************************!*\
  !*** ./node_modules/swagger-jsdoc/src/lib.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { build } = __webpack_require__(/*! ./specification */ \"(rsc)/./node_modules/swagger-jsdoc/src/specification.js\");\n/**\n * Generates the specification.\n * @param {object} options - Configuration options\n * @param {string} options.encoding Optional, passed to readFileSync options. Defaults to 'utf8'.\n * @param {boolean} options.failOnErrors Whether or not to throw when parsing errors. Defaults to false.\n * @param {boolean} options.verbose Whether the swagger snippet containing each error should be included in print/throws. Defaults to false.\n * @param {string} options.format Optional, defaults to '.json' - target file format '.yml' or '.yaml'.\n * @param {object} options.swaggerDefinition\n * @param {object} options.definition\n * @param {array} options.apis\n * @returns {object} Output specification\n */ module.exports = (options)=>{\n    if (!options) {\n        throw new Error(`Missing or invalid input: 'options' is required`);\n    }\n    if (!options.swaggerDefinition && !options.definition) {\n        throw new Error(`Missing or invalid input: 'options.swaggerDefinition' or 'options.definition' is required`);\n    }\n    if (!options.apis || !Array.isArray(options.apis)) {\n        throw new Error(`Missing or invalid input: 'options.apis' is required and it should be an array.`);\n    }\n    return build(options);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9zcmMvbGliLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLEVBQUVBLEtBQUssRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUUxQjs7Ozs7Ozs7Ozs7Q0FXQyxHQUNEQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQ0M7SUFDaEIsSUFBSSxDQUFDQSxTQUFTO1FBQ1osTUFBTSxJQUFJQyxNQUFNLENBQUMsK0NBQStDLENBQUM7SUFDbkU7SUFFQSxJQUFJLENBQUNELFFBQVFFLGlCQUFpQixJQUFJLENBQUNGLFFBQVFHLFVBQVUsRUFBRTtRQUNyRCxNQUFNLElBQUlGLE1BQ1IsQ0FBQyx5RkFBeUYsQ0FBQztJQUUvRjtJQUVBLElBQUksQ0FBQ0QsUUFBUUksSUFBSSxJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ04sUUFBUUksSUFBSSxHQUFHO1FBQ2pELE1BQU0sSUFBSUgsTUFDUixDQUFDLCtFQUErRSxDQUFDO0lBRXJGO0lBRUEsT0FBT0wsTUFBTUk7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL25hbnRlcy1wdWJsaWMtZGF0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9zcmMvbGliLmpzP2Q4M2QiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBidWlsZCB9ID0gcmVxdWlyZSgnLi9zcGVjaWZpY2F0aW9uJyk7XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBzcGVjaWZpY2F0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmVuY29kaW5nIE9wdGlvbmFsLCBwYXNzZWQgdG8gcmVhZEZpbGVTeW5jIG9wdGlvbnMuIERlZmF1bHRzIHRvICd1dGY4Jy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5mYWlsT25FcnJvcnMgV2hldGhlciBvciBub3QgdG8gdGhyb3cgd2hlbiBwYXJzaW5nIGVycm9ycy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMudmVyYm9zZSBXaGV0aGVyIHRoZSBzd2FnZ2VyIHNuaXBwZXQgY29udGFpbmluZyBlYWNoIGVycm9yIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBwcmludC90aHJvd3MuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZm9ybWF0IE9wdGlvbmFsLCBkZWZhdWx0cyB0byAnLmpzb24nIC0gdGFyZ2V0IGZpbGUgZm9ybWF0ICcueW1sJyBvciAnLnlhbWwnLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc3dhZ2dlckRlZmluaXRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmRlZmluaXRpb25cbiAqIEBwYXJhbSB7YXJyYXl9IG9wdGlvbnMuYXBpc1xuICogQHJldHVybnMge29iamVjdH0gT3V0cHV0IHNwZWNpZmljYXRpb25cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAob3B0aW9ucykgPT4ge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3Npbmcgb3IgaW52YWxpZCBpbnB1dDogJ29wdGlvbnMnIGlzIHJlcXVpcmVkYCk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuc3dhZ2dlckRlZmluaXRpb24gJiYgIW9wdGlvbnMuZGVmaW5pdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBNaXNzaW5nIG9yIGludmFsaWQgaW5wdXQ6ICdvcHRpb25zLnN3YWdnZXJEZWZpbml0aW9uJyBvciAnb3B0aW9ucy5kZWZpbml0aW9uJyBpcyByZXF1aXJlZGBcbiAgICApO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLmFwaXMgfHwgIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hcGlzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBNaXNzaW5nIG9yIGludmFsaWQgaW5wdXQ6ICdvcHRpb25zLmFwaXMnIGlzIHJlcXVpcmVkIGFuZCBpdCBzaG91bGQgYmUgYW4gYXJyYXkuYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gYnVpbGQob3B0aW9ucyk7XG59O1xuIl0sIm5hbWVzIjpbImJ1aWxkIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJvcHRpb25zIiwiRXJyb3IiLCJzd2FnZ2VyRGVmaW5pdGlvbiIsImRlZmluaXRpb24iLCJhcGlzIiwiQXJyYXkiLCJpc0FycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/src/lib.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/src/specification.js":
/*!*********************************************************!*\
  !*** ./node_modules/swagger-jsdoc/src/specification.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst doctrine = __webpack_require__(/*! doctrine */ \"(rsc)/./node_modules/doctrine/lib/doctrine.js\");\nconst parser = __webpack_require__(/*! swagger-parser */ \"(rsc)/./node_modules/swagger-parser/index.js\");\nconst YAML = __webpack_require__(/*! yaml */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/index.js\");\nconst { hasEmptyProperty, convertGlobPaths, extractAnnotations, mergeDeep, extractYamlFromJsDoc, isTagPresentInTags } = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/swagger-jsdoc/src/utils.js\");\n/**\n * Prepare the swagger/openapi specification object.\n * @see https://github.com/OAI/OpenAPI-Specification/tree/master/versions\n * @param {object} definition - The `definition` or `swaggerDefinition` from options.\n * @returns {object} swaggerObject\n */ function prepare(definition) {\n    const swaggerObject = JSON.parse(JSON.stringify(definition));\n    const specificationTemplate = {\n        v2: [\n            \"paths\",\n            \"definitions\",\n            \"responses\",\n            \"parameters\",\n            \"securityDefinitions\"\n        ],\n        v3: [\n            \"paths\",\n            \"definitions\",\n            \"responses\",\n            \"parameters\",\n            \"securityDefinitions\",\n            \"components\"\n        ],\n        v4: [\n            \"components\",\n            \"channels\"\n        ]\n    };\n    const getVersion = ()=>{\n        if (swaggerObject.asyncapi) {\n            return \"v4\";\n        }\n        if (swaggerObject.openapi) {\n            return \"v3\";\n        }\n        if (swaggerObject.swagger) {\n            return \"v2\";\n        }\n        swaggerObject.swagger = \"2.0\";\n        return \"v2\";\n    };\n    const version = getVersion();\n    specificationTemplate[version].forEach((property)=>{\n        swaggerObject[property] = swaggerObject[property] || {};\n    });\n    swaggerObject.tags = swaggerObject.tags || [];\n    return swaggerObject;\n}\n/**\n * @param {object} obj\n * @param {string} ext\n */ function format(swaggerObject, ext) {\n    if (ext === \".yml\" || ext === \".yaml\") {\n        return YAML.stringify(swaggerObject);\n    }\n    return swaggerObject;\n}\n/**\n * OpenAPI specification validator does not accept empty values for a few properties.\n * Solves validator error: \"Schema error should NOT have additional properties\"\n * @param {object} swaggerObject\n * @returns {object} swaggerObject\n */ function clean(swaggerObject) {\n    for (const prop of [\n        \"definitions\",\n        \"responses\",\n        \"parameters\",\n        \"securityDefinitions\"\n    ]){\n        if (hasEmptyProperty(swaggerObject[prop])) {\n            delete swaggerObject[prop];\n        }\n    }\n    return swaggerObject;\n}\n/**\n * Parse the swagger object and remove useless properties if necessary.\n *\n * @param {object} swaggerObject - Swagger object from parsing the api files.\n * @returns {object} The specification.\n */ function finalize(swaggerObject, options) {\n    let specification = swaggerObject;\n    parser.parse(swaggerObject, (err, api)=>{\n        if (!err) {\n            specification = api;\n        }\n    });\n    if (specification.openapi) {\n        specification = clean(specification);\n    }\n    return format(specification, options.format);\n}\n/**\n * @param {object} swaggerObject\n * @param {object} annotation\n * @param {string} property\n */ function organize(swaggerObject, annotation, property) {\n    // Root property on purpose.\n    // @see https://github.com/OAI/OpenAPI-Specification/blob/master/proposals/002_Webhooks.md#proposed-solution\n    if (property === \"x-webhooks\") {\n        swaggerObject[property] = mergeDeep(swaggerObject[property], annotation[property]);\n    }\n    // Other extensions can be in varying places depending on different vendors and opinions.\n    // The following return makes it so that they are not put in `paths` in the last case.\n    // New specific extensions will need to be handled on case-by-case if to be included in `paths`.\n    if (property.startsWith(\"x-\")) return;\n    const commonProperties = [\n        \"components\",\n        \"consumes\",\n        \"produces\",\n        \"paths\",\n        \"schemas\",\n        \"securityDefinitions\",\n        \"responses\",\n        \"parameters\",\n        \"definitions\",\n        \"channels\"\n    ];\n    if (commonProperties.includes(property)) {\n        for (const definition of Object.keys(annotation[property])){\n            swaggerObject[property][definition] = mergeDeep(swaggerObject[property][definition], annotation[property][definition]);\n        }\n    } else if (property === \"tags\") {\n        const { tags } = annotation;\n        if (Array.isArray(tags)) {\n            for (const tag of tags){\n                if (!isTagPresentInTags(tag, swaggerObject.tags)) {\n                    swaggerObject.tags.push(tag);\n                }\n            }\n        } else if (!isTagPresentInTags(tags, swaggerObject.tags)) {\n            swaggerObject.tags.push(tags);\n        }\n    } else {\n        // Paths which are not defined as \"paths\" property, starting with a slash \"/\"\n        swaggerObject.paths[property] = mergeDeep(swaggerObject.paths[property], annotation[property]);\n    }\n}\n/**\n * @param {object} options\n * @returns {object} swaggerObject\n */ function build(options) {\n    YAML.defaultOptions.keepCstNodes = true;\n    // Get input definition and prepare the specification's skeleton\n    const definition = options.swaggerDefinition || options.definition;\n    const specification = prepare(definition);\n    const yamlDocsAnchors = new Map();\n    const yamlDocsErrors = [];\n    const yamlDocsReady = [];\n    for (const filePath of convertGlobPaths(options.apis)){\n        const { yaml: yamlAnnotations, jsdoc: jsdocAnnotations } = extractAnnotations(filePath, options.encoding);\n        if (yamlAnnotations.length) {\n            for (const annotation of yamlAnnotations){\n                const parsed = Object.assign(YAML.parseDocument(annotation), {\n                    filePath\n                });\n                const anchors = parsed.anchors.getNames();\n                if (anchors.length) {\n                    for (const anchor of anchors){\n                        yamlDocsAnchors.set(anchor, parsed);\n                    }\n                } else if (parsed.errors && parsed.errors.length) {\n                    // Attach the relevent yaml section to the error for verbose logging\n                    parsed.errors.forEach((err)=>{\n                        err.annotation = annotation;\n                    });\n                    yamlDocsErrors.push(parsed);\n                } else {\n                    yamlDocsReady.push(parsed);\n                }\n            }\n        }\n        if (jsdocAnnotations.length) {\n            for (const annotation of jsdocAnnotations){\n                const jsDocComment = doctrine.parse(annotation, {\n                    unwrap: true\n                });\n                for (const doc of extractYamlFromJsDoc(jsDocComment)){\n                    const parsed = Object.assign(YAML.parseDocument(doc), {\n                        filePath\n                    });\n                    const anchors = parsed.anchors.getNames();\n                    if (anchors.length) {\n                        for (const anchor of anchors){\n                            yamlDocsAnchors.set(anchor, parsed);\n                        }\n                    } else if (parsed.errors && parsed.errors.length) {\n                        // Attach the relevent yaml section to the error for verbose logging\n                        parsed.errors.forEach((err)=>{\n                            err.annotation = doc;\n                        });\n                        yamlDocsErrors.push(parsed);\n                    } else {\n                        yamlDocsReady.push(parsed);\n                    }\n                }\n            }\n        }\n    }\n    if (yamlDocsErrors.length) {\n        for (const docWithErr of yamlDocsErrors){\n            const errsToDelete = [];\n            docWithErr.errors.forEach((error, index)=>{\n                if (error.name === \"YAMLReferenceError\") {\n                    // This should either be a smart regex or ideally a YAML library method using the error.range.\n                    // The following works with both pretty and not pretty errors.\n                    const refErr = error.message.split(\"Aliased anchor not found: \").filter((a)=>a).join(\"\").split(\" at line\")[0];\n                    const anchor = yamlDocsAnchors.get(refErr);\n                    const anchorString = anchor.cstNode.toString();\n                    const originalString = docWithErr.cstNode.toString();\n                    const readyDocument = YAML.parseDocument(`${anchorString}\\n${originalString}`);\n                    yamlDocsReady.push(readyDocument);\n                    errsToDelete.push(index);\n                }\n            });\n            // reverse sort the deletion array so we always delete from the end\n            errsToDelete.sort((a, b)=>b - a);\n            // Cleanup solved errors in order to allow for parser to pass through.\n            for (const errIndex of errsToDelete){\n                docWithErr.errors.splice(errIndex, 1);\n            }\n        }\n        // Format errors into a printable/throwable string\n        const errReport = yamlDocsErrors.filter((doc)=>doc.errors.length).map(({ errors, filePath })=>{\n            let str = `Error in ${filePath} :\\n`;\n            if (options.verbose) {\n                str += errors.map((e)=>`${e.toString()}\\nImbedded within:\\n\\`\\`\\`\\n  ${e.annotation.replace(/\\n/g, \"\\n  \")}\\n\\`\\`\\``).join(\"\\n\");\n            } else {\n                str += errors.map((e)=>e.toString()).join(\"\\n\");\n            }\n            return str;\n        }).filter((error)=>!!error);\n        if (errReport.length) {\n            if (options.failOnErrors) {\n                throw new Error(errReport);\n            }\n            // Place to provide feedback for errors. Previously throwing, now reporting only.\n            console.info(\"Not all input has been taken into account at your final specification.\");\n            console.error(`Here's the report: \\n\\n\\n ${errReport}`);\n        }\n    }\n    for (const document of yamlDocsReady){\n        const parsedDoc = document.toJSON();\n        for(const property in parsedDoc){\n            organize(specification, parsedDoc, property);\n        }\n    }\n    return finalize(specification, options);\n}\nmodule.exports = {\n    prepare,\n    build,\n    organize,\n    finalize,\n    format\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9zcmMvc3BlY2lmaWNhdGlvbi5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsV0FBV0MsbUJBQU9BLENBQUM7QUFDekIsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUM7QUFFckIsTUFBTSxFQUNKRyxnQkFBZ0IsRUFDaEJDLGdCQUFnQixFQUNoQkMsa0JBQWtCLEVBQ2xCQyxTQUFTLEVBQ1RDLG9CQUFvQixFQUNwQkMsa0JBQWtCLEVBQ25CLEdBQUdSLG1CQUFPQSxDQUFDO0FBRVo7Ozs7O0NBS0MsR0FDRCxTQUFTUyxRQUFRQyxVQUFVO0lBQ3pCLE1BQU1DLGdCQUFnQkMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxTQUFTLENBQUNKO0lBQ2hELE1BQU1LLHdCQUF3QjtRQUM1QkMsSUFBSTtZQUNGO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUNEQyxJQUFJO1lBQ0Y7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7UUFDREMsSUFBSTtZQUFDO1lBQWM7U0FBVztJQUNoQztJQUVBLE1BQU1DLGFBQWE7UUFDakIsSUFBSVIsY0FBY1MsUUFBUSxFQUFFO1lBQzFCLE9BQU87UUFDVDtRQUVBLElBQUlULGNBQWNVLE9BQU8sRUFBRTtZQUN6QixPQUFPO1FBQ1Q7UUFFQSxJQUFJVixjQUFjVyxPQUFPLEVBQUU7WUFDekIsT0FBTztRQUNUO1FBRUFYLGNBQWNXLE9BQU8sR0FBRztRQUN4QixPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxVQUFVSjtJQUVoQkoscUJBQXFCLENBQUNRLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLENBQUNDO1FBQ3RDZCxhQUFhLENBQUNjLFNBQVMsR0FBR2QsYUFBYSxDQUFDYyxTQUFTLElBQUksQ0FBQztJQUN4RDtJQUVBZCxjQUFjZSxJQUFJLEdBQUdmLGNBQWNlLElBQUksSUFBSSxFQUFFO0lBRTdDLE9BQU9mO0FBQ1Q7QUFFQTs7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RjtJQUVBLEtBQUssTUFBTVUsWUFBWW5ELGNBQWU7UUFDcEMsTUFBTW9ELFlBQVlELFNBQVNFLE1BQU07UUFDakMsSUFBSyxNQUFNbkYsWUFBWWtGLFVBQVc7WUFDaEN2RSxTQUFTSCxlQUFlMEUsV0FBV2xGO1FBQ3JDO0lBQ0Y7SUFFQSxPQUFPTSxTQUFTRSxlQUFlRDtBQUNqQztBQUVBNkUsT0FBT0MsT0FBTyxHQUFHO0lBQUVyRztJQUFTdUM7SUFBT1o7SUFBVUw7SUFBVUo7QUFBTyIsInNvdXJjZXMiOlsid2VicGFjazovL25hbnRlcy1wdWJsaWMtZGF0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9zcmMvc3BlY2lmaWNhdGlvbi5qcz8zMTIwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRvY3RyaW5lID0gcmVxdWlyZSgnZG9jdHJpbmUnKTtcbmNvbnN0IHBhcnNlciA9IHJlcXVpcmUoJ3N3YWdnZXItcGFyc2VyJyk7XG5jb25zdCBZQU1MID0gcmVxdWlyZSgneWFtbCcpO1xuXG5jb25zdCB7XG4gIGhhc0VtcHR5UHJvcGVydHksXG4gIGNvbnZlcnRHbG9iUGF0aHMsXG4gIGV4dHJhY3RBbm5vdGF0aW9ucyxcbiAgbWVyZ2VEZWVwLFxuICBleHRyYWN0WWFtbEZyb21Kc0RvYyxcbiAgaXNUYWdQcmVzZW50SW5UYWdzLFxufSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBzd2FnZ2VyL29wZW5hcGkgc3BlY2lmaWNhdGlvbiBvYmplY3QuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9PQUkvT3BlbkFQSS1TcGVjaWZpY2F0aW9uL3RyZWUvbWFzdGVyL3ZlcnNpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gZGVmaW5pdGlvbiAtIFRoZSBgZGVmaW5pdGlvbmAgb3IgYHN3YWdnZXJEZWZpbml0aW9uYCBmcm9tIG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBzd2FnZ2VyT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHByZXBhcmUoZGVmaW5pdGlvbikge1xuICBjb25zdCBzd2FnZ2VyT2JqZWN0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkZWZpbml0aW9uKSk7XG4gIGNvbnN0IHNwZWNpZmljYXRpb25UZW1wbGF0ZSA9IHtcbiAgICB2MjogW1xuICAgICAgJ3BhdGhzJyxcbiAgICAgICdkZWZpbml0aW9ucycsXG4gICAgICAncmVzcG9uc2VzJyxcbiAgICAgICdwYXJhbWV0ZXJzJyxcbiAgICAgICdzZWN1cml0eURlZmluaXRpb25zJyxcbiAgICBdLFxuICAgIHYzOiBbXG4gICAgICAncGF0aHMnLFxuICAgICAgJ2RlZmluaXRpb25zJyxcbiAgICAgICdyZXNwb25zZXMnLFxuICAgICAgJ3BhcmFtZXRlcnMnLFxuICAgICAgJ3NlY3VyaXR5RGVmaW5pdGlvbnMnLFxuICAgICAgJ2NvbXBvbmVudHMnLFxuICAgIF0sXG4gICAgdjQ6IFsnY29tcG9uZW50cycsICdjaGFubmVscyddLFxuICB9O1xuXG4gIGNvbnN0IGdldFZlcnNpb24gPSAoKSA9PiB7XG4gICAgaWYgKHN3YWdnZXJPYmplY3QuYXN5bmNhcGkpIHtcbiAgICAgIHJldHVybiAndjQnO1xuICAgIH1cblxuICAgIGlmIChzd2FnZ2VyT2JqZWN0Lm9wZW5hcGkpIHtcbiAgICAgIHJldHVybiAndjMnO1xuICAgIH1cblxuICAgIGlmIChzd2FnZ2VyT2JqZWN0LnN3YWdnZXIpIHtcbiAgICAgIHJldHVybiAndjInO1xuICAgIH1cblxuICAgIHN3YWdnZXJPYmplY3Quc3dhZ2dlciA9ICcyLjAnO1xuICAgIHJldHVybiAndjInO1xuICB9O1xuXG4gIGNvbnN0IHZlcnNpb24gPSBnZXRWZXJzaW9uKCk7XG5cbiAgc3BlY2lmaWNhdGlvblRlbXBsYXRlW3ZlcnNpb25dLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgc3dhZ2dlck9iamVjdFtwcm9wZXJ0eV0gPSBzd2FnZ2VyT2JqZWN0W3Byb3BlcnR5XSB8fCB7fTtcbiAgfSk7XG5cbiAgc3dhZ2dlck9iamVjdC50YWdzID0gc3dhZ2dlck9iamVjdC50YWdzIHx8IFtdO1xuXG4gIHJldHVybiBzd2FnZ2VyT2JqZWN0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHRcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KHN3YWdnZXJPYmplY3QsIGV4dCkge1xuICBpZiAoZXh0ID09PSAnLnltbCcgfHwgZXh0ID09PSAnLnlhbWwnKSB7XG4gICAgcmV0dXJuIFlBTUwuc3RyaW5naWZ5KHN3YWdnZXJPYmplY3QpO1xuICB9XG4gIHJldHVybiBzd2FnZ2VyT2JqZWN0O1xufVxuXG4vKipcbiAqIE9wZW5BUEkgc3BlY2lmaWNhdGlvbiB2YWxpZGF0b3IgZG9lcyBub3QgYWNjZXB0IGVtcHR5IHZhbHVlcyBmb3IgYSBmZXcgcHJvcGVydGllcy5cbiAqIFNvbHZlcyB2YWxpZGF0b3IgZXJyb3I6IFwiU2NoZW1hIGVycm9yIHNob3VsZCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcIlxuICogQHBhcmFtIHtvYmplY3R9IHN3YWdnZXJPYmplY3RcbiAqIEByZXR1cm5zIHtvYmplY3R9IHN3YWdnZXJPYmplY3RcbiAqL1xuZnVuY3Rpb24gY2xlYW4oc3dhZ2dlck9iamVjdCkge1xuICBmb3IgKGNvbnN0IHByb3Agb2YgW1xuICAgICdkZWZpbml0aW9ucycsXG4gICAgJ3Jlc3BvbnNlcycsXG4gICAgJ3BhcmFtZXRlcnMnLFxuICAgICdzZWN1cml0eURlZmluaXRpb25zJyxcbiAgXSkge1xuICAgIGlmIChoYXNFbXB0eVByb3BlcnR5KHN3YWdnZXJPYmplY3RbcHJvcF0pKSB7XG4gICAgICBkZWxldGUgc3dhZ2dlck9iamVjdFtwcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3dhZ2dlck9iamVjdDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgc3dhZ2dlciBvYmplY3QgYW5kIHJlbW92ZSB1c2VsZXNzIHByb3BlcnRpZXMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzd2FnZ2VyT2JqZWN0IC0gU3dhZ2dlciBvYmplY3QgZnJvbSBwYXJzaW5nIHRoZSBhcGkgZmlsZXMuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgc3BlY2lmaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmluYWxpemUoc3dhZ2dlck9iamVjdCwgb3B0aW9ucykge1xuICBsZXQgc3BlY2lmaWNhdGlvbiA9IHN3YWdnZXJPYmplY3Q7XG4gIHBhcnNlci5wYXJzZShzd2FnZ2VyT2JqZWN0LCAoZXJyLCBhcGkpID0+IHtcbiAgICBpZiAoIWVycikge1xuICAgICAgc3BlY2lmaWNhdGlvbiA9IGFwaTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChzcGVjaWZpY2F0aW9uLm9wZW5hcGkpIHtcbiAgICBzcGVjaWZpY2F0aW9uID0gY2xlYW4oc3BlY2lmaWNhdGlvbik7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0KHNwZWNpZmljYXRpb24sIG9wdGlvbnMuZm9ybWF0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gc3dhZ2dlck9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IGFubm90YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBvcmdhbml6ZShzd2FnZ2VyT2JqZWN0LCBhbm5vdGF0aW9uLCBwcm9wZXJ0eSkge1xuICAvLyBSb290IHByb3BlcnR5IG9uIHB1cnBvc2UuXG4gIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL09BSS9PcGVuQVBJLVNwZWNpZmljYXRpb24vYmxvYi9tYXN0ZXIvcHJvcG9zYWxzLzAwMl9XZWJob29rcy5tZCNwcm9wb3NlZC1zb2x1dGlvblxuICBpZiAocHJvcGVydHkgPT09ICd4LXdlYmhvb2tzJykge1xuICAgIHN3YWdnZXJPYmplY3RbcHJvcGVydHldID0gbWVyZ2VEZWVwKFxuICAgICAgc3dhZ2dlck9iamVjdFtwcm9wZXJ0eV0sXG4gICAgICBhbm5vdGF0aW9uW3Byb3BlcnR5XVxuICAgICk7XG4gIH1cblxuICAvLyBPdGhlciBleHRlbnNpb25zIGNhbiBiZSBpbiB2YXJ5aW5nIHBsYWNlcyBkZXBlbmRpbmcgb24gZGlmZmVyZW50IHZlbmRvcnMgYW5kIG9waW5pb25zLlxuICAvLyBUaGUgZm9sbG93aW5nIHJldHVybiBtYWtlcyBpdCBzbyB0aGF0IHRoZXkgYXJlIG5vdCBwdXQgaW4gYHBhdGhzYCBpbiB0aGUgbGFzdCBjYXNlLlxuICAvLyBOZXcgc3BlY2lmaWMgZXh0ZW5zaW9ucyB3aWxsIG5lZWQgdG8gYmUgaGFuZGxlZCBvbiBjYXNlLWJ5LWNhc2UgaWYgdG8gYmUgaW5jbHVkZWQgaW4gYHBhdGhzYC5cbiAgaWYgKHByb3BlcnR5LnN0YXJ0c1dpdGgoJ3gtJykpIHJldHVybjtcblxuICBjb25zdCBjb21tb25Qcm9wZXJ0aWVzID0gW1xuICAgICdjb21wb25lbnRzJyxcbiAgICAnY29uc3VtZXMnLFxuICAgICdwcm9kdWNlcycsXG4gICAgJ3BhdGhzJyxcbiAgICAnc2NoZW1hcycsXG4gICAgJ3NlY3VyaXR5RGVmaW5pdGlvbnMnLFxuICAgICdyZXNwb25zZXMnLFxuICAgICdwYXJhbWV0ZXJzJyxcbiAgICAnZGVmaW5pdGlvbnMnLFxuICAgICdjaGFubmVscycsXG4gIF07XG4gIGlmIChjb21tb25Qcm9wZXJ0aWVzLmluY2x1ZGVzKHByb3BlcnR5KSkge1xuICAgIGZvciAoY29uc3QgZGVmaW5pdGlvbiBvZiBPYmplY3Qua2V5cyhhbm5vdGF0aW9uW3Byb3BlcnR5XSkpIHtcbiAgICAgIHN3YWdnZXJPYmplY3RbcHJvcGVydHldW2RlZmluaXRpb25dID0gbWVyZ2VEZWVwKFxuICAgICAgICBzd2FnZ2VyT2JqZWN0W3Byb3BlcnR5XVtkZWZpbml0aW9uXSxcbiAgICAgICAgYW5ub3RhdGlvbltwcm9wZXJ0eV1bZGVmaW5pdGlvbl1cbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAndGFncycpIHtcbiAgICBjb25zdCB7IHRhZ3MgfSA9IGFubm90YXRpb247XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YWdzKSkge1xuICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgICBpZiAoIWlzVGFnUHJlc2VudEluVGFncyh0YWcsIHN3YWdnZXJPYmplY3QudGFncykpIHtcbiAgICAgICAgICBzd2FnZ2VyT2JqZWN0LnRhZ3MucHVzaCh0YWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNUYWdQcmVzZW50SW5UYWdzKHRhZ3MsIHN3YWdnZXJPYmplY3QudGFncykpIHtcbiAgICAgIHN3YWdnZXJPYmplY3QudGFncy5wdXNoKHRhZ3MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBQYXRocyB3aGljaCBhcmUgbm90IGRlZmluZWQgYXMgXCJwYXRoc1wiIHByb3BlcnR5LCBzdGFydGluZyB3aXRoIGEgc2xhc2ggXCIvXCJcbiAgICBzd2FnZ2VyT2JqZWN0LnBhdGhzW3Byb3BlcnR5XSA9IG1lcmdlRGVlcChcbiAgICAgIHN3YWdnZXJPYmplY3QucGF0aHNbcHJvcGVydHldLFxuICAgICAgYW5ub3RhdGlvbltwcm9wZXJ0eV1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtvYmplY3R9IHN3YWdnZXJPYmplY3RcbiAqL1xuZnVuY3Rpb24gYnVpbGQob3B0aW9ucykge1xuICBZQU1MLmRlZmF1bHRPcHRpb25zLmtlZXBDc3ROb2RlcyA9IHRydWU7XG5cbiAgLy8gR2V0IGlucHV0IGRlZmluaXRpb24gYW5kIHByZXBhcmUgdGhlIHNwZWNpZmljYXRpb24ncyBza2VsZXRvblxuICBjb25zdCBkZWZpbml0aW9uID0gb3B0aW9ucy5zd2FnZ2VyRGVmaW5pdGlvbiB8fCBvcHRpb25zLmRlZmluaXRpb247XG4gIGNvbnN0IHNwZWNpZmljYXRpb24gPSBwcmVwYXJlKGRlZmluaXRpb24pO1xuICBjb25zdCB5YW1sRG9jc0FuY2hvcnMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHlhbWxEb2NzRXJyb3JzID0gW107XG4gIGNvbnN0IHlhbWxEb2NzUmVhZHkgPSBbXTtcblxuICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGNvbnZlcnRHbG9iUGF0aHMob3B0aW9ucy5hcGlzKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHlhbWw6IHlhbWxBbm5vdGF0aW9ucyxcbiAgICAgIGpzZG9jOiBqc2RvY0Fubm90YXRpb25zLFxuICAgIH0gPSBleHRyYWN0QW5ub3RhdGlvbnMoZmlsZVBhdGgsIG9wdGlvbnMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHlhbWxBbm5vdGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiB5YW1sQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gT2JqZWN0LmFzc2lnbihZQU1MLnBhcnNlRG9jdW1lbnQoYW5ub3RhdGlvbiksIHtcbiAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYW5jaG9ycyA9IHBhcnNlZC5hbmNob3JzLmdldE5hbWVzKCk7XG4gICAgICAgIGlmIChhbmNob3JzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAoY29uc3QgYW5jaG9yIG9mIGFuY2hvcnMpIHtcbiAgICAgICAgICAgIHlhbWxEb2NzQW5jaG9ycy5zZXQoYW5jaG9yLCBwYXJzZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYXJzZWQuZXJyb3JzICYmIHBhcnNlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gQXR0YWNoIHRoZSByZWxldmVudCB5YW1sIHNlY3Rpb24gdG8gdGhlIGVycm9yIGZvciB2ZXJib3NlIGxvZ2dpbmdcbiAgICAgICAgICBwYXJzZWQuZXJyb3JzLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICAgICAgZXJyLmFubm90YXRpb24gPSBhbm5vdGF0aW9uO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHlhbWxEb2NzRXJyb3JzLnB1c2gocGFyc2VkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5YW1sRG9jc1JlYWR5LnB1c2gocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChqc2RvY0Fubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBhbm5vdGF0aW9uIG9mIGpzZG9jQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgY29uc3QganNEb2NDb21tZW50ID0gZG9jdHJpbmUucGFyc2UoYW5ub3RhdGlvbiwgeyB1bndyYXA6IHRydWUgfSk7XG4gICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGV4dHJhY3RZYW1sRnJvbUpzRG9jKGpzRG9jQ29tbWVudCkpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBPYmplY3QuYXNzaWduKFlBTUwucGFyc2VEb2N1bWVudChkb2MpLCB7IGZpbGVQYXRoIH0pO1xuXG4gICAgICAgICAgY29uc3QgYW5jaG9ycyA9IHBhcnNlZC5hbmNob3JzLmdldE5hbWVzKCk7XG4gICAgICAgICAgaWYgKGFuY2hvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFuY2hvciBvZiBhbmNob3JzKSB7XG4gICAgICAgICAgICAgIHlhbWxEb2NzQW5jaG9ycy5zZXQoYW5jaG9yLCBwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VkLmVycm9ycyAmJiBwYXJzZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSByZWxldmVudCB5YW1sIHNlY3Rpb24gdG8gdGhlIGVycm9yIGZvciB2ZXJib3NlIGxvZ2dpbmdcbiAgICAgICAgICAgIHBhcnNlZC5lcnJvcnMuZm9yRWFjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGVyci5hbm5vdGF0aW9uID0gZG9jO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5YW1sRG9jc0Vycm9ycy5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlhbWxEb2NzUmVhZHkucHVzaChwYXJzZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh5YW1sRG9jc0Vycm9ycy5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IGRvY1dpdGhFcnIgb2YgeWFtbERvY3NFcnJvcnMpIHtcbiAgICAgIGNvbnN0IGVycnNUb0RlbGV0ZSA9IFtdO1xuICAgICAgZG9jV2l0aEVyci5lcnJvcnMuZm9yRWFjaCgoZXJyb3IsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnWUFNTFJlZmVyZW5jZUVycm9yJykge1xuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGVpdGhlciBiZSBhIHNtYXJ0IHJlZ2V4IG9yIGlkZWFsbHkgYSBZQU1MIGxpYnJhcnkgbWV0aG9kIHVzaW5nIHRoZSBlcnJvci5yYW5nZS5cbiAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHdvcmtzIHdpdGggYm90aCBwcmV0dHkgYW5kIG5vdCBwcmV0dHkgZXJyb3JzLlxuICAgICAgICAgIGNvbnN0IHJlZkVyciA9IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIC5zcGxpdCgnQWxpYXNlZCBhbmNob3Igbm90IGZvdW5kOiAnKVxuICAgICAgICAgICAgLmZpbHRlcigoYSkgPT4gYSlcbiAgICAgICAgICAgIC5qb2luKCcnKVxuICAgICAgICAgICAgLnNwbGl0KCcgYXQgbGluZScpWzBdO1xuICAgICAgICAgIGNvbnN0IGFuY2hvciA9IHlhbWxEb2NzQW5jaG9ycy5nZXQocmVmRXJyKTtcbiAgICAgICAgICBjb25zdCBhbmNob3JTdHJpbmcgPSBhbmNob3IuY3N0Tm9kZS50b1N0cmluZygpO1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RyaW5nID0gZG9jV2l0aEVyci5jc3ROb2RlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgY29uc3QgcmVhZHlEb2N1bWVudCA9IFlBTUwucGFyc2VEb2N1bWVudChcbiAgICAgICAgICAgIGAke2FuY2hvclN0cmluZ31cXG4ke29yaWdpbmFsU3RyaW5nfWBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeWFtbERvY3NSZWFkeS5wdXNoKHJlYWR5RG9jdW1lbnQpO1xuICAgICAgICAgIGVycnNUb0RlbGV0ZS5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyByZXZlcnNlIHNvcnQgdGhlIGRlbGV0aW9uIGFycmF5IHNvIHdlIGFsd2F5cyBkZWxldGUgZnJvbSB0aGUgZW5kXG4gICAgICBlcnJzVG9EZWxldGUuc29ydCgoYSwgYikgPT4gYiAtIGEpO1xuXG4gICAgICAvLyBDbGVhbnVwIHNvbHZlZCBlcnJvcnMgaW4gb3JkZXIgdG8gYWxsb3cgZm9yIHBhcnNlciB0byBwYXNzIHRocm91Z2guXG4gICAgICBmb3IgKGNvbnN0IGVyckluZGV4IG9mIGVycnNUb0RlbGV0ZSkge1xuICAgICAgICBkb2NXaXRoRXJyLmVycm9ycy5zcGxpY2UoZXJySW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvcm1hdCBlcnJvcnMgaW50byBhIHByaW50YWJsZS90aHJvd2FibGUgc3RyaW5nXG4gICAgY29uc3QgZXJyUmVwb3J0ID0geWFtbERvY3NFcnJvcnNcbiAgICAgIC5maWx0ZXIoKGRvYykgPT4gZG9jLmVycm9ycy5sZW5ndGgpXG4gICAgICAubWFwKCh7IGVycm9ycywgZmlsZVBhdGggfSkgPT4ge1xuICAgICAgICBsZXQgc3RyID0gYEVycm9yIGluICR7ZmlsZVBhdGh9IDpcXG5gO1xuICAgICAgICBpZiAob3B0aW9ucy52ZXJib3NlKSB7XG4gICAgICAgICAgc3RyICs9IGVycm9yc1xuICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgKGUpID0+XG4gICAgICAgICAgICAgICAgYCR7ZS50b1N0cmluZygpfVxcbkltYmVkZGVkIHdpdGhpbjpcXG5cXGBcXGBcXGBcXG4gICR7ZS5hbm5vdGF0aW9uLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAvXFxuL2csXG4gICAgICAgICAgICAgICAgICAnXFxuICAnXG4gICAgICAgICAgICAgICAgKX1cXG5cXGBcXGBcXGBgXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9IGVycm9ycy5tYXAoKGUpID0+IGUudG9TdHJpbmcoKSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChlcnJvcikgPT4gISFlcnJvcik7XG5cbiAgICBpZiAoZXJyUmVwb3J0Lmxlbmd0aCkge1xuICAgICAgaWYgKG9wdGlvbnMuZmFpbE9uRXJyb3JzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJSZXBvcnQpO1xuICAgICAgfVxuICAgICAgLy8gUGxhY2UgdG8gcHJvdmlkZSBmZWVkYmFjayBmb3IgZXJyb3JzLiBQcmV2aW91c2x5IHRocm93aW5nLCBub3cgcmVwb3J0aW5nIG9ubHkuXG4gICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICdOb3QgYWxsIGlucHV0IGhhcyBiZWVuIHRha2VuIGludG8gYWNjb3VudCBhdCB5b3VyIGZpbmFsIHNwZWNpZmljYXRpb24uJ1xuICAgICAgKTtcblxuICAgICAgY29uc29sZS5lcnJvcihgSGVyZSdzIHRoZSByZXBvcnQ6IFxcblxcblxcbiAke2VyclJlcG9ydH1gKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGRvY3VtZW50IG9mIHlhbWxEb2NzUmVhZHkpIHtcbiAgICBjb25zdCBwYXJzZWREb2MgPSBkb2N1bWVudC50b0pTT04oKTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHBhcnNlZERvYykge1xuICAgICAgb3JnYW5pemUoc3BlY2lmaWNhdGlvbiwgcGFyc2VkRG9jLCBwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsaXplKHNwZWNpZmljYXRpb24sIG9wdGlvbnMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgcHJlcGFyZSwgYnVpbGQsIG9yZ2FuaXplLCBmaW5hbGl6ZSwgZm9ybWF0IH07XG4iXSwibmFtZXMiOlsiZG9jdHJpbmUiLCJyZXF1aXJlIiwicGFyc2VyIiwiWUFNTCIsImhhc0VtcHR5UHJvcGVydHkiLCJjb252ZXJ0R2xvYlBhdGhzIiwiZXh0cmFjdEFubm90YXRpb25zIiwibWVyZ2VEZWVwIiwiZXh0cmFjdFlhbWxGcm9tSnNEb2MiLCJpc1RhZ1ByZXNlbnRJblRhZ3MiLCJwcmVwYXJlIiwiZGVmaW5pdGlvbiIsInN3YWdnZXJPYmplY3QiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJzcGVjaWZpY2F0aW9uVGVtcGxhdGUiLCJ2MiIsInYzIiwidjQiLCJnZXRWZXJzaW9uIiwiYXN5bmNhcGkiLCJvcGVuYXBpIiwic3dhZ2dlciIsInZlcnNpb24iLCJmb3JFYWNoIiwicHJvcGVydHkiLCJ0YWdzIiwiZm9ybWF0IiwiZXh0IiwiY2xlYW4iLCJwcm9wIiwiZmluYWxpemUiLCJvcHRpb25zIiwic3BlY2lmaWNhdGlvbiIsImVyciIsImFwaSIsIm9yZ2FuaXplIiwiYW5ub3RhdGlvbiIsInN0YXJ0c1dpdGgiLCJjb21tb25Qcm9wZXJ0aWVzIiwiaW5jbHVkZXMiLCJPYmplY3QiLCJrZXlzIiwiQXJyYXkiLCJpc0FycmF5IiwidGFnIiwicHVzaCIsInBhdGhzIiwiYnVpbGQiLCJkZWZhdWx0T3B0aW9ucyIsImtlZXBDc3ROb2RlcyIsInN3YWdnZXJEZWZpbml0aW9uIiwieWFtbERvY3NBbmNob3JzIiwiTWFwIiwieWFtbERvY3NFcnJvcnMiLCJ5YW1sRG9jc1JlYWR5IiwiZmlsZVBhdGgiLCJhcGlzIiwieWFtbCIsInlhbWxBbm5vdGF0aW9ucyIsImpzZG9jIiwianNkb2NBbm5vdGF0aW9ucyIsImVuY29kaW5nIiwibGVuZ3RoIiwicGFyc2VkIiwiYXNzaWduIiwicGFyc2VEb2N1bWVudCIsImFuY2hvcnMiLCJnZXROYW1lcyIsImFuY2hvciIsInNldCIsImVycm9ycyIsImpzRG9jQ29tbWVudCIsInVud3JhcCIsImRvYyIsImRvY1dpdGhFcnIiLCJlcnJzVG9EZWxldGUiLCJlcnJvciIsImluZGV4IiwibmFtZSIsInJlZkVyciIsIm1lc3NhZ2UiLCJzcGxpdCIsImZpbHRlciIsImEiLCJqb2luIiwiZ2V0IiwiYW5jaG9yU3RyaW5nIiwiY3N0Tm9kZSIsInRvU3RyaW5nIiwib3JpZ2luYWxTdHJpbmciLCJyZWFkeURvY3VtZW50Iiwic29ydCIsImIiLCJlcnJJbmRleCIsInNwbGljZSIsImVyclJlcG9ydCIsIm1hcCIsInN0ciIsInZlcmJvc2UiLCJlIiwicmVwbGFjZSIsImZhaWxPbkVycm9ycyIsIkVycm9yIiwiY29uc29sZSIsImluZm8iLCJkb2N1bWVudCIsInBhcnNlZERvYyIsInRvSlNPTiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/src/specification.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/src/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/swagger-jsdoc/src/utils.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst glob = __webpack_require__(/*! glob */ \"(rsc)/./node_modules/glob/glob.js\");\nconst mergeWith = __webpack_require__(/*! lodash.mergewith */ \"(rsc)/./node_modules/lodash.mergewith/index.js\");\n/**\n * Converts an array of globs to full paths\n * @param {array} globs - Array of globs and/or normal paths\n * @return {array} Array of fully-qualified paths\n */ function convertGlobPaths(globs) {\n    return globs.map((globString)=>glob.sync(globString)).reduce((previous, current)=>previous.concat(current), []);\n}\n/**\n * Checks if there is any properties of the input object which are an empty object\n * @param {object} obj - the object to check\n * @returns {boolean}\n */ function hasEmptyProperty(obj) {\n    return Object.keys(obj).map((key)=>obj[key]).every((keyObject)=>typeof keyObject === \"object\" && Object.keys(keyObject).every((key)=>!(key in keyObject)));\n}\n/**\n * Extracts the YAML description from JSDoc comments with `@swagger`/`@openapi` annotation.\n * @param {object} jsDocComment - Single item of JSDoc comments from doctrine.parse\n * @returns {array} YAML parts\n */ function extractYamlFromJsDoc(jsDocComment) {\n    const yamlParts = [];\n    for (const tag of jsDocComment.tags){\n        if (tag.title === \"swagger\" || tag.title === \"openapi\") {\n            yamlParts.push(tag.description);\n        }\n    }\n    return yamlParts;\n}\n/**\n * @param {string} filePath\n * @returns {{jsdoc: array, yaml: array}} JSDoc comments and Yaml files\n */ function extractAnnotations(filePath, encoding = \"utf8\") {\n    const fileContent = fs.readFileSync(filePath, {\n        encoding\n    });\n    const ext = path.extname(filePath);\n    const jsDocRegex = /\\/\\*\\*([\\s\\S]*?)\\*\\//gm;\n    const csDocRegex = /###([\\s\\S]*?)###/gm;\n    const yaml = [];\n    const jsdoc = [];\n    let regexResults = null;\n    switch(ext){\n        case \".yml\":\n        case \".yaml\":\n            yaml.push(fileContent);\n            break;\n        case \".coffee\":\n            regexResults = fileContent.match(csDocRegex) || [];\n            for (const result of regexResults){\n                let part = result.split(\"###\");\n                part[0] = `/**`;\n                part[part.length - 1] = \"*/\";\n                part = part.join(\"\");\n                jsdoc.push(part);\n            }\n            break;\n        default:\n            {\n                regexResults = fileContent.match(jsDocRegex) || [];\n                for (const result of regexResults){\n                    jsdoc.push(result);\n                }\n            }\n    }\n    return {\n        yaml,\n        jsdoc\n    };\n}\n/**\n * @param {object} tag\n * @param {array} tags\n * @returns {boolean}\n */ function isTagPresentInTags(tag, tags) {\n    const match = tags.find((targetTag)=>tag.name === targetTag.name);\n    if (match) return true;\n    return false;\n}\n/**\n * Get an object of the definition file configuration.\n * @param {string} defPath\n * @param {object} swaggerDefinition\n */ function loadDefinition(defPath, swaggerDefinition) {\n    const resolvedPath = path.resolve(defPath);\n    const extName = path.extname(resolvedPath);\n    // eslint-disable-next-line\n    const loadCjs = ()=>__webpack_require__(\"(rsc)/./node_modules/swagger-jsdoc/src sync recursive\")(resolvedPath);\n    const loadJson = ()=>JSON.parse(swaggerDefinition);\n    // eslint-disable-next-line\n    const loadYaml = ()=>(__webpack_require__(/*! yaml */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/index.js\").parse)(swaggerDefinition);\n    const LOADERS = {\n        \".js\": loadCjs,\n        \".cjs\": loadCjs,\n        \".json\": loadJson,\n        \".yml\": loadYaml,\n        \".yaml\": loadYaml\n    };\n    const loader = LOADERS[extName];\n    if (loader === undefined) {\n        throw new Error(\"Definition file should be .cjs, .json, .yml or .yaml\");\n    }\n    return loader();\n}\n/**\n * A recursive deep-merge that ignores null values when merging.\n * This returns the merged object and does not mutate.\n * @param {object} first the first object to get merged\n * @param {object} second the second object to get merged\n */ function mergeDeep(first, second) {\n    return mergeWith({}, first, second, (a, b)=>b === null ? a : undefined);\n}\nmodule.exports.mergeDeep = mergeDeep;\nmodule.exports.convertGlobPaths = convertGlobPaths;\nmodule.exports.hasEmptyProperty = hasEmptyProperty;\nmodule.exports.extractYamlFromJsDoc = extractYamlFromJsDoc;\nmodule.exports.extractAnnotations = extractAnnotations;\nmodule.exports.isTagPresentInTags = isTagPresentInTags;\nmodule.exports.loadDefinition = loadDefinition;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ25CLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1HLFlBQVlILG1CQUFPQSxDQUFDO0FBRTFCOzs7O0NBSUMsR0FDRCxTQUFTSSxpQkFBaUJDLEtBQUs7SUFDN0IsT0FBT0EsTUFDSkMsR0FBRyxDQUFDLENBQUNDLGFBQWVMLEtBQUtNLElBQUksQ0FBQ0QsYUFDOUJFLE1BQU0sQ0FBQyxDQUFDQyxVQUFVQyxVQUFZRCxTQUFTRSxNQUFNLENBQUNELFVBQVUsRUFBRTtBQUMvRDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTRSxpQkFBaUJDLEdBQUc7SUFDM0IsT0FBT0MsT0FBT0MsSUFBSSxDQUFDRixLQUNoQlIsR0FBRyxDQUFDLENBQUNXLE1BQVFILEdBQUcsQ0FBQ0csSUFBSSxFQUNyQkMsS0FBSyxDQUNKLENBQUNDLFlBQ0MsT0FBT0EsY0FBYyxZQUNyQkosT0FBT0MsSUFBSSxDQUFDRyxXQUFXRCxLQUFLLENBQUMsQ0FBQ0QsTUFBUSxDQUFFQSxDQUFBQSxPQUFPRSxTQUFRO0FBRS9EO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNDLHFCQUFxQkMsWUFBWTtJQUN4QyxNQUFNQyxZQUFZLEVBQUU7SUFFcEIsS0FBSyxNQUFNQyxPQUFPRixhQUFhRyxJQUFJLENBQUU7UUFDbkMsSUFBSUQsSUFBSUUsS0FBSyxLQUFLLGFBQWFGLElBQUlFLEtBQUssS0FBSyxXQUFXO1lBQ3RESCxVQUFVSSxJQUFJLENBQUNILElBQUlJLFdBQVc7UUFDaEM7SUFDRjtJQUVBLE9BQU9MO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxTQUFTTSxtQkFBbUJDLFFBQVEsRUFBRUMsV0FBVyxNQUFNO0lBQ3JELE1BQU1DLGNBQWNoQyxHQUFHaUMsWUFBWSxDQUFDSCxVQUFVO1FBQUVDO0lBQVM7SUFDekQsTUFBTUcsTUFBTWhDLEtBQUtpQyxPQUFPLENBQUNMO0lBQ3pCLE1BQU1NLGFBQWE7SUFDbkIsTUFBTUMsYUFBYTtJQUNuQixNQUFNQyxPQUFPLEVBQUU7SUFDZixNQUFNQyxRQUFRLEVBQUU7SUFDaEIsSUFBSUMsZUFBZTtJQUVuQixPQUFRTjtRQUNOLEtBQUs7UUFDTCxLQUFLO1lBQ0hJLEtBQUtYLElBQUksQ0FBQ0s7WUFDVjtRQUVGLEtBQUs7WUFDSFEsZUFBZVIsWUFBWVMsS0FBSyxDQUFDSixlQUFlLEVBQUU7WUFDbEQsS0FBSyxNQUFNSyxVQUFVRixhQUFjO2dCQUNqQyxJQUFJRyxPQUFPRCxPQUFPRSxLQUFLLENBQUM7Z0JBQ3hCRCxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDO2dCQUNmQSxJQUFJLENBQUNBLEtBQUtFLE1BQU0sR0FBRyxFQUFFLEdBQUc7Z0JBQ3hCRixPQUFPQSxLQUFLRyxJQUFJLENBQUM7Z0JBQ2pCUCxNQUFNWixJQUFJLENBQUNnQjtZQUNiO1lBQ0E7UUFFRjtZQUFTO2dCQUNQSCxlQUFlUixZQUFZUyxLQUFLLENBQUNMLGVBQWUsRUFBRTtnQkFDbEQsS0FBSyxNQUFNTSxVQUFVRixhQUFjO29CQUNqQ0QsTUFBTVosSUFBSSxDQUFDZTtnQkFDYjtZQUNGO0lBQ0Y7SUFFQSxPQUFPO1FBQUVKO1FBQU1DO0lBQU07QUFDdkI7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU1EsbUJBQW1CdkIsR0FBRyxFQUFFQyxJQUFJO0lBQ25DLE1BQU1nQixRQUFRaEIsS0FBS3VCLElBQUksQ0FBQyxDQUFDQyxZQUFjekIsSUFBSTBCLElBQUksS0FBS0QsVUFBVUMsSUFBSTtJQUNsRSxJQUFJVCxPQUFPLE9BQU87SUFFbEIsT0FBTztBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNVLGVBQWVDLE9BQU8sRUFBRUMsaUJBQWlCO0lBQ2hELE1BQU1DLGVBQWVwRCxLQUFLcUQsT0FBTyxDQUFDSDtJQUNsQyxNQUFNSSxVQUFVdEQsS0FBS2lDLE9BQU8sQ0FBQ21CO0lBRTdCLDJCQUEyQjtJQUMzQixNQUFNRyxVQUFVLElBQU14RCw2RUFBUXFELFlBQVlBLENBQUNBO0lBQzNDLE1BQU1JLFdBQVcsSUFBTUMsS0FBS0MsS0FBSyxDQUFDUDtJQUNsQywyQkFBMkI7SUFDM0IsTUFBTVEsV0FBVyxJQUFNNUQsd0dBQXFCLENBQUNvRDtJQUU3QyxNQUFNUyxVQUFVO1FBQ2QsT0FBT0w7UUFDUCxRQUFRQTtRQUNSLFNBQVNDO1FBQ1QsUUFBUUc7UUFDUixTQUFTQTtJQUNYO0lBRUEsTUFBTUUsU0FBU0QsT0FBTyxDQUFDTixRQUFRO0lBRS9CLElBQUlPLFdBQVdDLFdBQVc7UUFDeEIsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUEsT0FBT0Y7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0csVUFBVUMsS0FBSyxFQUFFQyxNQUFNO0lBQzlCLE9BQU9oRSxVQUFVLENBQUMsR0FBRytELE9BQU9DLFFBQVEsQ0FBQ0MsR0FBR0MsSUFBT0EsTUFBTSxPQUFPRCxJQUFJTDtBQUNsRTtBQUVBTyx3QkFBd0IsR0FBR0w7QUFDM0JLLCtCQUErQixHQUFHbEU7QUFDbENrRSwrQkFBK0IsR0FBR3pEO0FBQ2xDeUQsbUNBQW1DLEdBQUdsRDtBQUN0Q2tELGlDQUFpQyxHQUFHMUM7QUFDcEMwQyxpQ0FBaUMsR0FBR3hCO0FBQ3BDd0IsNkJBQTZCLEdBQUdwQiIsInNvdXJjZXMiOlsid2VicGFjazovL25hbnRlcy1wdWJsaWMtZGF0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9zcmMvdXRpbHMuanM/YmU0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZ2xvYiA9IHJlcXVpcmUoJ2dsb2InKTtcbmNvbnN0IG1lcmdlV2l0aCA9IHJlcXVpcmUoJ2xvZGFzaC5tZXJnZXdpdGgnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBnbG9icyB0byBmdWxsIHBhdGhzXG4gKiBAcGFyYW0ge2FycmF5fSBnbG9icyAtIEFycmF5IG9mIGdsb2JzIGFuZC9vciBub3JtYWwgcGF0aHNcbiAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiBmdWxseS1xdWFsaWZpZWQgcGF0aHNcbiAqL1xuZnVuY3Rpb24gY29udmVydEdsb2JQYXRocyhnbG9icykge1xuICByZXR1cm4gZ2xvYnNcbiAgICAubWFwKChnbG9iU3RyaW5nKSA9PiBnbG9iLnN5bmMoZ2xvYlN0cmluZykpXG4gICAgLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHByZXZpb3VzLmNvbmNhdChjdXJyZW50KSwgW10pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGVyZSBpcyBhbnkgcHJvcGVydGllcyBvZiB0aGUgaW5wdXQgb2JqZWN0IHdoaWNoIGFyZSBhbiBlbXB0eSBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzRW1wdHlQcm9wZXJ0eShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAubWFwKChrZXkpID0+IG9ialtrZXldKVxuICAgIC5ldmVyeShcbiAgICAgIChrZXlPYmplY3QpID0+XG4gICAgICAgIHR5cGVvZiBrZXlPYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIE9iamVjdC5rZXlzKGtleU9iamVjdCkuZXZlcnkoKGtleSkgPT4gIShrZXkgaW4ga2V5T2JqZWN0KSlcbiAgICApO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBZQU1MIGRlc2NyaXB0aW9uIGZyb20gSlNEb2MgY29tbWVudHMgd2l0aCBgQHN3YWdnZXJgL2BAb3BlbmFwaWAgYW5ub3RhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBqc0RvY0NvbW1lbnQgLSBTaW5nbGUgaXRlbSBvZiBKU0RvYyBjb21tZW50cyBmcm9tIGRvY3RyaW5lLnBhcnNlXG4gKiBAcmV0dXJucyB7YXJyYXl9IFlBTUwgcGFydHNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFlhbWxGcm9tSnNEb2MoanNEb2NDb21tZW50KSB7XG4gIGNvbnN0IHlhbWxQYXJ0cyA9IFtdO1xuXG4gIGZvciAoY29uc3QgdGFnIG9mIGpzRG9jQ29tbWVudC50YWdzKSB7XG4gICAgaWYgKHRhZy50aXRsZSA9PT0gJ3N3YWdnZXInIHx8IHRhZy50aXRsZSA9PT0gJ29wZW5hcGknKSB7XG4gICAgICB5YW1sUGFydHMucHVzaCh0YWcuZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB5YW1sUGFydHM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVQYXRoXG4gKiBAcmV0dXJucyB7e2pzZG9jOiBhcnJheSwgeWFtbDogYXJyYXl9fSBKU0RvYyBjb21tZW50cyBhbmQgWWFtbCBmaWxlc1xuICovXG5mdW5jdGlvbiBleHRyYWN0QW5ub3RhdGlvbnMoZmlsZVBhdGgsIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIGNvbnN0IGZpbGVDb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCB7IGVuY29kaW5nIH0pO1xuICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUoZmlsZVBhdGgpO1xuICBjb25zdCBqc0RvY1JlZ2V4ID0gL1xcL1xcKlxcKihbXFxzXFxTXSo/KVxcKlxcLy9nbTtcbiAgY29uc3QgY3NEb2NSZWdleCA9IC8jIyMoW1xcc1xcU10qPykjIyMvZ207XG4gIGNvbnN0IHlhbWwgPSBbXTtcbiAgY29uc3QganNkb2MgPSBbXTtcbiAgbGV0IHJlZ2V4UmVzdWx0cyA9IG51bGw7XG5cbiAgc3dpdGNoIChleHQpIHtcbiAgICBjYXNlICcueW1sJzpcbiAgICBjYXNlICcueWFtbCc6XG4gICAgICB5YW1sLnB1c2goZmlsZUNvbnRlbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICcuY29mZmVlJzpcbiAgICAgIHJlZ2V4UmVzdWx0cyA9IGZpbGVDb250ZW50Lm1hdGNoKGNzRG9jUmVnZXgpIHx8IFtdO1xuICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVnZXhSZXN1bHRzKSB7XG4gICAgICAgIGxldCBwYXJ0ID0gcmVzdWx0LnNwbGl0KCcjIyMnKTtcbiAgICAgICAgcGFydFswXSA9IGAvKipgO1xuICAgICAgICBwYXJ0W3BhcnQubGVuZ3RoIC0gMV0gPSAnKi8nO1xuICAgICAgICBwYXJ0ID0gcGFydC5qb2luKCcnKTtcbiAgICAgICAganNkb2MucHVzaChwYXJ0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDoge1xuICAgICAgcmVnZXhSZXN1bHRzID0gZmlsZUNvbnRlbnQubWF0Y2goanNEb2NSZWdleCkgfHwgW107XG4gICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZWdleFJlc3VsdHMpIHtcbiAgICAgICAganNkb2MucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHlhbWwsIGpzZG9jIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHRhZ1xuICogQHBhcmFtIHthcnJheX0gdGFnc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVGFnUHJlc2VudEluVGFncyh0YWcsIHRhZ3MpIHtcbiAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbmQoKHRhcmdldFRhZykgPT4gdGFnLm5hbWUgPT09IHRhcmdldFRhZy5uYW1lKTtcbiAgaWYgKG1hdGNoKSByZXR1cm4gdHJ1ZTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCBvZiB0aGUgZGVmaW5pdGlvbiBmaWxlIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmUGF0aFxuICogQHBhcmFtIHtvYmplY3R9IHN3YWdnZXJEZWZpbml0aW9uXG4gKi9cbmZ1bmN0aW9uIGxvYWREZWZpbml0aW9uKGRlZlBhdGgsIHN3YWdnZXJEZWZpbml0aW9uKSB7XG4gIGNvbnN0IHJlc29sdmVkUGF0aCA9IHBhdGgucmVzb2x2ZShkZWZQYXRoKTtcbiAgY29uc3QgZXh0TmFtZSA9IHBhdGguZXh0bmFtZShyZXNvbHZlZFBhdGgpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBjb25zdCBsb2FkQ2pzID0gKCkgPT4gcmVxdWlyZShyZXNvbHZlZFBhdGgpO1xuICBjb25zdCBsb2FkSnNvbiA9ICgpID0+IEpTT04ucGFyc2Uoc3dhZ2dlckRlZmluaXRpb24pO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgY29uc3QgbG9hZFlhbWwgPSAoKSA9PiByZXF1aXJlKCd5YW1sJykucGFyc2Uoc3dhZ2dlckRlZmluaXRpb24pO1xuXG4gIGNvbnN0IExPQURFUlMgPSB7XG4gICAgJy5qcyc6IGxvYWRDanMsIC8vIG9uIHB1cnBvc2UsIHRvIGFsbG93IHRocm93aW5nIGJ5IG5vZGVqcyBhbmQgLmNqcyBzdWdnZXN0aW9uXG4gICAgJy5janMnOiBsb2FkQ2pzLFxuICAgICcuanNvbic6IGxvYWRKc29uLFxuICAgICcueW1sJzogbG9hZFlhbWwsXG4gICAgJy55YW1sJzogbG9hZFlhbWwsXG4gIH07XG5cbiAgY29uc3QgbG9hZGVyID0gTE9BREVSU1tleHROYW1lXTtcblxuICBpZiAobG9hZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmluaXRpb24gZmlsZSBzaG91bGQgYmUgLmNqcywgLmpzb24sIC55bWwgb3IgLnlhbWwnKTtcbiAgfVxuXG4gIHJldHVybiBsb2FkZXIoKTtcbn1cblxuLyoqXG4gKiBBIHJlY3Vyc2l2ZSBkZWVwLW1lcmdlIHRoYXQgaWdub3JlcyBudWxsIHZhbHVlcyB3aGVuIG1lcmdpbmcuXG4gKiBUaGlzIHJldHVybnMgdGhlIG1lcmdlZCBvYmplY3QgYW5kIGRvZXMgbm90IG11dGF0ZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBmaXJzdCB0aGUgZmlyc3Qgb2JqZWN0IHRvIGdldCBtZXJnZWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWNvbmQgdGhlIHNlY29uZCBvYmplY3QgdG8gZ2V0IG1lcmdlZFxuICovXG5mdW5jdGlvbiBtZXJnZURlZXAoZmlyc3QsIHNlY29uZCkge1xuICByZXR1cm4gbWVyZ2VXaXRoKHt9LCBmaXJzdCwgc2Vjb25kLCAoYSwgYikgPT4gKGIgPT09IG51bGwgPyBhIDogdW5kZWZpbmVkKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLm1lcmdlRGVlcCA9IG1lcmdlRGVlcDtcbm1vZHVsZS5leHBvcnRzLmNvbnZlcnRHbG9iUGF0aHMgPSBjb252ZXJ0R2xvYlBhdGhzO1xubW9kdWxlLmV4cG9ydHMuaGFzRW1wdHlQcm9wZXJ0eSA9IGhhc0VtcHR5UHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cy5leHRyYWN0WWFtbEZyb21Kc0RvYyA9IGV4dHJhY3RZYW1sRnJvbUpzRG9jO1xubW9kdWxlLmV4cG9ydHMuZXh0cmFjdEFubm90YXRpb25zID0gZXh0cmFjdEFubm90YXRpb25zO1xubW9kdWxlLmV4cG9ydHMuaXNUYWdQcmVzZW50SW5UYWdzID0gaXNUYWdQcmVzZW50SW5UYWdzO1xubW9kdWxlLmV4cG9ydHMubG9hZERlZmluaXRpb24gPSBsb2FkRGVmaW5pdGlvbjtcbiJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwiZ2xvYiIsIm1lcmdlV2l0aCIsImNvbnZlcnRHbG9iUGF0aHMiLCJnbG9icyIsIm1hcCIsImdsb2JTdHJpbmciLCJzeW5jIiwicmVkdWNlIiwicHJldmlvdXMiLCJjdXJyZW50IiwiY29uY2F0IiwiaGFzRW1wdHlQcm9wZXJ0eSIsIm9iaiIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJldmVyeSIsImtleU9iamVjdCIsImV4dHJhY3RZYW1sRnJvbUpzRG9jIiwianNEb2NDb21tZW50IiwieWFtbFBhcnRzIiwidGFnIiwidGFncyIsInRpdGxlIiwicHVzaCIsImRlc2NyaXB0aW9uIiwiZXh0cmFjdEFubm90YXRpb25zIiwiZmlsZVBhdGgiLCJlbmNvZGluZyIsImZpbGVDb250ZW50IiwicmVhZEZpbGVTeW5jIiwiZXh0IiwiZXh0bmFtZSIsImpzRG9jUmVnZXgiLCJjc0RvY1JlZ2V4IiwieWFtbCIsImpzZG9jIiwicmVnZXhSZXN1bHRzIiwibWF0Y2giLCJyZXN1bHQiLCJwYXJ0Iiwic3BsaXQiLCJsZW5ndGgiLCJqb2luIiwiaXNUYWdQcmVzZW50SW5UYWdzIiwiZmluZCIsInRhcmdldFRhZyIsIm5hbWUiLCJsb2FkRGVmaW5pdGlvbiIsImRlZlBhdGgiLCJzd2FnZ2VyRGVmaW5pdGlvbiIsInJlc29sdmVkUGF0aCIsInJlc29sdmUiLCJleHROYW1lIiwibG9hZENqcyIsImxvYWRKc29uIiwiSlNPTiIsInBhcnNlIiwibG9hZFlhbWwiLCJMT0FERVJTIiwibG9hZGVyIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJtZXJnZURlZXAiLCJmaXJzdCIsInNlY29uZCIsImEiLCJiIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/src/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/Document-f89a2614.js":
/*!********************************************************************************!*\
  !*** ./node_modules/swagger-jsdoc/node_modules/yaml/dist/Document-f89a2614.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar _rollupPluginBabelHelpers = __webpack_require__(/*! ./_rollupPluginBabelHelpers-eed30217.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/_rollupPluginBabelHelpers-eed30217.js\");\nvar parseCst = __webpack_require__(/*! ./parse-3997f544.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/parse-3997f544.js\");\nvar stringifyNumber = __webpack_require__(/*! ./stringifyNumber-dea1120c.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/stringifyNumber-dea1120c.js\");\nvar Schema = __webpack_require__(/*! ./Schema-807430ba.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/Schema-807430ba.js\");\nconst defaultOptions = {\n    anchorPrefix: \"a\",\n    customTags: null,\n    indent: 2,\n    indentSeq: true,\n    keepCstNodes: false,\n    keepNodeTypes: true,\n    keepUndefined: false,\n    mapAsMap: false,\n    maxAliasCount: 100,\n    prettyErrors: true,\n    simpleKeys: false,\n    version: \"1.2\"\n};\nconst scalarOptions = {\n    get binary () {\n        return stringifyNumber.binaryOptions;\n    },\n    set binary (opt){\n        Object.assign(stringifyNumber.binaryOptions, opt);\n    },\n    get bool () {\n        return stringifyNumber.boolOptions;\n    },\n    set bool (opt){\n        Object.assign(stringifyNumber.boolOptions, opt);\n    },\n    get int () {\n        return stringifyNumber.intOptions;\n    },\n    set int (opt){\n        Object.assign(stringifyNumber.intOptions, opt);\n    },\n    get null () {\n        return stringifyNumber.nullOptions;\n    },\n    set null (opt){\n        Object.assign(stringifyNumber.nullOptions, opt);\n    },\n    get str () {\n        return stringifyNumber.strOptions;\n    },\n    set str (opt){\n        Object.assign(stringifyNumber.strOptions, opt);\n    }\n};\nconst documentOptions = {\n    \"1.0\": {\n        schema: \"yaml-1.1\",\n        merge: true,\n        tagPrefixes: [\n            {\n                handle: \"!\",\n                prefix: _rollupPluginBabelHelpers.defaultTagPrefix\n            },\n            {\n                handle: \"!!\",\n                prefix: \"tag:private.yaml.org,2002:\"\n            }\n        ]\n    },\n    \"1.1\": {\n        schema: \"yaml-1.1\",\n        merge: true,\n        tagPrefixes: [\n            {\n                handle: \"!\",\n                prefix: \"!\"\n            },\n            {\n                handle: \"!!\",\n                prefix: _rollupPluginBabelHelpers.defaultTagPrefix\n            }\n        ]\n    },\n    \"1.2\": {\n        schema: \"core\",\n        merge: false,\n        resolveKnownTags: true,\n        tagPrefixes: [\n            {\n                handle: \"!\",\n                prefix: \"!\"\n            },\n            {\n                handle: \"!!\",\n                prefix: _rollupPluginBabelHelpers.defaultTagPrefix\n            }\n        ]\n    }\n};\nfunction stringifyTag(doc, tag) {\n    if ((doc.version || doc.options.version) === \"1.0\") {\n        const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n        if (priv) return \"!\" + priv[1];\n        const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n        return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, \"\")}`;\n    }\n    let p = doc.tagPrefixes.find((p)=>tag.indexOf(p.prefix) === 0);\n    if (!p) {\n        const dtp = doc.getDefaults().tagPrefixes;\n        p = dtp && dtp.find((p)=>tag.indexOf(p.prefix) === 0);\n    }\n    if (!p) return tag[0] === \"!\" ? tag : `!<${tag}>`;\n    const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, (ch)=>({\n            \"!\": \"%21\",\n            \",\": \"%2C\",\n            \"[\": \"%5B\",\n            \"]\": \"%5D\",\n            \"{\": \"%7B\",\n            \"}\": \"%7D\"\n        })[ch]);\n    return p.handle + suffix;\n}\nfunction getTagObject(tags, item) {\n    if (item instanceof stringifyNumber.Alias) return stringifyNumber.Alias;\n    if (item.tag) {\n        const match = tags.filter((t)=>t.tag === item.tag);\n        if (match.length > 0) return match.find((t)=>t.format === item.format) || match[0];\n    }\n    let tagObj, obj;\n    if (item instanceof stringifyNumber.Scalar) {\n        obj = item.value;\n        const match = tags.filter((t)=>t.identify && t.identify(obj));\n        tagObj = match.find((t)=>t.format === item.format) || match.find((t)=>!t.format);\n    } else {\n        obj = item;\n        tagObj = tags.find((t)=>t.nodeClass && obj instanceof t.nodeClass);\n    }\n    if (!tagObj) {\n        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n        throw new Error(`Tag not resolved for ${name} value`);\n    }\n    return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\nfunction stringifyProps(node, tagObj, { anchors, doc }) {\n    const props = [];\n    const anchor = doc.anchors.getName(node);\n    if (anchor) {\n        anchors[anchor] = node;\n        props.push(`&${anchor}`);\n    }\n    if (node.tag) {\n        props.push(stringifyTag(doc, node.tag));\n    } else if (!tagObj.default) {\n        props.push(stringifyTag(doc, tagObj.tag));\n    }\n    return props.join(\" \");\n}\nfunction stringify(item, ctx, onComment, onChompKeep) {\n    const { schema } = ctx.doc;\n    let tagObj;\n    if (!(item instanceof stringifyNumber.Node)) {\n        item = ctx.doc.createNode(item, {\n            onTagObj: (o)=>tagObj = o,\n            wrapScalars: true\n        });\n    }\n    if (item instanceof stringifyNumber.Pair) return item.toString(ctx, onComment, onChompKeep);\n    if (!tagObj) tagObj = getTagObject(schema.tags, item);\n    const props = stringifyProps(item, tagObj, ctx);\n    if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n    const str = typeof tagObj.stringify === \"function\" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof stringifyNumber.Scalar ? stringifyNumber.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n    if (!props) return str;\n    return item instanceof stringifyNumber.Scalar || str[0] === \"{\" || str[0] === \"[\" ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\nclass Anchors {\n    static validAnchorNode(node) {\n        return node instanceof stringifyNumber.Scalar || node instanceof stringifyNumber.YAMLSeq || node instanceof stringifyNumber.YAMLMap;\n    }\n    constructor(prefix){\n        _rollupPluginBabelHelpers._defineProperty(this, \"map\", Object.create(null));\n        this.prefix = prefix;\n    }\n    createAlias(node, name) {\n        this.setAnchor(node, name);\n        return new stringifyNumber.Alias(node);\n    }\n    createMergePair(...sources) {\n        const merge = new Schema.Merge();\n        merge.value.items = sources.map((s)=>{\n            if (s instanceof stringifyNumber.Alias) {\n                if (s.source instanceof stringifyNumber.YAMLMap) return s;\n            } else if (s instanceof stringifyNumber.YAMLMap) {\n                return this.createAlias(s);\n            }\n            throw new Error(\"Merge sources must be Map nodes or their Aliases\");\n        });\n        return merge;\n    }\n    getName(node) {\n        const { map } = this;\n        return Object.keys(map).find((a)=>map[a] === node);\n    }\n    getNames() {\n        return Object.keys(this.map);\n    }\n    getNode(name) {\n        return this.map[name];\n    }\n    newName(prefix) {\n        if (!prefix) prefix = this.prefix;\n        const names = Object.keys(this.map);\n        for(let i = 1; true; ++i){\n            const name = `${prefix}${i}`;\n            if (!names.includes(name)) return name;\n        }\n    }\n    resolveNodes() {\n        const { map, _cstAliases } = this;\n        Object.keys(map).forEach((a)=>{\n            map[a] = map[a].resolved;\n        });\n        _cstAliases.forEach((a)=>{\n            a.source = a.source.resolved;\n        });\n        delete this._cstAliases;\n    }\n    setAnchor(node, name) {\n        if (node != null && !Anchors.validAnchorNode(node)) {\n            throw new Error(\"Anchors may only be set for Scalar, Seq and Map nodes\");\n        }\n        if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n            throw new Error(\"Anchor names must not contain whitespace or control characters\");\n        }\n        const { map } = this;\n        const prev = node && Object.keys(map).find((a)=>map[a] === node);\n        if (prev) {\n            if (!name) {\n                return prev;\n            } else if (prev !== name) {\n                delete map[prev];\n                map[name] = node;\n            }\n        } else {\n            if (!name) {\n                if (!node) return null;\n                name = this.newName();\n            }\n            map[name] = node;\n        }\n        return name;\n    }\n}\n/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */ function applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === \"object\") {\n        if (Array.isArray(val)) {\n            for(let i = 0, len = val.length; i < len; ++i){\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                if (v1 === undefined) delete val[i];\n                else if (v1 !== v0) val[i] = v1;\n            }\n        } else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())){\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined) val.delete(k);\n                else if (v1 !== v0) val.set(k, v1);\n            }\n        } else if (val instanceof Set) {\n            for (const v0 of Array.from(val)){\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined) val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        } else {\n            for (const [k, v0] of Object.entries(val)){\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined) delete val[k];\n                else if (v1 !== v0) val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\nconst visit = (node, tags)=>{\n    if (node && typeof node === \"object\") {\n        const { tag } = node;\n        if (node instanceof stringifyNumber.Collection) {\n            if (tag) tags[tag] = true;\n            node.items.forEach((n)=>visit(n, tags));\n        } else if (node instanceof stringifyNumber.Pair) {\n            visit(node.key, tags);\n            visit(node.value, tags);\n        } else if (node instanceof stringifyNumber.Scalar) {\n            if (tag) tags[tag] = true;\n        }\n    }\n    return tags;\n};\nconst listTagNames = (node)=>Object.keys(visit(node, {}));\nfunction resolveTagHandle(doc, node) {\n    const { handle, suffix } = node.tag;\n    let prefix = doc.tagPrefixes.find((p)=>p.handle === handle);\n    if (!prefix) {\n        const dtp = doc.getDefaults().tagPrefixes;\n        if (dtp) prefix = dtp.find((p)=>p.handle === handle);\n        if (!prefix) throw new _rollupPluginBabelHelpers.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n    }\n    if (!suffix) throw new _rollupPluginBabelHelpers.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n    if (handle === \"!\" && (doc.version || doc.options.version) === \"1.0\") {\n        if (suffix[0] === \"^\") {\n            doc.warnings.push(new _rollupPluginBabelHelpers.YAMLWarning(node, \"YAML 1.0 ^ tag expansion is not supported\"));\n            return suffix;\n        }\n        if (/[:/]/.test(suffix)) {\n            // word/foo -> tag:word.yaml.org,2002:foo\n            const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n            return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n        }\n    }\n    return prefix.prefix + decodeURIComponent(suffix);\n}\nfunction resolveTagName(doc, node) {\n    const { tag, type } = node;\n    let nonSpecific = false;\n    if (tag) {\n        const { handle, suffix, verbatim } = tag;\n        if (verbatim) {\n            if (verbatim !== \"!\" && verbatim !== \"!!\") return verbatim;\n            const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n            doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(node, msg));\n        } else if (handle === \"!\" && !suffix) {\n            nonSpecific = true;\n        } else {\n            try {\n                return resolveTagHandle(doc, node);\n            } catch (error) {\n                doc.errors.push(error);\n            }\n        }\n    }\n    switch(type){\n        case _rollupPluginBabelHelpers.Type.BLOCK_FOLDED:\n        case _rollupPluginBabelHelpers.Type.BLOCK_LITERAL:\n        case _rollupPluginBabelHelpers.Type.QUOTE_DOUBLE:\n        case _rollupPluginBabelHelpers.Type.QUOTE_SINGLE:\n            return _rollupPluginBabelHelpers.defaultTags.STR;\n        case _rollupPluginBabelHelpers.Type.FLOW_MAP:\n        case _rollupPluginBabelHelpers.Type.MAP:\n            return _rollupPluginBabelHelpers.defaultTags.MAP;\n        case _rollupPluginBabelHelpers.Type.FLOW_SEQ:\n        case _rollupPluginBabelHelpers.Type.SEQ:\n            return _rollupPluginBabelHelpers.defaultTags.SEQ;\n        case _rollupPluginBabelHelpers.Type.PLAIN:\n            return nonSpecific ? _rollupPluginBabelHelpers.defaultTags.STR : null;\n        default:\n            return null;\n    }\n}\nfunction checkFlowCollectionEnd(errors, cst) {\n    let char, name;\n    switch(cst.type){\n        case _rollupPluginBabelHelpers.Type.FLOW_MAP:\n            char = \"}\";\n            name = \"flow map\";\n            break;\n        case _rollupPluginBabelHelpers.Type.FLOW_SEQ:\n            char = \"]\";\n            name = \"flow sequence\";\n            break;\n        default:\n            errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(cst, \"Not a flow collection!?\"));\n            return;\n    }\n    let lastItem;\n    for(let i = cst.items.length - 1; i >= 0; --i){\n        const item = cst.items[i];\n        if (!item || item.type !== _rollupPluginBabelHelpers.Type.COMMENT) {\n            lastItem = item;\n            break;\n        }\n    }\n    if (lastItem && lastItem.char !== char) {\n        const msg = `Expected ${name} to end with ${char}`;\n        let err;\n        if (typeof lastItem.offset === \"number\") {\n            err = new _rollupPluginBabelHelpers.YAMLSemanticError(cst, msg);\n            err.offset = lastItem.offset + 1;\n        } else {\n            err = new _rollupPluginBabelHelpers.YAMLSemanticError(lastItem, msg);\n            if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n        }\n        errors.push(err);\n    }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n    const prev = comment.context.src[comment.range.start - 1];\n    if (prev !== \"\\n\" && prev !== \"\t\" && prev !== \" \") {\n        const msg = \"Comments must be separated from other tokens by white space characters\";\n        errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(comment, msg));\n    }\n}\nfunction getLongKeyError(source, key) {\n    const sk = String(key);\n    const k = sk.substr(0, 8) + \"...\" + sk.substr(-8);\n    return new _rollupPluginBabelHelpers.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\nfunction resolveComments(collection, comments) {\n    for (const { afterKey, before, comment } of comments){\n        let item = collection.items[before];\n        if (!item) {\n            if (comment !== undefined) {\n                if (collection.comment) collection.comment += \"\\n\" + comment;\n                else collection.comment = comment;\n            }\n        } else {\n            if (afterKey && item.value) item = item.value;\n            if (comment === undefined) {\n                if (afterKey || !item.commentBefore) item.spaceBefore = true;\n            } else {\n                if (item.commentBefore) item.commentBefore += \"\\n\" + comment;\n                else item.commentBefore = comment;\n            }\n        }\n    }\n}\nfunction resolveMap(doc, cst) {\n    const { comments, items } = cst.type === _rollupPluginBabelHelpers.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n    const map = new stringifyNumber.YAMLMap(doc.schema);\n    map.items = items;\n    resolveComments(map, comments);\n    let hasCollectionKey = false;\n    for(let i = 0; i < items.length; ++i){\n        const { key: iKey } = items[i];\n        if (iKey instanceof stringifyNumber.Collection) hasCollectionKey = true;\n        if (doc.schema.merge && iKey && iKey.value === Schema.MERGE_KEY) {\n            items[i] = new Schema.Merge(items[i]);\n            const sources = items[i].value.items;\n            let error = null;\n            sources.some((node)=>{\n                if (node instanceof stringifyNumber.Alias) {\n                    // During parsing, alias sources are CST nodes; to account for\n                    // circular references their resolved values can't be used here.\n                    const { type } = node.source;\n                    if (type === _rollupPluginBabelHelpers.Type.MAP || type === _rollupPluginBabelHelpers.Type.FLOW_MAP) return false;\n                    return error = \"Merge nodes aliases can only point to maps\";\n                }\n                return error = \"Merge nodes can only have Alias nodes as values\";\n            });\n            if (error) doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(cst, error));\n        } else {\n            for(let j = i + 1; j < items.length; ++j){\n                const { key: jKey } = items[j];\n                if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, \"value\") && iKey.value === jKey.value) {\n                    const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n                    doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(cst, msg));\n                    break;\n                }\n            }\n        }\n    }\n    if (hasCollectionKey && !doc.options.mapAsMap) {\n        const warn = \"Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.\";\n        doc.warnings.push(new _rollupPluginBabelHelpers.YAMLWarning(cst, warn));\n    }\n    cst.resolved = map;\n    return map;\n}\nconst valueHasPairComment = ({ context: { lineStart, node, src }, props })=>{\n    if (props.length === 0) return false;\n    const { start } = props[0];\n    if (node && start > node.valueRange.start) return false;\n    if (src[start] !== _rollupPluginBabelHelpers.Char.COMMENT) return false;\n    for(let i = lineStart; i < start; ++i)if (src[i] === \"\\n\") return false;\n    return true;\n};\nfunction resolvePairComment(item, pair) {\n    if (!valueHasPairComment(item)) return;\n    const comment = item.getPropValue(0, _rollupPluginBabelHelpers.Char.COMMENT, true);\n    let found = false;\n    const cb = pair.value.commentBefore;\n    if (cb && cb.startsWith(comment)) {\n        pair.value.commentBefore = cb.substr(comment.length + 1);\n        found = true;\n    } else {\n        const cc = pair.value.comment;\n        if (!item.node && cc && cc.startsWith(comment)) {\n            pair.value.comment = cc.substr(comment.length + 1);\n            found = true;\n        }\n    }\n    if (found) pair.comment = comment;\n}\nfunction resolveBlockMapItems(doc, cst) {\n    const comments = [];\n    const items = [];\n    let key = undefined;\n    let keyStart = null;\n    for(let i = 0; i < cst.items.length; ++i){\n        const item = cst.items[i];\n        switch(item.type){\n            case _rollupPluginBabelHelpers.Type.BLANK_LINE:\n                comments.push({\n                    afterKey: !!key,\n                    before: items.length\n                });\n                break;\n            case _rollupPluginBabelHelpers.Type.COMMENT:\n                comments.push({\n                    afterKey: !!key,\n                    before: items.length,\n                    comment: item.comment\n                });\n                break;\n            case _rollupPluginBabelHelpers.Type.MAP_KEY:\n                if (key !== undefined) items.push(new stringifyNumber.Pair(key));\n                if (item.error) doc.errors.push(item.error);\n                key = resolveNode(doc, item.node);\n                keyStart = null;\n                break;\n            case _rollupPluginBabelHelpers.Type.MAP_VALUE:\n                {\n                    if (key === undefined) key = null;\n                    if (item.error) doc.errors.push(item.error);\n                    if (!item.context.atLineStart && item.node && item.node.type === _rollupPluginBabelHelpers.Type.MAP && !item.node.context.atLineStart) {\n                        const msg = \"Nested mappings are not allowed in compact mappings\";\n                        doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(item.node, msg));\n                    }\n                    let valueNode = item.node;\n                    if (!valueNode && item.props.length > 0) {\n                        // Comments on an empty mapping value need to be preserved, so we\n                        // need to construct a minimal empty node here to use instead of the\n                        // missing `item.node`. -- eemeli/yaml#19\n                        valueNode = new parseCst.PlainValue(_rollupPluginBabelHelpers.Type.PLAIN, []);\n                        valueNode.context = {\n                            parent: item,\n                            src: item.context.src\n                        };\n                        const pos = item.range.start + 1;\n                        valueNode.range = {\n                            start: pos,\n                            end: pos\n                        };\n                        valueNode.valueRange = {\n                            start: pos,\n                            end: pos\n                        };\n                        if (typeof item.range.origStart === \"number\") {\n                            const origPos = item.range.origStart + 1;\n                            valueNode.range.origStart = valueNode.range.origEnd = origPos;\n                            valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n                        }\n                    }\n                    const pair = new stringifyNumber.Pair(key, resolveNode(doc, valueNode));\n                    resolvePairComment(item, pair);\n                    items.push(pair);\n                    if (key && typeof keyStart === \"number\") {\n                        if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n                    }\n                    key = undefined;\n                    keyStart = null;\n                }\n                break;\n            default:\n                if (key !== undefined) items.push(new stringifyNumber.Pair(key));\n                key = resolveNode(doc, item);\n                keyStart = item.range.start;\n                if (item.error) doc.errors.push(item.error);\n                next: for(let j = i + 1;; ++j){\n                    const nextItem = cst.items[j];\n                    switch(nextItem && nextItem.type){\n                        case _rollupPluginBabelHelpers.Type.BLANK_LINE:\n                        case _rollupPluginBabelHelpers.Type.COMMENT:\n                            continue next;\n                        case _rollupPluginBabelHelpers.Type.MAP_VALUE:\n                            break next;\n                        default:\n                            {\n                                const msg = \"Implicit map keys need to be followed by map values\";\n                                doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(item, msg));\n                                break next;\n                            }\n                    }\n                }\n                if (item.valueRangeContainsNewline) {\n                    const msg = \"Implicit map keys need to be on a single line\";\n                    doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(item, msg));\n                }\n        }\n    }\n    if (key !== undefined) items.push(new stringifyNumber.Pair(key));\n    return {\n        comments,\n        items\n    };\n}\nfunction resolveFlowMapItems(doc, cst) {\n    const comments = [];\n    const items = [];\n    let key = undefined;\n    let explicitKey = false;\n    let next = \"{\";\n    for(let i = 0; i < cst.items.length; ++i){\n        const item = cst.items[i];\n        if (typeof item.char === \"string\") {\n            const { char, offset } = item;\n            if (char === \"?\" && key === undefined && !explicitKey) {\n                explicitKey = true;\n                next = \":\";\n                continue;\n            }\n            if (char === \":\") {\n                if (key === undefined) key = null;\n                if (next === \":\") {\n                    next = \",\";\n                    continue;\n                }\n            } else {\n                if (explicitKey) {\n                    if (key === undefined && char !== \",\") key = null;\n                    explicitKey = false;\n                }\n                if (key !== undefined) {\n                    items.push(new stringifyNumber.Pair(key));\n                    key = undefined;\n                    if (char === \",\") {\n                        next = \":\";\n                        continue;\n                    }\n                }\n            }\n            if (char === \"}\") {\n                if (i === cst.items.length - 1) continue;\n            } else if (char === next) {\n                next = \":\";\n                continue;\n            }\n            const msg = `Flow map contains an unexpected ${char}`;\n            const err = new _rollupPluginBabelHelpers.YAMLSyntaxError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n        } else if (item.type === _rollupPluginBabelHelpers.Type.BLANK_LINE) {\n            comments.push({\n                afterKey: !!key,\n                before: items.length\n            });\n        } else if (item.type === _rollupPluginBabelHelpers.Type.COMMENT) {\n            checkFlowCommentSpace(doc.errors, item);\n            comments.push({\n                afterKey: !!key,\n                before: items.length,\n                comment: item.comment\n            });\n        } else if (key === undefined) {\n            if (next === \",\") doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(item, \"Separator , missing in flow map\"));\n            key = resolveNode(doc, item);\n        } else {\n            if (next !== \",\") doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(item, \"Indicator : missing in flow map entry\"));\n            items.push(new stringifyNumber.Pair(key, resolveNode(doc, item)));\n            key = undefined;\n            explicitKey = false;\n        }\n    }\n    checkFlowCollectionEnd(doc.errors, cst);\n    if (key !== undefined) items.push(new stringifyNumber.Pair(key));\n    return {\n        comments,\n        items\n    };\n}\nfunction resolveSeq(doc, cst) {\n    const { comments, items } = cst.type === _rollupPluginBabelHelpers.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n    const seq = new stringifyNumber.YAMLSeq(doc.schema);\n    seq.items = items;\n    resolveComments(seq, comments);\n    if (!doc.options.mapAsMap && items.some((it)=>it instanceof stringifyNumber.Pair && it.key instanceof stringifyNumber.Collection)) {\n        const warn = \"Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.\";\n        doc.warnings.push(new _rollupPluginBabelHelpers.YAMLWarning(cst, warn));\n    }\n    cst.resolved = seq;\n    return seq;\n}\nfunction resolveBlockSeqItems(doc, cst) {\n    const comments = [];\n    const items = [];\n    for(let i = 0; i < cst.items.length; ++i){\n        const item = cst.items[i];\n        switch(item.type){\n            case _rollupPluginBabelHelpers.Type.BLANK_LINE:\n                comments.push({\n                    before: items.length\n                });\n                break;\n            case _rollupPluginBabelHelpers.Type.COMMENT:\n                comments.push({\n                    comment: item.comment,\n                    before: items.length\n                });\n                break;\n            case _rollupPluginBabelHelpers.Type.SEQ_ITEM:\n                if (item.error) doc.errors.push(item.error);\n                items.push(resolveNode(doc, item.node));\n                if (item.hasProps) {\n                    const msg = \"Sequence items cannot have tags or anchors before the - indicator\";\n                    doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(item, msg));\n                }\n                break;\n            default:\n                if (item.error) doc.errors.push(item.error);\n                doc.errors.push(new _rollupPluginBabelHelpers.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n        }\n    }\n    return {\n        comments,\n        items\n    };\n}\nfunction resolveFlowSeqItems(doc, cst) {\n    const comments = [];\n    const items = [];\n    let explicitKey = false;\n    let key = undefined;\n    let keyStart = null;\n    let next = \"[\";\n    let prevItem = null;\n    for(let i = 0; i < cst.items.length; ++i){\n        const item = cst.items[i];\n        if (typeof item.char === \"string\") {\n            const { char, offset } = item;\n            if (char !== \":\" && (explicitKey || key !== undefined)) {\n                if (explicitKey && key === undefined) key = next ? items.pop() : null;\n                items.push(new stringifyNumber.Pair(key));\n                explicitKey = false;\n                key = undefined;\n                keyStart = null;\n            }\n            if (char === next) {\n                next = null;\n            } else if (!next && char === \"?\") {\n                explicitKey = true;\n            } else if (next !== \"[\" && char === \":\" && key === undefined) {\n                if (next === \",\") {\n                    key = items.pop();\n                    if (key instanceof stringifyNumber.Pair) {\n                        const msg = \"Chaining flow sequence pairs is invalid\";\n                        const err = new _rollupPluginBabelHelpers.YAMLSemanticError(cst, msg);\n                        err.offset = offset;\n                        doc.errors.push(err);\n                    }\n                    if (!explicitKey && typeof keyStart === \"number\") {\n                        const keyEnd = item.range ? item.range.start : item.offset;\n                        if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n                        const { src } = prevItem.context;\n                        for(let i = keyStart; i < keyEnd; ++i)if (src[i] === \"\\n\") {\n                            const msg = \"Implicit keys of flow sequence pairs need to be on a single line\";\n                            doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(prevItem, msg));\n                            break;\n                        }\n                    }\n                } else {\n                    key = null;\n                }\n                keyStart = null;\n                explicitKey = false;\n                next = null;\n            } else if (next === \"[\" || char !== \"]\" || i < cst.items.length - 1) {\n                const msg = `Flow sequence contains an unexpected ${char}`;\n                const err = new _rollupPluginBabelHelpers.YAMLSyntaxError(cst, msg);\n                err.offset = offset;\n                doc.errors.push(err);\n            }\n        } else if (item.type === _rollupPluginBabelHelpers.Type.BLANK_LINE) {\n            comments.push({\n                before: items.length\n            });\n        } else if (item.type === _rollupPluginBabelHelpers.Type.COMMENT) {\n            checkFlowCommentSpace(doc.errors, item);\n            comments.push({\n                comment: item.comment,\n                before: items.length\n            });\n        } else {\n            if (next) {\n                const msg = `Expected a ${next} in flow sequence`;\n                doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(item, msg));\n            }\n            const value = resolveNode(doc, item);\n            if (key === undefined) {\n                items.push(value);\n                prevItem = item;\n            } else {\n                items.push(new stringifyNumber.Pair(key, value));\n                key = undefined;\n            }\n            keyStart = item.range.start;\n            next = \",\";\n        }\n    }\n    checkFlowCollectionEnd(doc.errors, cst);\n    if (key !== undefined) items.push(new stringifyNumber.Pair(key));\n    return {\n        comments,\n        items\n    };\n}\nfunction resolveByTagName({ knownTags, tags }, tagName, value, onError) {\n    const matchWithTest = [];\n    for (const tag of tags){\n        if (tag.tag === tagName) {\n            if (tag.test) {\n                if (typeof value === \"string\") matchWithTest.push(tag);\n                else onError(`The tag ${tagName} cannot be applied to a collection`);\n            } else {\n                const res = tag.resolve(value, onError);\n                return res instanceof stringifyNumber.Collection ? res : new stringifyNumber.Scalar(res);\n            }\n        }\n    }\n    if (matchWithTest.length > 0) return stringifyNumber.resolveScalar(value, matchWithTest);\n    const kt = knownTags[tagName];\n    if (kt) {\n        tags.push(Object.assign({}, kt, {\n            default: false,\n            test: undefined\n        }));\n        const res = kt.resolve(value, onError);\n        return res instanceof stringifyNumber.Collection ? res : new stringifyNumber.Scalar(res);\n    }\n    return null;\n}\nfunction resolveTag(doc, node, tagName) {\n    const { MAP, SEQ, STR } = _rollupPluginBabelHelpers.defaultTags;\n    let value, fallback;\n    const onError = (message)=>doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(node, message));\n    try {\n        switch(node.type){\n            case _rollupPluginBabelHelpers.Type.FLOW_MAP:\n            case _rollupPluginBabelHelpers.Type.MAP:\n                value = resolveMap(doc, node);\n                fallback = MAP;\n                if (tagName === SEQ || tagName === STR) onError(`The tag ${tagName} cannot be applied to a mapping`);\n                break;\n            case _rollupPluginBabelHelpers.Type.FLOW_SEQ:\n            case _rollupPluginBabelHelpers.Type.SEQ:\n                value = resolveSeq(doc, node);\n                fallback = SEQ;\n                if (tagName === MAP || tagName === STR) onError(`The tag ${tagName} cannot be applied to a sequence`);\n                break;\n            default:\n                value = node.strValue || \"\";\n                if (typeof value !== \"string\") {\n                    value.errors.forEach((error)=>doc.errors.push(error));\n                    value = value.str;\n                }\n                if (tagName === MAP || tagName === SEQ) onError(`The tag ${tagName} cannot be applied to a scalar`);\n                fallback = STR;\n        }\n        const res = resolveByTagName(doc.schema, tagName, value, onError);\n        if (res) {\n            if (tagName && node.tag) res.tag = tagName;\n            return res;\n        }\n    } catch (error) {\n        /* istanbul ignore if */ if (!error.source) error.source = node;\n        doc.errors.push(error);\n        return null;\n    }\n    try {\n        if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n        const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n        doc.warnings.push(new _rollupPluginBabelHelpers.YAMLWarning(node, msg));\n        const res = resolveByTagName(doc.schema, fallback, value, onError);\n        res.tag = tagName;\n        return res;\n    } catch (error) {\n        const refError = new _rollupPluginBabelHelpers.YAMLReferenceError(node, error.message);\n        refError.stack = error.stack;\n        doc.errors.push(refError);\n        return null;\n    }\n}\nconst isCollectionItem = (node)=>{\n    if (!node) return false;\n    const { type } = node;\n    return type === _rollupPluginBabelHelpers.Type.MAP_KEY || type === _rollupPluginBabelHelpers.Type.MAP_VALUE || type === _rollupPluginBabelHelpers.Type.SEQ_ITEM;\n};\nfunction resolveNodeProps(errors, node) {\n    const comments = {\n        before: [],\n        after: []\n    };\n    let hasAnchor = false;\n    let hasTag = false;\n    const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n    for (const { start, end } of props){\n        switch(node.context.src[start]){\n            case _rollupPluginBabelHelpers.Char.COMMENT:\n                {\n                    if (!node.commentHasRequiredWhitespace(start)) {\n                        const msg = \"Comments must be separated from other tokens by white space characters\";\n                        errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(node, msg));\n                    }\n                    const { header, valueRange } = node;\n                    const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n                    cc.push(node.context.src.slice(start + 1, end));\n                    break;\n                }\n            // Actual anchor & tag resolution is handled by schema, here we just complain\n            case _rollupPluginBabelHelpers.Char.ANCHOR:\n                if (hasAnchor) {\n                    const msg = \"A node can have at most one anchor\";\n                    errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(node, msg));\n                }\n                hasAnchor = true;\n                break;\n            case _rollupPluginBabelHelpers.Char.TAG:\n                if (hasTag) {\n                    const msg = \"A node can have at most one tag\";\n                    errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(node, msg));\n                }\n                hasTag = true;\n                break;\n        }\n    }\n    return {\n        comments,\n        hasAnchor,\n        hasTag\n    };\n}\nfunction resolveNodeValue(doc, node) {\n    const { anchors, errors, schema } = doc;\n    if (node.type === _rollupPluginBabelHelpers.Type.ALIAS) {\n        const name = node.rawValue;\n        const src = anchors.getNode(name);\n        if (!src) {\n            const msg = `Aliased anchor not found: ${name}`;\n            errors.push(new _rollupPluginBabelHelpers.YAMLReferenceError(node, msg));\n            return null;\n        } // Lazy resolution for circular references\n        const res = new stringifyNumber.Alias(src);\n        anchors._cstAliases.push(res);\n        return res;\n    }\n    const tagName = resolveTagName(doc, node);\n    if (tagName) return resolveTag(doc, node, tagName);\n    if (node.type !== _rollupPluginBabelHelpers.Type.PLAIN) {\n        const msg = `Failed to resolve ${node.type} node here`;\n        errors.push(new _rollupPluginBabelHelpers.YAMLSyntaxError(node, msg));\n        return null;\n    }\n    try {\n        let str = node.strValue || \"\";\n        if (typeof str !== \"string\") {\n            str.errors.forEach((error)=>doc.errors.push(error));\n            str = str.str;\n        }\n        return stringifyNumber.resolveScalar(str, schema.tags);\n    } catch (error) {\n        if (!error.source) error.source = node;\n        errors.push(error);\n        return null;\n    }\n} // sets node.resolved on success\nfunction resolveNode(doc, node) {\n    if (!node) return null;\n    if (node.error) doc.errors.push(node.error);\n    const { comments, hasAnchor, hasTag } = resolveNodeProps(doc.errors, node);\n    if (hasAnchor) {\n        const { anchors } = doc;\n        const name = node.anchor;\n        const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n        // name have already been resolved, so it may safely be renamed.\n        if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n        // anchors need to be available during resolution to allow for\n        // circular references.\n        anchors.map[name] = node;\n    }\n    if (node.type === _rollupPluginBabelHelpers.Type.ALIAS && (hasAnchor || hasTag)) {\n        const msg = \"An alias node must not specify any properties\";\n        doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(node, msg));\n    }\n    const res = resolveNodeValue(doc, node);\n    if (res) {\n        res.range = [\n            node.range.start,\n            node.range.end\n        ];\n        if (doc.options.keepCstNodes) res.cstNode = node;\n        if (doc.options.keepNodeTypes) res.type = node.type;\n        const cb = comments.before.join(\"\\n\");\n        if (cb) {\n            res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n        }\n        const ca = comments.after.join(\"\\n\");\n        if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n    }\n    return node.resolved = res;\n}\nfunction parseContents(doc, contents) {\n    const comments = {\n        before: [],\n        after: []\n    };\n    let body = undefined;\n    let spaceBefore = false;\n    for (const node of contents){\n        if (node.valueRange) {\n            if (body !== undefined) {\n                const msg = \"Document contains trailing content not separated by a ... or --- line\";\n                doc.errors.push(new _rollupPluginBabelHelpers.YAMLSyntaxError(node, msg));\n                break;\n            }\n            const res = resolveNode(doc, node);\n            if (spaceBefore) {\n                res.spaceBefore = true;\n                spaceBefore = false;\n            }\n            body = res;\n        } else if (node.comment !== null) {\n            const cc = body === undefined ? comments.before : comments.after;\n            cc.push(node.comment);\n        } else if (node.type === _rollupPluginBabelHelpers.Type.BLANK_LINE) {\n            spaceBefore = true;\n            if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n                // space-separated comments at start are parsed as document comments\n                doc.commentBefore = comments.before.join(\"\\n\");\n                comments.before = [];\n            }\n        }\n    }\n    doc.contents = body || null;\n    if (!body) {\n        doc.comment = comments.before.concat(comments.after).join(\"\\n\") || null;\n    } else {\n        const cb = comments.before.join(\"\\n\");\n        if (cb) {\n            const cbNode = body instanceof stringifyNumber.Collection && body.items[0] ? body.items[0] : body;\n            cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n        }\n        doc.comment = comments.after.join(\"\\n\") || null;\n    }\n}\nfunction resolveTagDirective({ tagPrefixes }, directive) {\n    const [handle, prefix] = directive.parameters;\n    if (!handle || !prefix) {\n        const msg = \"Insufficient parameters given for %TAG directive\";\n        throw new _rollupPluginBabelHelpers.YAMLSemanticError(directive, msg);\n    }\n    if (tagPrefixes.some((p)=>p.handle === handle)) {\n        const msg = \"The %TAG directive must only be given at most once per handle in the same document.\";\n        throw new _rollupPluginBabelHelpers.YAMLSemanticError(directive, msg);\n    }\n    return {\n        handle,\n        prefix\n    };\n}\nfunction resolveYamlDirective(doc, directive) {\n    let [version] = directive.parameters;\n    if (directive.name === \"YAML:1.0\") version = \"1.0\";\n    if (!version) {\n        const msg = \"Insufficient parameters given for %YAML directive\";\n        throw new _rollupPluginBabelHelpers.YAMLSemanticError(directive, msg);\n    }\n    if (!documentOptions[version]) {\n        const v0 = doc.version || doc.options.version;\n        const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n        doc.warnings.push(new _rollupPluginBabelHelpers.YAMLWarning(directive, msg));\n    }\n    return version;\n}\nfunction parseDirectives(doc, directives, prevDoc) {\n    const directiveComments = [];\n    let hasDirectives = false;\n    for (const directive of directives){\n        const { comment, name } = directive;\n        switch(name){\n            case \"TAG\":\n                try {\n                    doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n                } catch (error) {\n                    doc.errors.push(error);\n                }\n                hasDirectives = true;\n                break;\n            case \"YAML\":\n            case \"YAML:1.0\":\n                if (doc.version) {\n                    const msg = \"The %YAML directive must only be given at most once per document.\";\n                    doc.errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(directive, msg));\n                }\n                try {\n                    doc.version = resolveYamlDirective(doc, directive);\n                } catch (error) {\n                    doc.errors.push(error);\n                }\n                hasDirectives = true;\n                break;\n            default:\n                if (name) {\n                    const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n                    doc.warnings.push(new _rollupPluginBabelHelpers.YAMLWarning(directive, msg));\n                }\n        }\n        if (comment) directiveComments.push(comment);\n    }\n    if (prevDoc && !hasDirectives && \"1.1\" === (doc.version || prevDoc.version || doc.options.version)) {\n        const copyTagPrefix = ({ handle, prefix })=>({\n                handle,\n                prefix\n            });\n        doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n        doc.version = prevDoc.version;\n    }\n    doc.commentBefore = directiveComments.join(\"\\n\") || null;\n}\nfunction assertCollection(contents) {\n    if (contents instanceof stringifyNumber.Collection) return true;\n    throw new Error(\"Expected a YAML collection as document contents\");\n}\nclass Document {\n    constructor(value, replacer, options){\n        if (options === undefined && replacer && typeof replacer === \"object\" && !Array.isArray(replacer)) {\n            options = replacer;\n            replacer = undefined;\n        }\n        this.options = Object.assign({}, defaultOptions, options);\n        this.anchors = new Anchors(this.options.anchorPrefix);\n        this.commentBefore = null;\n        this.comment = null;\n        this.directivesEndMarker = null;\n        this.errors = [];\n        this.schema = null;\n        this.tagPrefixes = [];\n        this.version = null;\n        this.warnings = [];\n        if (value === undefined) {\n            // note that this.schema is left as null here\n            this.contents = null;\n        } else if (value instanceof parseCst.Document) {\n            this.parse(value);\n        } else {\n            this.contents = this.createNode(value, {\n                replacer\n            });\n        }\n    }\n    add(value) {\n        assertCollection(this.contents);\n        return this.contents.add(value);\n    }\n    addIn(path, value) {\n        assertCollection(this.contents);\n        this.contents.addIn(path, value);\n    }\n    createNode(value, { keepUndefined, onTagObj, replacer, tag, wrapScalars } = {}) {\n        this.setSchema();\n        if (typeof replacer === \"function\") value = replacer.call({\n            \"\": value\n        }, \"\", value);\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v)=>typeof v === \"number\" || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0) replacer = replacer.concat(asStr);\n        }\n        if (typeof keepUndefined !== \"boolean\") keepUndefined = !!this.options.keepUndefined;\n        const aliasNodes = [];\n        const ctx = {\n            keepUndefined,\n            onAlias (source) {\n                const alias = new stringifyNumber.Alias(source);\n                aliasNodes.push(alias);\n                return alias;\n            },\n            onTagObj,\n            prevObjects: new Map(),\n            replacer,\n            schema: this.schema,\n            wrapScalars: wrapScalars !== false\n        };\n        const node = stringifyNumber.createNode(value, tag, ctx);\n        for (const alias of aliasNodes){\n            // With circular references, the source node is only resolved after all of\n            // its child nodes are. This is why anchors are set only after all of the\n            // nodes have been created.\n            alias.source = alias.source.node;\n            let name = this.anchors.getName(alias.source);\n            if (!name) {\n                name = this.anchors.newName();\n                this.anchors.map[name] = alias.source;\n            }\n        }\n        return node;\n    }\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, options);\n        const v = this.createNode(value, options);\n        return new stringifyNumber.Pair(k, v);\n    }\n    delete(key) {\n        assertCollection(this.contents);\n        return this.contents.delete(key);\n    }\n    deleteIn(path) {\n        if (stringifyNumber.isEmptyPath(path)) {\n            if (this.contents == null) return false;\n            this.contents = null;\n            return true;\n        }\n        assertCollection(this.contents);\n        return this.contents.deleteIn(path);\n    }\n    getDefaults() {\n        return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n    get(key, keepScalar) {\n        return this.contents instanceof stringifyNumber.Collection ? this.contents.get(key, keepScalar) : undefined;\n    }\n    getIn(path, keepScalar) {\n        if (stringifyNumber.isEmptyPath(path)) return !keepScalar && this.contents instanceof stringifyNumber.Scalar ? this.contents.value : this.contents;\n        return this.contents instanceof stringifyNumber.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n    has(key) {\n        return this.contents instanceof stringifyNumber.Collection ? this.contents.has(key) : false;\n    }\n    hasIn(path) {\n        if (stringifyNumber.isEmptyPath(path)) return this.contents !== undefined;\n        return this.contents instanceof stringifyNumber.Collection ? this.contents.hasIn(path) : false;\n    }\n    set(key, value) {\n        if (this.contents == null) {\n            this.setSchema();\n            this.contents = stringifyNumber.collectionFromPath(this.schema, [\n                key\n            ], value);\n        } else {\n            assertCollection(this.contents);\n            this.contents.set(key, value);\n        }\n    }\n    setIn(path, value) {\n        if (stringifyNumber.isEmptyPath(path)) this.contents = value;\n        else if (this.contents == null) {\n            this.setSchema();\n            this.contents = stringifyNumber.collectionFromPath(this.schema, path, value);\n        } else {\n            assertCollection(this.contents);\n            this.contents.setIn(path, value);\n        }\n    }\n    setSchema(id, customTags) {\n        if (!id && !customTags && this.schema) return;\n        if (typeof id === \"number\") id = id.toFixed(1);\n        if (id === \"1.0\" || id === \"1.1\" || id === \"1.2\") {\n            if (this.version) this.version = id;\n            else this.options.version = id;\n            delete this.options.schema;\n        } else if (id && typeof id === \"string\") {\n            this.options.schema = id;\n        }\n        if (Array.isArray(customTags)) this.options.customTags = customTags;\n        const opt1 = Object.assign({}, this.getDefaults(), this.options);\n        this.schema = new Schema.Schema(opt1);\n    }\n    parse(node, prevDoc) {\n        if (this.options.keepCstNodes) this.cstNode = node;\n        if (this.options.keepNodeTypes) this.type = \"DOCUMENT\";\n        const { directives = [], contents = [], directivesEndMarker, error, valueRange } = node;\n        if (error) {\n            if (!error.source) error.source = this;\n            this.errors.push(error);\n        }\n        parseDirectives(this, directives, prevDoc);\n        if (directivesEndMarker) this.directivesEndMarker = true;\n        this.range = valueRange ? [\n            valueRange.start,\n            valueRange.end\n        ] : null;\n        this.setSchema();\n        this.anchors._cstAliases = [];\n        parseContents(this, contents);\n        this.anchors.resolveNodes();\n        if (this.options.prettyErrors) {\n            for (const error of this.errors)if (error instanceof _rollupPluginBabelHelpers.YAMLError) error.makePretty();\n            for (const warn of this.warnings)if (warn instanceof _rollupPluginBabelHelpers.YAMLError) warn.makePretty();\n        }\n        return this;\n    }\n    listNonDefaultTags() {\n        return listTagNames(this.contents).filter((t)=>t.indexOf(_rollupPluginBabelHelpers.defaultTagPrefix) !== 0);\n    }\n    setTagPrefix(handle, prefix) {\n        if (handle[0] !== \"!\" || handle[handle.length - 1] !== \"!\") throw new Error(\"Handle must start and end with !\");\n        if (prefix) {\n            const prev = this.tagPrefixes.find((p)=>p.handle === handle);\n            if (prev) prev.prefix = prefix;\n            else this.tagPrefixes.push({\n                handle,\n                prefix\n            });\n        } else {\n            this.tagPrefixes = this.tagPrefixes.filter((p)=>p.handle !== handle);\n        }\n    }\n    toJS({ json, jsonArg, mapAsMap, onAnchor, reviver } = {}) {\n        const anchorNodes = Object.values(this.anchors.map).map((node)=>[\n                node,\n                {\n                    alias: [],\n                    aliasCount: 0,\n                    count: 1\n                }\n            ]);\n        const anchors = anchorNodes.length > 0 ? new Map(anchorNodes) : null;\n        const ctx = {\n            anchors,\n            doc: this,\n            indentStep: \"  \",\n            keep: !json,\n            mapAsMap: typeof mapAsMap === \"boolean\" ? mapAsMap : !!this.options.mapAsMap,\n            maxAliasCount: this.options.maxAliasCount,\n            stringify\n        };\n        const res = stringifyNumber.toJS(this.contents, jsonArg || \"\", ctx);\n        if (typeof onAnchor === \"function\" && anchors) for (const { count, res } of anchors.values())onAnchor(res, count);\n        return typeof reviver === \"function\" ? applyReviver(reviver, {\n            \"\": res\n        }, \"\", res) : res;\n    }\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({\n            json: true,\n            jsonArg,\n            mapAsMap: false,\n            onAnchor\n        });\n    }\n    toString() {\n        if (this.errors.length > 0) throw new Error(\"Document with errors cannot be stringified\");\n        const indentSize = this.options.indent;\n        if (!Number.isInteger(indentSize) || indentSize <= 0) {\n            const s = JSON.stringify(indentSize);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        this.setSchema();\n        const lines = [];\n        let hasDirectives = false;\n        if (this.version) {\n            let vd = \"%YAML 1.2\";\n            if (this.schema.name === \"yaml-1.1\") {\n                if (this.version === \"1.0\") vd = \"%YAML:1.0\";\n                else if (this.version === \"1.1\") vd = \"%YAML 1.1\";\n            }\n            lines.push(vd);\n            hasDirectives = true;\n        }\n        const tagNames = this.listNonDefaultTags();\n        this.tagPrefixes.forEach(({ handle, prefix })=>{\n            if (tagNames.some((t)=>t.indexOf(prefix) === 0)) {\n                lines.push(`%TAG ${handle} ${prefix}`);\n                hasDirectives = true;\n            }\n        });\n        if (hasDirectives || this.directivesEndMarker) lines.push(\"---\");\n        if (this.commentBefore) {\n            if (hasDirectives || !this.directivesEndMarker) lines.unshift(\"\");\n            lines.unshift(this.commentBefore.replace(/^/gm, \"#\"));\n        }\n        const ctx = {\n            anchors: Object.create(null),\n            doc: this,\n            indent: \"\",\n            indentStep: \" \".repeat(indentSize),\n            stringify\n        };\n        let chompKeep = false;\n        let contentComment = null;\n        if (this.contents) {\n            if (this.contents instanceof stringifyNumber.Node) {\n                if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push(\"\");\n                if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, \"#\")); // top-level block scalars need to be indented if followed by a comment\n                ctx.forceBlockIndent = !!this.comment;\n                contentComment = this.contents.comment;\n            }\n            const onChompKeep = contentComment ? null : ()=>chompKeep = true;\n            const body = stringify(this.contents, ctx, ()=>contentComment = null, onChompKeep);\n            lines.push(stringifyNumber.addComment(body, \"\", contentComment));\n        } else {\n            lines.push(stringify(this.contents, ctx));\n        }\n        if (this.comment) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== \"\") lines.push(\"\");\n            lines.push(this.comment.replace(/^/gm, \"#\"));\n        }\n        return lines.join(\"\\n\") + \"\\n\";\n    }\n}\n_rollupPluginBabelHelpers._defineProperty(Document, \"defaults\", documentOptions);\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9ub2RlX21vZHVsZXMveWFtbC9kaXN0L0RvY3VtZW50LWY4OWEyNjE0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsNEJBQTRCQyxtQkFBT0EsQ0FBQztBQUN4QyxJQUFJQyxXQUFXRCxtQkFBT0EsQ0FBQztBQUN2QixJQUFJRSxrQkFBa0JGLG1CQUFPQSxDQUFDO0FBQzlCLElBQUlHLFNBQVNILG1CQUFPQSxDQUFDO0FBRXJCLE1BQU1JLGlCQUFpQjtJQUNyQkMsY0FBYztJQUNkQyxZQUFZO0lBQ1pDLFFBQVE7SUFDUkMsV0FBVztJQUNYQyxjQUFjO0lBQ2RDLGVBQWU7SUFDZkMsZUFBZTtJQUNmQyxVQUFVO0lBQ1ZDLGVBQWU7SUFDZkMsY0FBYztJQUNkQyxZQUFZO0lBQ1pDLFNBQVM7QUFDWDtBQUNBLE1BQU1DLGdCQUFnQjtJQUNwQixJQUFJQyxVQUFTO1FBQ1gsT0FBT2hCLGdCQUFnQmlCLGFBQWE7SUFDdEM7SUFFQSxJQUFJRCxRQUFPRSxJQUFLO1FBQ2RDLE9BQU9DLE1BQU0sQ0FBQ3BCLGdCQUFnQmlCLGFBQWEsRUFBRUM7SUFDL0M7SUFFQSxJQUFJRyxRQUFPO1FBQ1QsT0FBT3JCLGdCQUFnQnNCLFdBQVc7SUFDcEM7SUFFQSxJQUFJRCxNQUFLSCxJQUFLO1FBQ1pDLE9BQU9DLE1BQU0sQ0FBQ3BCLGdCQUFnQnNCLFdBQVcsRUFBRUo7SUFDN0M7SUFFQSxJQUFJSyxPQUFNO1FBQ1IsT0FBT3ZCLGdCQUFnQndCLFVBQVU7SUFDbkM7SUFFQSxJQUFJRCxLQUFJTCxJQUFLO1FBQ1hDLE9BQU9DLE1BQU0sQ0FBQ3BCLGdCQUFnQndCLFVBQVUsRUFBRU47SUFDNUM7SUFFQSxJQUFJTyxRQUFPO1FBQ1QsT0FBT3pCLGdCQUFnQjBCLFdBQVc7SUFDcEM7SUFFQSxJQUFJRCxNQUFLUCxJQUFLO1FBQ1pDLE9BQU9DLE1BQU0sQ0FBQ3BCLGdCQUFnQjBCLFdBQVcsRUFBRVI7SUFDN0M7SUFF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QUFDLE9BQU8sT0FBTyx1RUFBdUU7Z0JBRXJLb0MsSUFBSXVRLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUNsSyxPQUFPO2dCQUNyQ2lLLGlCQUFpQixJQUFJLENBQUNqRSxRQUFRLENBQUNoRyxPQUFPO1lBQ3hDO1lBRUEsTUFBTW5HLGNBQWNvUSxpQkFBaUIsT0FBTyxJQUFNRCxZQUFZO1lBQzlELE1BQU0vRCxPQUFPdk0sVUFBVSxJQUFJLENBQUNzTSxRQUFRLEVBQUVyTSxLQUFLLElBQU1zUSxpQkFBaUIsTUFBTXBRO1lBQ3hFOFAsTUFBTXBRLElBQUksQ0FBQzVFLGdCQUFnQndWLFVBQVUsQ0FBQ2xFLE1BQU0sSUFBSWdFO1FBQ2xELE9BQU87WUFDTE4sTUFBTXBRLElBQUksQ0FBQ0csVUFBVSxJQUFJLENBQUNzTSxRQUFRLEVBQUVyTTtRQUN0QztRQUVBLElBQUksSUFBSSxDQUFDcUcsT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxDQUFDZ0ssYUFBYUMsY0FBYSxLQUFNTixLQUFLLENBQUNBLE1BQU01UixNQUFNLEdBQUcsRUFBRSxLQUFLLElBQUk0UixNQUFNcFEsSUFBSSxDQUFDO1lBQ2pGb1EsTUFBTXBRLElBQUksQ0FBQyxJQUFJLENBQUN5RyxPQUFPLENBQUN6SSxPQUFPLENBQUMsT0FBTztRQUN6QztRQUVBLE9BQU9vUyxNQUFNbFEsSUFBSSxDQUFDLFFBQVE7SUFDNUI7QUFFRjtBQUVBakYsMEJBQTBCbUcsZUFBZSxDQUFDbU0sVUFBVSxZQUFZdFE7QUFFaEU0VCxnQkFBZ0IsR0FBR3REO0FBQ25Cc0Qsc0JBQXNCLEdBQUd2VjtBQUN6QnVWLHFCQUFxQixHQUFHMVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3N3YWdnZXItanNkb2Mvbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9Eb2N1bWVudC1mODlhMjYxNC5qcz9hNmFkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMgPSByZXF1aXJlKCcuL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtZWVkMzAyMTcuanMnKTtcbnZhciBwYXJzZUNzdCA9IHJlcXVpcmUoJy4vcGFyc2UtMzk5N2Y1NDQuanMnKTtcbnZhciBzdHJpbmdpZnlOdW1iZXIgPSByZXF1aXJlKCcuL3N0cmluZ2lmeU51bWJlci1kZWExMTIwYy5qcycpO1xudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4vU2NoZW1hLTgwNzQzMGJhLmpzJyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBhbmNob3JQcmVmaXg6ICdhJyxcbiAgY3VzdG9tVGFnczogbnVsbCxcbiAgaW5kZW50OiAyLFxuICBpbmRlbnRTZXE6IHRydWUsXG4gIGtlZXBDc3ROb2RlczogZmFsc2UsXG4gIGtlZXBOb2RlVHlwZXM6IHRydWUsXG4gIGtlZXBVbmRlZmluZWQ6IGZhbHNlLFxuICBtYXBBc01hcDogZmFsc2UsXG4gIG1heEFsaWFzQ291bnQ6IDEwMCxcbiAgcHJldHR5RXJyb3JzOiB0cnVlLFxuICBzaW1wbGVLZXlzOiBmYWxzZSxcbiAgdmVyc2lvbjogJzEuMidcbn07XG5jb25zdCBzY2FsYXJPcHRpb25zID0ge1xuICBnZXQgYmluYXJ5KCkge1xuICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIuYmluYXJ5T3B0aW9ucztcbiAgfSxcblxuICBzZXQgYmluYXJ5KG9wdCkge1xuICAgIE9iamVjdC5hc3NpZ24oc3RyaW5naWZ5TnVtYmVyLmJpbmFyeU9wdGlvbnMsIG9wdCk7XG4gIH0sXG5cbiAgZ2V0IGJvb2woKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU51bWJlci5ib29sT3B0aW9ucztcbiAgfSxcblxuICBzZXQgYm9vbChvcHQpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0cmluZ2lmeU51bWJlci5ib29sT3B0aW9ucywgb3B0KTtcbiAgfSxcblxuICBnZXQgaW50KCkge1xuICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIuaW50T3B0aW9ucztcbiAgfSxcblxuICBzZXQgaW50KG9wdCkge1xuICAgIE9iamVjdC5hc3NpZ24oc3RyaW5naWZ5TnVtYmVyLmludE9wdGlvbnMsIG9wdCk7XG4gIH0sXG5cbiAgZ2V0IG51bGwoKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU51bWJlci5udWxsT3B0aW9ucztcbiAgfSxcblxuICBzZXQgbnVsbChvcHQpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0cmluZ2lmeU51bWJlci5udWxsT3B0aW9ucywgb3B0KTtcbiAgfSxcblxuICBnZXQgc3RyKCkge1xuICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIuc3RyT3B0aW9ucztcbiAgfSxcblxuICBzZXQgc3RyKG9wdCkge1xuICAgIE9iamVjdC5hc3NpZ24oc3RyaW5naWZ5TnVtYmVyLnN0ck9wdGlvbnMsIG9wdCk7XG4gIH1cblxufTtcbmNvbnN0IGRvY3VtZW50T3B0aW9ucyA9IHtcbiAgJzEuMCc6IHtcbiAgICBzY2hlbWE6ICd5YW1sLTEuMScsXG4gICAgbWVyZ2U6IHRydWUsXG4gICAgdGFnUHJlZml4ZXM6IFt7XG4gICAgICBoYW5kbGU6ICchJyxcbiAgICAgIHByZWZpeDogX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5kZWZhdWx0VGFnUHJlZml4XG4gICAgfSwge1xuICAgICAgaGFuZGxlOiAnISEnLFxuICAgICAgcHJlZml4OiAndGFnOnByaXZhdGUueWFtbC5vcmcsMjAwMjonXG4gICAgfV1cbiAgfSxcbiAgJzEuMSc6IHtcbiAgICBzY2hlbWE6ICd5YW1sLTEuMScsXG4gICAgbWVyZ2U6IHRydWUsXG4gICAgdGFnUHJlZml4ZXM6IFt7XG4gICAgICBoYW5kbGU6ICchJyxcbiAgICAgIHByZWZpeDogJyEnXG4gICAgfSwge1xuICAgICAgaGFuZGxlOiAnISEnLFxuICAgICAgcHJlZml4OiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmRlZmF1bHRUYWdQcmVmaXhcbiAgICB9XVxuICB9LFxuICAnMS4yJzoge1xuICAgIHNjaGVtYTogJ2NvcmUnLFxuICAgIG1lcmdlOiBmYWxzZSxcbiAgICByZXNvbHZlS25vd25UYWdzOiB0cnVlLFxuICAgIHRhZ1ByZWZpeGVzOiBbe1xuICAgICAgaGFuZGxlOiAnIScsXG4gICAgICBwcmVmaXg6ICchJ1xuICAgIH0sIHtcbiAgICAgIGhhbmRsZTogJyEhJyxcbiAgICAgIHByZWZpeDogX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5kZWZhdWx0VGFnUHJlZml4XG4gICAgfV1cbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5VGFnKGRvYywgdGFnKSB7XG4gIGlmICgoZG9jLnZlcnNpb24gfHwgZG9jLm9wdGlvbnMudmVyc2lvbikgPT09ICcxLjAnKSB7XG4gICAgY29uc3QgcHJpdiA9IHRhZy5tYXRjaCgvXnRhZzpwcml2YXRlXFwueWFtbFxcLm9yZywyMDAyOihbXjovXSspJC8pO1xuICAgIGlmIChwcml2KSByZXR1cm4gJyEnICsgcHJpdlsxXTtcbiAgICBjb25zdCB2b2NhYiA9IHRhZy5tYXRjaCgvXnRhZzooW2EtekEtWjAtOS1dKylcXC55YW1sXFwub3JnLDIwMDI6KC4qKS8pO1xuICAgIHJldHVybiB2b2NhYiA/IGAhJHt2b2NhYlsxXX0vJHt2b2NhYlsyXX1gIDogYCEke3RhZy5yZXBsYWNlKC9edGFnOi8sICcnKX1gO1xuICB9XG5cbiAgbGV0IHAgPSBkb2MudGFnUHJlZml4ZXMuZmluZChwID0+IHRhZy5pbmRleE9mKHAucHJlZml4KSA9PT0gMCk7XG5cbiAgaWYgKCFwKSB7XG4gICAgY29uc3QgZHRwID0gZG9jLmdldERlZmF1bHRzKCkudGFnUHJlZml4ZXM7XG4gICAgcCA9IGR0cCAmJiBkdHAuZmluZChwID0+IHRhZy5pbmRleE9mKHAucHJlZml4KSA9PT0gMCk7XG4gIH1cblxuICBpZiAoIXApIHJldHVybiB0YWdbMF0gPT09ICchJyA/IHRhZyA6IGAhPCR7dGFnfT5gO1xuICBjb25zdCBzdWZmaXggPSB0YWcuc3Vic3RyKHAucHJlZml4Lmxlbmd0aCkucmVwbGFjZSgvWyEsW1xcXXt9XS9nLCBjaCA9PiAoe1xuICAgICchJzogJyUyMScsXG4gICAgJywnOiAnJTJDJyxcbiAgICAnWyc6ICclNUInLFxuICAgICddJzogJyU1RCcsXG4gICAgJ3snOiAnJTdCJyxcbiAgICAnfSc6ICclN0QnXG4gIH0pW2NoXSk7XG4gIHJldHVybiBwLmhhbmRsZSArIHN1ZmZpeDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFnT2JqZWN0KHRhZ3MsIGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuQWxpYXMpIHJldHVybiBzdHJpbmdpZnlOdW1iZXIuQWxpYXM7XG5cbiAgaWYgKGl0ZW0udGFnKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSBpdGVtLnRhZyk7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApIHJldHVybiBtYXRjaC5maW5kKHQgPT4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0KSB8fCBtYXRjaFswXTtcbiAgfVxuXG4gIGxldCB0YWdPYmosIG9iajtcblxuICBpZiAoaXRlbSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5TY2FsYXIpIHtcbiAgICBvYmogPSBpdGVtLnZhbHVlO1xuICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LmlkZW50aWZ5ICYmIHQuaWRlbnRpZnkob2JqKSk7XG4gICAgdGFnT2JqID0gbWF0Y2guZmluZCh0ID0+IHQuZm9ybWF0ID09PSBpdGVtLmZvcm1hdCkgfHwgbWF0Y2guZmluZCh0ID0+ICF0LmZvcm1hdCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqID0gaXRlbTtcbiAgICB0YWdPYmogPSB0YWdzLmZpbmQodCA9PiB0Lm5vZGVDbGFzcyAmJiBvYmogaW5zdGFuY2VvZiB0Lm5vZGVDbGFzcyk7XG4gIH1cblxuICBpZiAoIXRhZ09iaikge1xuICAgIGNvbnN0IG5hbWUgPSBvYmogJiYgb2JqLmNvbnN0cnVjdG9yID8gb2JqLmNvbnN0cnVjdG9yLm5hbWUgOiB0eXBlb2Ygb2JqO1xuICAgIHRocm93IG5ldyBFcnJvcihgVGFnIG5vdCByZXNvbHZlZCBmb3IgJHtuYW1lfSB2YWx1ZWApO1xuICB9XG5cbiAgcmV0dXJuIHRhZ09iajtcbn0gLy8gbmVlZHMgdG8gYmUgY2FsbGVkIGJlZm9yZSB2YWx1ZSBzdHJpbmdpZmllciB0byBhbGxvdyBmb3IgY2lyY3VsYXIgYW5jaG9yIHJlZnNcblxuXG5mdW5jdGlvbiBzdHJpbmdpZnlQcm9wcyhub2RlLCB0YWdPYmosIHtcbiAgYW5jaG9ycyxcbiAgZG9jXG59KSB7XG4gIGNvbnN0IHByb3BzID0gW107XG4gIGNvbnN0IGFuY2hvciA9IGRvYy5hbmNob3JzLmdldE5hbWUobm9kZSk7XG5cbiAgaWYgKGFuY2hvcikge1xuICAgIGFuY2hvcnNbYW5jaG9yXSA9IG5vZGU7XG4gICAgcHJvcHMucHVzaChgJiR7YW5jaG9yfWApO1xuICB9XG5cbiAgaWYgKG5vZGUudGFnKSB7XG4gICAgcHJvcHMucHVzaChzdHJpbmdpZnlUYWcoZG9jLCBub2RlLnRhZykpO1xuICB9IGVsc2UgaWYgKCF0YWdPYmouZGVmYXVsdCkge1xuICAgIHByb3BzLnB1c2goc3RyaW5naWZ5VGFnKGRvYywgdGFnT2JqLnRhZykpO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICBjb25zdCB7XG4gICAgc2NoZW1hXG4gIH0gPSBjdHguZG9jO1xuICBsZXQgdGFnT2JqO1xuXG4gIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuTm9kZSkpIHtcbiAgICBpdGVtID0gY3R4LmRvYy5jcmVhdGVOb2RlKGl0ZW0sIHtcbiAgICAgIG9uVGFnT2JqOiBvID0+IHRhZ09iaiA9IG8sXG4gICAgICB3cmFwU2NhbGFyczogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuUGFpcikgcmV0dXJuIGl0ZW0udG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgaWYgKCF0YWdPYmopIHRhZ09iaiA9IGdldFRhZ09iamVjdChzY2hlbWEudGFncywgaXRlbSk7XG4gIGNvbnN0IHByb3BzID0gc3RyaW5naWZ5UHJvcHMoaXRlbSwgdGFnT2JqLCBjdHgpO1xuICBpZiAocHJvcHMubGVuZ3RoID4gMCkgY3R4LmluZGVudEF0U3RhcnQgPSAoY3R4LmluZGVudEF0U3RhcnQgfHwgMCkgKyBwcm9wcy5sZW5ndGggKyAxO1xuICBjb25zdCBzdHIgPSB0eXBlb2YgdGFnT2JqLnN0cmluZ2lmeSA9PT0gJ2Z1bmN0aW9uJyA/IHRhZ09iai5zdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSA6IGl0ZW0gaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuU2NhbGFyID8gc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeVN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIDogaXRlbS50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICBpZiAoIXByb3BzKSByZXR1cm4gc3RyO1xuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5TY2FsYXIgfHwgc3RyWzBdID09PSAneycgfHwgc3RyWzBdID09PSAnWycgPyBgJHtwcm9wc30gJHtzdHJ9YCA6IGAke3Byb3BzfVxcbiR7Y3R4LmluZGVudH0ke3N0cn1gO1xufVxuXG5jbGFzcyBBbmNob3JzIHtcbiAgc3RhdGljIHZhbGlkQW5jaG9yTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuU2NhbGFyIHx8IG5vZGUgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuWUFNTFNlcSB8fCBub2RlIGluc3RhbmNlb2Ygc3RyaW5naWZ5TnVtYmVyLllBTUxNYXA7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwcmVmaXgpIHtcbiAgICBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hcFwiLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICB9XG5cbiAgY3JlYXRlQWxpYXMobm9kZSwgbmFtZSkge1xuICAgIHRoaXMuc2V0QW5jaG9yKG5vZGUsIG5hbWUpO1xuICAgIHJldHVybiBuZXcgc3RyaW5naWZ5TnVtYmVyLkFsaWFzKG5vZGUpO1xuICB9XG5cbiAgY3JlYXRlTWVyZ2VQYWlyKC4uLnNvdXJjZXMpIHtcbiAgICBjb25zdCBtZXJnZSA9IG5ldyBTY2hlbWEuTWVyZ2UoKTtcbiAgICBtZXJnZS52YWx1ZS5pdGVtcyA9IHNvdXJjZXMubWFwKHMgPT4ge1xuICAgICAgaWYgKHMgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuQWxpYXMpIHtcbiAgICAgICAgaWYgKHMuc291cmNlIGluc3RhbmNlb2Ygc3RyaW5naWZ5TnVtYmVyLllBTUxNYXApIHJldHVybiBzO1xuICAgICAgfSBlbHNlIGlmIChzIGluc3RhbmNlb2Ygc3RyaW5naWZ5TnVtYmVyLllBTUxNYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQWxpYXMocyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignTWVyZ2Ugc291cmNlcyBtdXN0IGJlIE1hcCBub2RlcyBvciB0aGVpciBBbGlhc2VzJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlO1xuICB9XG5cbiAgZ2V0TmFtZShub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFwXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkuZmluZChhID0+IG1hcFthXSA9PT0gbm9kZSk7XG4gIH1cblxuICBnZXROYW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXApO1xuICB9XG5cbiAgZ2V0Tm9kZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25hbWVdO1xuICB9XG5cbiAgbmV3TmFtZShwcmVmaXgpIHtcbiAgICBpZiAoIXByZWZpeCkgcHJlZml4ID0gdGhpcy5wcmVmaXg7XG4gICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgdHJ1ZTsgKytpKSB7XG4gICAgICBjb25zdCBuYW1lID0gYCR7cHJlZml4fSR7aX1gO1xuICAgICAgaWYgKCFuYW1lcy5pbmNsdWRlcyhuYW1lKSkgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9IC8vIER1cmluZyBwYXJzaW5nLCBtYXAgJiBhbGlhc2VzIGNvbnRhaW4gQ1NUIG5vZGVzXG5cblxuICByZXNvbHZlTm9kZXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgX2NzdEFsaWFzZXNcbiAgICB9ID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goYSA9PiB7XG4gICAgICBtYXBbYV0gPSBtYXBbYV0ucmVzb2x2ZWQ7XG4gICAgfSk7XG5cbiAgICBfY3N0QWxpYXNlcy5mb3JFYWNoKGEgPT4ge1xuICAgICAgYS5zb3VyY2UgPSBhLnNvdXJjZS5yZXNvbHZlZDtcbiAgICB9KTtcblxuICAgIGRlbGV0ZSB0aGlzLl9jc3RBbGlhc2VzO1xuICB9XG5cbiAgc2V0QW5jaG9yKG5vZGUsIG5hbWUpIHtcbiAgICBpZiAobm9kZSAhPSBudWxsICYmICFBbmNob3JzLnZhbGlkQW5jaG9yTm9kZShub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbmNob3JzIG1heSBvbmx5IGJlIHNldCBmb3IgU2NhbGFyLCBTZXEgYW5kIE1hcCBub2RlcycpO1xuICAgIH1cblxuICAgIGlmIChuYW1lICYmIC9bXFx4MDAtXFx4MTlcXHMsW1xcXXt9XS8udGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbmNob3IgbmFtZXMgbXVzdCBub3QgY29udGFpbiB3aGl0ZXNwYWNlIG9yIGNvbnRyb2wgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIG1hcFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHByZXYgPSBub2RlICYmIE9iamVjdC5rZXlzKG1hcCkuZmluZChhID0+IG1hcFthXSA9PT0gbm9kZSk7XG5cbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfSBlbHNlIGlmIChwcmV2ICE9PSBuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSBtYXBbcHJldl07XG4gICAgICAgIG1hcFtuYW1lXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuICAgICAgICBuYW1lID0gdGhpcy5uZXdOYW1lKCk7XG4gICAgICB9XG5cbiAgICAgIG1hcFtuYW1lXSA9IG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIEpTT04ucGFyc2UgcmV2aXZlciBhbGdvcml0aG0gYXMgZGVmaW5lZCBpbiB0aGUgRUNNQS0yNjIgc3BlYyxcbiAqIGluIHNlY3Rpb24gMjQuNS4xLjEgXCJSdW50aW1lIFNlbWFudGljczogSW50ZXJuYWxpemVKU09OUHJvcGVydHlcIiBvZiB0aGVcbiAqIDIwMjEgZWRpdGlvbjogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLnBhcnNlXG4gKlxuICogSW5jbHVkZXMgZXh0ZW5zaW9ucyBmb3IgaGFuZGxpbmcgTWFwIGFuZCBTZXQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlSZXZpdmVyKHJldml2ZXIsIG9iaiwga2V5LCB2YWwpIHtcbiAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2YWxbaV07XG4gICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgU3RyaW5nKGkpLCB2MCk7XG4gICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgdmFsW2ldO2Vsc2UgaWYgKHYxICE9PSB2MCkgdmFsW2ldID0gdjE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIGZvciAoY29uc3QgayBvZiBBcnJheS5mcm9tKHZhbC5rZXlzKCkpKSB7XG4gICAgICAgIGNvbnN0IHYwID0gdmFsLmdldChrKTtcbiAgICAgICAgY29uc3QgdjEgPSBhcHBseVJldml2ZXIocmV2aXZlciwgdmFsLCBrLCB2MCk7XG4gICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKSB2YWwuZGVsZXRlKGspO2Vsc2UgaWYgKHYxICE9PSB2MCkgdmFsLnNldChrLCB2MSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGZvciAoY29uc3QgdjAgb2YgQXJyYXkuZnJvbSh2YWwpKSB7XG4gICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgdjAsIHYwKTtcbiAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpIHZhbC5kZWxldGUodjApO2Vsc2UgaWYgKHYxICE9PSB2MCkge1xuICAgICAgICAgIHZhbC5kZWxldGUodjApO1xuICAgICAgICAgIHZhbC5hZGQodjEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgW2ssIHYwXSBvZiBPYmplY3QuZW50cmllcyh2YWwpKSB7XG4gICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHZhbFtrXTtlbHNlIGlmICh2MSAhPT0gdjApIHZhbFtrXSA9IHYxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXZpdmVyLmNhbGwob2JqLCBrZXksIHZhbCk7XG59XG5cbmNvbnN0IHZpc2l0ID0gKG5vZGUsIHRhZ3MpID0+IHtcbiAgaWYgKG5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFnXG4gICAgfSA9IG5vZGU7XG5cbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5Db2xsZWN0aW9uKSB7XG4gICAgICBpZiAodGFnKSB0YWdzW3RhZ10gPSB0cnVlO1xuICAgICAgbm9kZS5pdGVtcy5mb3JFYWNoKG4gPT4gdmlzaXQobiwgdGFncykpO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5QYWlyKSB7XG4gICAgICB2aXNpdChub2RlLmtleSwgdGFncyk7XG4gICAgICB2aXNpdChub2RlLnZhbHVlLCB0YWdzKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuU2NhbGFyKSB7XG4gICAgICBpZiAodGFnKSB0YWdzW3RhZ10gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWdzO1xufTtcblxuY29uc3QgbGlzdFRhZ05hbWVzID0gbm9kZSA9PiBPYmplY3Qua2V5cyh2aXNpdChub2RlLCB7fSkpO1xuXG5mdW5jdGlvbiByZXNvbHZlVGFnSGFuZGxlKGRvYywgbm9kZSkge1xuICBjb25zdCB7XG4gICAgaGFuZGxlLFxuICAgIHN1ZmZpeFxuICB9ID0gbm9kZS50YWc7XG4gIGxldCBwcmVmaXggPSBkb2MudGFnUHJlZml4ZXMuZmluZChwID0+IHAuaGFuZGxlID09PSBoYW5kbGUpO1xuXG4gIGlmICghcHJlZml4KSB7XG4gICAgY29uc3QgZHRwID0gZG9jLmdldERlZmF1bHRzKCkudGFnUHJlZml4ZXM7XG4gICAgaWYgKGR0cCkgcHJlZml4ID0gZHRwLmZpbmQocCA9PiBwLmhhbmRsZSA9PT0gaGFuZGxlKTtcbiAgICBpZiAoIXByZWZpeCkgdGhyb3cgbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgYFRoZSAke2hhbmRsZX0gdGFnIGhhbmRsZSBpcyBub24tZGVmYXVsdCBhbmQgd2FzIG5vdCBkZWNsYXJlZC5gKTtcbiAgfVxuXG4gIGlmICghc3VmZml4KSB0aHJvdyBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihub2RlLCBgVGhlICR7aGFuZGxlfSB0YWcgaGFzIG5vIHN1ZmZpeC5gKTtcblxuICBpZiAoaGFuZGxlID09PSAnIScgJiYgKGRvYy52ZXJzaW9uIHx8IGRvYy5vcHRpb25zLnZlcnNpb24pID09PSAnMS4wJykge1xuICAgIGlmIChzdWZmaXhbMF0gPT09ICdeJykge1xuICAgICAgZG9jLndhcm5pbmdzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFdhcm5pbmcobm9kZSwgJ1lBTUwgMS4wIF4gdGFnIGV4cGFuc2lvbiBpcyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgcmV0dXJuIHN1ZmZpeDtcbiAgICB9XG5cbiAgICBpZiAoL1s6L10vLnRlc3Qoc3VmZml4KSkge1xuICAgICAgLy8gd29yZC9mb28gLT4gdGFnOndvcmQueWFtbC5vcmcsMjAwMjpmb29cbiAgICAgIGNvbnN0IHZvY2FiID0gc3VmZml4Lm1hdGNoKC9eKFthLXowLTktXSspXFwvKC4qKS9pKTtcbiAgICAgIHJldHVybiB2b2NhYiA/IGB0YWc6JHt2b2NhYlsxXX0ueWFtbC5vcmcsMjAwMjoke3ZvY2FiWzJdfWAgOiBgdGFnOiR7c3VmZml4fWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZWZpeC5wcmVmaXggKyBkZWNvZGVVUklDb21wb25lbnQoc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhZ05hbWUoZG9jLCBub2RlKSB7XG4gIGNvbnN0IHtcbiAgICB0YWcsXG4gICAgdHlwZVxuICB9ID0gbm9kZTtcbiAgbGV0IG5vblNwZWNpZmljID0gZmFsc2U7XG5cbiAgaWYgKHRhZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbmRsZSxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHZlcmJhdGltXG4gICAgfSA9IHRhZztcblxuICAgIGlmICh2ZXJiYXRpbSkge1xuICAgICAgaWYgKHZlcmJhdGltICE9PSAnIScgJiYgdmVyYmF0aW0gIT09ICchIScpIHJldHVybiB2ZXJiYXRpbTtcbiAgICAgIGNvbnN0IG1zZyA9IGBWZXJiYXRpbSB0YWdzIGFyZW4ndCByZXNvbHZlZCwgc28gJHt2ZXJiYXRpbX0gaXMgaW52YWxpZC5gO1xuICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIG1zZykpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlID09PSAnIScgJiYgIXN1ZmZpeCkge1xuICAgICAgbm9uU3BlY2lmaWMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVRhZ0hhbmRsZShkb2MsIG5vZGUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5CTE9DS19GT0xERUQ6XG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxPQ0tfTElURVJBTDpcbiAgICBjYXNlIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5RVU9URV9ET1VCTEU6XG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuUVVPVEVfU0lOR0xFOlxuICAgICAgcmV0dXJuIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuZGVmYXVsdFRhZ3MuU1RSO1xuXG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRkxPV19NQVA6XG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuTUFQOlxuICAgICAgcmV0dXJuIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuZGVmYXVsdFRhZ3MuTUFQO1xuXG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRkxPV19TRVE6XG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuU0VROlxuICAgICAgcmV0dXJuIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuZGVmYXVsdFRhZ3MuU0VRO1xuXG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuUExBSU46XG4gICAgICByZXR1cm4gbm9uU3BlY2lmaWMgPyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmRlZmF1bHRUYWdzLlNUUiA6IG51bGw7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tGbG93Q29sbGVjdGlvbkVuZChlcnJvcnMsIGNzdCkge1xuICBsZXQgY2hhciwgbmFtZTtcblxuICBzd2l0Y2ggKGNzdC50eXBlKSB7XG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRkxPV19NQVA6XG4gICAgICBjaGFyID0gJ30nO1xuICAgICAgbmFtZSA9ICdmbG93IG1hcCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkZMT1dfU0VROlxuICAgICAgY2hhciA9ICddJztcbiAgICAgIG5hbWUgPSAnZmxvdyBzZXF1ZW5jZSc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBlcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihjc3QsICdOb3QgYSBmbG93IGNvbGxlY3Rpb24hPycpKTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBsYXN0SXRlbTtcblxuICBmb3IgKGxldCBpID0gY3N0Lml0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgY29uc3QgaXRlbSA9IGNzdC5pdGVtc1tpXTtcblxuICAgIGlmICghaXRlbSB8fCBpdGVtLnR5cGUgIT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5DT01NRU5UKSB7XG4gICAgICBsYXN0SXRlbSA9IGl0ZW07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAobGFzdEl0ZW0gJiYgbGFzdEl0ZW0uY2hhciAhPT0gY2hhcikge1xuICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCAke25hbWV9IHRvIGVuZCB3aXRoICR7Y2hhcn1gO1xuICAgIGxldCBlcnI7XG5cbiAgICBpZiAodHlwZW9mIGxhc3RJdGVtLm9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVyciA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKGNzdCwgbXNnKTtcbiAgICAgIGVyci5vZmZzZXQgPSBsYXN0SXRlbS5vZmZzZXQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnIgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihsYXN0SXRlbSwgbXNnKTtcbiAgICAgIGlmIChsYXN0SXRlbS5yYW5nZSAmJiBsYXN0SXRlbS5yYW5nZS5lbmQpIGVyci5vZmZzZXQgPSBsYXN0SXRlbS5yYW5nZS5lbmQgLSBsYXN0SXRlbS5yYW5nZS5zdGFydDtcbiAgICB9XG5cbiAgICBlcnJvcnMucHVzaChlcnIpO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja0Zsb3dDb21tZW50U3BhY2UoZXJyb3JzLCBjb21tZW50KSB7XG4gIGNvbnN0IHByZXYgPSBjb21tZW50LmNvbnRleHQuc3JjW2NvbW1lbnQucmFuZ2Uuc3RhcnQgLSAxXTtcblxuICBpZiAocHJldiAhPT0gJ1xcbicgJiYgcHJldiAhPT0gJ1xcdCcgJiYgcHJldiAhPT0gJyAnKSB7XG4gICAgY29uc3QgbXNnID0gJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnO1xuICAgIGVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKGNvbW1lbnQsIG1zZykpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMb25nS2V5RXJyb3Ioc291cmNlLCBrZXkpIHtcbiAgY29uc3Qgc2sgPSBTdHJpbmcoa2V5KTtcbiAgY29uc3QgayA9IHNrLnN1YnN0cigwLCA4KSArICcuLi4nICsgc2suc3Vic3RyKC04KTtcbiAgcmV0dXJuIG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKHNvdXJjZSwgYFRoZSBcIiR7a31cIiBrZXkgaXMgdG9vIGxvbmdgKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDb21tZW50cyhjb2xsZWN0aW9uLCBjb21tZW50cykge1xuICBmb3IgKGNvbnN0IHtcbiAgICBhZnRlcktleSxcbiAgICBiZWZvcmUsXG4gICAgY29tbWVudFxuICB9IG9mIGNvbW1lbnRzKSB7XG4gICAgbGV0IGl0ZW0gPSBjb2xsZWN0aW9uLml0ZW1zW2JlZm9yZV07XG5cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24uY29tbWVudCkgY29sbGVjdGlvbi5jb21tZW50ICs9ICdcXG4nICsgY29tbWVudDtlbHNlIGNvbGxlY3Rpb24uY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhZnRlcktleSAmJiBpdGVtLnZhbHVlKSBpdGVtID0gaXRlbS52YWx1ZTtcblxuICAgICAgaWYgKGNvbW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYWZ0ZXJLZXkgfHwgIWl0ZW0uY29tbWVudEJlZm9yZSkgaXRlbS5zcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKSBpdGVtLmNvbW1lbnRCZWZvcmUgKz0gJ1xcbicgKyBjb21tZW50O2Vsc2UgaXRlbS5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1hcChkb2MsIGNzdCkge1xuICBjb25zdCB7XG4gICAgY29tbWVudHMsXG4gICAgaXRlbXNcbiAgfSA9IGNzdC50eXBlID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRkxPV19NQVAgPyByZXNvbHZlRmxvd01hcEl0ZW1zKGRvYywgY3N0KSA6IHJlc29sdmVCbG9ja01hcEl0ZW1zKGRvYywgY3N0KTtcbiAgY29uc3QgbWFwID0gbmV3IHN0cmluZ2lmeU51bWJlci5ZQU1MTWFwKGRvYy5zY2hlbWEpO1xuICBtYXAuaXRlbXMgPSBpdGVtcztcbiAgcmVzb2x2ZUNvbW1lbnRzKG1hcCwgY29tbWVudHMpO1xuICBsZXQgaGFzQ29sbGVjdGlvbktleSA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCB7XG4gICAgICBrZXk6IGlLZXlcbiAgICB9ID0gaXRlbXNbaV07XG4gICAgaWYgKGlLZXkgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuQ29sbGVjdGlvbikgaGFzQ29sbGVjdGlvbktleSA9IHRydWU7XG5cbiAgICBpZiAoZG9jLnNjaGVtYS5tZXJnZSAmJiBpS2V5ICYmIGlLZXkudmFsdWUgPT09IFNjaGVtYS5NRVJHRV9LRVkpIHtcbiAgICAgIGl0ZW1zW2ldID0gbmV3IFNjaGVtYS5NZXJnZShpdGVtc1tpXSk7XG4gICAgICBjb25zdCBzb3VyY2VzID0gaXRlbXNbaV0udmFsdWUuaXRlbXM7XG4gICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgc291cmNlcy5zb21lKG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5BbGlhcykge1xuICAgICAgICAgIC8vIER1cmluZyBwYXJzaW5nLCBhbGlhcyBzb3VyY2VzIGFyZSBDU1Qgbm9kZXM7IHRvIGFjY291bnQgZm9yXG4gICAgICAgICAgLy8gY2lyY3VsYXIgcmVmZXJlbmNlcyB0aGVpciByZXNvbHZlZCB2YWx1ZXMgY2FuJ3QgYmUgdXNlZCBoZXJlLlxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICB9ID0gbm9kZS5zb3VyY2U7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5NQVAgfHwgdHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkZMT1dfTUFQKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGVycm9yID0gJ01lcmdlIG5vZGVzIGFsaWFzZXMgY2FuIG9ubHkgcG9pbnQgdG8gbWFwcyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3IgPSAnTWVyZ2Ugbm9kZXMgY2FuIG9ubHkgaGF2ZSBBbGlhcyBub2RlcyBhcyB2YWx1ZXMnO1xuICAgICAgfSk7XG4gICAgICBpZiAoZXJyb3IpIGRvYy5lcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihjc3QsIGVycm9yKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGl0ZW1zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBrZXk6IGpLZXlcbiAgICAgICAgfSA9IGl0ZW1zW2pdO1xuXG4gICAgICAgIGlmIChpS2V5ID09PSBqS2V5IHx8IGlLZXkgJiYgaktleSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaUtleSwgJ3ZhbHVlJykgJiYgaUtleS52YWx1ZSA9PT0gaktleS52YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IGBNYXAga2V5cyBtdXN0IGJlIHVuaXF1ZTsgXCIke2lLZXl9XCIgaXMgcmVwZWF0ZWRgO1xuICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihjc3QsIG1zZykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc0NvbGxlY3Rpb25LZXkgJiYgIWRvYy5vcHRpb25zLm1hcEFzTWFwKSB7XG4gICAgY29uc3Qgd2FybiA9ICdLZXlzIHdpdGggY29sbGVjdGlvbiB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZCBhcyBZQU1MIGR1ZSB0byBKUyBPYmplY3QgcmVzdHJpY3Rpb25zLiBVc2UgbWFwQXNNYXA6IHRydWUgdG8gYXZvaWQgdGhpcy4nO1xuICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxXYXJuaW5nKGNzdCwgd2FybikpO1xuICB9XG5cbiAgY3N0LnJlc29sdmVkID0gbWFwO1xuICByZXR1cm4gbWFwO1xufVxuXG5jb25zdCB2YWx1ZUhhc1BhaXJDb21tZW50ID0gKHtcbiAgY29udGV4dDoge1xuICAgIGxpbmVTdGFydCxcbiAgICBub2RlLFxuICAgIHNyY1xuICB9LFxuICBwcm9wc1xufSkgPT4ge1xuICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHtcbiAgICBzdGFydFxuICB9ID0gcHJvcHNbMF07XG4gIGlmIChub2RlICYmIHN0YXJ0ID4gbm9kZS52YWx1ZVJhbmdlLnN0YXJ0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChzcmNbc3RhcnRdICE9PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLkNoYXIuQ09NTUVOVCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSBsaW5lU3RhcnQ7IGkgPCBzdGFydDsgKytpKSBpZiAoc3JjW2ldID09PSAnXFxuJykgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVBhaXJDb21tZW50KGl0ZW0sIHBhaXIpIHtcbiAgaWYgKCF2YWx1ZUhhc1BhaXJDb21tZW50KGl0ZW0pKSByZXR1cm47XG4gIGNvbnN0IGNvbW1lbnQgPSBpdGVtLmdldFByb3BWYWx1ZSgwLCBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLkNoYXIuQ09NTUVOVCwgdHJ1ZSk7XG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuICBjb25zdCBjYiA9IHBhaXIudmFsdWUuY29tbWVudEJlZm9yZTtcblxuICBpZiAoY2IgJiYgY2Iuc3RhcnRzV2l0aChjb21tZW50KSkge1xuICAgIHBhaXIudmFsdWUuY29tbWVudEJlZm9yZSA9IGNiLnN1YnN0cihjb21tZW50Lmxlbmd0aCArIDEpO1xuICAgIGZvdW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYyA9IHBhaXIudmFsdWUuY29tbWVudDtcblxuICAgIGlmICghaXRlbS5ub2RlICYmIGNjICYmIGNjLnN0YXJ0c1dpdGgoY29tbWVudCkpIHtcbiAgICAgIHBhaXIudmFsdWUuY29tbWVudCA9IGNjLnN1YnN0cihjb21tZW50Lmxlbmd0aCArIDEpO1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZCkgcGFpci5jb21tZW50ID0gY29tbWVudDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrTWFwSXRlbXMoZG9jLCBjc3QpIHtcbiAgY29uc3QgY29tbWVudHMgPSBbXTtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgbGV0IGtleSA9IHVuZGVmaW5lZDtcbiAgbGV0IGtleVN0YXJ0ID0gbnVsbDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNzdC5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBjc3QuaXRlbXNbaV07XG5cbiAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuICAgICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxBTktfTElORTpcbiAgICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgICAgYWZ0ZXJLZXk6ICEha2V5LFxuICAgICAgICAgIGJlZm9yZTogaXRlbXMubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQ09NTUVOVDpcbiAgICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgICAgYWZ0ZXJLZXk6ICEha2V5LFxuICAgICAgICAgIGJlZm9yZTogaXRlbXMubGVuZ3RoLFxuICAgICAgICAgIGNvbW1lbnQ6IGl0ZW0uY29tbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLk1BUF9LRVk6XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkgaXRlbXMucHVzaChuZXcgc3RyaW5naWZ5TnVtYmVyLlBhaXIoa2V5KSk7XG4gICAgICAgIGlmIChpdGVtLmVycm9yKSBkb2MuZXJyb3JzLnB1c2goaXRlbS5lcnJvcik7XG4gICAgICAgIGtleSA9IHJlc29sdmVOb2RlKGRvYywgaXRlbS5ub2RlKTtcbiAgICAgICAga2V5U3RhcnQgPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuTUFQX1ZBTFVFOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSBrZXkgPSBudWxsO1xuICAgICAgICAgIGlmIChpdGVtLmVycm9yKSBkb2MuZXJyb3JzLnB1c2goaXRlbS5lcnJvcik7XG5cbiAgICAgICAgICBpZiAoIWl0ZW0uY29udGV4dC5hdExpbmVTdGFydCAmJiBpdGVtLm5vZGUgJiYgaXRlbS5ub2RlLnR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5NQVAgJiYgIWl0ZW0ubm9kZS5jb250ZXh0LmF0TGluZVN0YXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnTmVzdGVkIG1hcHBpbmdzIGFyZSBub3QgYWxsb3dlZCBpbiBjb21wYWN0IG1hcHBpbmdzJztcbiAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihpdGVtLm5vZGUsIG1zZykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB2YWx1ZU5vZGUgPSBpdGVtLm5vZGU7XG5cbiAgICAgICAgICBpZiAoIXZhbHVlTm9kZSAmJiBpdGVtLnByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIENvbW1lbnRzIG9uIGFuIGVtcHR5IG1hcHBpbmcgdmFsdWUgbmVlZCB0byBiZSBwcmVzZXJ2ZWQsIHNvIHdlXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNvbnN0cnVjdCBhIG1pbmltYWwgZW1wdHkgbm9kZSBoZXJlIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZVxuICAgICAgICAgICAgLy8gbWlzc2luZyBgaXRlbS5ub2RlYC4gLS0gZWVtZWxpL3lhbWwjMTlcbiAgICAgICAgICAgIHZhbHVlTm9kZSA9IG5ldyBwYXJzZUNzdC5QbGFpblZhbHVlKF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5QTEFJTiwgW10pO1xuICAgICAgICAgICAgdmFsdWVOb2RlLmNvbnRleHQgPSB7XG4gICAgICAgICAgICAgIHBhcmVudDogaXRlbSxcbiAgICAgICAgICAgICAgc3JjOiBpdGVtLmNvbnRleHQuc3JjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcG9zID0gaXRlbS5yYW5nZS5zdGFydCArIDE7XG4gICAgICAgICAgICB2YWx1ZU5vZGUucmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICAgICAgICAgIGVuZDogcG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWVOb2RlLnZhbHVlUmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICAgICAgICAgIGVuZDogcG9zXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0ucmFuZ2Uub3JpZ1N0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBjb25zdCBvcmlnUG9zID0gaXRlbS5yYW5nZS5vcmlnU3RhcnQgKyAxO1xuICAgICAgICAgICAgICB2YWx1ZU5vZGUucmFuZ2Uub3JpZ1N0YXJ0ID0gdmFsdWVOb2RlLnJhbmdlLm9yaWdFbmQgPSBvcmlnUG9zO1xuICAgICAgICAgICAgICB2YWx1ZU5vZGUudmFsdWVSYW5nZS5vcmlnU3RhcnQgPSB2YWx1ZU5vZGUudmFsdWVSYW5nZS5vcmlnRW5kID0gb3JpZ1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IHN0cmluZ2lmeU51bWJlci5QYWlyKGtleSwgcmVzb2x2ZU5vZGUoZG9jLCB2YWx1ZU5vZGUpKTtcbiAgICAgICAgICByZXNvbHZlUGFpckNvbW1lbnQoaXRlbSwgcGFpcik7XG4gICAgICAgICAgaXRlbXMucHVzaChwYWlyKTtcblxuICAgICAgICAgIGlmIChrZXkgJiYgdHlwZW9mIGtleVN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucmFuZ2Uuc3RhcnQgPiBrZXlTdGFydCArIDEwMjQpIGRvYy5lcnJvcnMucHVzaChnZXRMb25nS2V5RXJyb3IoY3N0LCBrZXkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAga2V5U3RhcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIGl0ZW1zLnB1c2gobmV3IHN0cmluZ2lmeU51bWJlci5QYWlyKGtleSkpO1xuICAgICAgICBrZXkgPSByZXNvbHZlTm9kZShkb2MsIGl0ZW0pO1xuICAgICAgICBrZXlTdGFydCA9IGl0ZW0ucmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGlmIChpdGVtLmVycm9yKSBkb2MuZXJyb3JzLnB1c2goaXRlbS5lcnJvcik7XG5cbiAgICAgICAgbmV4dDogZm9yIChsZXQgaiA9IGkgKyAxOzsgKytqKSB7XG4gICAgICAgICAgY29uc3QgbmV4dEl0ZW0gPSBjc3QuaXRlbXNbal07XG5cbiAgICAgICAgICBzd2l0Y2ggKG5leHRJdGVtICYmIG5leHRJdGVtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkJMQU5LX0xJTkU6XG4gICAgICAgICAgICBjYXNlIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5DT01NRU5UOlxuICAgICAgICAgICAgICBjb250aW51ZSBuZXh0O1xuXG4gICAgICAgICAgICBjYXNlIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5NQVBfVkFMVUU6XG4gICAgICAgICAgICAgIGJyZWFrIG5leHQ7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnSW1wbGljaXQgbWFwIGtleXMgbmVlZCB0byBiZSBmb2xsb3dlZCBieSBtYXAgdmFsdWVzJztcbiAgICAgICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgbXNnKSk7XG4gICAgICAgICAgICAgICAgYnJlYWsgbmV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtLnZhbHVlUmFuZ2VDb250YWluc05ld2xpbmUpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnSW1wbGljaXQgbWFwIGtleXMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJztcbiAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgbXNnKSk7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCkgaXRlbXMucHVzaChuZXcgc3RyaW5naWZ5TnVtYmVyLlBhaXIoa2V5KSk7XG4gIHJldHVybiB7XG4gICAgY29tbWVudHMsXG4gICAgaXRlbXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZsb3dNYXBJdGVtcyhkb2MsIGNzdCkge1xuICBjb25zdCBjb21tZW50cyA9IFtdO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICBsZXQgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgbGV0IG5leHQgPSAneyc7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc3QuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gY3N0Lml0ZW1zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVtLmNoYXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoYXIsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGl0ZW07XG5cbiAgICAgIGlmIChjaGFyID09PSAnPycgJiYga2V5ID09PSB1bmRlZmluZWQgJiYgIWV4cGxpY2l0S2V5KSB7XG4gICAgICAgIGV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgbmV4dCA9ICc6JztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFyID09PSAnOicpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSBrZXkgPSBudWxsO1xuXG4gICAgICAgIGlmIChuZXh0ID09PSAnOicpIHtcbiAgICAgICAgICBuZXh0ID0gJywnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgJiYgY2hhciAhPT0gJywnKSBrZXkgPSBudWxsO1xuICAgICAgICAgIGV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKG5ldyBzdHJpbmdpZnlOdW1iZXIuUGFpcihrZXkpKTtcbiAgICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoY2hhciA9PT0gJywnKSB7XG4gICAgICAgICAgICBuZXh0ID0gJzonO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFyID09PSAnfScpIHtcbiAgICAgICAgaWYgKGkgPT09IGNzdC5pdGVtcy5sZW5ndGggLSAxKSBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gbmV4dCkge1xuICAgICAgICBuZXh0ID0gJzonO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbXNnID0gYEZsb3cgbWFwIGNvbnRhaW5zIGFuIHVuZXhwZWN0ZWQgJHtjaGFyfWA7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU3ludGF4RXJyb3IoY3N0LCBtc2cpO1xuICAgICAgZXJyLm9mZnNldCA9IG9mZnNldDtcbiAgICAgIGRvYy5lcnJvcnMucHVzaChlcnIpO1xuICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxBTktfTElORSkge1xuICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgIGFmdGVyS2V5OiAhIWtleSxcbiAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQ09NTUVOVCkge1xuICAgICAgY2hlY2tGbG93Q29tbWVudFNwYWNlKGRvYy5lcnJvcnMsIGl0ZW0pO1xuICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgIGFmdGVyS2V5OiAhIWtleSxcbiAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGgsXG4gICAgICAgIGNvbW1lbnQ6IGl0ZW0uY29tbWVudFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG5leHQgPT09ICcsJykgZG9jLmVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKGl0ZW0sICdTZXBhcmF0b3IgLCBtaXNzaW5nIGluIGZsb3cgbWFwJykpO1xuICAgICAga2V5ID0gcmVzb2x2ZU5vZGUoZG9jLCBpdGVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5leHQgIT09ICcsJykgZG9jLmVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKGl0ZW0sICdJbmRpY2F0b3IgOiBtaXNzaW5nIGluIGZsb3cgbWFwIGVudHJ5JykpO1xuICAgICAgaXRlbXMucHVzaChuZXcgc3RyaW5naWZ5TnVtYmVyLlBhaXIoa2V5LCByZXNvbHZlTm9kZShkb2MsIGl0ZW0pKSk7XG4gICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICBleHBsaWNpdEtleSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRmxvd0NvbGxlY3Rpb25FbmQoZG9jLmVycm9ycywgY3N0KTtcbiAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSBpdGVtcy5wdXNoKG5ldyBzdHJpbmdpZnlOdW1iZXIuUGFpcihrZXkpKTtcbiAgcmV0dXJuIHtcbiAgICBjb21tZW50cyxcbiAgICBpdGVtc1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2VxKGRvYywgY3N0KSB7XG4gIGNvbnN0IHtcbiAgICBjb21tZW50cyxcbiAgICBpdGVtc1xuICB9ID0gY3N0LnR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5GTE9XX1NFUSA/IHJlc29sdmVGbG93U2VxSXRlbXMoZG9jLCBjc3QpIDogcmVzb2x2ZUJsb2NrU2VxSXRlbXMoZG9jLCBjc3QpO1xuICBjb25zdCBzZXEgPSBuZXcgc3RyaW5naWZ5TnVtYmVyLllBTUxTZXEoZG9jLnNjaGVtYSk7XG4gIHNlcS5pdGVtcyA9IGl0ZW1zO1xuICByZXNvbHZlQ29tbWVudHMoc2VxLCBjb21tZW50cyk7XG5cbiAgaWYgKCFkb2Mub3B0aW9ucy5tYXBBc01hcCAmJiBpdGVtcy5zb21lKGl0ID0+IGl0IGluc3RhbmNlb2Ygc3RyaW5naWZ5TnVtYmVyLlBhaXIgJiYgaXQua2V5IGluc3RhbmNlb2Ygc3RyaW5naWZ5TnVtYmVyLkNvbGxlY3Rpb24pKSB7XG4gICAgY29uc3Qgd2FybiA9ICdLZXlzIHdpdGggY29sbGVjdGlvbiB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZCBhcyBZQU1MIGR1ZSB0byBKUyBPYmplY3QgcmVzdHJpY3Rpb25zLiBVc2UgbWFwQXNNYXA6IHRydWUgdG8gYXZvaWQgdGhpcy4nO1xuICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxXYXJuaW5nKGNzdCwgd2FybikpO1xuICB9XG5cbiAgY3N0LnJlc29sdmVkID0gc2VxO1xuICByZXR1cm4gc2VxO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTZXFJdGVtcyhkb2MsIGNzdCkge1xuICBjb25zdCBjb21tZW50cyA9IFtdO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3N0Lml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IGNzdC5pdGVtc1tpXTtcblxuICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgICBjYXNlIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5CTEFOS19MSU5FOlxuICAgICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkNPTU1FTlQ6XG4gICAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICAgIGNvbW1lbnQ6IGl0ZW0uY29tbWVudCxcbiAgICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlNFUV9JVEVNOlxuICAgICAgICBpZiAoaXRlbS5lcnJvcikgZG9jLmVycm9ycy5wdXNoKGl0ZW0uZXJyb3IpO1xuICAgICAgICBpdGVtcy5wdXNoKHJlc29sdmVOb2RlKGRvYywgaXRlbS5ub2RlKSk7XG5cbiAgICAgICAgaWYgKGl0ZW0uaGFzUHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnU2VxdWVuY2UgaXRlbXMgY2Fubm90IGhhdmUgdGFncyBvciBhbmNob3JzIGJlZm9yZSB0aGUgLSBpbmRpY2F0b3InO1xuICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihpdGVtLCBtc2cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoaXRlbS5lcnJvcikgZG9jLmVycm9ycy5wdXNoKGl0ZW0uZXJyb3IpO1xuICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFN5bnRheEVycm9yKGl0ZW0sIGBVbmV4cGVjdGVkICR7aXRlbS50eXBlfSBub2RlIGluIHNlcXVlbmNlYCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tbWVudHMsXG4gICAgaXRlbXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZsb3dTZXFJdGVtcyhkb2MsIGNzdCkge1xuICBjb25zdCBjb21tZW50cyA9IFtdO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBsZXQgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgbGV0IGtleSA9IHVuZGVmaW5lZDtcbiAgbGV0IGtleVN0YXJ0ID0gbnVsbDtcbiAgbGV0IG5leHQgPSAnWyc7XG4gIGxldCBwcmV2SXRlbSA9IG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc3QuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gY3N0Lml0ZW1zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVtLmNoYXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoYXIsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGl0ZW07XG5cbiAgICAgIGlmIChjaGFyICE9PSAnOicgJiYgKGV4cGxpY2l0S2V5IHx8IGtleSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBpZiAoZXhwbGljaXRLZXkgJiYga2V5ID09PSB1bmRlZmluZWQpIGtleSA9IG5leHQgPyBpdGVtcy5wb3AoKSA6IG51bGw7XG4gICAgICAgIGl0ZW1zLnB1c2gobmV3IHN0cmluZ2lmeU51bWJlci5QYWlyKGtleSkpO1xuICAgICAgICBleHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGtleVN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXIgPT09IG5leHQpIHtcbiAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCFuZXh0ICYmIGNoYXIgPT09ICc/Jykge1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5leHQgIT09ICdbJyAmJiBjaGFyID09PSAnOicgJiYga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG5leHQgPT09ICcsJykge1xuICAgICAgICAgIGtleSA9IGl0ZW1zLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5QYWlyKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnQ2hhaW5pbmcgZmxvdyBzZXF1ZW5jZSBwYWlycyBpcyBpbnZhbGlkJztcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKGNzdCwgbXNnKTtcbiAgICAgICAgICAgIGVyci5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWV4cGxpY2l0S2V5ICYmIHR5cGVvZiBrZXlTdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleUVuZCA9IGl0ZW0ucmFuZ2UgPyBpdGVtLnJhbmdlLnN0YXJ0IDogaXRlbS5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoa2V5RW5kID4ga2V5U3RhcnQgKyAxMDI0KSBkb2MuZXJyb3JzLnB1c2goZ2V0TG9uZ0tleUVycm9yKGNzdCwga2V5KSk7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHNyY1xuICAgICAgICAgICAgfSA9IHByZXZJdGVtLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBrZXlTdGFydDsgaSA8IGtleUVuZDsgKytpKSBpZiAoc3JjW2ldID09PSAnXFxuJykge1xuICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnSW1wbGljaXQga2V5cyBvZiBmbG93IHNlcXVlbmNlIHBhaXJzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZSc7XG4gICAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihwcmV2SXRlbSwgbXNnKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5U3RhcnQgPSBudWxsO1xuICAgICAgICBleHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBuZXh0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gJ1snIHx8IGNoYXIgIT09ICddJyB8fCBpIDwgY3N0Lml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYEZsb3cgc2VxdWVuY2UgY29udGFpbnMgYW4gdW5leHBlY3RlZCAke2NoYXJ9YDtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFN5bnRheEVycm9yKGNzdCwgbXNnKTtcbiAgICAgICAgZXJyLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgZG9jLmVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5CTEFOS19MSU5FKSB7XG4gICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQ09NTUVOVCkge1xuICAgICAgY2hlY2tGbG93Q29tbWVudFNwYWNlKGRvYy5lcnJvcnMsIGl0ZW0pO1xuICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgIGNvbW1lbnQ6IGl0ZW0uY29tbWVudCxcbiAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgYSAke25leHR9IGluIGZsb3cgc2VxdWVuY2VgO1xuICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgbXNnKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZU5vZGUoZG9jLCBpdGVtKTtcblxuICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICBwcmV2SXRlbSA9IGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtcy5wdXNoKG5ldyBzdHJpbmdpZnlOdW1iZXIuUGFpcihrZXksIHZhbHVlKSk7XG4gICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAga2V5U3RhcnQgPSBpdGVtLnJhbmdlLnN0YXJ0O1xuICAgICAgbmV4dCA9ICcsJztcbiAgICB9XG4gIH1cblxuICBjaGVja0Zsb3dDb2xsZWN0aW9uRW5kKGRvYy5lcnJvcnMsIGNzdCk7XG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCkgaXRlbXMucHVzaChuZXcgc3RyaW5naWZ5TnVtYmVyLlBhaXIoa2V5KSk7XG4gIHJldHVybiB7XG4gICAgY29tbWVudHMsXG4gICAgaXRlbXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUJ5VGFnTmFtZSh7XG4gIGtub3duVGFncyxcbiAgdGFnc1xufSwgdGFnTmFtZSwgdmFsdWUsIG9uRXJyb3IpIHtcbiAgY29uc3QgbWF0Y2hXaXRoVGVzdCA9IFtdO1xuXG4gIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICBpZiAodGFnLnRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgaWYgKHRhZy50ZXN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSBtYXRjaFdpdGhUZXN0LnB1c2godGFnKTtlbHNlIG9uRXJyb3IoYFRoZSB0YWcgJHt0YWdOYW1lfSBjYW5ub3QgYmUgYXBwbGllZCB0byBhIGNvbGxlY3Rpb25gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlKHZhbHVlLCBvbkVycm9yKTtcbiAgICAgICAgcmV0dXJuIHJlcyBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5Db2xsZWN0aW9uID8gcmVzIDogbmV3IHN0cmluZ2lmeU51bWJlci5TY2FsYXIocmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobWF0Y2hXaXRoVGVzdC5sZW5ndGggPiAwKSByZXR1cm4gc3RyaW5naWZ5TnVtYmVyLnJlc29sdmVTY2FsYXIodmFsdWUsIG1hdGNoV2l0aFRlc3QpO1xuICBjb25zdCBrdCA9IGtub3duVGFnc1t0YWdOYW1lXTtcblxuICBpZiAoa3QpIHtcbiAgICB0YWdzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwga3QsIHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgdGVzdDogdW5kZWZpbmVkXG4gICAgfSkpO1xuICAgIGNvbnN0IHJlcyA9IGt0LnJlc29sdmUodmFsdWUsIG9uRXJyb3IpO1xuICAgIHJldHVybiByZXMgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuQ29sbGVjdGlvbiA/IHJlcyA6IG5ldyBzdHJpbmdpZnlOdW1iZXIuU2NhbGFyKHJlcyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhZyhkb2MsIG5vZGUsIHRhZ05hbWUpIHtcbiAgY29uc3Qge1xuICAgIE1BUCxcbiAgICBTRVEsXG4gICAgU1RSXG4gIH0gPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmRlZmF1bHRUYWdzO1xuICBsZXQgdmFsdWUsIGZhbGxiYWNrO1xuXG4gIGNvbnN0IG9uRXJyb3IgPSBtZXNzYWdlID0+IGRvYy5lcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihub2RlLCBtZXNzYWdlKSk7XG5cbiAgdHJ5IHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRkxPV19NQVA6XG4gICAgICBjYXNlIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5NQVA6XG4gICAgICAgIHZhbHVlID0gcmVzb2x2ZU1hcChkb2MsIG5vZGUpO1xuICAgICAgICBmYWxsYmFjayA9IE1BUDtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09IFNFUSB8fCB0YWdOYW1lID09PSBTVFIpIG9uRXJyb3IoYFRoZSB0YWcgJHt0YWdOYW1lfSBjYW5ub3QgYmUgYXBwbGllZCB0byBhIG1hcHBpbmdgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkZMT1dfU0VROlxuICAgICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuU0VROlxuICAgICAgICB2YWx1ZSA9IHJlc29sdmVTZXEoZG9jLCBub2RlKTtcbiAgICAgICAgZmFsbGJhY2sgPSBTRVE7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSBNQVAgfHwgdGFnTmFtZSA9PT0gU1RSKSBvbkVycm9yKGBUaGUgdGFnICR7dGFnTmFtZX0gY2Fubm90IGJlIGFwcGxpZWQgdG8gYSBzZXF1ZW5jZWApO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFsdWUgPSBub2RlLnN0clZhbHVlIHx8ICcnO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFsdWUuZXJyb3JzLmZvckVhY2goZXJyb3IgPT4gZG9jLmVycm9ycy5wdXNoKGVycm9yKSk7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdHI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gTUFQIHx8IHRhZ05hbWUgPT09IFNFUSkgb25FcnJvcihgVGhlIHRhZyAke3RhZ05hbWV9IGNhbm5vdCBiZSBhcHBsaWVkIHRvIGEgc2NhbGFyYCk7XG4gICAgICAgIGZhbGxiYWNrID0gU1RSO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IHJlc29sdmVCeVRhZ05hbWUoZG9jLnNjaGVtYSwgdGFnTmFtZSwgdmFsdWUsIG9uRXJyb3IpO1xuXG4gICAgaWYgKHJlcykge1xuICAgICAgaWYgKHRhZ05hbWUgJiYgbm9kZS50YWcpIHJlcy50YWcgPSB0YWdOYW1lO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFlcnJvci5zb3VyY2UpIGVycm9yLnNvdXJjZSA9IG5vZGU7XG4gICAgZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKCFmYWxsYmFjaykgdGhyb3cgbmV3IEVycm9yKGBUaGUgdGFnICR7dGFnTmFtZX0gaXMgdW5hdmFpbGFibGVgKTtcbiAgICBjb25zdCBtc2cgPSBgVGhlIHRhZyAke3RhZ05hbWV9IGlzIHVuYXZhaWxhYmxlLCBmYWxsaW5nIGJhY2sgdG8gJHtmYWxsYmFja31gO1xuICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxXYXJuaW5nKG5vZGUsIG1zZykpO1xuICAgIGNvbnN0IHJlcyA9IHJlc29sdmVCeVRhZ05hbWUoZG9jLnNjaGVtYSwgZmFsbGJhY2ssIHZhbHVlLCBvbkVycm9yKTtcbiAgICByZXMudGFnID0gdGFnTmFtZTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IHJlZkVycm9yID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFJlZmVyZW5jZUVycm9yKG5vZGUsIGVycm9yLm1lc3NhZ2UpO1xuICAgIHJlZkVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgZG9jLmVycm9ycy5wdXNoKHJlZkVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBpc0NvbGxlY3Rpb25JdGVtID0gbm9kZSA9PiB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB7XG4gICAgdHlwZVxuICB9ID0gbm9kZTtcbiAgcmV0dXJuIHR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5NQVBfS0VZIHx8IHR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5NQVBfVkFMVUUgfHwgdHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlNFUV9JVEVNO1xufTtcblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGVQcm9wcyhlcnJvcnMsIG5vZGUpIHtcbiAgY29uc3QgY29tbWVudHMgPSB7XG4gICAgYmVmb3JlOiBbXSxcbiAgICBhZnRlcjogW11cbiAgfTtcbiAgbGV0IGhhc0FuY2hvciA9IGZhbHNlO1xuICBsZXQgaGFzVGFnID0gZmFsc2U7XG4gIGNvbnN0IHByb3BzID0gaXNDb2xsZWN0aW9uSXRlbShub2RlLmNvbnRleHQucGFyZW50KSA/IG5vZGUuY29udGV4dC5wYXJlbnQucHJvcHMuY29uY2F0KG5vZGUucHJvcHMpIDogbm9kZS5wcm9wcztcblxuICBmb3IgKGNvbnN0IHtcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgfSBvZiBwcm9wcykge1xuICAgIHN3aXRjaCAobm9kZS5jb250ZXh0LnNyY1tzdGFydF0pIHtcbiAgICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5DaGFyLkNPTU1FTlQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIW5vZGUuY29tbWVudEhhc1JlcXVpcmVkV2hpdGVzcGFjZShzdGFydCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJztcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIG1zZykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgIHZhbHVlUmFuZ2VcbiAgICAgICAgICB9ID0gbm9kZTtcbiAgICAgICAgICBjb25zdCBjYyA9IHZhbHVlUmFuZ2UgJiYgKHN0YXJ0ID4gdmFsdWVSYW5nZS5zdGFydCB8fCBoZWFkZXIgJiYgc3RhcnQgPiBoZWFkZXIuc3RhcnQpID8gY29tbWVudHMuYWZ0ZXIgOiBjb21tZW50cy5iZWZvcmU7XG4gICAgICAgICAgY2MucHVzaChub2RlLmNvbnRleHQuc3JjLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIEFjdHVhbCBhbmNob3IgJiB0YWcgcmVzb2x1dGlvbiBpcyBoYW5kbGVkIGJ5IHNjaGVtYSwgaGVyZSB3ZSBqdXN0IGNvbXBsYWluXG5cbiAgICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5DaGFyLkFOQ0hPUjpcbiAgICAgICAgaWYgKGhhc0FuY2hvcikge1xuICAgICAgICAgIGNvbnN0IG1zZyA9ICdBIG5vZGUgY2FuIGhhdmUgYXQgbW9zdCBvbmUgYW5jaG9yJztcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0FuY2hvciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuQ2hhci5UQUc6XG4gICAgICAgIGlmIChoYXNUYWcpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnQSBub2RlIGNhbiBoYXZlIGF0IG1vc3Qgb25lIHRhZyc7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgbXNnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNUYWcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbW1lbnRzLFxuICAgIGhhc0FuY2hvcixcbiAgICBoYXNUYWdcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGVWYWx1ZShkb2MsIG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvcnMsXG4gICAgZXJyb3JzLFxuICAgIHNjaGVtYVxuICB9ID0gZG9jO1xuXG4gIGlmIChub2RlLnR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5BTElBUykge1xuICAgIGNvbnN0IG5hbWUgPSBub2RlLnJhd1ZhbHVlO1xuICAgIGNvbnN0IHNyYyA9IGFuY2hvcnMuZ2V0Tm9kZShuYW1lKTtcblxuICAgIGlmICghc3JjKSB7XG4gICAgICBjb25zdCBtc2cgPSBgQWxpYXNlZCBhbmNob3Igbm90IGZvdW5kOiAke25hbWV9YDtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxSZWZlcmVuY2VFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gTGF6eSByZXNvbHV0aW9uIGZvciBjaXJjdWxhciByZWZlcmVuY2VzXG5cblxuICAgIGNvbnN0IHJlcyA9IG5ldyBzdHJpbmdpZnlOdW1iZXIuQWxpYXMoc3JjKTtcblxuICAgIGFuY2hvcnMuX2NzdEFsaWFzZXMucHVzaChyZXMpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGNvbnN0IHRhZ05hbWUgPSByZXNvbHZlVGFnTmFtZShkb2MsIG5vZGUpO1xuICBpZiAodGFnTmFtZSkgcmV0dXJuIHJlc29sdmVUYWcoZG9jLCBub2RlLCB0YWdOYW1lKTtcblxuICBpZiAobm9kZS50eXBlICE9PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuUExBSU4pIHtcbiAgICBjb25zdCBtc2cgPSBgRmFpbGVkIHRvIHJlc29sdmUgJHtub2RlLnR5cGV9IG5vZGUgaGVyZWA7XG4gICAgZXJyb3JzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFN5bnRheEVycm9yKG5vZGUsIG1zZykpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsZXQgc3RyID0gbm9kZS5zdHJWYWx1ZSB8fCAnJztcblxuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgc3RyLmVycm9ycy5mb3JFYWNoKGVycm9yID0+IGRvYy5lcnJvcnMucHVzaChlcnJvcikpO1xuICAgICAgc3RyID0gc3RyLnN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyLnJlc29sdmVTY2FsYXIoc3RyLCBzY2hlbWEudGFncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFlcnJvci5zb3VyY2UpIGVycm9yLnNvdXJjZSA9IG5vZGU7XG4gICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59IC8vIHNldHMgbm9kZS5yZXNvbHZlZCBvbiBzdWNjZXNzXG5cblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUoZG9jLCBub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG4gIGlmIChub2RlLmVycm9yKSBkb2MuZXJyb3JzLnB1c2gobm9kZS5lcnJvcik7XG4gIGNvbnN0IHtcbiAgICBjb21tZW50cyxcbiAgICBoYXNBbmNob3IsXG4gICAgaGFzVGFnXG4gIH0gPSByZXNvbHZlTm9kZVByb3BzKGRvYy5lcnJvcnMsIG5vZGUpO1xuXG4gIGlmIChoYXNBbmNob3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JzXG4gICAgfSA9IGRvYztcbiAgICBjb25zdCBuYW1lID0gbm9kZS5hbmNob3I7XG4gICAgY29uc3QgcHJldiA9IGFuY2hvcnMuZ2V0Tm9kZShuYW1lKTsgLy8gQXQgdGhpcyBwb2ludCwgYWxpYXNlcyBmb3IgYW55IHByZWNlZGluZyBub2RlIHdpdGggdGhlIHNhbWUgYW5jaG9yXG4gICAgLy8gbmFtZSBoYXZlIGFscmVhZHkgYmVlbiByZXNvbHZlZCwgc28gaXQgbWF5IHNhZmVseSBiZSByZW5hbWVkLlxuXG4gICAgaWYgKHByZXYpIGFuY2hvcnMubWFwW2FuY2hvcnMubmV3TmFtZShuYW1lKV0gPSBwcmV2OyAvLyBEdXJpbmcgcGFyc2luZywgd2UgbmVlZCB0byBzdG9yZSB0aGUgQ1NUIG5vZGUgaW4gYW5jaG9ycy5tYXAgYXNcbiAgICAvLyBhbmNob3JzIG5lZWQgdG8gYmUgYXZhaWxhYmxlIGR1cmluZyByZXNvbHV0aW9uIHRvIGFsbG93IGZvclxuICAgIC8vIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG5cbiAgICBhbmNob3JzLm1hcFtuYW1lXSA9IG5vZGU7XG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQUxJQVMgJiYgKGhhc0FuY2hvciB8fCBoYXNUYWcpKSB7XG4gICAgY29uc3QgbXNnID0gJ0FuIGFsaWFzIG5vZGUgbXVzdCBub3Qgc3BlY2lmeSBhbnkgcHJvcGVydGllcyc7XG4gICAgZG9jLmVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIG1zZykpO1xuICB9XG5cbiAgY29uc3QgcmVzID0gcmVzb2x2ZU5vZGVWYWx1ZShkb2MsIG5vZGUpO1xuXG4gIGlmIChyZXMpIHtcbiAgICByZXMucmFuZ2UgPSBbbm9kZS5yYW5nZS5zdGFydCwgbm9kZS5yYW5nZS5lbmRdO1xuICAgIGlmIChkb2Mub3B0aW9ucy5rZWVwQ3N0Tm9kZXMpIHJlcy5jc3ROb2RlID0gbm9kZTtcbiAgICBpZiAoZG9jLm9wdGlvbnMua2VlcE5vZGVUeXBlcykgcmVzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgY29uc3QgY2IgPSBjb21tZW50cy5iZWZvcmUuam9pbignXFxuJyk7XG5cbiAgICBpZiAoY2IpIHtcbiAgICAgIHJlcy5jb21tZW50QmVmb3JlID0gcmVzLmNvbW1lbnRCZWZvcmUgPyBgJHtyZXMuY29tbWVudEJlZm9yZX1cXG4ke2NifWAgOiBjYjtcbiAgICB9XG5cbiAgICBjb25zdCBjYSA9IGNvbW1lbnRzLmFmdGVyLmpvaW4oJ1xcbicpO1xuICAgIGlmIChjYSkgcmVzLmNvbW1lbnQgPSByZXMuY29tbWVudCA/IGAke3Jlcy5jb21tZW50fVxcbiR7Y2F9YCA6IGNhO1xuICB9XG5cbiAgcmV0dXJuIG5vZGUucmVzb2x2ZWQgPSByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29udGVudHMoZG9jLCBjb250ZW50cykge1xuICBjb25zdCBjb21tZW50cyA9IHtcbiAgICBiZWZvcmU6IFtdLFxuICAgIGFmdGVyOiBbXVxuICB9O1xuICBsZXQgYm9keSA9IHVuZGVmaW5lZDtcbiAgbGV0IHNwYWNlQmVmb3JlID0gZmFsc2U7XG5cbiAgZm9yIChjb25zdCBub2RlIG9mIGNvbnRlbnRzKSB7XG4gICAgaWYgKG5vZGUudmFsdWVSYW5nZSkge1xuICAgICAgaWYgKGJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBtc2cgPSAnRG9jdW1lbnQgY29udGFpbnMgdHJhaWxpbmcgY29udGVudCBub3Qgc2VwYXJhdGVkIGJ5IGEgLi4uIG9yIC0tLSBsaW5lJztcbiAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTeW50YXhFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcyA9IHJlc29sdmVOb2RlKGRvYywgbm9kZSk7XG5cbiAgICAgIGlmIChzcGFjZUJlZm9yZSkge1xuICAgICAgICByZXMuc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgICAgICBzcGFjZUJlZm9yZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBib2R5ID0gcmVzO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jb21tZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjYyA9IGJvZHkgPT09IHVuZGVmaW5lZCA/IGNvbW1lbnRzLmJlZm9yZSA6IGNvbW1lbnRzLmFmdGVyO1xuICAgICAgY2MucHVzaChub2RlLmNvbW1lbnQpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxBTktfTElORSkge1xuICAgICAgc3BhY2VCZWZvcmUgPSB0cnVlO1xuXG4gICAgICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkICYmIGNvbW1lbnRzLmJlZm9yZS5sZW5ndGggPiAwICYmICFkb2MuY29tbWVudEJlZm9yZSkge1xuICAgICAgICAvLyBzcGFjZS1zZXBhcmF0ZWQgY29tbWVudHMgYXQgc3RhcnQgYXJlIHBhcnNlZCBhcyBkb2N1bWVudCBjb21tZW50c1xuICAgICAgICBkb2MuY29tbWVudEJlZm9yZSA9IGNvbW1lbnRzLmJlZm9yZS5qb2luKCdcXG4nKTtcbiAgICAgICAgY29tbWVudHMuYmVmb3JlID0gW107XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZG9jLmNvbnRlbnRzID0gYm9keSB8fCBudWxsO1xuXG4gIGlmICghYm9keSkge1xuICAgIGRvYy5jb21tZW50ID0gY29tbWVudHMuYmVmb3JlLmNvbmNhdChjb21tZW50cy5hZnRlcikuam9pbignXFxuJykgfHwgbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYiA9IGNvbW1lbnRzLmJlZm9yZS5qb2luKCdcXG4nKTtcblxuICAgIGlmIChjYikge1xuICAgICAgY29uc3QgY2JOb2RlID0gYm9keSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5Db2xsZWN0aW9uICYmIGJvZHkuaXRlbXNbMF0gPyBib2R5Lml0ZW1zWzBdIDogYm9keTtcbiAgICAgIGNiTm9kZS5jb21tZW50QmVmb3JlID0gY2JOb2RlLmNvbW1lbnRCZWZvcmUgPyBgJHtjYn1cXG4ke2NiTm9kZS5jb21tZW50QmVmb3JlfWAgOiBjYjtcbiAgICB9XG5cbiAgICBkb2MuY29tbWVudCA9IGNvbW1lbnRzLmFmdGVyLmpvaW4oJ1xcbicpIHx8IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhZ0RpcmVjdGl2ZSh7XG4gIHRhZ1ByZWZpeGVzXG59LCBkaXJlY3RpdmUpIHtcbiAgY29uc3QgW2hhbmRsZSwgcHJlZml4XSA9IGRpcmVjdGl2ZS5wYXJhbWV0ZXJzO1xuXG4gIGlmICghaGFuZGxlIHx8ICFwcmVmaXgpIHtcbiAgICBjb25zdCBtc2cgPSAnSW5zdWZmaWNpZW50IHBhcmFtZXRlcnMgZ2l2ZW4gZm9yICVUQUcgZGlyZWN0aXZlJztcbiAgICB0aHJvdyBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihkaXJlY3RpdmUsIG1zZyk7XG4gIH1cblxuICBpZiAodGFnUHJlZml4ZXMuc29tZShwID0+IHAuaGFuZGxlID09PSBoYW5kbGUpKSB7XG4gICAgY29uc3QgbXNnID0gJ1RoZSAlVEFHIGRpcmVjdGl2ZSBtdXN0IG9ubHkgYmUgZ2l2ZW4gYXQgbW9zdCBvbmNlIHBlciBoYW5kbGUgaW4gdGhlIHNhbWUgZG9jdW1lbnQuJztcbiAgICB0aHJvdyBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcihkaXJlY3RpdmUsIG1zZyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhhbmRsZSxcbiAgICBwcmVmaXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxEaXJlY3RpdmUoZG9jLCBkaXJlY3RpdmUpIHtcbiAgbGV0IFt2ZXJzaW9uXSA9IGRpcmVjdGl2ZS5wYXJhbWV0ZXJzO1xuICBpZiAoZGlyZWN0aXZlLm5hbWUgPT09ICdZQU1MOjEuMCcpIHZlcnNpb24gPSAnMS4wJztcblxuICBpZiAoIXZlcnNpb24pIHtcbiAgICBjb25zdCBtc2cgPSAnSW5zdWZmaWNpZW50IHBhcmFtZXRlcnMgZ2l2ZW4gZm9yICVZQU1MIGRpcmVjdGl2ZSc7XG4gICAgdGhyb3cgbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFNlbWFudGljRXJyb3IoZGlyZWN0aXZlLCBtc2cpO1xuICB9XG5cbiAgaWYgKCFkb2N1bWVudE9wdGlvbnNbdmVyc2lvbl0pIHtcbiAgICBjb25zdCB2MCA9IGRvYy52ZXJzaW9uIHx8IGRvYy5vcHRpb25zLnZlcnNpb247XG4gICAgY29uc3QgbXNnID0gYERvY3VtZW50IHdpbGwgYmUgcGFyc2VkIGFzIFlBTUwgJHt2MH0gcmF0aGVyIHRoYW4gWUFNTCAke3ZlcnNpb259YDtcbiAgICBkb2Mud2FybmluZ3MucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MV2FybmluZyhkaXJlY3RpdmUsIG1zZykpO1xuICB9XG5cbiAgcmV0dXJuIHZlcnNpb247XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGlyZWN0aXZlcyhkb2MsIGRpcmVjdGl2ZXMsIHByZXZEb2MpIHtcbiAgY29uc3QgZGlyZWN0aXZlQ29tbWVudHMgPSBbXTtcbiAgbGV0IGhhc0RpcmVjdGl2ZXMgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IGRpcmVjdGl2ZSBvZiBkaXJlY3RpdmVzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudCxcbiAgICAgIG5hbWVcbiAgICB9ID0gZGlyZWN0aXZlO1xuXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdUQUcnOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvYy50YWdQcmVmaXhlcy5wdXNoKHJlc29sdmVUYWdEaXJlY3RpdmUoZG9jLCBkaXJlY3RpdmUpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBkb2MuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdZQU1MJzpcbiAgICAgIGNhc2UgJ1lBTUw6MS4wJzpcbiAgICAgICAgaWYgKGRvYy52ZXJzaW9uKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ1RoZSAlWUFNTCBkaXJlY3RpdmUgbXVzdCBvbmx5IGJlIGdpdmVuIGF0IG1vc3Qgb25jZSBwZXIgZG9jdW1lbnQuJztcbiAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFNlbWFudGljRXJyb3IoZGlyZWN0aXZlLCBtc2cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9jLnZlcnNpb24gPSByZXNvbHZlWWFtbERpcmVjdGl2ZShkb2MsIGRpcmVjdGl2ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBgWUFNTCBvbmx5IHN1cHBvcnRzICVUQUcgYW5kICVZQU1MIGRpcmVjdGl2ZXMsIGFuZCBub3QgJSR7bmFtZX1gO1xuICAgICAgICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxXYXJuaW5nKGRpcmVjdGl2ZSwgbXNnKSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlmIChjb21tZW50KSBkaXJlY3RpdmVDb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICB9XG5cbiAgaWYgKHByZXZEb2MgJiYgIWhhc0RpcmVjdGl2ZXMgJiYgJzEuMScgPT09IChkb2MudmVyc2lvbiB8fCBwcmV2RG9jLnZlcnNpb24gfHwgZG9jLm9wdGlvbnMudmVyc2lvbikpIHtcbiAgICBjb25zdCBjb3B5VGFnUHJlZml4ID0gKHtcbiAgICAgIGhhbmRsZSxcbiAgICAgIHByZWZpeFxuICAgIH0pID0+ICh7XG4gICAgICBoYW5kbGUsXG4gICAgICBwcmVmaXhcbiAgICB9KTtcblxuICAgIGRvYy50YWdQcmVmaXhlcyA9IHByZXZEb2MudGFnUHJlZml4ZXMubWFwKGNvcHlUYWdQcmVmaXgpO1xuICAgIGRvYy52ZXJzaW9uID0gcHJldkRvYy52ZXJzaW9uO1xuICB9XG5cbiAgZG9jLmNvbW1lbnRCZWZvcmUgPSBkaXJlY3RpdmVDb21tZW50cy5qb2luKCdcXG4nKSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDb2xsZWN0aW9uKGNvbnRlbnRzKSB7XG4gIGlmIChjb250ZW50cyBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5Db2xsZWN0aW9uKSByZXR1cm4gdHJ1ZTtcbiAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIFlBTUwgY29sbGVjdGlvbiBhcyBkb2N1bWVudCBjb250ZW50cycpO1xufVxuXG5jbGFzcyBEb2N1bWVudCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLmFuY2hvcnMgPSBuZXcgQW5jaG9ycyh0aGlzLm9wdGlvbnMuYW5jaG9yUHJlZml4KTtcbiAgICB0aGlzLmNvbW1lbnRCZWZvcmUgPSBudWxsO1xuICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG4gICAgdGhpcy5kaXJlY3RpdmVzRW5kTWFya2VyID0gbnVsbDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMuc2NoZW1hID0gbnVsbDtcbiAgICB0aGlzLnRhZ1ByZWZpeGVzID0gW107XG4gICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICB0aGlzLndhcm5pbmdzID0gW107XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gbm90ZSB0aGF0IHRoaXMuc2NoZW1hIGlzIGxlZnQgYXMgbnVsbCBoZXJlXG4gICAgICB0aGlzLmNvbnRlbnRzID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgcGFyc2VDc3QuRG9jdW1lbnQpIHtcbiAgICAgIHRoaXMucGFyc2UodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRlbnRzID0gdGhpcy5jcmVhdGVOb2RlKHZhbHVlLCB7XG4gICAgICAgIHJlcGxhY2VyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhZGQodmFsdWUpIHtcbiAgICBhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLmFkZCh2YWx1ZSk7XG4gIH1cblxuICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cyk7XG4gICAgdGhpcy5jb250ZW50cy5hZGRJbihwYXRoLCB2YWx1ZSk7XG4gIH1cblxuICBjcmVhdGVOb2RlKHZhbHVlLCB7XG4gICAga2VlcFVuZGVmaW5lZCxcbiAgICBvblRhZ09iaixcbiAgICByZXBsYWNlcixcbiAgICB0YWcsXG4gICAgd3JhcFNjYWxhcnNcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5zZXRTY2hlbWEoKTtcbiAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoe1xuICAgICAgJyc6IHZhbHVlXG4gICAgfSwgJycsIHZhbHVlKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgY29uc3Qga2V5VG9TdHIgPSB2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB2IGluc3RhbmNlb2YgU3RyaW5nIHx8IHYgaW5zdGFuY2VvZiBOdW1iZXI7XG5cbiAgICAgIGNvbnN0IGFzU3RyID0gcmVwbGFjZXIuZmlsdGVyKGtleVRvU3RyKS5tYXAoU3RyaW5nKTtcbiAgICAgIGlmIChhc1N0ci5sZW5ndGggPiAwKSByZXBsYWNlciA9IHJlcGxhY2VyLmNvbmNhdChhc1N0cik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2VlcFVuZGVmaW5lZCAhPT0gJ2Jvb2xlYW4nKSBrZWVwVW5kZWZpbmVkID0gISF0aGlzLm9wdGlvbnMua2VlcFVuZGVmaW5lZDtcbiAgICBjb25zdCBhbGlhc05vZGVzID0gW107XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAga2VlcFVuZGVmaW5lZCxcblxuICAgICAgb25BbGlhcyhzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgYWxpYXMgPSBuZXcgc3RyaW5naWZ5TnVtYmVyLkFsaWFzKHNvdXJjZSk7XG4gICAgICAgIGFsaWFzTm9kZXMucHVzaChhbGlhcyk7XG4gICAgICAgIHJldHVybiBhbGlhcztcbiAgICAgIH0sXG5cbiAgICAgIG9uVGFnT2JqLFxuICAgICAgcHJldk9iamVjdHM6IG5ldyBNYXAoKSxcbiAgICAgIHJlcGxhY2VyLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIHdyYXBTY2FsYXJzOiB3cmFwU2NhbGFycyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IG5vZGUgPSBzdHJpbmdpZnlOdW1iZXIuY3JlYXRlTm9kZSh2YWx1ZSwgdGFnLCBjdHgpO1xuXG4gICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc05vZGVzKSB7XG4gICAgICAvLyBXaXRoIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHRoZSBzb3VyY2Ugbm9kZSBpcyBvbmx5IHJlc29sdmVkIGFmdGVyIGFsbCBvZlxuICAgICAgLy8gaXRzIGNoaWxkIG5vZGVzIGFyZS4gVGhpcyBpcyB3aHkgYW5jaG9ycyBhcmUgc2V0IG9ubHkgYWZ0ZXIgYWxsIG9mIHRoZVxuICAgICAgLy8gbm9kZXMgaGF2ZSBiZWVuIGNyZWF0ZWQuXG4gICAgICBhbGlhcy5zb3VyY2UgPSBhbGlhcy5zb3VyY2Uubm9kZTtcbiAgICAgIGxldCBuYW1lID0gdGhpcy5hbmNob3JzLmdldE5hbWUoYWxpYXMuc291cmNlKTtcblxuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLmFuY2hvcnMubmV3TmFtZSgpO1xuICAgICAgICB0aGlzLmFuY2hvcnMubWFwW25hbWVdID0gYWxpYXMuc291cmNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgY3JlYXRlUGFpcihrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBrID0gdGhpcy5jcmVhdGVOb2RlKGtleSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdiA9IHRoaXMuY3JlYXRlTm9kZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBzdHJpbmdpZnlOdW1iZXIuUGFpcihrLCB2KTtcbiAgfVxuXG4gIGRlbGV0ZShrZXkpIHtcbiAgICBhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZGVsZXRlSW4ocGF0aCkge1xuICAgIGlmIChzdHJpbmdpZnlOdW1iZXIuaXNFbXB0eVBhdGgocGF0aCkpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMuY29udGVudHMgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cy5kZWxldGVJbihwYXRoKTtcbiAgfVxuXG4gIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiBEb2N1bWVudC5kZWZhdWx0c1t0aGlzLnZlcnNpb25dIHx8IERvY3VtZW50LmRlZmF1bHRzW3RoaXMub3B0aW9ucy52ZXJzaW9uXSB8fCB7fTtcbiAgfVxuXG4gIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cyBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5Db2xsZWN0aW9uID8gdGhpcy5jb250ZW50cy5nZXQoa2V5LCBrZWVwU2NhbGFyKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldEluKHBhdGgsIGtlZXBTY2FsYXIpIHtcbiAgICBpZiAoc3RyaW5naWZ5TnVtYmVyLmlzRW1wdHlQYXRoKHBhdGgpKSByZXR1cm4gIWtlZXBTY2FsYXIgJiYgdGhpcy5jb250ZW50cyBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5TY2FsYXIgPyB0aGlzLmNvbnRlbnRzLnZhbHVlIDogdGhpcy5jb250ZW50cztcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cyBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5Db2xsZWN0aW9uID8gdGhpcy5jb250ZW50cy5nZXRJbihwYXRoLCBrZWVwU2NhbGFyKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cyBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5Db2xsZWN0aW9uID8gdGhpcy5jb250ZW50cy5oYXMoa2V5KSA6IGZhbHNlO1xuICB9XG5cbiAgaGFzSW4ocGF0aCkge1xuICAgIGlmIChzdHJpbmdpZnlOdW1iZXIuaXNFbXB0eVBhdGgocGF0aCkpIHJldHVybiB0aGlzLmNvbnRlbnRzICE9PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHMgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuQ29sbGVjdGlvbiA/IHRoaXMuY29udGVudHMuaGFzSW4ocGF0aCkgOiBmYWxzZTtcbiAgfVxuXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuY29udGVudHMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5zZXRTY2hlbWEoKTtcbiAgICAgIHRoaXMuY29udGVudHMgPSBzdHJpbmdpZnlOdW1iZXIuY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCBba2V5XSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpO1xuICAgICAgdGhpcy5jb250ZW50cy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc2V0SW4ocGF0aCwgdmFsdWUpIHtcbiAgICBpZiAoc3RyaW5naWZ5TnVtYmVyLmlzRW1wdHlQYXRoKHBhdGgpKSB0aGlzLmNvbnRlbnRzID0gdmFsdWU7ZWxzZSBpZiAodGhpcy5jb250ZW50cyA9PSBudWxsKSB7XG4gICAgICB0aGlzLnNldFNjaGVtYSgpO1xuICAgICAgdGhpcy5jb250ZW50cyA9IHN0cmluZ2lmeU51bWJlci5jb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHBhdGgsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKTtcbiAgICAgIHRoaXMuY29udGVudHMuc2V0SW4ocGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHNldFNjaGVtYShpZCwgY3VzdG9tVGFncykge1xuICAgIGlmICghaWQgJiYgIWN1c3RvbVRhZ3MgJiYgdGhpcy5zY2hlbWEpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJykgaWQgPSBpZC50b0ZpeGVkKDEpO1xuXG4gICAgaWYgKGlkID09PSAnMS4wJyB8fCBpZCA9PT0gJzEuMScgfHwgaWQgPT09ICcxLjInKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uKSB0aGlzLnZlcnNpb24gPSBpZDtlbHNlIHRoaXMub3B0aW9ucy52ZXJzaW9uID0gaWQ7XG4gICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnNjaGVtYTtcbiAgICB9IGVsc2UgaWYgKGlkICYmIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zY2hlbWEgPSBpZDtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSkgdGhpcy5vcHRpb25zLmN1c3RvbVRhZ3MgPSBjdXN0b21UYWdzO1xuICAgIGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0RGVmYXVsdHMoKSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLnNjaGVtYSA9IG5ldyBTY2hlbWEuU2NoZW1hKG9wdCk7XG4gIH1cblxuICBwYXJzZShub2RlLCBwcmV2RG9jKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQ3N0Tm9kZXMpIHRoaXMuY3N0Tm9kZSA9IG5vZGU7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwTm9kZVR5cGVzKSB0aGlzLnR5cGUgPSAnRE9DVU1FTlQnO1xuICAgIGNvbnN0IHtcbiAgICAgIGRpcmVjdGl2ZXMgPSBbXSxcbiAgICAgIGNvbnRlbnRzID0gW10sXG4gICAgICBkaXJlY3RpdmVzRW5kTWFya2VyLFxuICAgICAgZXJyb3IsXG4gICAgICB2YWx1ZVJhbmdlXG4gICAgfSA9IG5vZGU7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGlmICghZXJyb3Iuc291cmNlKSBlcnJvci5zb3VyY2UgPSB0aGlzO1xuICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgfVxuXG4gICAgcGFyc2VEaXJlY3RpdmVzKHRoaXMsIGRpcmVjdGl2ZXMsIHByZXZEb2MpO1xuICAgIGlmIChkaXJlY3RpdmVzRW5kTWFya2VyKSB0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIgPSB0cnVlO1xuICAgIHRoaXMucmFuZ2UgPSB2YWx1ZVJhbmdlID8gW3ZhbHVlUmFuZ2Uuc3RhcnQsIHZhbHVlUmFuZ2UuZW5kXSA6IG51bGw7XG4gICAgdGhpcy5zZXRTY2hlbWEoKTtcbiAgICB0aGlzLmFuY2hvcnMuX2NzdEFsaWFzZXMgPSBbXTtcbiAgICBwYXJzZUNvbnRlbnRzKHRoaXMsIGNvbnRlbnRzKTtcbiAgICB0aGlzLmFuY2hvcnMucmVzb2x2ZU5vZGVzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXR0eUVycm9ycykge1xuICAgICAgZm9yIChjb25zdCBlcnJvciBvZiB0aGlzLmVycm9ycykgaWYgKGVycm9yIGluc3RhbmNlb2YgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MRXJyb3IpIGVycm9yLm1ha2VQcmV0dHkoKTtcblxuICAgICAgZm9yIChjb25zdCB3YXJuIG9mIHRoaXMud2FybmluZ3MpIGlmICh3YXJuIGluc3RhbmNlb2YgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MRXJyb3IpIHdhcm4ubWFrZVByZXR0eSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdE5vbkRlZmF1bHRUYWdzKCkge1xuICAgIHJldHVybiBsaXN0VGFnTmFtZXModGhpcy5jb250ZW50cykuZmlsdGVyKHQgPT4gdC5pbmRleE9mKF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuZGVmYXVsdFRhZ1ByZWZpeCkgIT09IDApO1xuICB9XG5cbiAgc2V0VGFnUHJlZml4KGhhbmRsZSwgcHJlZml4KSB7XG4gICAgaWYgKGhhbmRsZVswXSAhPT0gJyEnIHx8IGhhbmRsZVtoYW5kbGUubGVuZ3RoIC0gMV0gIT09ICchJykgdGhyb3cgbmV3IEVycm9yKCdIYW5kbGUgbXVzdCBzdGFydCBhbmQgZW5kIHdpdGggIScpO1xuXG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMudGFnUHJlZml4ZXMuZmluZChwID0+IHAuaGFuZGxlID09PSBoYW5kbGUpO1xuICAgICAgaWYgKHByZXYpIHByZXYucHJlZml4ID0gcHJlZml4O2Vsc2UgdGhpcy50YWdQcmVmaXhlcy5wdXNoKHtcbiAgICAgICAgaGFuZGxlLFxuICAgICAgICBwcmVmaXhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ1ByZWZpeGVzID0gdGhpcy50YWdQcmVmaXhlcy5maWx0ZXIocCA9PiBwLmhhbmRsZSAhPT0gaGFuZGxlKTtcbiAgICB9XG4gIH1cblxuICB0b0pTKHtcbiAgICBqc29uLFxuICAgIGpzb25BcmcsXG4gICAgbWFwQXNNYXAsXG4gICAgb25BbmNob3IsXG4gICAgcmV2aXZlclxuICB9ID0ge30pIHtcbiAgICBjb25zdCBhbmNob3JOb2RlcyA9IE9iamVjdC52YWx1ZXModGhpcy5hbmNob3JzLm1hcCkubWFwKG5vZGUgPT4gW25vZGUsIHtcbiAgICAgIGFsaWFzOiBbXSxcbiAgICAgIGFsaWFzQ291bnQ6IDAsXG4gICAgICBjb3VudDogMVxuICAgIH1dKTtcbiAgICBjb25zdCBhbmNob3JzID0gYW5jaG9yTm9kZXMubGVuZ3RoID4gMCA/IG5ldyBNYXAoYW5jaG9yTm9kZXMpIDogbnVsbDtcbiAgICBjb25zdCBjdHggPSB7XG4gICAgICBhbmNob3JzLFxuICAgICAgZG9jOiB0aGlzLFxuICAgICAgaW5kZW50U3RlcDogJyAgJyxcbiAgICAgIGtlZXA6ICFqc29uLFxuICAgICAgbWFwQXNNYXA6IHR5cGVvZiBtYXBBc01hcCA9PT0gJ2Jvb2xlYW4nID8gbWFwQXNNYXAgOiAhIXRoaXMub3B0aW9ucy5tYXBBc01hcCxcbiAgICAgIG1heEFsaWFzQ291bnQ6IHRoaXMub3B0aW9ucy5tYXhBbGlhc0NvdW50LFxuICAgICAgc3RyaW5naWZ5IC8vIFJlcXVpcmluZyBkaXJlY3RseSBpbiBQYWlyIHdvdWxkIGNyZWF0ZSBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuICAgIH07XG4gICAgY29uc3QgcmVzID0gc3RyaW5naWZ5TnVtYmVyLnRvSlModGhpcy5jb250ZW50cywganNvbkFyZyB8fCAnJywgY3R4KTtcbiAgICBpZiAodHlwZW9mIG9uQW5jaG9yID09PSAnZnVuY3Rpb24nICYmIGFuY2hvcnMpIGZvciAoY29uc3Qge1xuICAgICAgY291bnQsXG4gICAgICByZXNcbiAgICB9IG9mIGFuY2hvcnMudmFsdWVzKCkpIG9uQW5jaG9yKHJlcywgY291bnQpO1xuICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB7XG4gICAgICAnJzogcmVzXG4gICAgfSwgJycsIHJlcykgOiByZXM7XG4gIH1cblxuICB0b0pTT04oanNvbkFyZywgb25BbmNob3IpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTKHtcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBqc29uQXJnLFxuICAgICAgbWFwQXNNYXA6IGZhbHNlLFxuICAgICAgb25BbmNob3JcbiAgICB9KTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IHdpdGggZXJyb3JzIGNhbm5vdCBiZSBzdHJpbmdpZmllZCcpO1xuICAgIGNvbnN0IGluZGVudFNpemUgPSB0aGlzLm9wdGlvbnMuaW5kZW50O1xuXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluZGVudFNpemUpIHx8IGluZGVudFNpemUgPD0gMCkge1xuICAgICAgY29uc3QgcyA9IEpTT04uc3RyaW5naWZ5KGluZGVudFNpemUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcImluZGVudFwiIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgbm90ICR7c31gKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFNjaGVtYSgpO1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgbGV0IGhhc0RpcmVjdGl2ZXMgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnZlcnNpb24pIHtcbiAgICAgIGxldCB2ZCA9ICclWUFNTCAxLjInO1xuXG4gICAgICBpZiAodGhpcy5zY2hlbWEubmFtZSA9PT0gJ3lhbWwtMS4xJykge1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID09PSAnMS4wJykgdmQgPSAnJVlBTUw6MS4wJztlbHNlIGlmICh0aGlzLnZlcnNpb24gPT09ICcxLjEnKSB2ZCA9ICclWUFNTCAxLjEnO1xuICAgICAgfVxuXG4gICAgICBsaW5lcy5wdXNoKHZkKTtcbiAgICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHRhZ05hbWVzID0gdGhpcy5saXN0Tm9uRGVmYXVsdFRhZ3MoKTtcbiAgICB0aGlzLnRhZ1ByZWZpeGVzLmZvckVhY2goKHtcbiAgICAgIGhhbmRsZSxcbiAgICAgIHByZWZpeFxuICAgIH0pID0+IHtcbiAgICAgIGlmICh0YWdOYW1lcy5zb21lKHQgPT4gdC5pbmRleE9mKHByZWZpeCkgPT09IDApKSB7XG4gICAgICAgIGxpbmVzLnB1c2goYCVUQUcgJHtoYW5kbGV9ICR7cHJlZml4fWApO1xuICAgICAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaGFzRGlyZWN0aXZlcyB8fCB0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIpIGxpbmVzLnB1c2goJy0tLScpO1xuXG4gICAgaWYgKHRoaXMuY29tbWVudEJlZm9yZSkge1xuICAgICAgaWYgKGhhc0RpcmVjdGl2ZXMgfHwgIXRoaXMuZGlyZWN0aXZlc0VuZE1hcmtlcikgbGluZXMudW5zaGlmdCgnJyk7XG4gICAgICBsaW5lcy51bnNoaWZ0KHRoaXMuY29tbWVudEJlZm9yZS5yZXBsYWNlKC9eL2dtLCAnIycpKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdHggPSB7XG4gICAgICBhbmNob3JzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgZG9jOiB0aGlzLFxuICAgICAgaW5kZW50OiAnJyxcbiAgICAgIGluZGVudFN0ZXA6ICcgJy5yZXBlYXQoaW5kZW50U2l6ZSksXG4gICAgICBzdHJpbmdpZnkgLy8gUmVxdWlyaW5nIGRpcmVjdGx5IGluIG5vZGVzIHdvdWxkIGNyZWF0ZSBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuICAgIH07XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50Q29tbWVudCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5jb250ZW50cykge1xuICAgICAgaWYgKHRoaXMuY29udGVudHMgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuTm9kZSkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50cy5zcGFjZUJlZm9yZSAmJiAoaGFzRGlyZWN0aXZlcyB8fCB0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIpKSBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudHMuY29tbWVudEJlZm9yZSkgbGluZXMucHVzaCh0aGlzLmNvbnRlbnRzLmNvbW1lbnRCZWZvcmUucmVwbGFjZSgvXi9nbSwgJyMnKSk7IC8vIHRvcC1sZXZlbCBibG9jayBzY2FsYXJzIG5lZWQgdG8gYmUgaW5kZW50ZWQgaWYgZm9sbG93ZWQgYnkgYSBjb21tZW50XG5cbiAgICAgICAgY3R4LmZvcmNlQmxvY2tJbmRlbnQgPSAhIXRoaXMuY29tbWVudDtcbiAgICAgICAgY29udGVudENvbW1lbnQgPSB0aGlzLmNvbnRlbnRzLmNvbW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uQ2hvbXBLZWVwID0gY29udGVudENvbW1lbnQgPyBudWxsIDogKCkgPT4gY2hvbXBLZWVwID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGJvZHkgPSBzdHJpbmdpZnkodGhpcy5jb250ZW50cywgY3R4LCAoKSA9PiBjb250ZW50Q29tbWVudCA9IG51bGwsIG9uQ2hvbXBLZWVwKTtcbiAgICAgIGxpbmVzLnB1c2goc3RyaW5naWZ5TnVtYmVyLmFkZENvbW1lbnQoYm9keSwgJycsIGNvbnRlbnRDb21tZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVzLnB1c2goc3RyaW5naWZ5KHRoaXMuY29udGVudHMsIGN0eCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbW1lbnQpIHtcbiAgICAgIGlmICgoIWNob21wS2VlcCB8fCBjb250ZW50Q29tbWVudCkgJiYgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gIT09ICcnKSBsaW5lcy5wdXNoKCcnKTtcbiAgICAgIGxpbmVzLnB1c2godGhpcy5jb21tZW50LnJlcGxhY2UoL14vZ20sICcjJykpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKSArICdcXG4nO1xuICB9XG5cbn1cblxuX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5fZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQsIFwiZGVmYXVsdHNcIiwgZG9jdW1lbnRPcHRpb25zKTtcblxuZXhwb3J0cy5Eb2N1bWVudCA9IERvY3VtZW50O1xuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuZXhwb3J0cy5zY2FsYXJPcHRpb25zID0gc2NhbGFyT3B0aW9ucztcbiJdLCJuYW1lcyI6WyJfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzIiwicmVxdWlyZSIsInBhcnNlQ3N0Iiwic3RyaW5naWZ5TnVtYmVyIiwiU2NoZW1hIiwiZGVmYXVsdE9wdGlvbnMiLCJhbmNob3JQcmVmaXgiLCJjdXN0b21UYWdzIiwiaW5kZW50IiwiaW5kZW50U2VxIiwia2VlcENzdE5vZGVzIiwia2VlcE5vZGVUeXBlcyIsImtlZXBVbmRlZmluZWQiLCJtYXBBc01hcCIsIm1heEFsaWFzQ291bnQiLCJwcmV0dHlFcnJvcnMiLCJzaW1wbGVLZXlzIiwidmVyc2lvbiIsInNjYWxhck9wdGlvbnMiLCJiaW5hcnkiLCJiaW5hcnlPcHRpb25zIiwib3B0IiwiT2JqZWN0IiwiYXNzaWduIiwiYm9vbCIsImJvb2xPcHRpb25zIiwiaW50IiwiaW50T3B0aW9ucyIsIm51bGwiLCJudWxsT3B0aW9ucyIsInN0ciIsInN0ck9wdGlvbnMiLCJkb2N1bWVudE9wdGlvbnMiLCJzY2hlbWEiLCJtZXJnZSIsInRhZ1ByZWZpeGVzIiwiaGFuZGxlIiwicHJlZml4IiwiZGVmYXVsdFRhZ1ByZWZpeCIsInJlc29sdmVLbm93blRhZ3MiLCJzdHJpbmdpZnlUYWciLCJkb2MiLCJ0YWciLCJvcHRpb25zIiwicHJpdiIsIm1hdGNoIiwidm9jYWIiLCJyZXBsYWNlIiwicCIsImZpbmQiLCJpbmRleE9mIiwiZHRwIiwiZ2V0RGVmYXVsdHMiLCJzdWZmaXgiLCJzdWJzdHIiLCJsZW5ndGgiLCJjaCIsImdldFRhZ09iamVjdCIsInRhZ3MiLCJpdGVtIiwiQWxpYXMiLCJmaWx0ZXIiLCJ0IiwiZm9ybWF0IiwidGFnT2JqIiwib2JqIiwiU2NhbGFyIiwidmFsdWUiLCJpZGVudGlmeSIsIm5vZGVDbGFzcyIsIm5hbWUiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwic3RyaW5naWZ5UHJvcHMiLCJub2RlIiwiYW5jaG9ycyIsInByb3BzIiwiYW5jaG9yIiwiZ2V0TmFtZSIsInB1c2giLCJkZWZhdWx0Iiwiam9pbiIsInN0cmluZ2lmeSIsImN0eCIsIm9uQ29tbWVudCIsIm9uQ2hvbXBLZWVwIiwiTm9kZSIsImNyZWF0ZU5vZGUiLCJvblRhZ09iaiIsIm8iLCJ3cmFwU2NhbGFycyIsIlBhaXIiLCJ0b1N0cmluZyIsImluZGVudEF0U3RhcnQiLCJzdHJpbmdpZnlTdHJpbmciLCJBbmNob3JzIiwidmFsaWRBbmNob3JOb2RlIiwiWUFNTFNlcSIsIllBTUxNYXAiLCJfZGVmaW5lUHJvcGVydHkiLCJjcmVhdGUiLCJjcmVhdGVBbGlhcyIsInNldEFuY2hvciIsImNyZWF0ZU1lcmdlUGFpciIsInNvdXJjZXMiLCJNZXJnZSIsIml0ZW1zIiwibWFwIiwicyIsInNvdXJjZSIsImtleXMiLCJhIiwiZ2V0TmFtZXMiLCJnZXROb2RlIiwibmV3TmFtZSIsIm5hbWVzIiwiaSIsImluY2x1ZGVzIiwicmVzb2x2ZU5vZGVzIiwiX2NzdEFsaWFzZXMiLCJmb3JFYWNoIiwicmVzb2x2ZWQiLCJ0ZXN0IiwicHJldiIsImFwcGx5UmV2aXZlciIsInJldml2ZXIiLCJrZXkiLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJsZW4iLCJ2MCIsInYxIiwiU3RyaW5nIiwidW5kZWZpbmVkIiwiTWFwIiwiayIsImZyb20iLCJnZXQiLCJkZWxldGUiLCJzZXQiLCJTZXQiLCJhZGQiLCJlbnRyaWVzIiwiY2FsbCIsInZpc2l0IiwiQ29sbGVjdGlvbiIsIm4iLCJsaXN0VGFnTmFtZXMiLCJyZXNvbHZlVGFnSGFuZGxlIiwiWUFNTFNlbWFudGljRXJyb3IiLCJ3YXJuaW5ncyIsIllBTUxXYXJuaW5nIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVzb2x2ZVRhZ05hbWUiLCJ0eXBlIiwibm9uU3BlY2lmaWMiLCJ2ZXJiYXRpbSIsIm1zZyIsImVycm9ycyIsImVycm9yIiwiVHlwZSIsIkJMT0NLX0ZPTERFRCIsIkJMT0NLX0xJVEVSQUwiLCJRVU9URV9ET1VCTEUiLCJRVU9URV9TSU5HTEUiLCJkZWZhdWx0VGFncyIsIlNUUiIsIkZMT1dfTUFQIiwiTUFQIiwiRkxPV19TRVEiLCJTRVEiLCJQTEFJTiIsImNoZWNrRmxvd0NvbGxlY3Rpb25FbmQiLCJjc3QiLCJjaGFyIiwibGFzdEl0ZW0iLCJDT01NRU5UIiwiZXJyIiwib2Zmc2V0IiwicmFuZ2UiLCJlbmQiLCJzdGFydCIsImNoZWNrRmxvd0NvbW1lbnRTcGFjZSIsImNvbW1lbnQiLCJjb250ZXh0Iiwic3JjIiwiZ2V0TG9uZ0tleUVycm9yIiwic2siLCJyZXNvbHZlQ29tbWVudHMiLCJjb2xsZWN0aW9uIiwiY29tbWVudHMiLCJhZnRlcktleSIsImJlZm9yZSIsImNvbW1lbnRCZWZvcmUiLCJzcGFjZUJlZm9yZSIsInJlc29sdmVNYXAiLCJyZXNvbHZlRmxvd01hcEl0ZW1zIiwicmVzb2x2ZUJsb2NrTWFwSXRlbXMiLCJoYXNDb2xsZWN0aW9uS2V5IiwiaUtleSIsIk1FUkdFX0tFWSIsInNvbWUiLCJqIiwiaktleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5Iiwid2FybiIsInZhbHVlSGFzUGFpckNvbW1lbnQiLCJsaW5lU3RhcnQiLCJ2YWx1ZVJhbmdlIiwiQ2hhciIsInJlc29sdmVQYWlyQ29tbWVudCIsInBhaXIiLCJnZXRQcm9wVmFsdWUiLCJmb3VuZCIsImNiIiwic3RhcnRzV2l0aCIsImNjIiwia2V5U3RhcnQiLCJCTEFOS19MSU5FIiwiTUFQX0tFWSIsInJlc29sdmVOb2RlIiwiTUFQX1ZBTFVFIiwiYXRMaW5lU3RhcnQiLCJ2YWx1ZU5vZGUiLCJQbGFpblZhbHVlIiwicGFyZW50IiwicG9zIiwib3JpZ1N0YXJ0Iiwib3JpZ1BvcyIsIm9yaWdFbmQiLCJuZXh0IiwibmV4dEl0ZW0iLCJ2YWx1ZVJhbmdlQ29udGFpbnNOZXdsaW5lIiwiZXhwbGljaXRLZXkiLCJZQU1MU3ludGF4RXJyb3IiLCJyZXNvbHZlU2VxIiwicmVzb2x2ZUZsb3dTZXFJdGVtcyIsInJlc29sdmVCbG9ja1NlcUl0ZW1zIiwic2VxIiwiaXQiLCJTRVFfSVRFTSIsImhhc1Byb3BzIiwicHJldkl0ZW0iLCJwb3AiLCJrZXlFbmQiLCJyZXNvbHZlQnlUYWdOYW1lIiwia25vd25UYWdzIiwidGFnTmFtZSIsIm9uRXJyb3IiLCJtYXRjaFdpdGhUZXN0IiwicmVzIiwicmVzb2x2ZSIsInJlc29sdmVTY2FsYXIiLCJrdCIsInJlc29sdmVUYWciLCJmYWxsYmFjayIsIm1lc3NhZ2UiLCJzdHJWYWx1ZSIsInJlZkVycm9yIiwiWUFNTFJlZmVyZW5jZUVycm9yIiwic3RhY2siLCJpc0NvbGxlY3Rpb25JdGVtIiwicmVzb2x2ZU5vZGVQcm9wcyIsImFmdGVyIiwiaGFzQW5jaG9yIiwiaGFzVGFnIiwiY29uY2F0IiwiY29tbWVudEhhc1JlcXVpcmVkV2hpdGVzcGFjZSIsImhlYWRlciIsInNsaWNlIiwiQU5DSE9SIiwiVEFHIiwicmVzb2x2ZU5vZGVWYWx1ZSIsIkFMSUFTIiwicmF3VmFsdWUiLCJjc3ROb2RlIiwiY2EiLCJwYXJzZUNvbnRlbnRzIiwiY29udGVudHMiLCJib2R5IiwiY2JOb2RlIiwicmVzb2x2ZVRhZ0RpcmVjdGl2ZSIsImRpcmVjdGl2ZSIsInBhcmFtZXRlcnMiLCJyZXNvbHZlWWFtbERpcmVjdGl2ZSIsInBhcnNlRGlyZWN0aXZlcyIsImRpcmVjdGl2ZXMiLCJwcmV2RG9jIiwiZGlyZWN0aXZlQ29tbWVudHMiLCJoYXNEaXJlY3RpdmVzIiwiY29weVRhZ1ByZWZpeCIsImFzc2VydENvbGxlY3Rpb24iLCJEb2N1bWVudCIsInJlcGxhY2VyIiwiZGlyZWN0aXZlc0VuZE1hcmtlciIsInBhcnNlIiwiYWRkSW4iLCJwYXRoIiwic2V0U2NoZW1hIiwia2V5VG9TdHIiLCJ2IiwiTnVtYmVyIiwiYXNTdHIiLCJhbGlhc05vZGVzIiwib25BbGlhcyIsImFsaWFzIiwicHJldk9iamVjdHMiLCJjcmVhdGVQYWlyIiwiZGVsZXRlSW4iLCJpc0VtcHR5UGF0aCIsImRlZmF1bHRzIiwia2VlcFNjYWxhciIsImdldEluIiwiaGFzIiwiaGFzSW4iLCJjb2xsZWN0aW9uRnJvbVBhdGgiLCJzZXRJbiIsImlkIiwidG9GaXhlZCIsIllBTUxFcnJvciIsIm1ha2VQcmV0dHkiLCJsaXN0Tm9uRGVmYXVsdFRhZ3MiLCJzZXRUYWdQcmVmaXgiLCJ0b0pTIiwianNvbiIsImpzb25BcmciLCJvbkFuY2hvciIsImFuY2hvck5vZGVzIiwidmFsdWVzIiwiYWxpYXNDb3VudCIsImNvdW50IiwiaW5kZW50U3RlcCIsImtlZXAiLCJ0b0pTT04iLCJpbmRlbnRTaXplIiwiaXNJbnRlZ2VyIiwiSlNPTiIsImxpbmVzIiwidmQiLCJ0YWdOYW1lcyIsInVuc2hpZnQiLCJyZXBlYXQiLCJjaG9tcEtlZXAiLCJjb250ZW50Q29tbWVudCIsImZvcmNlQmxvY2tJbmRlbnQiLCJhZGRDb21tZW50IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/Document-f89a2614.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/Schema-807430ba.js":
/*!******************************************************************************!*\
  !*** ./node_modules/swagger-jsdoc/node_modules/yaml/dist/Schema-807430ba.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar _rollupPluginBabelHelpers = __webpack_require__(/*! ./_rollupPluginBabelHelpers-eed30217.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/_rollupPluginBabelHelpers-eed30217.js\");\nvar stringifyNumber = __webpack_require__(/*! ./stringifyNumber-dea1120c.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/stringifyNumber-dea1120c.js\");\nconst MERGE_KEY = \"<<\";\nclass Merge extends stringifyNumber.Pair {\n    constructor(pair){\n        if (pair instanceof stringifyNumber.Pair) {\n            let seq = pair.value;\n            if (!(seq instanceof stringifyNumber.YAMLSeq)) {\n                seq = new stringifyNumber.YAMLSeq();\n                seq.items.push(pair.value);\n                seq.range = pair.value.range;\n            }\n            super(pair.key, seq);\n            this.range = pair.range;\n        } else {\n            super(new stringifyNumber.Scalar(MERGE_KEY), new stringifyNumber.YAMLSeq());\n        }\n        this.type = stringifyNumber.Pair.Type.MERGE_PAIR;\n    }\n    // its key/value pairs is inserted into the current mapping, unless the key\n    // already exists in it. If the value associated with the merge key is a\n    // sequence, then this sequence is expected to contain mapping nodes and each\n    // of these nodes is merged in turn according to its order in the sequence.\n    // Keys in mapping nodes earlier in the sequence override keys specified in\n    // later mapping nodes. -- http://yaml.org/type/merge.html\n    addToJSMap(ctx, map) {\n        for (const { source } of this.value.items){\n            if (!(source instanceof stringifyNumber.YAMLMap)) throw new Error(\"Merge sources must be maps\");\n            const srcMap = source.toJSON(null, ctx, Map);\n            for (const [key, value] of srcMap){\n                if (map instanceof Map) {\n                    if (!map.has(key)) map.set(key, value);\n                } else if (map instanceof Set) {\n                    map.add(key);\n                } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n                    Object.defineProperty(map, key, {\n                        value,\n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                }\n            }\n        }\n        return map;\n    }\n    toString(ctx, onComment) {\n        const seq = this.value;\n        if (seq.items.length > 1) return super.toString(ctx, onComment);\n        this.value = seq.items[0];\n        const str = super.toString(ctx, onComment);\n        this.value = seq;\n        return str;\n    }\n}\nfunction createMap(schema, obj, ctx) {\n    const { keepUndefined, replacer } = ctx;\n    const map = new stringifyNumber.YAMLMap(schema);\n    const add = (key, value)=>{\n        if (typeof replacer === \"function\") value = replacer.call(obj, key, value);\n        else if (Array.isArray(replacer) && !replacer.includes(key)) return;\n        if (value !== undefined || keepUndefined) map.items.push(stringifyNumber.createPair(key, value, ctx));\n    };\n    if (obj instanceof Map) {\n        for (const [key, value] of obj)add(key, value);\n    } else if (obj && typeof obj === \"object\") {\n        for (const key of Object.keys(obj))add(key, obj[key]);\n    }\n    if (typeof schema.sortMapEntries === \"function\") {\n        map.items.sort(schema.sortMapEntries);\n    }\n    return map;\n}\nconst map = {\n    createNode: createMap,\n    default: true,\n    nodeClass: stringifyNumber.YAMLMap,\n    tag: \"tag:yaml.org,2002:map\",\n    resolve: (map)=>map\n};\nfunction createSeq(schema, obj, ctx) {\n    const { replacer } = ctx;\n    const seq = new stringifyNumber.YAMLSeq(schema);\n    if (obj && obj[Symbol.iterator]) {\n        let i = 0;\n        for (let it of obj){\n            if (typeof replacer === \"function\") {\n                const key = obj instanceof Set ? it : String(i++);\n                it = replacer.call(obj, key, it);\n            }\n            seq.items.push(stringifyNumber.createNode(it, null, ctx));\n        }\n    }\n    return seq;\n}\nconst seq = {\n    createNode: createSeq,\n    default: true,\n    nodeClass: stringifyNumber.YAMLSeq,\n    tag: \"tag:yaml.org,2002:seq\",\n    resolve: (seq)=>seq\n};\nconst string = {\n    identify: (value)=>typeof value === \"string\",\n    default: true,\n    tag: \"tag:yaml.org,2002:str\",\n    resolve: (str)=>str,\n    stringify (item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({\n            actualString: true\n        }, ctx);\n        return stringifyNumber.stringifyString(item, ctx, onComment, onChompKeep);\n    },\n    options: stringifyNumber.strOptions\n};\nconst failsafe = [\n    map,\n    seq,\n    string\n];\n/* global BigInt */ const intIdentify = (value)=>typeof value === \"bigint\" || Number.isInteger(value);\nconst intResolve = (src, offset, radix)=>stringifyNumber.intOptions.asBigInt ? BigInt(src) : parseInt(src.substring(offset), radix);\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);\n    return stringifyNumber.stringifyNumber(node);\n}\nconst nullObj = {\n    identify: (value)=>value == null,\n    createNode: (schema, value, ctx)=>ctx.wrapScalars ? new stringifyNumber.Scalar(null) : null,\n    default: true,\n    tag: \"tag:yaml.org,2002:null\",\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: (str)=>{\n        const node = new stringifyNumber.Scalar(null);\n        node.sourceStr = str;\n        return node;\n    },\n    options: stringifyNumber.nullOptions,\n    stringify: ({ sourceStr })=>sourceStr !== null && sourceStr !== void 0 ? sourceStr : stringifyNumber.nullOptions.nullStr\n};\nconst boolObj = {\n    identify: (value)=>typeof value === \"boolean\",\n    default: true,\n    tag: \"tag:yaml.org,2002:bool\",\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: (str)=>str[0] === \"t\" || str[0] === \"T\",\n    options: stringifyNumber.boolOptions,\n    stringify: ({ value })=>value ? stringifyNumber.boolOptions.trueStr : stringifyNumber.boolOptions.falseStr\n};\nconst octObj = {\n    identify: (value)=>intIdentify(value) && value >= 0,\n    default: true,\n    tag: \"tag:yaml.org,2002:int\",\n    format: \"OCT\",\n    test: /^0o[0-7]+$/,\n    resolve: (str)=>intResolve(str, 2, 8),\n    options: stringifyNumber.intOptions,\n    stringify: (node)=>intStringify(node, 8, \"0o\")\n};\nconst intObj = {\n    identify: intIdentify,\n    default: true,\n    tag: \"tag:yaml.org,2002:int\",\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str)=>intResolve(str, 0, 10),\n    options: stringifyNumber.intOptions,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst hexObj = {\n    identify: (value)=>intIdentify(value) && value >= 0,\n    default: true,\n    tag: \"tag:yaml.org,2002:int\",\n    format: \"HEX\",\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str)=>intResolve(str, 2, 16),\n    options: stringifyNumber.intOptions,\n    stringify: (node)=>intStringify(node, 16, \"0x\")\n};\nconst nanObj = {\n    identify: (value)=>typeof value === \"number\",\n    default: true,\n    tag: \"tag:yaml.org,2002:float\",\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF|nan|NaN|NAN))$/,\n    resolve: (str)=>str.slice(-3).toLowerCase() === \"nan\" ? NaN : str[0] === \"-\" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst expObj = {\n    identify: (value)=>typeof value === \"number\",\n    default: true,\n    tag: \"tag:yaml.org,2002:float\",\n    format: \"EXP\",\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: (str)=>parseFloat(str),\n    stringify: ({ value })=>Number(value).toExponential()\n};\nconst floatObj = {\n    identify: (value)=>typeof value === \"number\",\n    default: true,\n    tag: \"tag:yaml.org,2002:float\",\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve (str) {\n        const node = new stringifyNumber.Scalar(parseFloat(str));\n        const dot = str.indexOf(\".\");\n        if (dot !== -1 && str[str.length - 1] === \"0\") node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\nconst core = failsafe.concat([\n    nullObj,\n    boolObj,\n    octObj,\n    intObj,\n    hexObj,\n    nanObj,\n    expObj,\n    floatObj\n]);\n/* global BigInt */ const intIdentify$1 = (value)=>typeof value === \"bigint\" || Number.isInteger(value);\nconst stringifyJSON = ({ value })=>JSON.stringify(value);\nconst json = [\n    map,\n    seq,\n    {\n        identify: (value)=>typeof value === \"string\",\n        default: true,\n        tag: \"tag:yaml.org,2002:str\",\n        resolve: (str)=>str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: (value)=>value == null,\n        createNode: (schema, value, ctx)=>ctx.wrapScalars ? new stringifyNumber.Scalar(null) : null,\n        default: true,\n        tag: \"tag:yaml.org,2002:null\",\n        test: /^null$/,\n        resolve: ()=>null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: (value)=>typeof value === \"boolean\",\n        default: true,\n        tag: \"tag:yaml.org,2002:bool\",\n        test: /^true|false$/,\n        resolve: (str)=>str === \"true\",\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify$1,\n        default: true,\n        tag: \"tag:yaml.org,2002:int\",\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str)=>stringifyNumber.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value })=>intIdentify$1(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: (value)=>typeof value === \"number\",\n        default: true,\n        tag: \"tag:yaml.org,2002:float\",\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: (str)=>parseFloat(str),\n        stringify: stringifyJSON\n    },\n    {\n        default: true,\n        test: /^/,\n        resolve (str, onError) {\n            onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n            return str;\n        }\n    }\n];\n/* global atob, btoa, Buffer */ const binary = {\n    identify: (value)=>value instanceof Uint8Array,\n    // Buffer inherits from Uint8Array\n    default: false,\n    tag: \"tag:yaml.org,2002:binary\",\n    /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */ resolve (src, onError) {\n        if (typeof Buffer === \"function\") {\n            return Buffer.from(src, \"base64\");\n        } else if (typeof atob === \"function\") {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, \"\"));\n            const buffer = new Uint8Array(str.length);\n            for(let i = 0; i < str.length; ++i)buffer[i] = str.charCodeAt(i);\n            return buffer;\n        } else {\n            onError(\"This environment does not support reading binary tags; either Buffer or atob is required\");\n            return src;\n        }\n    },\n    options: stringifyNumber.binaryOptions,\n    stringify: ({ comment, type, value }, ctx, onComment, onChompKeep)=>{\n        let src;\n        if (typeof Buffer === \"function\") {\n            src = value instanceof Buffer ? value.toString(\"base64\") : Buffer.from(value.buffer).toString(\"base64\");\n        } else if (typeof btoa === \"function\") {\n            let s = \"\";\n            for(let i = 0; i < value.length; ++i)s += String.fromCharCode(value[i]);\n            src = btoa(s);\n        } else {\n            throw new Error(\"This environment does not support writing binary tags; either Buffer or btoa is required\");\n        }\n        if (!type) type = stringifyNumber.binaryOptions.defaultType;\n        if (type === _rollupPluginBabelHelpers.Type.QUOTE_DOUBLE) {\n            value = src;\n        } else {\n            const { lineWidth } = stringifyNumber.binaryOptions;\n            const n = Math.ceil(src.length / lineWidth);\n            const lines = new Array(n);\n            for(let i = 0, o = 0; i < n; ++i, o += lineWidth){\n                lines[i] = src.substr(o, lineWidth);\n            }\n            value = lines.join(type === _rollupPluginBabelHelpers.Type.BLOCK_LITERAL ? \"\\n\" : \" \");\n        }\n        return stringifyNumber.stringifyString({\n            comment,\n            type,\n            value\n        }, ctx, onComment, onChompKeep);\n    }\n};\nfunction parsePairs(seq, onError) {\n    if (seq instanceof stringifyNumber.YAMLSeq) {\n        for(let i = 0; i < seq.items.length; ++i){\n            let item = seq.items[i];\n            if (item instanceof stringifyNumber.Pair) continue;\n            else if (item instanceof stringifyNumber.YAMLMap) {\n                if (item.items.length > 1) onError(\"Each pair must have its own sequence indicator\");\n                const pair = item.items[0] || new stringifyNumber.Pair();\n                if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\\n${pair.commentBefore}` : item.commentBefore;\n                if (item.comment) pair.comment = pair.comment ? `${item.comment}\\n${pair.comment}` : item.comment;\n                item = pair;\n            }\n            seq.items[i] = item instanceof stringifyNumber.Pair ? item : new stringifyNumber.Pair(item);\n        }\n    } else onError(\"Expected a sequence for this tag\");\n    return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const pairs = new stringifyNumber.YAMLSeq(schema);\n    pairs.tag = \"tag:yaml.org,2002:pairs\";\n    let i = 0;\n    for (let it of iterable){\n        if (typeof replacer === \"function\") it = replacer.call(iterable, String(i++), it);\n        let key, value;\n        if (Array.isArray(it)) {\n            if (it.length === 2) {\n                key = it[0];\n                value = it[1];\n            } else throw new TypeError(`Expected [key, value] tuple: ${it}`);\n        } else if (it && it instanceof Object) {\n            const keys = Object.keys(it);\n            if (keys.length === 1) {\n                key = keys[0];\n                value = it[key];\n            } else throw new TypeError(`Expected { key: value } tuple: ${it}`);\n        } else {\n            key = it;\n        }\n        pairs.items.push(stringifyNumber.createPair(key, value, ctx));\n    }\n    return pairs;\n}\nconst pairs = {\n    default: false,\n    tag: \"tag:yaml.org,2002:pairs\",\n    resolve: parsePairs,\n    createNode: createPairs\n};\nclass YAMLOMap extends stringifyNumber.YAMLSeq {\n    constructor(){\n        super();\n        _rollupPluginBabelHelpers._defineProperty(this, \"add\", stringifyNumber.YAMLMap.prototype.add.bind(this));\n        _rollupPluginBabelHelpers._defineProperty(this, \"delete\", stringifyNumber.YAMLMap.prototype.delete.bind(this));\n        _rollupPluginBabelHelpers._defineProperty(this, \"get\", stringifyNumber.YAMLMap.prototype.get.bind(this));\n        _rollupPluginBabelHelpers._defineProperty(this, \"has\", stringifyNumber.YAMLMap.prototype.has.bind(this));\n        _rollupPluginBabelHelpers._defineProperty(this, \"set\", stringifyNumber.YAMLMap.prototype.set.bind(this));\n        this.tag = YAMLOMap.tag;\n    }\n    toJSON(_, ctx) {\n        const map = new Map();\n        if (ctx && ctx.onCreate) ctx.onCreate(map);\n        for (const pair of this.items){\n            let key, value;\n            if (pair instanceof stringifyNumber.Pair) {\n                key = stringifyNumber.toJS(pair.key, \"\", ctx);\n                value = stringifyNumber.toJS(pair.value, key, ctx);\n            } else {\n                key = stringifyNumber.toJS(pair, \"\", ctx);\n            }\n            if (map.has(key)) throw new Error(\"Ordered maps must not include duplicate keys\");\n            map.set(key, value);\n        }\n        return map;\n    }\n}\n_rollupPluginBabelHelpers._defineProperty(YAMLOMap, \"tag\", \"tag:yaml.org,2002:omap\");\nfunction parseOMap(seq, onError) {\n    const pairs = parsePairs(seq, onError);\n    const seenKeys = [];\n    for (const { key } of pairs.items){\n        if (key instanceof stringifyNumber.Scalar) {\n            if (seenKeys.includes(key.value)) {\n                onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n            } else {\n                seenKeys.push(key.value);\n            }\n        }\n    }\n    return Object.assign(new YAMLOMap(), pairs);\n}\nfunction createOMap(schema, iterable, ctx) {\n    const pairs = createPairs(schema, iterable, ctx);\n    const omap = new YAMLOMap();\n    omap.items = pairs.items;\n    return omap;\n}\nconst omap = {\n    identify: (value)=>value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: \"tag:yaml.org,2002:omap\",\n    resolve: parseOMap,\n    createNode: createOMap\n};\nclass YAMLSet extends stringifyNumber.YAMLMap {\n    constructor(schema){\n        super(schema);\n        this.tag = YAMLSet.tag;\n    }\n    add(key) {\n        const pair = key instanceof stringifyNumber.Pair ? key : new stringifyNumber.Pair(key);\n        const prev = stringifyNumber.findPair(this.items, pair.key);\n        if (!prev) this.items.push(pair);\n    }\n    get(key, keepPair) {\n        const pair = stringifyNumber.findPair(this.items, key);\n        return !keepPair && pair instanceof stringifyNumber.Pair ? pair.key instanceof stringifyNumber.Scalar ? pair.key.value : pair.key : pair;\n    }\n    set(key, value) {\n        if (typeof value !== \"boolean\") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n        const prev = stringifyNumber.findPair(this.items, key);\n        if (prev && !value) {\n            this.items.splice(this.items.indexOf(prev), 1);\n        } else if (!prev && value) {\n            this.items.push(new stringifyNumber.Pair(key));\n        }\n    }\n    toJSON(_, ctx) {\n        return super.toJSON(_, ctx, Set);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx) return JSON.stringify(this);\n        if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);\n        else throw new Error(\"Set items must all have null values\");\n    }\n}\n_rollupPluginBabelHelpers._defineProperty(YAMLSet, \"tag\", \"tag:yaml.org,2002:set\");\nfunction parseSet(map, onError) {\n    if (map instanceof stringifyNumber.YAMLMap) {\n        if (map.hasAllNullValues()) return Object.assign(new YAMLSet(), map);\n        else onError(\"Set items must all have null values\");\n    } else onError(\"Expected a mapping for this tag\");\n    return map;\n}\nfunction createSet(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const set = new YAMLSet(schema);\n    for (let value of iterable){\n        if (typeof replacer === \"function\") value = replacer.call(iterable, value, value);\n        set.items.push(stringifyNumber.createPair(value, null, ctx));\n    }\n    return set;\n}\nconst set = {\n    identify: (value)=>value instanceof Set,\n    nodeClass: YAMLSet,\n    default: false,\n    tag: \"tag:yaml.org,2002:set\",\n    resolve: parseSet,\n    createNode: createSet\n};\n/* global BigInt */ const parseSexagesimal = (str, isInt)=>{\n    const sign = str[0];\n    const parts = sign === \"-\" || sign === \"+\" ? str.substring(1) : str;\n    const num = (n)=>isInt && stringifyNumber.intOptions.asBigInt ? BigInt(n) : Number(n);\n    const res = parts.replace(/_/g, \"\").split(\":\").reduce((res, p)=>res * num(60) + num(p), num(0));\n    return sign === \"-\" ? num(-1) * res : res;\n}; // hhhh:mm:ss.sss\nconst stringifySexagesimal = ({ value })=>{\n    let num = (n)=>n;\n    if (typeof value === \"bigint\") num = (n)=>BigInt(n);\n    else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(value);\n    let sign = \"\";\n    if (value < 0) {\n        sign = \"-\";\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [\n        value % _60\n    ]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    } else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return sign + parts.map((n)=>n < 10 ? \"0\" + String(n) : String(n)).join(\":\").replace(/000000\\d*$/, \"\") // % 60 may introduce error\n    ;\n};\nconst intTime = {\n    identify: (value)=>typeof value === \"bigint\" || Number.isInteger(value),\n    default: true,\n    tag: \"tag:yaml.org,2002:int\",\n    format: \"TIME\",\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str)=>parseSexagesimal(str, true),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: (value)=>typeof value === \"number\",\n    default: true,\n    tag: \"tag:yaml.org,2002:float\",\n    format: \"TIME\",\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: (str)=>parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: (value)=>value instanceof Date,\n    default: true,\n    tag: \"tag:yaml.org,2002:timestamp\",\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp(\"^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})\" + // YYYY-Mm-Dd\n    \"(?:\" + // time is optional\n    \"(?:t|T|[ \\\\t]+)\" + // t | T | whitespace\n    \"([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)\" + // Hh:Mm:Ss(.ss)?\n    \"(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?\" + // Z | +5 | -03:30\n    \")?$\"),\n    resolve (str) {\n        let [, year, month, day, hour, minute, second, millisec, tz] = str.match(timestamp.test);\n        if (millisec) millisec = (millisec + \"00\").substr(1, 3);\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n        if (tz && tz !== \"Z\") {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30) d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value })=>value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, \"\")\n};\n/* global BigInt */ const boolStringify = ({ value })=>value ? stringifyNumber.boolOptions.trueStr : stringifyNumber.boolOptions.falseStr;\nconst intIdentify$2 = (value)=>typeof value === \"bigint\" || Number.isInteger(value);\nfunction intResolve$1(str, offset, radix) {\n    const sign = str[0];\n    if (sign === \"-\" || sign === \"+\") offset += 1;\n    str = str.substring(offset).replace(/_/g, \"\");\n    if (stringifyNumber.intOptions.asBigInt) {\n        switch(radix){\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === \"-\" ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === \"-\" ? -1 * n : n;\n}\nfunction intStringify$1(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify$2(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? \"-\" + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber.stringifyNumber(node);\n}\nconst yaml11 = failsafe.concat([\n    {\n        identify: (value)=>value == null,\n        createNode: (schema, value, ctx)=>ctx.wrapScalars ? new stringifyNumber.Scalar(null) : null,\n        default: true,\n        tag: \"tag:yaml.org,2002:null\",\n        test: /^(?:~|[Nn]ull|NULL)?$/,\n        resolve: (str)=>{\n            const node = new stringifyNumber.Scalar(null);\n            node.sourceStr = str;\n            return node;\n        },\n        options: stringifyNumber.nullOptions,\n        stringify: ({ sourceStr })=>sourceStr !== null && sourceStr !== void 0 ? sourceStr : stringifyNumber.nullOptions.nullStr\n    },\n    {\n        identify: (value)=>typeof value === \"boolean\",\n        default: true,\n        tag: \"tag:yaml.org,2002:bool\",\n        test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n        resolve: ()=>true,\n        options: stringifyNumber.boolOptions,\n        stringify: boolStringify\n    },\n    {\n        identify: (value)=>typeof value === \"boolean\",\n        default: true,\n        tag: \"tag:yaml.org,2002:bool\",\n        test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,\n        resolve: ()=>false,\n        options: stringifyNumber.boolOptions,\n        stringify: boolStringify\n    },\n    {\n        identify: intIdentify$2,\n        default: true,\n        tag: \"tag:yaml.org,2002:int\",\n        format: \"BIN\",\n        test: /^[-+]?0b[0-1_]+$/,\n        resolve: (str)=>intResolve$1(str, 2, 2),\n        stringify: (node)=>intStringify$1(node, 2, \"0b\")\n    },\n    {\n        identify: intIdentify$2,\n        default: true,\n        tag: \"tag:yaml.org,2002:int\",\n        format: \"OCT\",\n        test: /^[-+]?0[0-7_]+$/,\n        resolve: (str)=>intResolve$1(str, 1, 8),\n        stringify: (node)=>intStringify$1(node, 8, \"0\")\n    },\n    {\n        identify: intIdentify$2,\n        default: true,\n        tag: \"tag:yaml.org,2002:int\",\n        test: /^[-+]?[0-9][0-9_]*$/,\n        resolve: (str)=>intResolve$1(str, 0, 10),\n        stringify: stringifyNumber.stringifyNumber\n    },\n    {\n        identify: intIdentify$2,\n        default: true,\n        tag: \"tag:yaml.org,2002:int\",\n        format: \"HEX\",\n        test: /^[-+]?0x[0-9a-fA-F_]+$/,\n        resolve: (str)=>intResolve$1(str, 2, 16),\n        stringify: (node)=>intStringify$1(node, 16, \"0x\")\n    },\n    {\n        identify: (value)=>typeof value === \"number\",\n        default: true,\n        tag: \"tag:yaml.org,2002:float\",\n        test: /^[-+]?\\.(?:inf|Inf|INF|nan|NaN|NAN)$/,\n        resolve: (str)=>str.slice(-3).toLowerCase() === \"nan\" ? NaN : str[0] === \"-\" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n        stringify: stringifyNumber.stringifyNumber\n    },\n    {\n        identify: (value)=>typeof value === \"number\",\n        default: true,\n        tag: \"tag:yaml.org,2002:float\",\n        format: \"EXP\",\n        test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n        resolve: (str)=>parseFloat(str.replace(/_/g, \"\")),\n        stringify: ({ value })=>Number(value).toExponential()\n    },\n    {\n        identify: (value)=>typeof value === \"number\",\n        default: true,\n        tag: \"tag:yaml.org,2002:float\",\n        test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n        resolve (str) {\n            const node = new stringifyNumber.Scalar(parseFloat(str.replace(/_/g, \"\")));\n            const dot = str.indexOf(\".\");\n            if (dot !== -1) {\n                const f = str.substring(dot + 1).replace(/_/g, \"\");\n                if (f[f.length - 1] === \"0\") node.minFractionDigits = f.length;\n            }\n            return node;\n        },\n        stringify: stringifyNumber.stringifyNumber\n    }\n], binary, omap, pairs, set, intTime, floatTime, timestamp);\nconst schemas = {\n    core,\n    failsafe,\n    json,\n    yaml11\n};\nconst tags = {\n    binary,\n    bool: boolObj,\n    float: floatObj,\n    floatExp: expObj,\n    floatNaN: nanObj,\n    floatTime,\n    int: intObj,\n    intHex: hexObj,\n    intOct: octObj,\n    intTime,\n    map,\n    null: nullObj,\n    omap,\n    pairs,\n    seq,\n    set,\n    timestamp\n};\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n    let tags = schemas[schemaId.replace(/\\W/g, \"\")]; // 'yaml-1.1' -> 'yaml11'\n    if (!tags) {\n        const keys = Object.keys(schemas).map((key)=>JSON.stringify(key)).join(\", \");\n        throw new Error(`Unknown schema \"${schemaId}\"; use one of ${keys}`);\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)tags = tags.concat(tag);\n    } else if (typeof customTags === \"function\") {\n        tags = customTags(tags.slice());\n    }\n    for(let i = 0; i < tags.length; ++i){\n        const tag = tags[i];\n        if (typeof tag === \"string\") {\n            const tagObj = knownTags[tag];\n            if (!tagObj) {\n                const keys = Object.keys(knownTags).map((key)=>JSON.stringify(key)).join(\", \");\n                throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n            }\n            tags[i] = tagObj;\n        }\n    }\n    return tags;\n}\nconst sortMapEntriesByKey = (a, b)=>a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nconst coreKnownTags = {\n    \"tag:yaml.org,2002:binary\": tags.binary,\n    \"tag:yaml.org,2002:omap\": tags.omap,\n    \"tag:yaml.org,2002:pairs\": tags.pairs,\n    \"tag:yaml.org,2002:set\": tags.set,\n    \"tag:yaml.org,2002:timestamp\": tags.timestamp\n};\nclass Schema {\n    constructor({ customTags, merge, resolveKnownTags, schema, sortMapEntries }){\n        this.merge = !!merge;\n        this.name = schema;\n        this.knownTags = resolveKnownTags ? coreKnownTags : {};\n        this.tags = getSchemaTags(schemas, tags, customTags, schema); // Used by createNode(), to avoid circular dependencies\n        this.map = tags.map;\n        this.seq = tags.seq; // Used by createMap()\n        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    }\n}\nexports.MERGE_KEY = MERGE_KEY;\nexports.Merge = Merge;\nexports.Schema = Schema;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9ub2RlX21vZHVsZXMveWFtbC9kaXN0L1NjaGVtYS04MDc0MzBiYS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLDRCQUE0QkMsbUJBQU9BLENBQUM7QUFDeEMsSUFBSUMsa0JBQWtCRCxtQkFBT0EsQ0FBQztBQUU5QixNQUFNRSxZQUFZO0FBQ2xCLE1BQU1DLGNBQWNGLGdCQUFnQkcsSUFBSTtJQUN0Q0MsWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLElBQUlBLGdCQUFnQkwsZ0JBQWdCRyxJQUFJLEVBQUU7WUFDeEMsSUFBSUcsTUFBTUQsS0FBS0UsS0FBSztZQUVwQixJQUFJLENBQUVELENBQUFBLGVBQWVOLGdCQUFnQlEsT0FBTyxHQUFHO2dCQUM3Q0YsTUFBTSxJQUFJTixnQkFBZ0JRLE9BQU87Z0JBQ2pDRixJQUFJRyxLQUFLLENBQUNDLElBQUksQ0FBQ0wsS0FBS0UsS0FBSztnQkFDekJELElBQUlLLEtBQUssR0FBR04sS0FBS0UsS0FBSyxDQUFDSSxLQUFLO1lBQzlCO1lBRUEsS0FBSyxDQUFDTixLQUFLTyxHQUFHLEVBQUVOO1lBQ2hCLElBQUksQ0FBQ0ssS0FBSyxHQUFHTixLQUFLTSxLQUFLO1FBQ3pCLE9BQU87WUFDTCxLQUFLLENBQUMsSUFBSVgsZ0JBQWdCYSxNQUFNLENBQUNaLFlBQVksSUFBSUQsZ0JBQWdCUSxPQUFPO1FBQzFFO1FBRUEsSUFBSSxDQUFDTSxJQUFJLEdBQUdkLGdCQUFnQkcsSUFBSSxDQUFDWSxJQUFJLENBQUNDLFVBQVU7SUFDbEQ7SUFDQSwyRUFBMkU7SUFDM0Usd0VBQXdFO0lBQ3hFLDZFQUE2RTtJQUM3RSwyRUFBMkU7SUFDM0UsMkVBQTJFO0lBQzNFLDBEQUEwRDtJQUcxREMsV0FBV0MsR0FBRyxFQUFFQyxHQUFHLEVBQUU7UUFDbkIsS0FBSyxNQUFNLEVBQ1RDLE1BQU0sRUFDUCxJQUFJLElBQUksQ0FBQ2IsS0FBSyxDQUFDRSxLQUFLLENBQUU7WUFD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M0MsSUFBSSxDQUFDK0MsY0FBYyxHQUFHQSxtQkFBbUIsT0FBT2lMLHNCQUFzQmpMLGtCQUFrQjtJQUMxRjtBQUVGO0FBRUF5TCxpQkFBaUIsR0FBRzdPO0FBQ3BCNk8sYUFBYSxHQUFHNU87QUFDaEI0TyxjQUFjLEdBQUdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9zd2FnZ2VyLWpzZG9jL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvU2NoZW1hLTgwNzQzMGJhLmpzPzk3OGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycyA9IHJlcXVpcmUoJy4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy1lZWQzMDIxNy5qcycpO1xudmFyIHN0cmluZ2lmeU51bWJlciA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5TnVtYmVyLWRlYTExMjBjLmpzJyk7XG5cbmNvbnN0IE1FUkdFX0tFWSA9ICc8PCc7XG5jbGFzcyBNZXJnZSBleHRlbmRzIHN0cmluZ2lmeU51bWJlci5QYWlyIHtcbiAgY29uc3RydWN0b3IocGFpcikge1xuICAgIGlmIChwYWlyIGluc3RhbmNlb2Ygc3RyaW5naWZ5TnVtYmVyLlBhaXIpIHtcbiAgICAgIGxldCBzZXEgPSBwYWlyLnZhbHVlO1xuXG4gICAgICBpZiAoIShzZXEgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuWUFNTFNlcSkpIHtcbiAgICAgICAgc2VxID0gbmV3IHN0cmluZ2lmeU51bWJlci5ZQU1MU2VxKCk7XG4gICAgICAgIHNlcS5pdGVtcy5wdXNoKHBhaXIudmFsdWUpO1xuICAgICAgICBzZXEucmFuZ2UgPSBwYWlyLnZhbHVlLnJhbmdlO1xuICAgICAgfVxuXG4gICAgICBzdXBlcihwYWlyLmtleSwgc2VxKTtcbiAgICAgIHRoaXMucmFuZ2UgPSBwYWlyLnJhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlcihuZXcgc3RyaW5naWZ5TnVtYmVyLlNjYWxhcihNRVJHRV9LRVkpLCBuZXcgc3RyaW5naWZ5TnVtYmVyLllBTUxTZXEoKSk7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gc3RyaW5naWZ5TnVtYmVyLlBhaXIuVHlwZS5NRVJHRV9QQUlSO1xuICB9IC8vIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBtZXJnZSBrZXkgaXMgYSBzaW5nbGUgbWFwcGluZyBub2RlLCBlYWNoIG9mXG4gIC8vIGl0cyBrZXkvdmFsdWUgcGFpcnMgaXMgaW5zZXJ0ZWQgaW50byB0aGUgY3VycmVudCBtYXBwaW5nLCB1bmxlc3MgdGhlIGtleVxuICAvLyBhbHJlYWR5IGV4aXN0cyBpbiBpdC4gSWYgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWVyZ2Uga2V5IGlzIGFcbiAgLy8gc2VxdWVuY2UsIHRoZW4gdGhpcyBzZXF1ZW5jZSBpcyBleHBlY3RlZCB0byBjb250YWluIG1hcHBpbmcgbm9kZXMgYW5kIGVhY2hcbiAgLy8gb2YgdGhlc2Ugbm9kZXMgaXMgbWVyZ2VkIGluIHR1cm4gYWNjb3JkaW5nIHRvIGl0cyBvcmRlciBpbiB0aGUgc2VxdWVuY2UuXG4gIC8vIEtleXMgaW4gbWFwcGluZyBub2RlcyBlYXJsaWVyIGluIHRoZSBzZXF1ZW5jZSBvdmVycmlkZSBrZXlzIHNwZWNpZmllZCBpblxuICAvLyBsYXRlciBtYXBwaW5nIG5vZGVzLiAtLSBodHRwOi8veWFtbC5vcmcvdHlwZS9tZXJnZS5odG1sXG5cblxuICBhZGRUb0pTTWFwKGN0eCwgbWFwKSB7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBzb3VyY2VcbiAgICB9IG9mIHRoaXMudmFsdWUuaXRlbXMpIHtcbiAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5ZQU1MTWFwKSkgdGhyb3cgbmV3IEVycm9yKCdNZXJnZSBzb3VyY2VzIG11c3QgYmUgbWFwcycpO1xuICAgICAgY29uc3Qgc3JjTWFwID0gc291cmNlLnRvSlNPTihudWxsLCBjdHgsIE1hcCk7XG5cbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNyY01hcCkge1xuICAgICAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgaWYgKCFtYXAuaGFzKGtleSkpIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgbWFwLmFkZChrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBrZXkpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHRvU3RyaW5nKGN0eCwgb25Db21tZW50KSB7XG4gICAgY29uc3Qgc2VxID0gdGhpcy52YWx1ZTtcbiAgICBpZiAoc2VxLml0ZW1zLmxlbmd0aCA+IDEpIHJldHVybiBzdXBlci50b1N0cmluZyhjdHgsIG9uQ29tbWVudCk7XG4gICAgdGhpcy52YWx1ZSA9IHNlcS5pdGVtc1swXTtcbiAgICBjb25zdCBzdHIgPSBzdXBlci50b1N0cmluZyhjdHgsIG9uQ29tbWVudCk7XG4gICAgdGhpcy52YWx1ZSA9IHNlcTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlTWFwKHNjaGVtYSwgb2JqLCBjdHgpIHtcbiAgY29uc3Qge1xuICAgIGtlZXBVbmRlZmluZWQsXG4gICAgcmVwbGFjZXJcbiAgfSA9IGN0eDtcbiAgY29uc3QgbWFwID0gbmV3IHN0cmluZ2lmeU51bWJlci5ZQU1MTWFwKHNjaGVtYSk7XG5cbiAgY29uc3QgYWRkID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwob2JqLCBrZXksIHZhbHVlKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSAmJiAhcmVwbGFjZXIuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGtlZXBVbmRlZmluZWQpIG1hcC5pdGVtcy5wdXNoKHN0cmluZ2lmeU51bWJlci5jcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkpO1xuICB9O1xuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmopIGFkZChrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSBhZGQoa2V5LCBvYmpba2V5XSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHNjaGVtYS5zb3J0TWFwRW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1hcC5pdGVtcy5zb3J0KHNjaGVtYS5zb3J0TWFwRW50cmllcyk7XG4gIH1cblxuICByZXR1cm4gbWFwO1xufVxuXG5jb25zdCBtYXAgPSB7XG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZU1hcCxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgbm9kZUNsYXNzOiBzdHJpbmdpZnlOdW1iZXIuWUFNTE1hcCxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bWFwJyxcbiAgcmVzb2x2ZTogbWFwID0+IG1hcFxufTtcblxuZnVuY3Rpb24gY3JlYXRlU2VxKHNjaGVtYSwgb2JqLCBjdHgpIHtcbiAgY29uc3Qge1xuICAgIHJlcGxhY2VyXG4gIH0gPSBjdHg7XG4gIGNvbnN0IHNlcSA9IG5ldyBzdHJpbmdpZnlOdW1iZXIuWUFNTFNlcShzY2hlbWEpO1xuXG4gIGlmIChvYmogJiYgb2JqW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBmb3IgKGxldCBpdCBvZiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gb2JqIGluc3RhbmNlb2YgU2V0ID8gaXQgOiBTdHJpbmcoaSsrKTtcbiAgICAgICAgaXQgPSByZXBsYWNlci5jYWxsKG9iaiwga2V5LCBpdCk7XG4gICAgICB9XG5cbiAgICAgIHNlcS5pdGVtcy5wdXNoKHN0cmluZ2lmeU51bWJlci5jcmVhdGVOb2RlKGl0LCBudWxsLCBjdHgpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VxO1xufVxuXG5jb25zdCBzZXEgPSB7XG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZVNlcSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgbm9kZUNsYXNzOiBzdHJpbmdpZnlOdW1iZXIuWUFNTFNlcSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJyxcbiAgcmVzb2x2ZTogc2VxID0+IHNlcVxufTtcblxuY29uc3Qgc3RyaW5nID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyxcbiAgcmVzb2x2ZTogc3RyID0+IHN0cixcblxuICBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBhY3R1YWxTdHJpbmc6IHRydWVcbiAgICB9LCBjdHgpO1xuICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIuc3RyaW5naWZ5U3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIH0sXG5cbiAgb3B0aW9uczogc3RyaW5naWZ5TnVtYmVyLnN0ck9wdGlvbnNcbn07XG5cbmNvbnN0IGZhaWxzYWZlID0gW21hcCwgc2VxLCBzdHJpbmddO1xuXG4vKiBnbG9iYWwgQmlnSW50ICovXG5cbmNvbnN0IGludElkZW50aWZ5ID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcblxuY29uc3QgaW50UmVzb2x2ZSA9IChzcmMsIG9mZnNldCwgcmFkaXgpID0+IHN0cmluZ2lmeU51bWJlci5pbnRPcHRpb25zLmFzQmlnSW50ID8gQmlnSW50KHNyYykgOiBwYXJzZUludChzcmMuc3Vic3RyaW5nKG9mZnNldCksIHJhZGl4KTtcblxuZnVuY3Rpb24gaW50U3RyaW5naWZ5KG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgY29uc3Qge1xuICAgIHZhbHVlXG4gIH0gPSBub2RlO1xuICBpZiAoaW50SWRlbnRpZnkodmFsdWUpICYmIHZhbHVlID49IDApIHJldHVybiBwcmVmaXggKyB2YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gIHJldHVybiBzdHJpbmdpZnlOdW1iZXIuc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuXG5jb25zdCBudWxsT2JqID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCxcbiAgY3JlYXRlTm9kZTogKHNjaGVtYSwgdmFsdWUsIGN0eCkgPT4gY3R4LndyYXBTY2FsYXJzID8gbmV3IHN0cmluZ2lmeU51bWJlci5TY2FsYXIobnVsbCkgOiBudWxsLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgdGVzdDogL14oPzp+fFtObl11bGx8TlVMTCk/JC8sXG4gIHJlc29sdmU6IHN0ciA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBzdHJpbmdpZnlOdW1iZXIuU2NhbGFyKG51bGwpO1xuICAgIG5vZGUuc291cmNlU3RyID0gc3RyO1xuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBvcHRpb25zOiBzdHJpbmdpZnlOdW1iZXIubnVsbE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogKHtcbiAgICBzb3VyY2VTdHJcbiAgfSkgPT4gc291cmNlU3RyICE9PSBudWxsICYmIHNvdXJjZVN0ciAhPT0gdm9pZCAwID8gc291cmNlU3RyIDogc3RyaW5naWZ5TnVtYmVyLm51bGxPcHRpb25zLm51bGxTdHJcbn07XG5jb25zdCBib29sT2JqID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICB0ZXN0OiAvXig/OltUdF1ydWV8VFJVRXxbRmZdYWxzZXxGQUxTRSkkLyxcbiAgcmVzb2x2ZTogc3RyID0+IHN0clswXSA9PT0gJ3QnIHx8IHN0clswXSA9PT0gJ1QnLFxuICBvcHRpb25zOiBzdHJpbmdpZnlOdW1iZXIuYm9vbE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogKHtcbiAgICB2YWx1ZVxuICB9KSA9PiB2YWx1ZSA/IHN0cmluZ2lmeU51bWJlci5ib29sT3B0aW9ucy50cnVlU3RyIDogc3RyaW5naWZ5TnVtYmVyLmJvb2xPcHRpb25zLmZhbHNlU3RyXG59O1xuY29uc3Qgb2N0T2JqID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gaW50SWRlbnRpZnkodmFsdWUpICYmIHZhbHVlID49IDAsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ09DVCcsXG4gIHRlc3Q6IC9eMG9bMC03XSskLyxcbiAgcmVzb2x2ZTogc3RyID0+IGludFJlc29sdmUoc3RyLCAyLCA4KSxcbiAgb3B0aW9uczogc3RyaW5naWZ5TnVtYmVyLmludE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgOCwgJzBvJylcbn07XG5jb25zdCBpbnRPYmogPSB7XG4gIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgdGVzdDogL15bLStdP1swLTldKyQvLFxuICByZXNvbHZlOiBzdHIgPT4gaW50UmVzb2x2ZShzdHIsIDAsIDEwKSxcbiAgb3B0aW9uczogc3RyaW5naWZ5TnVtYmVyLmludE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGhleE9iaiA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdIRVgnLFxuICB0ZXN0OiAvXjB4WzAtOWEtZkEtRl0rJC8sXG4gIHJlc29sdmU6IHN0ciA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMTYpLFxuICBvcHRpb25zOiBzdHJpbmdpZnlOdW1iZXIuaW50T3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jylcbn07XG5jb25zdCBuYW5PYmogPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIHRlc3Q6IC9eKD86Wy0rXT9cXC4oPzppbmZ8SW5mfElORnxuYW58TmFOfE5BTikpJC8sXG4gIHJlc29sdmU6IHN0ciA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nID8gTmFOIDogc3RyWzBdID09PSAnLScgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGV4cE9iaiA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgZm9ybWF0OiAnRVhQJyxcbiAgdGVzdDogL15bLStdPyg/OlxcLlswLTldK3xbMC05XSsoPzpcXC5bMC05XSopPylbZUVdWy0rXT9bMC05XSskLyxcbiAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyKSxcbiAgc3RyaW5naWZ5OiAoe1xuICAgIHZhbHVlXG4gIH0pID0+IE51bWJlcih2YWx1ZSkudG9FeHBvbmVudGlhbCgpXG59O1xuY29uc3QgZmxvYXRPYmogPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rXFwuWzAtOV0qKSQvLFxuXG4gIHJlc29sdmUoc3RyKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBzdHJpbmdpZnlOdW1iZXIuU2NhbGFyKHBhcnNlRmxvYXQoc3RyKSk7XG4gICAgY29uc3QgZG90ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZiAoZG90ICE9PSAtMSAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnMCcpIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBzdHIubGVuZ3RoIC0gZG90IC0gMTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBjb3JlID0gZmFpbHNhZmUuY29uY2F0KFtudWxsT2JqLCBib29sT2JqLCBvY3RPYmosIGludE9iaiwgaGV4T2JqLCBuYW5PYmosIGV4cE9iaiwgZmxvYXRPYmpdKTtcblxuLyogZ2xvYmFsIEJpZ0ludCAqL1xuXG5jb25zdCBpbnRJZGVudGlmeSQxID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcblxuY29uc3Qgc3RyaW5naWZ5SlNPTiA9ICh7XG4gIHZhbHVlXG59KSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cbmNvbnN0IGpzb24gPSBbbWFwLCBzZXEsIHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gIHJlc29sdmU6IHN0ciA9PiBzdHIsXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxufSwge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCxcbiAgY3JlYXRlTm9kZTogKHNjaGVtYSwgdmFsdWUsIGN0eCkgPT4gY3R4LndyYXBTY2FsYXJzID8gbmV3IHN0cmluZ2lmeU51bWJlci5TY2FsYXIobnVsbCkgOiBudWxsLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgdGVzdDogL15udWxsJC8sXG4gIHJlc29sdmU6ICgpID0+IG51bGwsXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxufSwge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICB0ZXN0OiAvXnRydWV8ZmFsc2UkLyxcbiAgcmVzb2x2ZTogc3RyID0+IHN0ciA9PT0gJ3RydWUnLFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbn0sIHtcbiAgaWRlbnRpZnk6IGludElkZW50aWZ5JDEsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvLFxuICByZXNvbHZlOiBzdHIgPT4gc3RyaW5naWZ5TnVtYmVyLmludE9wdGlvbnMuYXNCaWdJbnQgPyBCaWdJbnQoc3RyKSA6IHBhcnNlSW50KHN0ciwgMTApLFxuICBzdHJpbmdpZnk6ICh7XG4gICAgdmFsdWVcbiAgfSkgPT4gaW50SWRlbnRpZnkkMSh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpXG59LCB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSg/OlxcLlswLTldKik/KD86W2VFXVstK10/WzAtOV0rKT8kLyxcbiAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyKSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG59LCB7XG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRlc3Q6IC9eLyxcblxuICByZXNvbHZlKHN0ciwgb25FcnJvcikge1xuICAgIG9uRXJyb3IoYFVucmVzb2x2ZWQgcGxhaW4gc2NhbGFyICR7SlNPTi5zdHJpbmdpZnkoc3RyKX1gKTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbn1dO1xuXG4vKiBnbG9iYWwgYXRvYiwgYnRvYSwgQnVmZmVyICovXG5jb25zdCBiaW5hcnkgPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksXG4gIC8vIEJ1ZmZlciBpbmhlcml0cyBmcm9tIFVpbnQ4QXJyYXlcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCdWZmZXIgaW4gbm9kZSBhbmQgYW4gVWludDhBcnJheSBpbiBicm93c2Vyc1xuICAgKlxuICAgKiBUbyB1c2UgdGhlIHJlc3VsdGluZyBidWZmZXIgYXMgYW4gaW1hZ2UsIHlvdSdsbCB3YW50IHRvIGRvIHNvbWV0aGluZyBsaWtlOlxuICAgKlxuICAgKiAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvdG8nKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAqL1xuICByZXNvbHZlKHNyYywgb25FcnJvcikge1xuICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3JjLCAnYmFzZTY0Jyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gT24gSUUgMTEsIGF0b2IoKSBjYW4ndCBoYW5kbGUgbmV3bGluZXNcbiAgICAgIGNvbnN0IHN0ciA9IGF0b2Ioc3JjLnJlcGxhY2UoL1tcXG5cXHJdL2csICcnKSk7XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIGJ1ZmZlcltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgcmVhZGluZyBiaW5hcnkgdGFnczsgZWl0aGVyIEJ1ZmZlciBvciBhdG9iIGlzIHJlcXVpcmVkJyk7XG4gICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgfSxcblxuICBvcHRpb25zOiBzdHJpbmdpZnlOdW1iZXIuYmluYXJ5T3B0aW9ucyxcbiAgc3RyaW5naWZ5OiAoe1xuICAgIGNvbW1lbnQsXG4gICAgdHlwZSxcbiAgICB2YWx1ZVxuICB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApID0+IHtcbiAgICBsZXQgc3JjO1xuXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNyYyA9IHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyID8gdmFsdWUudG9TdHJpbmcoJ2Jhc2U2NCcpIDogQnVmZmVyLmZyb20odmFsdWUuYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGV0IHMgPSAnJztcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlW2ldKTtcblxuICAgICAgc3JjID0gYnRvYShzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgd3JpdGluZyBiaW5hcnkgdGFnczsgZWl0aGVyIEJ1ZmZlciBvciBidG9hIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlKSB0eXBlID0gc3RyaW5naWZ5TnVtYmVyLmJpbmFyeU9wdGlvbnMuZGVmYXVsdFR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlFVT1RFX0RPVUJMRSkge1xuICAgICAgdmFsdWUgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZVdpZHRoXG4gICAgICB9ID0gc3RyaW5naWZ5TnVtYmVyLmJpbmFyeU9wdGlvbnM7XG4gICAgICBjb25zdCBuID0gTWF0aC5jZWlsKHNyYy5sZW5ndGggLyBsaW5lV2lkdGgpO1xuICAgICAgY29uc3QgbGluZXMgPSBuZXcgQXJyYXkobik7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBvID0gMDsgaSA8IG47ICsraSwgbyArPSBsaW5lV2lkdGgpIHtcbiAgICAgICAgbGluZXNbaV0gPSBzcmMuc3Vic3RyKG8sIGxpbmVXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gbGluZXMuam9pbih0eXBlID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxPQ0tfTElURVJBTCA/ICdcXG4nIDogJyAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeVN0cmluZyh7XG4gICAgICBjb21tZW50LFxuICAgICAgdHlwZSxcbiAgICAgIHZhbHVlXG4gICAgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyc2VQYWlycyhzZXEsIG9uRXJyb3IpIHtcbiAgaWYgKHNlcSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5ZQU1MU2VxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXEuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxldCBpdGVtID0gc2VxLml0ZW1zW2ldO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuUGFpcikgY29udGludWU7ZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5ZQU1MTWFwKSB7XG4gICAgICAgIGlmIChpdGVtLml0ZW1zLmxlbmd0aCA+IDEpIG9uRXJyb3IoJ0VhY2ggcGFpciBtdXN0IGhhdmUgaXRzIG93biBzZXF1ZW5jZSBpbmRpY2F0b3InKTtcbiAgICAgICAgY29uc3QgcGFpciA9IGl0ZW0uaXRlbXNbMF0gfHwgbmV3IHN0cmluZ2lmeU51bWJlci5QYWlyKCk7XG4gICAgICAgIGlmIChpdGVtLmNvbW1lbnRCZWZvcmUpIHBhaXIuY29tbWVudEJlZm9yZSA9IHBhaXIuY29tbWVudEJlZm9yZSA/IGAke2l0ZW0uY29tbWVudEJlZm9yZX1cXG4ke3BhaXIuY29tbWVudEJlZm9yZX1gIDogaXRlbS5jb21tZW50QmVmb3JlO1xuICAgICAgICBpZiAoaXRlbS5jb21tZW50KSBwYWlyLmNvbW1lbnQgPSBwYWlyLmNvbW1lbnQgPyBgJHtpdGVtLmNvbW1lbnR9XFxuJHtwYWlyLmNvbW1lbnR9YCA6IGl0ZW0uY29tbWVudDtcbiAgICAgICAgaXRlbSA9IHBhaXI7XG4gICAgICB9XG4gICAgICBzZXEuaXRlbXNbaV0gPSBpdGVtIGluc3RhbmNlb2Ygc3RyaW5naWZ5TnVtYmVyLlBhaXIgPyBpdGVtIDogbmV3IHN0cmluZ2lmeU51bWJlci5QYWlyKGl0ZW0pO1xuICAgIH1cbiAgfSBlbHNlIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG5cbiAgcmV0dXJuIHNlcTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICBjb25zdCB7XG4gICAgcmVwbGFjZXJcbiAgfSA9IGN0eDtcbiAgY29uc3QgcGFpcnMgPSBuZXcgc3RyaW5naWZ5TnVtYmVyLllBTUxTZXEoc2NoZW1hKTtcbiAgcGFpcnMudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJztcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAobGV0IGl0IG9mIGl0ZXJhYmxlKSB7XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykgaXQgPSByZXBsYWNlci5jYWxsKGl0ZXJhYmxlLCBTdHJpbmcoaSsrKSwgaXQpO1xuICAgIGxldCBrZXksIHZhbHVlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXQpKSB7XG4gICAgICBpZiAoaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGtleSA9IGl0WzBdO1xuICAgICAgICB2YWx1ZSA9IGl0WzFdO1xuICAgICAgfSBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFtrZXksIHZhbHVlXSB0dXBsZTogJHtpdH1gKTtcbiAgICB9IGVsc2UgaWYgKGl0ICYmIGl0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXQpO1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAga2V5ID0ga2V5c1swXTtcbiAgICAgICAgdmFsdWUgPSBpdFtrZXldO1xuICAgICAgfSBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHsga2V5OiB2YWx1ZSB9IHR1cGxlOiAke2l0fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBpdDtcbiAgICB9XG5cbiAgICBwYWlycy5pdGVtcy5wdXNoKHN0cmluZ2lmeU51bWJlci5jcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkpO1xuICB9XG5cbiAgcmV0dXJuIHBhaXJzO1xufVxuY29uc3QgcGFpcnMgPSB7XG4gIGRlZmF1bHQ6IGZhbHNlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsXG4gIHJlc29sdmU6IHBhcnNlUGFpcnMsXG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZVBhaXJzXG59O1xuXG5jbGFzcyBZQU1MT01hcCBleHRlbmRzIHN0cmluZ2lmeU51bWJlci5ZQU1MU2VxIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRkXCIsIHN0cmluZ2lmeU51bWJlci5ZQU1MTWFwLnByb3RvdHlwZS5hZGQuYmluZCh0aGlzKSk7XG5cbiAgICBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlbGV0ZVwiLCBzdHJpbmdpZnlOdW1iZXIuWUFNTE1hcC5wcm90b3R5cGUuZGVsZXRlLmJpbmQodGhpcykpO1xuXG4gICAgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRcIiwgc3RyaW5naWZ5TnVtYmVyLllBTUxNYXAucHJvdG90eXBlLmdldC5iaW5kKHRoaXMpKTtcblxuICAgIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFzXCIsIHN0cmluZ2lmeU51bWJlci5ZQU1MTWFwLnByb3RvdHlwZS5oYXMuYmluZCh0aGlzKSk7XG5cbiAgICBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFwiLCBzdHJpbmdpZnlOdW1iZXIuWUFNTE1hcC5wcm90b3R5cGUuc2V0LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy50YWcgPSBZQU1MT01hcC50YWc7XG4gIH1cblxuICB0b0pTT04oXywgY3R4KSB7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKSBjdHgub25DcmVhdGUobWFwKTtcblxuICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICBsZXQga2V5LCB2YWx1ZTtcblxuICAgICAgaWYgKHBhaXIgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuUGFpcikge1xuICAgICAgICBrZXkgPSBzdHJpbmdpZnlOdW1iZXIudG9KUyhwYWlyLmtleSwgJycsIGN0eCk7XG4gICAgICAgIHZhbHVlID0gc3RyaW5naWZ5TnVtYmVyLnRvSlMocGFpci52YWx1ZSwga2V5LCBjdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gc3RyaW5naWZ5TnVtYmVyLnRvSlMocGFpciwgJycsIGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXAuaGFzKGtleSkpIHRocm93IG5ldyBFcnJvcignT3JkZXJlZCBtYXBzIG11c3Qgbm90IGluY2x1ZGUgZHVwbGljYXRlIGtleXMnKTtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG59XG5cbl9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuX2RlZmluZVByb3BlcnR5KFlBTUxPTWFwLCBcInRhZ1wiLCAndGFnOnlhbWwub3JnLDIwMDI6b21hcCcpO1xuXG5mdW5jdGlvbiBwYXJzZU9NYXAoc2VxLCBvbkVycm9yKSB7XG4gIGNvbnN0IHBhaXJzID0gcGFyc2VQYWlycyhzZXEsIG9uRXJyb3IpO1xuICBjb25zdCBzZWVuS2V5cyA9IFtdO1xuXG4gIGZvciAoY29uc3Qge1xuICAgIGtleVxuICB9IG9mIHBhaXJzLml0ZW1zKSB7XG4gICAgaWYgKGtleSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5TY2FsYXIpIHtcbiAgICAgIGlmIChzZWVuS2V5cy5pbmNsdWRlcyhrZXkudmFsdWUpKSB7XG4gICAgICAgIG9uRXJyb3IoYE9yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzOiAke2tleS52YWx1ZX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW5LZXlzLnB1c2goa2V5LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgWUFNTE9NYXAoKSwgcGFpcnMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPTWFwKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICBjb25zdCBwYWlycyA9IGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCk7XG4gIGNvbnN0IG9tYXAgPSBuZXcgWUFNTE9NYXAoKTtcbiAgb21hcC5pdGVtcyA9IHBhaXJzLml0ZW1zO1xuICByZXR1cm4gb21hcDtcbn1cblxuY29uc3Qgb21hcCA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgTWFwLFxuICBub2RlQ2xhc3M6IFlBTUxPTWFwLFxuICBkZWZhdWx0OiBmYWxzZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsXG4gIHJlc29sdmU6IHBhcnNlT01hcCxcbiAgY3JlYXRlTm9kZTogY3JlYXRlT01hcFxufTtcblxuY2xhc3MgWUFNTFNldCBleHRlbmRzIHN0cmluZ2lmeU51bWJlci5ZQU1MTWFwIHtcbiAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgc3VwZXIoc2NoZW1hKTtcbiAgICB0aGlzLnRhZyA9IFlBTUxTZXQudGFnO1xuICB9XG5cbiAgYWRkKGtleSkge1xuICAgIGNvbnN0IHBhaXIgPSBrZXkgaW5zdGFuY2VvZiBzdHJpbmdpZnlOdW1iZXIuUGFpciA/IGtleSA6IG5ldyBzdHJpbmdpZnlOdW1iZXIuUGFpcihrZXkpO1xuICAgIGNvbnN0IHByZXYgPSBzdHJpbmdpZnlOdW1iZXIuZmluZFBhaXIodGhpcy5pdGVtcywgcGFpci5rZXkpO1xuICAgIGlmICghcHJldikgdGhpcy5pdGVtcy5wdXNoKHBhaXIpO1xuICB9XG5cbiAgZ2V0KGtleSwga2VlcFBhaXIpIHtcbiAgICBjb25zdCBwYWlyID0gc3RyaW5naWZ5TnVtYmVyLmZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgcmV0dXJuICFrZWVwUGFpciAmJiBwYWlyIGluc3RhbmNlb2Ygc3RyaW5naWZ5TnVtYmVyLlBhaXIgPyBwYWlyLmtleSBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5TY2FsYXIgPyBwYWlyLmtleS52YWx1ZSA6IHBhaXIua2V5IDogcGFpcjtcbiAgfVxuXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4gdmFsdWUgZm9yIHNldChrZXksIHZhbHVlKSBpbiBhIFlBTUwgc2V0LCBub3QgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgY29uc3QgcHJldiA9IHN0cmluZ2lmeU51bWJlci5maW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuXG4gICAgaWYgKHByZXYgJiYgIXZhbHVlKSB7XG4gICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YocHJldiksIDEpO1xuICAgIH0gZWxzZSBpZiAoIXByZXYgJiYgdmFsdWUpIHtcbiAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgc3RyaW5naWZ5TnVtYmVyLlBhaXIoa2V5KSk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKF8sIGN0eCkge1xuICAgIHJldHVybiBzdXBlci50b0pTT04oXywgY3R4LCBTZXQpO1xuICB9XG5cbiAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgaWYgKCFjdHgpIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICBpZiAodGhpcy5oYXNBbGxOdWxsVmFsdWVzKCkpIHJldHVybiBzdXBlci50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICB9XG5cbn1cblxuX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5fZGVmaW5lUHJvcGVydHkoWUFNTFNldCwgXCJ0YWdcIiwgJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcpO1xuXG5mdW5jdGlvbiBwYXJzZVNldChtYXAsIG9uRXJyb3IpIHtcbiAgaWYgKG1hcCBpbnN0YW5jZW9mIHN0cmluZ2lmeU51bWJlci5ZQU1MTWFwKSB7XG4gICAgaWYgKG1hcC5oYXNBbGxOdWxsVmFsdWVzKCkpIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBZQU1MU2V0KCksIG1hcCk7ZWxzZSBvbkVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICB9IGVsc2Ugb25FcnJvcignRXhwZWN0ZWQgYSBtYXBwaW5nIGZvciB0aGlzIHRhZycpO1xuXG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNldChzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgY29uc3Qge1xuICAgIHJlcGxhY2VyXG4gIH0gPSBjdHg7XG4gIGNvbnN0IHNldCA9IG5ldyBZQU1MU2V0KHNjaGVtYSk7XG5cbiAgZm9yIChsZXQgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIHZhbHVlLCB2YWx1ZSk7XG4gICAgc2V0Lml0ZW1zLnB1c2goc3RyaW5naWZ5TnVtYmVyLmNyZWF0ZVBhaXIodmFsdWUsIG51bGwsIGN0eCkpO1xuICB9XG5cbiAgcmV0dXJuIHNldDtcbn1cblxuY29uc3Qgc2V0ID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBTZXQsXG4gIG5vZGVDbGFzczogWUFNTFNldCxcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsXG4gIHJlc29sdmU6IHBhcnNlU2V0LFxuICBjcmVhdGVOb2RlOiBjcmVhdGVTZXRcbn07XG5cbi8qIGdsb2JhbCBCaWdJbnQgKi9cblxuY29uc3QgcGFyc2VTZXhhZ2VzaW1hbCA9IChzdHIsIGlzSW50KSA9PiB7XG4gIGNvbnN0IHNpZ24gPSBzdHJbMF07XG4gIGNvbnN0IHBhcnRzID0gc2lnbiA9PT0gJy0nIHx8IHNpZ24gPT09ICcrJyA/IHN0ci5zdWJzdHJpbmcoMSkgOiBzdHI7XG5cbiAgY29uc3QgbnVtID0gbiA9PiBpc0ludCAmJiBzdHJpbmdpZnlOdW1iZXIuaW50T3B0aW9ucy5hc0JpZ0ludCA/IEJpZ0ludChuKSA6IE51bWJlcihuKTtcblxuICBjb25zdCByZXMgPSBwYXJ0cy5yZXBsYWNlKC9fL2csICcnKS5zcGxpdCgnOicpLnJlZHVjZSgocmVzLCBwKSA9PiByZXMgKiBudW0oNjApICsgbnVtKHApLCBudW0oMCkpO1xuICByZXR1cm4gc2lnbiA9PT0gJy0nID8gbnVtKC0xKSAqIHJlcyA6IHJlcztcbn07IC8vIGhoaGg6bW06c3Muc3NzXG5cblxuY29uc3Qgc3RyaW5naWZ5U2V4YWdlc2ltYWwgPSAoe1xuICB2YWx1ZVxufSkgPT4ge1xuICBsZXQgbnVtID0gbiA9PiBuO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSBudW0gPSBuID0+IEJpZ0ludChuKTtlbHNlIGlmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkgcmV0dXJuIHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXIodmFsdWUpO1xuICBsZXQgc2lnbiA9ICcnO1xuXG4gIGlmICh2YWx1ZSA8IDApIHtcbiAgICBzaWduID0gJy0nO1xuICAgIHZhbHVlICo9IG51bSgtMSk7XG4gIH1cblxuICBjb25zdCBfNjAgPSBudW0oNjApO1xuXG4gIGNvbnN0IHBhcnRzID0gW3ZhbHVlICUgXzYwXTsgLy8gc2Vjb25kcywgaW5jbHVkaW5nIG1zXG5cbiAgaWYgKHZhbHVlIDwgNjApIHtcbiAgICBwYXJ0cy51bnNoaWZ0KDApOyAvLyBhdCBsZWFzdCBvbmUgOiBpcyByZXF1aXJlZFxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gKHZhbHVlIC0gcGFydHNbMF0pIC8gXzYwO1xuICAgIHBhcnRzLnVuc2hpZnQodmFsdWUgJSBfNjApOyAvLyBtaW51dGVzXG5cbiAgICBpZiAodmFsdWUgPj0gNjApIHtcbiAgICAgIHZhbHVlID0gKHZhbHVlIC0gcGFydHNbMF0pIC8gXzYwO1xuICAgICAgcGFydHMudW5zaGlmdCh2YWx1ZSk7IC8vIGhvdXJzXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNpZ24gKyBwYXJ0cy5tYXAobiA9PiBuIDwgMTAgPyAnMCcgKyBTdHJpbmcobikgOiBTdHJpbmcobikpLmpvaW4oJzonKS5yZXBsYWNlKC8wMDAwMDBcXGQqJC8sICcnKSAvLyAlIDYwIG1heSBpbnRyb2R1Y2UgZXJyb3JcbiAgO1xufTtcblxuY29uc3QgaW50VGltZSA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ1RJTUUnLFxuICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKSskLyxcbiAgcmVzb2x2ZTogc3RyID0+IHBhcnNlU2V4YWdlc2ltYWwoc3RyLCB0cnVlKSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlTZXhhZ2VzaW1hbFxufTtcbmNvbnN0IGZsb2F0VGltZSA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgZm9ybWF0OiAnVElNRScsXG4gIHRlc3Q6IC9eWy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcLlswLTlfXSokLyxcbiAgcmVzb2x2ZTogc3RyID0+IHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBmYWxzZSksXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCB0aW1lc3RhbXAgPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsXG4gIC8vIElmIHRoZSB0aW1lIHpvbmUgaXMgb21pdHRlZCwgdGhlIHRpbWVzdGFtcCBpcyBhc3N1bWVkIHRvIGJlIHNwZWNpZmllZCBpbiBVVEMuIFRoZSB0aW1lIHBhcnRcbiAgLy8gbWF5IGJlIG9taXR0ZWQgYWx0b2dldGhlciwgcmVzdWx0aW5nIGluIGEgZGF0ZSBmb3JtYXQuIEluIHN1Y2ggYSBjYXNlLCB0aGUgdGltZSBwYXJ0IGlzXG4gIC8vIGFzc3VtZWQgdG8gYmUgMDA6MDA6MDBaIChzdGFydCBvZiBkYXksIFVUQykuXG4gIHRlc3Q6IFJlZ0V4cCgnXihbMC05XXs0fSktKFswLTldezEsMn0pLShbMC05XXsxLDJ9KScgKyAvLyBZWVlZLU1tLURkXG4gICcoPzonICsgLy8gdGltZSBpcyBvcHRpb25hbFxuICAnKD86dHxUfFsgXFxcXHRdKyknICsgLy8gdCB8IFQgfCB3aGl0ZXNwYWNlXG4gICcoWzAtOV17MSwyfSk6KFswLTldezEsMn0pOihbMC05XXsxLDJ9KFxcXFwuWzAtOV0rKT8pJyArIC8vIEhoOk1tOlNzKC5zcyk/XG4gICcoPzpbIFxcXFx0XSooWnxbLStdWzAxMl0/WzAtOV0oPzo6WzAtOV17Mn0pPykpPycgKyAvLyBaIHwgKzUgfCAtMDM6MzBcbiAgJyk/JCcpLFxuXG4gIHJlc29sdmUoc3RyKSB7XG4gICAgbGV0IFssIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlYywgdHpdID0gc3RyLm1hdGNoKHRpbWVzdGFtcC50ZXN0KTtcbiAgICBpZiAobWlsbGlzZWMpIG1pbGxpc2VjID0gKG1pbGxpc2VjICsgJzAwJykuc3Vic3RyKDEsIDMpO1xuICAgIGxldCBkYXRlID0gRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIgfHwgMCwgbWludXRlIHx8IDAsIHNlY29uZCB8fCAwLCBtaWxsaXNlYyB8fCAwKTtcblxuICAgIGlmICh0eiAmJiB0eiAhPT0gJ1onKSB7XG4gICAgICBsZXQgZCA9IHBhcnNlU2V4YWdlc2ltYWwodHosIGZhbHNlKTtcbiAgICAgIGlmIChNYXRoLmFicyhkKSA8IDMwKSBkICo9IDYwO1xuICAgICAgZGF0ZSAtPSA2MDAwMCAqIGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICB9LFxuXG4gIHN0cmluZ2lmeTogKHtcbiAgICB2YWx1ZVxuICB9KSA9PiB2YWx1ZS50b0lTT1N0cmluZygpLnJlcGxhY2UoLygoVDAwOjAwKT86MDApP1xcLjAwMFokLywgJycpXG59O1xuXG4vKiBnbG9iYWwgQmlnSW50ICovXG5cbmNvbnN0IGJvb2xTdHJpbmdpZnkgPSAoe1xuICB2YWx1ZVxufSkgPT4gdmFsdWUgPyBzdHJpbmdpZnlOdW1iZXIuYm9vbE9wdGlvbnMudHJ1ZVN0ciA6IHN0cmluZ2lmeU51bWJlci5ib29sT3B0aW9ucy5mYWxzZVN0cjtcblxuY29uc3QgaW50SWRlbnRpZnkkMiA9IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5cbmZ1bmN0aW9uIGludFJlc29sdmUkMShzdHIsIG9mZnNldCwgcmFkaXgpIHtcbiAgY29uc3Qgc2lnbiA9IHN0clswXTtcbiAgaWYgKHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycpIG9mZnNldCArPSAxO1xuICBzdHIgPSBzdHIuc3Vic3RyaW5nKG9mZnNldCkucmVwbGFjZSgvXy9nLCAnJyk7XG5cbiAgaWYgKHN0cmluZ2lmeU51bWJlci5pbnRPcHRpb25zLmFzQmlnSW50KSB7XG4gICAgc3dpdGNoIChyYWRpeCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICBzdHIgPSBgMGIke3N0cn1gO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA4OlxuICAgICAgICBzdHIgPSBgMG8ke3N0cn1gO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxNjpcbiAgICAgICAgc3RyID0gYDB4JHtzdHJ9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgbiA9IEJpZ0ludChzdHIpO1xuICAgIHJldHVybiBzaWduID09PSAnLScgPyBCaWdJbnQoLTEpICogbiA6IG47XG4gIH1cblxuICBjb25zdCBuID0gcGFyc2VJbnQoc3RyLCByYWRpeCk7XG4gIHJldHVybiBzaWduID09PSAnLScgPyAtMSAqIG4gOiBuO1xufVxuXG5mdW5jdGlvbiBpbnRTdHJpbmdpZnkkMShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZVxuICB9ID0gbm9kZTtcblxuICBpZiAoaW50SWRlbnRpZnkkMih2YWx1ZSkpIHtcbiAgICBjb25zdCBzdHIgPSB2YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgcmV0dXJuIHZhbHVlIDwgMCA/ICctJyArIHByZWZpeCArIHN0ci5zdWJzdHIoMSkgOiBwcmVmaXggKyBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlcihub2RlKTtcbn1cblxuY29uc3QgeWFtbDExID0gZmFpbHNhZmUuY29uY2F0KFt7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsLFxuICBjcmVhdGVOb2RlOiAoc2NoZW1hLCB2YWx1ZSwgY3R4KSA9PiBjdHgud3JhcFNjYWxhcnMgPyBuZXcgc3RyaW5naWZ5TnVtYmVyLlNjYWxhcihudWxsKSA6IG51bGwsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICB0ZXN0OiAvXig/On58W05uXXVsbHxOVUxMKT8kLyxcbiAgcmVzb2x2ZTogc3RyID0+IHtcbiAgICBjb25zdCBub2RlID0gbmV3IHN0cmluZ2lmeU51bWJlci5TY2FsYXIobnVsbCk7XG4gICAgbm9kZS5zb3VyY2VTdHIgPSBzdHI7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIG9wdGlvbnM6IHN0cmluZ2lmeU51bWJlci5udWxsT3B0aW9ucyxcbiAgc3RyaW5naWZ5OiAoe1xuICAgIHNvdXJjZVN0clxuICB9KSA9PiBzb3VyY2VTdHIgIT09IG51bGwgJiYgc291cmNlU3RyICE9PSB2b2lkIDAgPyBzb3VyY2VTdHIgOiBzdHJpbmdpZnlOdW1iZXIubnVsbE9wdGlvbnMubnVsbFN0clxufSwge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICB0ZXN0OiAvXig/Oll8eXxbWXldZXN8WUVTfFtUdF1ydWV8VFJVRXxbT29dbnxPTikkLyxcbiAgcmVzb2x2ZTogKCkgPT4gdHJ1ZSxcbiAgb3B0aW9uczogc3RyaW5naWZ5TnVtYmVyLmJvb2xPcHRpb25zLFxuICBzdHJpbmdpZnk6IGJvb2xTdHJpbmdpZnlcbn0sIHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgdGVzdDogL14oPzpOfG58W05uXW98Tk98W0ZmXWFsc2V8RkFMU0V8W09vXWZmfE9GRikkLyxcbiAgcmVzb2x2ZTogKCkgPT4gZmFsc2UsXG4gIG9wdGlvbnM6IHN0cmluZ2lmeU51bWJlci5ib29sT3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59LCB7XG4gIGlkZW50aWZ5OiBpbnRJZGVudGlmeSQyLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdCSU4nLFxuICB0ZXN0OiAvXlstK10/MGJbMC0xX10rJC8sXG4gIHJlc29sdmU6IHN0ciA9PiBpbnRSZXNvbHZlJDEoc3RyLCAyLCAyKSxcbiAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeSQxKG5vZGUsIDIsICcwYicpXG59LCB7XG4gIGlkZW50aWZ5OiBpbnRJZGVudGlmeSQyLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdPQ1QnLFxuICB0ZXN0OiAvXlstK10/MFswLTdfXSskLyxcbiAgcmVzb2x2ZTogc3RyID0+IGludFJlc29sdmUkMShzdHIsIDEsIDgpLFxuICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5JDEobm9kZSwgOCwgJzAnKVxufSwge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnkkMixcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgdGVzdDogL15bLStdP1swLTldWzAtOV9dKiQvLFxuICByZXNvbHZlOiBzdHIgPT4gaW50UmVzb2x2ZSQxKHN0ciwgMCwgMTApLFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXJcbn0sIHtcbiAgaWRlbnRpZnk6IGludElkZW50aWZ5JDIsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ0hFWCcsXG4gIHRlc3Q6IC9eWy0rXT8weFswLTlhLWZBLUZfXSskLyxcbiAgcmVzb2x2ZTogc3RyID0+IGludFJlc29sdmUkMShzdHIsIDIsIDE2KSxcbiAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeSQxKG5vZGUsIDE2LCAnMHgnKVxufSwge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICB0ZXN0OiAvXlstK10/XFwuKD86aW5mfEluZnxJTkZ8bmFufE5hTnxOQU4pJC8sXG4gIHJlc29sdmU6IHN0ciA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nID8gTmFOIDogc3RyWzBdID09PSAnLScgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlclxufSwge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICBmb3JtYXQ6ICdFWFAnLFxuICB0ZXN0OiAvXlstK10/KD86WzAtOV1bMC05X10qKT8oPzpcXC5bMC05X10qKT9bZUVdWy0rXT9bMC05XSskLyxcbiAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoL18vZywgJycpKSxcbiAgc3RyaW5naWZ5OiAoe1xuICAgIHZhbHVlXG4gIH0pID0+IE51bWJlcih2YWx1ZSkudG9FeHBvbmVudGlhbCgpXG59LCB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIHRlc3Q6IC9eWy0rXT8oPzpbMC05XVswLTlfXSopP1xcLlswLTlfXSokLyxcblxuICByZXNvbHZlKHN0cikge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgc3RyaW5naWZ5TnVtYmVyLlNjYWxhcihwYXJzZUZsb2F0KHN0ci5yZXBsYWNlKC9fL2csICcnKSkpO1xuICAgIGNvbnN0IGRvdCA9IHN0ci5pbmRleE9mKCcuJyk7XG5cbiAgICBpZiAoZG90ICE9PSAtMSkge1xuICAgICAgY29uc3QgZiA9IHN0ci5zdWJzdHJpbmcoZG90ICsgMSkucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICBpZiAoZltmLmxlbmd0aCAtIDFdID09PSAnMCcpIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBmLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXJcbn1dLCBiaW5hcnksIG9tYXAsIHBhaXJzLCBzZXQsIGludFRpbWUsIGZsb2F0VGltZSwgdGltZXN0YW1wKTtcblxuY29uc3Qgc2NoZW1hcyA9IHtcbiAgY29yZSxcbiAgZmFpbHNhZmUsXG4gIGpzb24sXG4gIHlhbWwxMVxufTtcbmNvbnN0IHRhZ3MgPSB7XG4gIGJpbmFyeSxcbiAgYm9vbDogYm9vbE9iaixcbiAgZmxvYXQ6IGZsb2F0T2JqLFxuICBmbG9hdEV4cDogZXhwT2JqLFxuICBmbG9hdE5hTjogbmFuT2JqLFxuICBmbG9hdFRpbWUsXG4gIGludDogaW50T2JqLFxuICBpbnRIZXg6IGhleE9iaixcbiAgaW50T2N0OiBvY3RPYmosXG4gIGludFRpbWUsXG4gIG1hcCxcbiAgbnVsbDogbnVsbE9iaixcbiAgb21hcCxcbiAgcGFpcnMsXG4gIHNlcSxcbiAgc2V0LFxuICB0aW1lc3RhbXBcbn07XG5cbmZ1bmN0aW9uIGdldFNjaGVtYVRhZ3Moc2NoZW1hcywga25vd25UYWdzLCBjdXN0b21UYWdzLCBzY2hlbWFJZCkge1xuICBsZXQgdGFncyA9IHNjaGVtYXNbc2NoZW1hSWQucmVwbGFjZSgvXFxXL2csICcnKV07IC8vICd5YW1sLTEuMScgLT4gJ3lhbWwxMSdcblxuICBpZiAoIXRhZ3MpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hcykubWFwKGtleSA9PiBKU09OLnN0cmluZ2lmeShrZXkpKS5qb2luKCcsICcpO1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzY2hlbWEgXCIke3NjaGVtYUlkfVwiOyB1c2Ugb25lIG9mICR7a2V5c31gKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKSB7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgY3VzdG9tVGFncykgdGFncyA9IHRhZ3MuY29uY2F0KHRhZyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGN1c3RvbVRhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0YWdzID0gY3VzdG9tVGFncyh0YWdzLnNsaWNlKCkpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgdGFnID0gdGFnc1tpXTtcblxuICAgIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdGFnT2JqID0ga25vd25UYWdzW3RhZ107XG5cbiAgICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhrbm93blRhZ3MpLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSkuam9pbignLCAnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGN1c3RvbSB0YWcgXCIke3RhZ31cIjsgdXNlIG9uZSBvZiAke2tleXN9YCk7XG4gICAgICB9XG5cbiAgICAgIHRhZ3NbaV0gPSB0YWdPYmo7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhZ3M7XG59XG5cbmNvbnN0IHNvcnRNYXBFbnRyaWVzQnlLZXkgPSAoYSwgYikgPT4gYS5rZXkgPCBiLmtleSA/IC0xIDogYS5rZXkgPiBiLmtleSA/IDEgOiAwO1xuXG5jb25zdCBjb3JlS25vd25UYWdzID0ge1xuICAndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5JzogdGFncy5iaW5hcnksXG4gICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJzogdGFncy5vbWFwLFxuICAndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnOiB0YWdzLnBhaXJzLFxuICAndGFnOnlhbWwub3JnLDIwMDI6c2V0JzogdGFncy5zZXQsXG4gICd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnOiB0YWdzLnRpbWVzdGFtcFxufTtcbmNsYXNzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjdXN0b21UYWdzLFxuICAgIG1lcmdlLFxuICAgIHJlc29sdmVLbm93blRhZ3MsXG4gICAgc2NoZW1hLFxuICAgIHNvcnRNYXBFbnRyaWVzXG4gIH0pIHtcbiAgICB0aGlzLm1lcmdlID0gISFtZXJnZTtcbiAgICB0aGlzLm5hbWUgPSBzY2hlbWE7XG4gICAgdGhpcy5rbm93blRhZ3MgPSByZXNvbHZlS25vd25UYWdzID8gY29yZUtub3duVGFncyA6IHt9O1xuICAgIHRoaXMudGFncyA9IGdldFNjaGVtYVRhZ3Moc2NoZW1hcywgdGFncywgY3VzdG9tVGFncywgc2NoZW1hKTsgLy8gVXNlZCBieSBjcmVhdGVOb2RlKCksIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG4gICAgdGhpcy5tYXAgPSB0YWdzLm1hcDtcbiAgICB0aGlzLnNlcSA9IHRhZ3Muc2VxOyAvLyBVc2VkIGJ5IGNyZWF0ZU1hcCgpXG5cbiAgICB0aGlzLnNvcnRNYXBFbnRyaWVzID0gc29ydE1hcEVudHJpZXMgPT09IHRydWUgPyBzb3J0TWFwRW50cmllc0J5S2V5IDogc29ydE1hcEVudHJpZXMgfHwgbnVsbDtcbiAgfVxuXG59XG5cbmV4cG9ydHMuTUVSR0VfS0VZID0gTUVSR0VfS0VZO1xuZXhwb3J0cy5NZXJnZSA9IE1lcmdlO1xuZXhwb3J0cy5TY2hlbWEgPSBTY2hlbWE7XG4iXSwibmFtZXMiOlsiX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycyIsInJlcXVpcmUiLCJzdHJpbmdpZnlOdW1iZXIiLCJNRVJHRV9LRVkiLCJNZXJnZSIsIlBhaXIiLCJjb25zdHJ1Y3RvciIsInBhaXIiLCJzZXEiLCJ2YWx1ZSIsIllBTUxTZXEiLCJpdGVtcyIsInB1c2giLCJyYW5nZSIsImtleSIsIlNjYWxhciIsInR5cGUiLCJUeXBlIiwiTUVSR0VfUEFJUiIsImFkZFRvSlNNYXAiLCJjdHgiLCJtYXAiLCJzb3VyY2UiLCJZQU1MTWFwIiwiRXJyb3IiLCJzcmNNYXAiLCJ0b0pTT04iLCJNYXAiLCJoYXMiLCJzZXQiLCJTZXQiLCJhZGQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInRvU3RyaW5nIiwib25Db21tZW50IiwibGVuZ3RoIiwic3RyIiwiY3JlYXRlTWFwIiwic2NoZW1hIiwib2JqIiwia2VlcFVuZGVmaW5lZCIsInJlcGxhY2VyIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5jbHVkZXMiLCJ1bmRlZmluZWQiLCJjcmVhdGVQYWlyIiwia2V5cyIsInNvcnRNYXBFbnRyaWVzIiwic29ydCIsImNyZWF0ZU5vZGUiLCJkZWZhdWx0Iiwibm9kZUNsYXNzIiwidGFnIiwicmVzb2x2ZSIsImNyZWF0ZVNlcSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaSIsIml0IiwiU3RyaW5nIiwic3RyaW5nIiwiaWRlbnRpZnkiLCJzdHJpbmdpZnkiLCJpdGVtIiwib25DaG9tcEtlZXAiLCJhc3NpZ24iLCJhY3R1YWxTdHJpbmciLCJzdHJpbmdpZnlTdHJpbmciLCJvcHRpb25zIiwic3RyT3B0aW9ucyIsImZhaWxzYWZlIiwiaW50SWRlbnRpZnkiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJpbnRSZXNvbHZlIiwic3JjIiwib2Zmc2V0IiwicmFkaXgiLCJpbnRPcHRpb25zIiwiYXNCaWdJbnQiLCJCaWdJbnQiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImludFN0cmluZ2lmeSIsIm5vZGUiLCJwcmVmaXgiLCJudWxsT2JqIiwid3JhcFNjYWxhcnMiLCJ0ZXN0Iiwic291cmNlU3RyIiwibnVsbE9wdGlvbnMiLCJudWxsU3RyIiwiYm9vbE9iaiIsImJvb2xPcHRpb25zIiwidHJ1ZVN0ciIsImZhbHNlU3RyIiwib2N0T2JqIiwiZm9ybWF0IiwiaW50T2JqIiwiaGV4T2JqIiwibmFuT2JqIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsIk5hTiIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJleHBPYmoiLCJwYXJzZUZsb2F0IiwidG9FeHBvbmVudGlhbCIsImZsb2F0T2JqIiwiZG90IiwiaW5kZXhPZiIsIm1pbkZyYWN0aW9uRGlnaXRzIiwiY29yZSIsImNvbmNhdCIsImludElkZW50aWZ5JDEiLCJzdHJpbmdpZnlKU09OIiwiSlNPTiIsImpzb24iLCJvbkVycm9yIiwiYmluYXJ5IiwiVWludDhBcnJheSIsIkJ1ZmZlciIsImZyb20iLCJhdG9iIiwicmVwbGFjZSIsImJ1ZmZlciIsImNoYXJDb2RlQXQiLCJiaW5hcnlPcHRpb25zIiwiY29tbWVudCIsImJ0b2EiLCJzIiwiZnJvbUNoYXJDb2RlIiwiZGVmYXVsdFR5cGUiLCJRVU9URV9ET1VCTEUiLCJsaW5lV2lkdGgiLCJuIiwiTWF0aCIsImNlaWwiLCJsaW5lcyIsIm8iLCJzdWJzdHIiLCJqb2luIiwiQkxPQ0tfTElURVJBTCIsInBhcnNlUGFpcnMiLCJjb21tZW50QmVmb3JlIiwiY3JlYXRlUGFpcnMiLCJpdGVyYWJsZSIsInBhaXJzIiwiVHlwZUVycm9yIiwiWUFNTE9NYXAiLCJfZGVmaW5lUHJvcGVydHkiLCJiaW5kIiwiZGVsZXRlIiwiZ2V0IiwiXyIsIm9uQ3JlYXRlIiwidG9KUyIsInBhcnNlT01hcCIsInNlZW5LZXlzIiwiY3JlYXRlT01hcCIsIm9tYXAiLCJZQU1MU2V0IiwicHJldiIsImZpbmRQYWlyIiwia2VlcFBhaXIiLCJzcGxpY2UiLCJoYXNBbGxOdWxsVmFsdWVzIiwicGFyc2VTZXQiLCJjcmVhdGVTZXQiLCJwYXJzZVNleGFnZXNpbWFsIiwiaXNJbnQiLCJzaWduIiwicGFydHMiLCJudW0iLCJyZXMiLCJzcGxpdCIsInJlZHVjZSIsInAiLCJzdHJpbmdpZnlTZXhhZ2VzaW1hbCIsImlzTmFOIiwiaXNGaW5pdGUiLCJfNjAiLCJ1bnNoaWZ0IiwiaW50VGltZSIsImZsb2F0VGltZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJSZWdFeHAiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWMiLCJ0eiIsIm1hdGNoIiwiZGF0ZSIsIlVUQyIsImQiLCJhYnMiLCJ0b0lTT1N0cmluZyIsImJvb2xTdHJpbmdpZnkiLCJpbnRJZGVudGlmeSQyIiwiaW50UmVzb2x2ZSQxIiwiaW50U3RyaW5naWZ5JDEiLCJ5YW1sMTEiLCJmIiwic2NoZW1hcyIsInRhZ3MiLCJib29sIiwiZmxvYXQiLCJmbG9hdEV4cCIsImZsb2F0TmFOIiwiaW50IiwiaW50SGV4IiwiaW50T2N0IiwibnVsbCIsImdldFNjaGVtYVRhZ3MiLCJrbm93blRhZ3MiLCJjdXN0b21UYWdzIiwic2NoZW1hSWQiLCJ0YWdPYmoiLCJzb3J0TWFwRW50cmllc0J5S2V5IiwiYSIsImIiLCJjb3JlS25vd25UYWdzIiwiU2NoZW1hIiwibWVyZ2UiLCJyZXNvbHZlS25vd25UYWdzIiwibmFtZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/Schema-807430ba.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/_rollupPluginBabelHelpers-eed30217.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/swagger-jsdoc/node_modules/yaml/dist/_rollupPluginBabelHelpers-eed30217.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nconst Char = {\n    ANCHOR: \"&\",\n    COMMENT: \"#\",\n    TAG: \"!\",\n    DIRECTIVES_END: \"-\",\n    DOCUMENT_END: \".\"\n};\nconst Type = {\n    ALIAS: \"ALIAS\",\n    BLANK_LINE: \"BLANK_LINE\",\n    BLOCK_FOLDED: \"BLOCK_FOLDED\",\n    BLOCK_LITERAL: \"BLOCK_LITERAL\",\n    COMMENT: \"COMMENT\",\n    DIRECTIVE: \"DIRECTIVE\",\n    DOCUMENT: \"DOCUMENT\",\n    FLOW_MAP: \"FLOW_MAP\",\n    FLOW_SEQ: \"FLOW_SEQ\",\n    MAP: \"MAP\",\n    MAP_KEY: \"MAP_KEY\",\n    MAP_VALUE: \"MAP_VALUE\",\n    PLAIN: \"PLAIN\",\n    QUOTE_DOUBLE: \"QUOTE_DOUBLE\",\n    QUOTE_SINGLE: \"QUOTE_SINGLE\",\n    SEQ: \"SEQ\",\n    SEQ_ITEM: \"SEQ_ITEM\"\n};\nconst defaultTagPrefix = \"tag:yaml.org,2002:\";\nconst defaultTags = {\n    MAP: \"tag:yaml.org,2002:map\",\n    SEQ: \"tag:yaml.org,2002:seq\",\n    STR: \"tag:yaml.org,2002:str\"\n};\nfunction findLineStarts(src) {\n    const ls = [\n        0\n    ];\n    let offset = src.indexOf(\"\\n\");\n    while(offset !== -1){\n        offset += 1;\n        ls.push(offset);\n        offset = src.indexOf(\"\\n\", offset);\n    }\n    return ls;\n}\nfunction getSrcInfo(cst) {\n    let lineStarts, src;\n    if (typeof cst === \"string\") {\n        lineStarts = findLineStarts(cst);\n        src = cst;\n    } else {\n        if (Array.isArray(cst)) cst = cst[0];\n        if (cst && cst.context) {\n            if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n            lineStarts = cst.lineStarts;\n            src = cst.context.src;\n        }\n    }\n    return {\n        lineStarts,\n        src\n    };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */ /**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */ function getLinePos(offset, cst) {\n    if (typeof offset !== \"number\" || offset < 0) return null;\n    const { lineStarts, src } = getSrcInfo(cst);\n    if (!lineStarts || !src || offset > src.length) return null;\n    for(let i = 0; i < lineStarts.length; ++i){\n        const start = lineStarts[i];\n        if (offset < start) {\n            return {\n                line: i,\n                col: offset - lineStarts[i - 1] + 1\n            };\n        }\n        if (offset === start) return {\n            line: i + 1,\n            col: 1\n        };\n    }\n    const line = lineStarts.length;\n    return {\n        line,\n        col: offset - lineStarts[line - 1] + 1\n    };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */ function getLine(line, cst) {\n    const { lineStarts, src } = getSrcInfo(cst);\n    if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n    const start = lineStarts[line - 1];\n    let end = lineStarts[line]; // undefined for last line; that's ok for slice()\n    while(end && end > start && src[end - 1] === \"\\n\")--end;\n    return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */ function getPrettyContext({ start, end }, cst, maxWidth = 80) {\n    let src = getLine(start.line, cst);\n    if (!src) return null;\n    let { col } = start;\n    if (src.length > maxWidth) {\n        if (col <= maxWidth - 10) {\n            src = src.substr(0, maxWidth - 1) + \"\";\n        } else {\n            const halfWidth = Math.round(maxWidth / 2);\n            if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + \"\";\n            col -= src.length - maxWidth;\n            src = \"\" + src.substr(1 - maxWidth);\n        }\n    }\n    let errLen = 1;\n    let errEnd = \"\";\n    if (end) {\n        if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n            errLen = end.col - start.col;\n        } else {\n            errLen = Math.min(src.length + 1, maxWidth) - col;\n            errEnd = \"\";\n        }\n    }\n    const offset = col > 1 ? \" \".repeat(col - 1) : \"\";\n    const err = \"^\".repeat(errLen);\n    return `${src}\\n${offset}${err}${errEnd}`;\n}\nclass Range {\n    static copy(orig) {\n        return new Range(orig.start, orig.end);\n    }\n    constructor(start, end){\n        this.start = start;\n        this.end = end || start;\n    }\n    isEmpty() {\n        return typeof this.start !== \"number\" || !this.end || this.end <= this.start;\n    }\n    /**\n   * Set `origStart` and `origEnd` to point to the original source range for\n   * this node, which may differ due to dropped CR characters.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */ setOrigRange(cr, offset) {\n        const { start, end } = this;\n        if (cr.length === 0 || end <= cr[0]) {\n            this.origStart = start;\n            this.origEnd = end;\n            return offset;\n        }\n        let i = offset;\n        while(i < cr.length){\n            if (cr[i] > start) break;\n            else ++i;\n        }\n        this.origStart = start + i;\n        const nextOffset = i;\n        while(i < cr.length){\n            // if end was at \\n, it should now be at \\r\n            if (cr[i] >= end) break;\n            else ++i;\n        }\n        this.origEnd = end + i;\n        return nextOffset;\n    }\n}\n/** Root class of all nodes */ class Node {\n    static addStringTerminator(src, offset, str) {\n        if (str[str.length - 1] === \"\\n\") return str;\n        const next = Node.endOfWhiteSpace(src, offset);\n        return next >= src.length || src[next] === \"\\n\" ? str + \"\\n\" : str;\n    }\n    static atDocumentBoundary(src, offset, sep) {\n        const ch0 = src[offset];\n        if (!ch0) return true;\n        const prev = src[offset - 1];\n        if (prev && prev !== \"\\n\") return false;\n        if (sep) {\n            if (ch0 !== sep) return false;\n        } else {\n            if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n        }\n        const ch1 = src[offset + 1];\n        const ch2 = src[offset + 2];\n        if (ch1 !== ch0 || ch2 !== ch0) return false;\n        const ch3 = src[offset + 3];\n        return !ch3 || ch3 === \"\\n\" || ch3 === \"\t\" || ch3 === \" \";\n    }\n    static endOfIdentifier(src, offset) {\n        let ch = src[offset];\n        const isVerbatim = ch === \"<\";\n        const notOk = isVerbatim ? [\n            \"\\n\",\n            \"\t\",\n            \" \",\n            \">\"\n        ] : [\n            \"\\n\",\n            \"\t\",\n            \" \",\n            \"[\",\n            \"]\",\n            \"{\",\n            \"}\",\n            \",\"\n        ];\n        while(ch && notOk.indexOf(ch) === -1)ch = src[offset += 1];\n        if (isVerbatim && ch === \">\") offset += 1;\n        return offset;\n    }\n    static endOfIndent(src, offset) {\n        let ch = src[offset];\n        while(ch === \" \")ch = src[offset += 1];\n        return offset;\n    }\n    static endOfLine(src, offset) {\n        let ch = src[offset];\n        while(ch && ch !== \"\\n\")ch = src[offset += 1];\n        return offset;\n    }\n    static endOfWhiteSpace(src, offset) {\n        let ch = src[offset];\n        while(ch === \"\t\" || ch === \" \")ch = src[offset += 1];\n        return offset;\n    }\n    static startOfLine(src, offset) {\n        let ch = src[offset - 1];\n        if (ch === \"\\n\") return offset;\n        while(ch && ch !== \"\\n\")ch = src[offset -= 1];\n        return offset + 1;\n    }\n    /**\n   * End of indentation, or null if the line's indent level is not more\n   * than `indent`\n   *\n   * @param {string} src\n   * @param {number} indent\n   * @param {number} lineStart\n   * @returns {?number}\n   */ static endOfBlockIndent(src, indent, lineStart) {\n        const inEnd = Node.endOfIndent(src, lineStart);\n        if (inEnd > lineStart + indent) {\n            return inEnd;\n        } else {\n            const wsEnd = Node.endOfWhiteSpace(src, inEnd);\n            const ch = src[wsEnd];\n            if (!ch || ch === \"\\n\") return wsEnd;\n        }\n        return null;\n    }\n    static atBlank(src, offset, endAsBlank) {\n        const ch = src[offset];\n        return ch === \"\\n\" || ch === \"\t\" || ch === \" \" || endAsBlank && !ch;\n    }\n    static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n        if (!ch || indentDiff < 0) return false;\n        if (indentDiff > 0) return true;\n        return indicatorAsIndent && ch === \"-\";\n    }\n    static normalizeOffset(src, offset) {\n        const ch = src[offset];\n        return !ch ? offset : ch !== \"\\n\" && src[offset - 1] === \"\\n\" ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    }\n    // presumes src[offset] === '\\n'\n    static foldNewline(src, offset, indent) {\n        let inCount = 0;\n        let error = false;\n        let fold = \"\";\n        let ch = src[offset + 1];\n        while(ch === \" \" || ch === \"\t\" || ch === \"\\n\"){\n            switch(ch){\n                case \"\\n\":\n                    inCount = 0;\n                    offset += 1;\n                    fold += \"\\n\";\n                    break;\n                case \"\t\":\n                    if (inCount <= indent) error = true;\n                    offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n                    break;\n                case \" \":\n                    inCount += 1;\n                    offset += 1;\n                    break;\n            }\n            ch = src[offset + 1];\n        }\n        if (!fold) fold = \" \";\n        if (ch && inCount <= indent) error = true;\n        return {\n            fold,\n            offset,\n            error\n        };\n    }\n    constructor(type, props, context){\n        Object.defineProperty(this, \"context\", {\n            value: context || null,\n            writable: true\n        });\n        this.error = null;\n        this.range = null;\n        this.valueRange = null;\n        this.props = props || [];\n        this.type = type;\n        this.value = null;\n    }\n    getPropValue(idx, key, skipKey) {\n        if (!this.context) return null;\n        const { src } = this.context;\n        const prop = this.props[idx];\n        return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n    get anchor() {\n        for(let i = 0; i < this.props.length; ++i){\n            const anchor = this.getPropValue(i, Char.ANCHOR, true);\n            if (anchor != null) return anchor;\n        }\n        return null;\n    }\n    get comment() {\n        const comments = [];\n        for(let i = 0; i < this.props.length; ++i){\n            const comment = this.getPropValue(i, Char.COMMENT, true);\n            if (comment != null) comments.push(comment);\n        }\n        return comments.length > 0 ? comments.join(\"\\n\") : null;\n    }\n    commentHasRequiredWhitespace(start) {\n        const { src } = this.context;\n        if (this.header && start === this.header.end) return false;\n        if (!this.valueRange) return false;\n        const { end } = this.valueRange;\n        return start !== end || Node.atBlank(src, end - 1);\n    }\n    get hasComment() {\n        if (this.context) {\n            const { src } = this.context;\n            for(let i = 0; i < this.props.length; ++i){\n                if (src[this.props[i].start] === Char.COMMENT) return true;\n            }\n        }\n        return false;\n    }\n    get hasProps() {\n        if (this.context) {\n            const { src } = this.context;\n            for(let i = 0; i < this.props.length; ++i){\n                if (src[this.props[i].start] !== Char.COMMENT) return true;\n            }\n        }\n        return false;\n    }\n    get includesTrailingLines() {\n        return false;\n    }\n    get jsonLike() {\n        const jsonLikeTypes = [\n            Type.FLOW_MAP,\n            Type.FLOW_SEQ,\n            Type.QUOTE_DOUBLE,\n            Type.QUOTE_SINGLE\n        ];\n        return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n    get rangeAsLinePos() {\n        if (!this.range || !this.context) return undefined;\n        const start = getLinePos(this.range.start, this.context.root);\n        if (!start) return undefined;\n        const end = getLinePos(this.range.end, this.context.root);\n        return {\n            start,\n            end\n        };\n    }\n    get rawValue() {\n        if (!this.valueRange || !this.context) return null;\n        const { start, end } = this.valueRange;\n        return this.context.src.slice(start, end);\n    }\n    get tag() {\n        for(let i = 0; i < this.props.length; ++i){\n            const tag = this.getPropValue(i, Char.TAG, false);\n            if (tag != null) {\n                if (tag[1] === \"<\") {\n                    return {\n                        verbatim: tag.slice(2, -1)\n                    };\n                } else {\n                    // eslint-disable-next-line no-unused-vars\n                    const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);\n                    return {\n                        handle,\n                        suffix\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    get valueRangeContainsNewline() {\n        if (!this.valueRange || !this.context) return false;\n        const { start, end } = this.valueRange;\n        const { src } = this.context;\n        for(let i = start; i < end; ++i){\n            if (src[i] === \"\\n\") return true;\n        }\n        return false;\n    }\n    parseComment(start) {\n        const { src } = this.context;\n        if (src[start] === Char.COMMENT) {\n            const end = Node.endOfLine(src, start + 1);\n            const commentRange = new Range(start, end);\n            this.props.push(commentRange);\n            return end;\n        }\n        return start;\n    }\n    /**\n   * Populates the `origStart` and `origEnd` values of all ranges for this\n   * node. Extended by child classes to handle descendant nodes.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */ setOrigRanges(cr, offset) {\n        if (this.range) offset = this.range.setOrigRange(cr, offset);\n        if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n        this.props.forEach((prop)=>prop.setOrigRange(cr, offset));\n        return offset;\n    }\n    toString() {\n        const { context: { src }, range, value } = this;\n        if (value != null) return value;\n        const str = src.slice(range.start, range.end);\n        return Node.addStringTerminator(src, range.end, str);\n    }\n}\nclass YAMLError extends Error {\n    constructor(name, source, message){\n        if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);\n        super();\n        this.name = name;\n        this.message = message;\n        this.source = source;\n    }\n    makePretty() {\n        if (!this.source) return;\n        this.nodeType = this.source.type;\n        const cst = this.source.context && this.source.context.root;\n        if (typeof this.offset === \"number\") {\n            this.range = new Range(this.offset, this.offset + 1);\n            const start = cst && getLinePos(this.offset, cst);\n            if (start) {\n                const end = {\n                    line: start.line,\n                    col: start.col + 1\n                };\n                this.linePos = {\n                    start,\n                    end\n                };\n            }\n            delete this.offset;\n        } else {\n            this.range = this.source.range;\n            this.linePos = this.source.rangeAsLinePos;\n        }\n        if (this.linePos) {\n            const { line, col } = this.linePos.start;\n            this.message += ` at line ${line}, column ${col}`;\n            const ctx = cst && getPrettyContext(this.linePos, cst);\n            if (ctx) this.message += `:\\n\\n${ctx}\\n`;\n        }\n        delete this.source;\n    }\n}\nclass YAMLReferenceError extends YAMLError {\n    constructor(source, message){\n        super(\"YAMLReferenceError\", source, message);\n    }\n}\nclass YAMLSemanticError extends YAMLError {\n    constructor(source, message){\n        super(\"YAMLSemanticError\", source, message);\n    }\n}\nclass YAMLSyntaxError extends YAMLError {\n    constructor(source, message){\n        super(\"YAMLSyntaxError\", source, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(source, message){\n        super(\"YAMLWarning\", source, message);\n    }\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nexports.Char = Char;\nexports.Node = Node;\nexports.Range = Range;\nexports.Type = Type;\nexports.YAMLError = YAMLError;\nexports.YAMLReferenceError = YAMLReferenceError;\nexports.YAMLSemanticError = YAMLSemanticError;\nexports.YAMLSyntaxError = YAMLSyntaxError;\nexports.YAMLWarning = YAMLWarning;\nexports._defineProperty = _defineProperty;\nexports.defaultTagPrefix = defaultTagPrefix;\nexports.defaultTags = defaultTags;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9ub2RlX21vZHVsZXMveWFtbC9kaXN0L19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtZWVkMzAyMTcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPO0lBQ1hDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxLQUFLO0lBQ0xDLGdCQUFnQjtJQUNoQkMsY0FBYztBQUNoQjtBQUNBLE1BQU1DLE9BQU87SUFDWEMsT0FBTztJQUNQQyxZQUFZO0lBQ1pDLGNBQWM7SUFDZEMsZUFBZTtJQUNmUixTQUFTO0lBQ1RTLFdBQVc7SUFDWEMsVUFBVTtJQUNWQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDVkMsS0FBSztJQUNMQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsT0FBTztJQUNQQyxjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsS0FBSztJQUNMQyxVQUFVO0FBQ1o7QUFDQSxNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsY0FBYztJQUNsQlQsS0FBSztJQUNMTSxLQUFLO0lBQ0xJLEtBQUs7QUFDUDtBQUVBLFNBQVNDLGVBQWVDLEdBQUc7SUFDekIsTUFBTUMsS0FBSztRQUFDO0tBQUU7SUFDZCxJQUFJQyxTQUFTRixJQUFJRyxPQUFPLENBQUM7SUFFekIsTUFBT0QsV0FBVyxDQUFDLEVBQUc7UUFDcEJBLFVBQVU7UUFDVkQsR0FBR0csSUFBSSxDQUFDRjtRQUNSQSxTQUFTRixJQUFJRyxPQUFPLENBQUMsTUFBTUQ7SUFDN0I7SUFFQSxPQUFPRDtBQUNUO0FBRUEsU0FBU0ksV0FBV0MsR0FBRztJQUNyQixJQUFJQyxZQUFZUDtJQUVoQixJQUFJLE9BQU9NLFFBQVEsVUFBVTtRQUMzQkMsYUFBYVIsZUFBZU87UUFDNUJOLE1BQU1NO0lBQ1IsT0FBTztRQUNMLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0gsTUFBTUEsTUFBTUEsR0FBRyxDQUFDLEVBQUU7UUFFcEMsSUFBSUEsT0FBT0EsSUFBSUksT0FBTyxFQUFFO1lBQ3RC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STtBQUMzQndJLG1CQUFtQixHQUFHdkkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3N3YWdnZXItanNkb2Mvbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLWVlZDMwMjE3LmpzPzE0NDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDaGFyID0ge1xuICBBTkNIT1I6ICcmJyxcbiAgQ09NTUVOVDogJyMnLFxuICBUQUc6ICchJyxcbiAgRElSRUNUSVZFU19FTkQ6ICctJyxcbiAgRE9DVU1FTlRfRU5EOiAnLidcbn07XG5jb25zdCBUeXBlID0ge1xuICBBTElBUzogJ0FMSUFTJyxcbiAgQkxBTktfTElORTogJ0JMQU5LX0xJTkUnLFxuICBCTE9DS19GT0xERUQ6ICdCTE9DS19GT0xERUQnLFxuICBCTE9DS19MSVRFUkFMOiAnQkxPQ0tfTElURVJBTCcsXG4gIENPTU1FTlQ6ICdDT01NRU5UJyxcbiAgRElSRUNUSVZFOiAnRElSRUNUSVZFJyxcbiAgRE9DVU1FTlQ6ICdET0NVTUVOVCcsXG4gIEZMT1dfTUFQOiAnRkxPV19NQVAnLFxuICBGTE9XX1NFUTogJ0ZMT1dfU0VRJyxcbiAgTUFQOiAnTUFQJyxcbiAgTUFQX0tFWTogJ01BUF9LRVknLFxuICBNQVBfVkFMVUU6ICdNQVBfVkFMVUUnLFxuICBQTEFJTjogJ1BMQUlOJyxcbiAgUVVPVEVfRE9VQkxFOiAnUVVPVEVfRE9VQkxFJyxcbiAgUVVPVEVfU0lOR0xFOiAnUVVPVEVfU0lOR0xFJyxcbiAgU0VROiAnU0VRJyxcbiAgU0VRX0lURU06ICdTRVFfSVRFTSdcbn07XG5jb25zdCBkZWZhdWx0VGFnUHJlZml4ID0gJ3RhZzp5YW1sLm9yZywyMDAyOic7XG5jb25zdCBkZWZhdWx0VGFncyA9IHtcbiAgTUFQOiAndGFnOnlhbWwub3JnLDIwMDI6bWFwJyxcbiAgU0VROiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJyxcbiAgU1RSOiAndGFnOnlhbWwub3JnLDIwMDI6c3RyJ1xufTtcblxuZnVuY3Rpb24gZmluZExpbmVTdGFydHMoc3JjKSB7XG4gIGNvbnN0IGxzID0gWzBdO1xuICBsZXQgb2Zmc2V0ID0gc3JjLmluZGV4T2YoJ1xcbicpO1xuXG4gIHdoaWxlIChvZmZzZXQgIT09IC0xKSB7XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgbHMucHVzaChvZmZzZXQpO1xuICAgIG9mZnNldCA9IHNyYy5pbmRleE9mKCdcXG4nLCBvZmZzZXQpO1xuICB9XG5cbiAgcmV0dXJuIGxzO1xufVxuXG5mdW5jdGlvbiBnZXRTcmNJbmZvKGNzdCkge1xuICBsZXQgbGluZVN0YXJ0cywgc3JjO1xuXG4gIGlmICh0eXBlb2YgY3N0ID09PSAnc3RyaW5nJykge1xuICAgIGxpbmVTdGFydHMgPSBmaW5kTGluZVN0YXJ0cyhjc3QpO1xuICAgIHNyYyA9IGNzdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjc3QpKSBjc3QgPSBjc3RbMF07XG5cbiAgICBpZiAoY3N0ICYmIGNzdC5jb250ZXh0KSB7XG4gICAgICBpZiAoIWNzdC5saW5lU3RhcnRzKSBjc3QubGluZVN0YXJ0cyA9IGZpbmRMaW5lU3RhcnRzKGNzdC5jb250ZXh0LnNyYyk7XG4gICAgICBsaW5lU3RhcnRzID0gY3N0LmxpbmVTdGFydHM7XG4gICAgICBzcmMgPSBjc3QuY29udGV4dC5zcmM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lU3RhcnRzLFxuICAgIHNyY1xuICB9O1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaW5lUG9zIC0gT25lLWluZGV4ZWQgcG9zaXRpb24gaW4gdGhlIHNvdXJjZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xcbiAqL1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgbGluZS9jb2wgcG9zaXRpb24gbWF0Y2hpbmcgYSBjaGFyYWN0ZXIgb2Zmc2V0LlxuICpcbiAqIEFjY2VwdHMgYSBzb3VyY2Ugc3RyaW5nIG9yIGEgQ1NUIGRvY3VtZW50IGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLiBXaXRoXG4gKiB0aGUgbGF0dGVyLCBzdGFydGluZyBpbmRpY2VzIGZvciBsaW5lcyBhcmUgY2FjaGVkIGluIHRoZSBkb2N1bWVudCBhc1xuICogYGxpbmVTdGFydHM6IG51bWJlcltdYC5cbiAqXG4gKiBSZXR1cm5zIGEgb25lLWluZGV4ZWQgYHsgbGluZSwgY29sIH1gIGxvY2F0aW9uIGlmIGZvdW5kLCBvclxuICogYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfERvY3VtZW50fERvY3VtZW50W119IGNzdFxuICogQHJldHVybnMgez9MaW5lUG9zfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGluZVBvcyhvZmZzZXQsIGNzdCkge1xuICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0IDwgMCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHtcbiAgICBsaW5lU3RhcnRzLFxuICAgIHNyY1xuICB9ID0gZ2V0U3JjSW5mbyhjc3QpO1xuICBpZiAoIWxpbmVTdGFydHMgfHwgIXNyYyB8fCBvZmZzZXQgPiBzcmMubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVTdGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBzdGFydCA9IGxpbmVTdGFydHNbaV07XG5cbiAgICBpZiAob2Zmc2V0IDwgc3RhcnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IGksXG4gICAgICAgIGNvbDogb2Zmc2V0IC0gbGluZVN0YXJ0c1tpIC0gMV0gKyAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0KSByZXR1cm4ge1xuICAgICAgbGluZTogaSArIDEsXG4gICAgICBjb2w6IDFcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgbGluZSA9IGxpbmVTdGFydHMubGVuZ3RoO1xuICByZXR1cm4ge1xuICAgIGxpbmUsXG4gICAgY29sOiBvZmZzZXQgLSBsaW5lU3RhcnRzW2xpbmUgLSAxXSArIDFcbiAgfTtcbn1cbi8qKlxuICogR2V0IGEgc3BlY2lmaWVkIGxpbmUgZnJvbSB0aGUgc291cmNlLlxuICpcbiAqIEFjY2VwdHMgYSBzb3VyY2Ugc3RyaW5nIG9yIGEgQ1NUIGRvY3VtZW50IGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLiBXaXRoXG4gKiB0aGUgbGF0dGVyLCBzdGFydGluZyBpbmRpY2VzIGZvciBsaW5lcyBhcmUgY2FjaGVkIGluIHRoZSBkb2N1bWVudCBhc1xuICogYGxpbmVTdGFydHM6IG51bWJlcltdYC5cbiAqXG4gKiBSZXR1cm5zIHRoZSBsaW5lIGFzIGEgc3RyaW5nIGlmIGZvdW5kLCBvciBgbnVsbGAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lIE9uZS1pbmRleGVkIGxpbmUgbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ3xEb2N1bWVudHxEb2N1bWVudFtdfSBjc3RcbiAqIEByZXR1cm5zIHs/c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldExpbmUobGluZSwgY3N0KSB7XG4gIGNvbnN0IHtcbiAgICBsaW5lU3RhcnRzLFxuICAgIHNyY1xuICB9ID0gZ2V0U3JjSW5mbyhjc3QpO1xuICBpZiAoIWxpbmVTdGFydHMgfHwgIShsaW5lID49IDEpIHx8IGxpbmUgPiBsaW5lU3RhcnRzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHN0YXJ0ID0gbGluZVN0YXJ0c1tsaW5lIC0gMV07XG4gIGxldCBlbmQgPSBsaW5lU3RhcnRzW2xpbmVdOyAvLyB1bmRlZmluZWQgZm9yIGxhc3QgbGluZTsgdGhhdCdzIG9rIGZvciBzbGljZSgpXG5cbiAgd2hpbGUgKGVuZCAmJiBlbmQgPiBzdGFydCAmJiBzcmNbZW5kIC0gMV0gPT09ICdcXG4nKSAtLWVuZDtcblxuICByZXR1cm4gc3JjLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuLyoqXG4gKiBQcmV0dHktcHJpbnQgdGhlIHN0YXJ0aW5nIGxpbmUgZnJvbSB0aGUgc291cmNlIGluZGljYXRlZCBieSB0aGUgcmFuZ2UgYHBvc2BcbiAqXG4gKiBUcmltcyBvdXRwdXQgdG8gYG1heFdpZHRoYCBjaGFycyB3aGlsZSBrZWVwaW5nIHRoZSBzdGFydGluZyBjb2x1bW4gdmlzaWJsZSxcbiAqIHVzaW5nIGDigKZgIGF0IGVpdGhlciBlbmQgdG8gaW5kaWNhdGUgZHJvcHBlZCBjaGFyYWN0ZXJzLlxuICpcbiAqIFJldHVybnMgYSB0d28tbGluZSBzdHJpbmcgKG9yIGBudWxsYCkgd2l0aCBgXFxuYCBhcyBzZXBhcmF0b3I7IHRoZSBzZWNvbmQgbGluZVxuICogd2lsbCBob2xkIGFwcHJvcHJpYXRlbHkgaW5kZW50ZWQgYF5gIG1hcmtzIGluZGljYXRpbmcgdGhlIGNvbHVtbiByYW5nZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gKiBAcGFyYW0ge0xpbmVQb3N9IHBvcy5zdGFydFxuICogQHBhcmFtIHtMaW5lUG9zfSBbcG9zLmVuZF1cbiAqIEBwYXJhbSB7c3RyaW5nfERvY3VtZW50fERvY3VtZW50W10qfSBjc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4V2lkdGg9ODBdXG4gKiBAcmV0dXJucyB7P3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRQcmV0dHlDb250ZXh0KHtcbiAgc3RhcnQsXG4gIGVuZFxufSwgY3N0LCBtYXhXaWR0aCA9IDgwKSB7XG4gIGxldCBzcmMgPSBnZXRMaW5lKHN0YXJ0LmxpbmUsIGNzdCk7XG4gIGlmICghc3JjKSByZXR1cm4gbnVsbDtcbiAgbGV0IHtcbiAgICBjb2xcbiAgfSA9IHN0YXJ0O1xuXG4gIGlmIChzcmMubGVuZ3RoID4gbWF4V2lkdGgpIHtcbiAgICBpZiAoY29sIDw9IG1heFdpZHRoIC0gMTApIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHIoMCwgbWF4V2lkdGggLSAxKSArICfigKYnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKG1heFdpZHRoIC8gMik7XG4gICAgICBpZiAoc3JjLmxlbmd0aCA+IGNvbCArIGhhbGZXaWR0aCkgc3JjID0gc3JjLnN1YnN0cigwLCBjb2wgKyBoYWxmV2lkdGggLSAxKSArICfigKYnO1xuICAgICAgY29sIC09IHNyYy5sZW5ndGggLSBtYXhXaWR0aDtcbiAgICAgIHNyYyA9ICfigKYnICsgc3JjLnN1YnN0cigxIC0gbWF4V2lkdGgpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBlcnJMZW4gPSAxO1xuICBsZXQgZXJyRW5kID0gJyc7XG5cbiAgaWYgKGVuZCkge1xuICAgIGlmIChlbmQubGluZSA9PT0gc3RhcnQubGluZSAmJiBjb2wgKyAoZW5kLmNvbCAtIHN0YXJ0LmNvbCkgPD0gbWF4V2lkdGggKyAxKSB7XG4gICAgICBlcnJMZW4gPSBlbmQuY29sIC0gc3RhcnQuY29sO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJMZW4gPSBNYXRoLm1pbihzcmMubGVuZ3RoICsgMSwgbWF4V2lkdGgpIC0gY29sO1xuICAgICAgZXJyRW5kID0gJ+KApic7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb2Zmc2V0ID0gY29sID4gMSA/ICcgJy5yZXBlYXQoY29sIC0gMSkgOiAnJztcbiAgY29uc3QgZXJyID0gJ14nLnJlcGVhdChlcnJMZW4pO1xuICByZXR1cm4gYCR7c3JjfVxcbiR7b2Zmc2V0fSR7ZXJyfSR7ZXJyRW5kfWA7XG59XG5cbmNsYXNzIFJhbmdlIHtcbiAgc3RhdGljIGNvcHkob3JpZykge1xuICAgIHJldHVybiBuZXcgUmFuZ2Uob3JpZy5zdGFydCwgb3JpZy5lbmQpO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZCB8fCBzdGFydDtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnN0YXJ0ICE9PSAnbnVtYmVyJyB8fCAhdGhpcy5lbmQgfHwgdGhpcy5lbmQgPD0gdGhpcy5zdGFydDtcbiAgfVxuICAvKipcbiAgICogU2V0IGBvcmlnU3RhcnRgIGFuZCBgb3JpZ0VuZGAgdG8gcG9pbnQgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSByYW5nZSBmb3JcbiAgICogdGhpcyBub2RlLCB3aGljaCBtYXkgZGlmZmVyIGR1ZSB0byBkcm9wcGVkIENSIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGNyIC0gUG9zaXRpb25zIG9mIGRyb3BwZWQgQ1IgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gU3RhcnRpbmcgaW5kZXggb2YgYGNyYCBmcm9tIHRoZSBsYXN0IGNhbGxcbiAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgbmV4dCBvZmZzZXQsIG1hdGNoaW5nIHRoZSBvbmUgZm91bmQgZm9yIGBvcmlnU3RhcnRgXG4gICAqL1xuXG5cbiAgc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGNyLmxlbmd0aCA9PT0gMCB8fCBlbmQgPD0gY3JbMF0pIHtcbiAgICAgIHRoaXMub3JpZ1N0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLm9yaWdFbmQgPSBlbmQ7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGxldCBpID0gb2Zmc2V0O1xuXG4gICAgd2hpbGUgKGkgPCBjci5sZW5ndGgpIHtcbiAgICAgIGlmIChjcltpXSA+IHN0YXJ0KSBicmVhaztlbHNlICsraTtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWdTdGFydCA9IHN0YXJ0ICsgaTtcbiAgICBjb25zdCBuZXh0T2Zmc2V0ID0gaTtcblxuICAgIHdoaWxlIChpIDwgY3IubGVuZ3RoKSB7XG4gICAgICAvLyBpZiBlbmQgd2FzIGF0IFxcbiwgaXQgc2hvdWxkIG5vdyBiZSBhdCBcXHJcbiAgICAgIGlmIChjcltpXSA+PSBlbmQpIGJyZWFrO2Vsc2UgKytpO1xuICAgIH1cblxuICAgIHRoaXMub3JpZ0VuZCA9IGVuZCArIGk7XG4gICAgcmV0dXJuIG5leHRPZmZzZXQ7XG4gIH1cblxufVxuXG4vKiogUm9vdCBjbGFzcyBvZiBhbGwgbm9kZXMgKi9cblxuY2xhc3MgTm9kZSB7XG4gIHN0YXRpYyBhZGRTdHJpbmdUZXJtaW5hdG9yKHNyYywgb2Zmc2V0LCBzdHIpIHtcbiAgICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHJldHVybiBzdHI7XG4gICAgY29uc3QgbmV4dCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICByZXR1cm4gbmV4dCA+PSBzcmMubGVuZ3RoIHx8IHNyY1tuZXh0XSA9PT0gJ1xcbicgPyBzdHIgKyAnXFxuJyA6IHN0cjtcbiAgfSAvLyBeKC0tLXwuLi4pXG5cblxuICBzdGF0aWMgYXREb2N1bWVudEJvdW5kYXJ5KHNyYywgb2Zmc2V0LCBzZXApIHtcbiAgICBjb25zdCBjaDAgPSBzcmNbb2Zmc2V0XTtcbiAgICBpZiAoIWNoMCkgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgcHJldiA9IHNyY1tvZmZzZXQgLSAxXTtcbiAgICBpZiAocHJldiAmJiBwcmV2ICE9PSAnXFxuJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHNlcCkge1xuICAgICAgaWYgKGNoMCAhPT0gc2VwKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaDAgIT09IENoYXIuRElSRUNUSVZFU19FTkQgJiYgY2gwICE9PSBDaGFyLkRPQ1VNRU5UX0VORCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNoMSA9IHNyY1tvZmZzZXQgKyAxXTtcbiAgICBjb25zdCBjaDIgPSBzcmNbb2Zmc2V0ICsgMl07XG4gICAgaWYgKGNoMSAhPT0gY2gwIHx8IGNoMiAhPT0gY2gwKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY2gzID0gc3JjW29mZnNldCArIDNdO1xuICAgIHJldHVybiAhY2gzIHx8IGNoMyA9PT0gJ1xcbicgfHwgY2gzID09PSAnXFx0JyB8fCBjaDMgPT09ICcgJztcbiAgfVxuXG4gIHN0YXRpYyBlbmRPZklkZW50aWZpZXIoc3JjLCBvZmZzZXQpIHtcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICBjb25zdCBpc1ZlcmJhdGltID0gY2ggPT09ICc8JztcbiAgICBjb25zdCBub3RPayA9IGlzVmVyYmF0aW0gPyBbJ1xcbicsICdcXHQnLCAnICcsICc+J10gOiBbJ1xcbicsICdcXHQnLCAnICcsICdbJywgJ10nLCAneycsICd9JywgJywnXTtcblxuICAgIHdoaWxlIChjaCAmJiBub3RPay5pbmRleE9mKGNoKSA9PT0gLTEpIGNoID0gc3JjW29mZnNldCArPSAxXTtcblxuICAgIGlmIChpc1ZlcmJhdGltICYmIGNoID09PSAnPicpIG9mZnNldCArPSAxO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBzdGF0aWMgZW5kT2ZJbmRlbnQoc3JjLCBvZmZzZXQpIHtcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgIHdoaWxlIChjaCA9PT0gJyAnKSBjaCA9IHNyY1tvZmZzZXQgKz0gMV07XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGljIGVuZE9mTGluZShzcmMsIG9mZnNldCkge1xuICAgIGxldCBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJykgY2ggPSBzcmNbb2Zmc2V0ICs9IDFdO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHN0YXRpYyBlbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpIHtcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgIHdoaWxlIChjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJykgY2ggPSBzcmNbb2Zmc2V0ICs9IDFdO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHN0YXRpYyBzdGFydE9mTGluZShzcmMsIG9mZnNldCkge1xuICAgIGxldCBjaCA9IHNyY1tvZmZzZXQgLSAxXTtcbiAgICBpZiAoY2ggPT09ICdcXG4nKSByZXR1cm4gb2Zmc2V0O1xuXG4gICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJykgY2ggPSBzcmNbb2Zmc2V0IC09IDFdO1xuXG4gICAgcmV0dXJuIG9mZnNldCArIDE7XG4gIH1cbiAgLyoqXG4gICAqIEVuZCBvZiBpbmRlbnRhdGlvbiwgb3IgbnVsbCBpZiB0aGUgbGluZSdzIGluZGVudCBsZXZlbCBpcyBub3QgbW9yZVxuICAgKiB0aGFuIGBpbmRlbnRgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVN0YXJ0XG4gICAqIEByZXR1cm5zIHs/bnVtYmVyfVxuICAgKi9cblxuXG4gIHN0YXRpYyBlbmRPZkJsb2NrSW5kZW50KHNyYywgaW5kZW50LCBsaW5lU3RhcnQpIHtcbiAgICBjb25zdCBpbkVuZCA9IE5vZGUuZW5kT2ZJbmRlbnQoc3JjLCBsaW5lU3RhcnQpO1xuXG4gICAgaWYgKGluRW5kID4gbGluZVN0YXJ0ICsgaW5kZW50KSB7XG4gICAgICByZXR1cm4gaW5FbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdzRW5kID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBpbkVuZCk7XG4gICAgICBjb25zdCBjaCA9IHNyY1t3c0VuZF07XG4gICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxuJykgcmV0dXJuIHdzRW5kO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3RhdGljIGF0Qmxhbmsoc3JjLCBvZmZzZXQsIGVuZEFzQmxhbmspIHtcbiAgICBjb25zdCBjaCA9IHNyY1tvZmZzZXRdO1xuICAgIHJldHVybiBjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnICcgfHwgZW5kQXNCbGFuayAmJiAhY2g7XG4gIH1cblxuICBzdGF0aWMgbmV4dE5vZGVJc0luZGVudGVkKGNoLCBpbmRlbnREaWZmLCBpbmRpY2F0b3JBc0luZGVudCkge1xuICAgIGlmICghY2ggfHwgaW5kZW50RGlmZiA8IDApIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaW5kZW50RGlmZiA+IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBpbmRpY2F0b3JBc0luZGVudCAmJiBjaCA9PT0gJy0nO1xuICB9IC8vIHNob3VsZCBiZSBhdCBsaW5lIG9yIHN0cmluZyBlbmQsIG9yIGF0IG5leHQgbm9uLXdoaXRlc3BhY2UgY2hhclxuXG5cbiAgc3RhdGljIG5vcm1hbGl6ZU9mZnNldChzcmMsIG9mZnNldCkge1xuICAgIGNvbnN0IGNoID0gc3JjW29mZnNldF07XG4gICAgcmV0dXJuICFjaCA/IG9mZnNldCA6IGNoICE9PSAnXFxuJyAmJiBzcmNbb2Zmc2V0IC0gMV0gPT09ICdcXG4nID8gb2Zmc2V0IC0gMSA6IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgfSAvLyBmb2xkIHNpbmdsZSBuZXdsaW5lIGludG8gc3BhY2UsIG11bHRpcGxlIG5ld2xpbmVzIHRvIE4gLSAxIG5ld2xpbmVzXG4gIC8vIHByZXN1bWVzIHNyY1tvZmZzZXRdID09PSAnXFxuJ1xuXG5cbiAgc3RhdGljIGZvbGROZXdsaW5lKHNyYywgb2Zmc2V0LCBpbmRlbnQpIHtcbiAgICBsZXQgaW5Db3VudCA9IDA7XG4gICAgbGV0IGVycm9yID0gZmFsc2U7XG4gICAgbGV0IGZvbGQgPSAnJztcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0ICsgMV07XG5cbiAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICdcXG4nKSB7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgaW5Db3VudCA9IDA7XG4gICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgZm9sZCArPSAnXFxuJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgIGlmIChpbkNvdW50IDw9IGluZGVudCkgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0ICsgMikgLSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgIGluQ291bnQgKz0gMTtcbiAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2ggPSBzcmNbb2Zmc2V0ICsgMV07XG4gICAgfVxuXG4gICAgaWYgKCFmb2xkKSBmb2xkID0gJyAnO1xuICAgIGlmIChjaCAmJiBpbkNvdW50IDw9IGluZGVudCkgZXJyb3IgPSB0cnVlO1xuICAgIHJldHVybiB7XG4gICAgICBmb2xkLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IodHlwZSwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbnRleHQnLCB7XG4gICAgICB2YWx1ZTogY29udGV4dCB8fCBudWxsLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICB0aGlzLnJhbmdlID0gbnVsbDtcbiAgICB0aGlzLnZhbHVlUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcyB8fCBbXTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG5cbiAgZ2V0UHJvcFZhbHVlKGlkeCwga2V5LCBza2lwS2V5KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgcHJvcCA9IHRoaXMucHJvcHNbaWR4XTtcbiAgICByZXR1cm4gcHJvcCAmJiBzcmNbcHJvcC5zdGFydF0gPT09IGtleSA/IHNyYy5zbGljZShwcm9wLnN0YXJ0ICsgKHNraXBLZXkgPyAxIDogMCksIHByb3AuZW5kKSA6IG51bGw7XG4gIH1cblxuICBnZXQgYW5jaG9yKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5nZXRQcm9wVmFsdWUoaSwgQ2hhci5BTkNIT1IsIHRydWUpO1xuICAgICAgaWYgKGFuY2hvciAhPSBudWxsKSByZXR1cm4gYW5jaG9yO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IGNvbW1lbnQoKSB7XG4gICAgY29uc3QgY29tbWVudHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuZ2V0UHJvcFZhbHVlKGksIENoYXIuQ09NTUVOVCwgdHJ1ZSk7XG4gICAgICBpZiAoY29tbWVudCAhPSBudWxsKSBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50cy5sZW5ndGggPiAwID8gY29tbWVudHMuam9pbignXFxuJykgOiBudWxsO1xuICB9XG5cbiAgY29tbWVudEhhc1JlcXVpcmVkV2hpdGVzcGFjZShzdGFydCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgaWYgKHRoaXMuaGVhZGVyICYmIHN0YXJ0ID09PSB0aGlzLmhlYWRlci5lbmQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXRoaXMudmFsdWVSYW5nZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHtcbiAgICAgIGVuZFxuICAgIH0gPSB0aGlzLnZhbHVlUmFuZ2U7XG4gICAgcmV0dXJuIHN0YXJ0ICE9PSBlbmQgfHwgTm9kZS5hdEJsYW5rKHNyYywgZW5kIC0gMSk7XG4gIH1cblxuICBnZXQgaGFzQ29tbWVudCgpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNyY1xuICAgICAgfSA9IHRoaXMuY29udGV4dDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzcmNbdGhpcy5wcm9wc1tpXS5zdGFydF0gPT09IENoYXIuQ09NTUVOVCkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0IGhhc1Byb3BzKCkge1xuICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3JjXG4gICAgICB9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHNyY1t0aGlzLnByb3BzW2ldLnN0YXJ0XSAhPT0gQ2hhci5DT01NRU5UKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQgaW5jbHVkZXNUcmFpbGluZ0xpbmVzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldCBqc29uTGlrZSgpIHtcbiAgICBjb25zdCBqc29uTGlrZVR5cGVzID0gW1R5cGUuRkxPV19NQVAsIFR5cGUuRkxPV19TRVEsIFR5cGUuUVVPVEVfRE9VQkxFLCBUeXBlLlFVT1RFX1NJTkdMRV07XG4gICAgcmV0dXJuIGpzb25MaWtlVHlwZXMuaW5kZXhPZih0aGlzLnR5cGUpICE9PSAtMTtcbiAgfVxuXG4gIGdldCByYW5nZUFzTGluZVBvcygpIHtcbiAgICBpZiAoIXRoaXMucmFuZ2UgfHwgIXRoaXMuY29udGV4dCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBzdGFydCA9IGdldExpbmVQb3ModGhpcy5yYW5nZS5zdGFydCwgdGhpcy5jb250ZXh0LnJvb3QpO1xuICAgIGlmICghc3RhcnQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZW5kID0gZ2V0TGluZVBvcyh0aGlzLnJhbmdlLmVuZCwgdGhpcy5jb250ZXh0LnJvb3QpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH07XG4gIH1cblxuICBnZXQgcmF3VmFsdWUoKSB7XG4gICAgaWYgKCF0aGlzLnZhbHVlUmFuZ2UgfHwgIXRoaXMuY29udGV4dCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9ID0gdGhpcy52YWx1ZVJhbmdlO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuc3JjLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB9XG5cbiAgZ2V0IHRhZygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHRoaXMuZ2V0UHJvcFZhbHVlKGksIENoYXIuVEFHLCBmYWxzZSk7XG5cbiAgICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgICBpZiAodGFnWzFdID09PSAnPCcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyYmF0aW06IHRhZy5zbGljZSgyLCAtMSlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgIGNvbnN0IFtfLCBoYW5kbGUsIHN1ZmZpeF0gPSB0YWcubWF0Y2goL14oLiohKShbXiFdKikkLyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhbmRsZSxcbiAgICAgICAgICAgIHN1ZmZpeFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCB2YWx1ZVJhbmdlQ29udGFpbnNOZXdsaW5lKCkge1xuICAgIGlmICghdGhpcy52YWx1ZVJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gPSB0aGlzLnZhbHVlUmFuZ2U7XG4gICAgY29uc3Qge1xuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBpZiAoc3JjW2ldID09PSAnXFxuJykgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcGFyc2VDb21tZW50KHN0YXJ0KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcblxuICAgIGlmIChzcmNbc3RhcnRdID09PSBDaGFyLkNPTU1FTlQpIHtcbiAgICAgIGNvbnN0IGVuZCA9IE5vZGUuZW5kT2ZMaW5lKHNyYywgc3RhcnQgKyAxKTtcbiAgICAgIGNvbnN0IGNvbW1lbnRSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgZW5kKTtcbiAgICAgIHRoaXMucHJvcHMucHVzaChjb21tZW50UmFuZ2UpO1xuICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhcnQ7XG4gIH1cbiAgLyoqXG4gICAqIFBvcHVsYXRlcyB0aGUgYG9yaWdTdGFydGAgYW5kIGBvcmlnRW5kYCB2YWx1ZXMgb2YgYWxsIHJhbmdlcyBmb3IgdGhpc1xuICAgKiBub2RlLiBFeHRlbmRlZCBieSBjaGlsZCBjbGFzc2VzIHRvIGhhbmRsZSBkZXNjZW5kYW50IG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBjciAtIFBvc2l0aW9ucyBvZiBkcm9wcGVkIENSIGNoYXJhY3RlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFN0YXJ0aW5nIGluZGV4IG9mIGBjcmAgZnJvbSB0aGUgbGFzdCBjYWxsXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIG5leHQgb2Zmc2V0LCBtYXRjaGluZyB0aGUgb25lIGZvdW5kIGZvciBgb3JpZ1N0YXJ0YFxuICAgKi9cblxuXG4gIHNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLnJhbmdlKSBvZmZzZXQgPSB0aGlzLnJhbmdlLnNldE9yaWdSYW5nZShjciwgb2Zmc2V0KTtcbiAgICBpZiAodGhpcy52YWx1ZVJhbmdlKSB0aGlzLnZhbHVlUmFuZ2Uuc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpO1xuICAgIHRoaXMucHJvcHMuZm9yRWFjaChwcm9wID0+IHByb3Auc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBzcmNcbiAgICAgIH0sXG4gICAgICByYW5nZSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBzdHIgPSBzcmMuc2xpY2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgcmV0dXJuIE5vZGUuYWRkU3RyaW5nVGVybWluYXRvcihzcmMsIHJhbmdlLmVuZCwgc3RyKTtcbiAgfVxuXG59XG5cbmNsYXNzIFlBTUxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobmFtZSwgc291cmNlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFtZXNzYWdlIHx8ICEoc291cmNlIGluc3RhbmNlb2YgTm9kZSkpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcmd1bWVudHMgZm9yIG5ldyAke25hbWV9YCk7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIH1cblxuICBtYWtlUHJldHR5KCkge1xuICAgIGlmICghdGhpcy5zb3VyY2UpIHJldHVybjtcbiAgICB0aGlzLm5vZGVUeXBlID0gdGhpcy5zb3VyY2UudHlwZTtcbiAgICBjb25zdCBjc3QgPSB0aGlzLnNvdXJjZS5jb250ZXh0ICYmIHRoaXMuc291cmNlLmNvbnRleHQucm9vdDtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5vZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnJhbmdlID0gbmV3IFJhbmdlKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgY29uc3Qgc3RhcnQgPSBjc3QgJiYgZ2V0TGluZVBvcyh0aGlzLm9mZnNldCwgY3N0KTtcblxuICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IHtcbiAgICAgICAgICBsaW5lOiBzdGFydC5saW5lLFxuICAgICAgICAgIGNvbDogc3RhcnQuY29sICsgMVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpbmVQb3MgPSB7XG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZW5kXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLm9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYW5nZSA9IHRoaXMuc291cmNlLnJhbmdlO1xuICAgICAgdGhpcy5saW5lUG9zID0gdGhpcy5zb3VyY2UucmFuZ2VBc0xpbmVQb3M7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGluZVBvcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBjb2xcbiAgICAgIH0gPSB0aGlzLmxpbmVQb3Muc3RhcnQ7XG4gICAgICB0aGlzLm1lc3NhZ2UgKz0gYCBhdCBsaW5lICR7bGluZX0sIGNvbHVtbiAke2NvbH1gO1xuICAgICAgY29uc3QgY3R4ID0gY3N0ICYmIGdldFByZXR0eUNvbnRleHQodGhpcy5saW5lUG9zLCBjc3QpO1xuICAgICAgaWYgKGN0eCkgdGhpcy5tZXNzYWdlICs9IGA6XFxuXFxuJHtjdHh9XFxuYDtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5zb3VyY2U7XG4gIH1cblxufVxuY2xhc3MgWUFNTFJlZmVyZW5jZUVycm9yIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIoJ1lBTUxSZWZlcmVuY2VFcnJvcicsIHNvdXJjZSwgbWVzc2FnZSk7XG4gIH1cblxufVxuY2xhc3MgWUFNTFNlbWFudGljRXJyb3IgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcignWUFNTFNlbWFudGljRXJyb3InLCBzb3VyY2UsIG1lc3NhZ2UpO1xuICB9XG5cbn1cbmNsYXNzIFlBTUxTeW50YXhFcnJvciBleHRlbmRzIFlBTUxFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKCdZQU1MU3ludGF4RXJyb3InLCBzb3VyY2UsIG1lc3NhZ2UpO1xuICB9XG5cbn1cbmNsYXNzIFlBTUxXYXJuaW5nIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIoJ1lBTUxXYXJuaW5nJywgc291cmNlLCBtZXNzYWdlKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnRzLkNoYXIgPSBDaGFyO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmV4cG9ydHMuVHlwZSA9IFR5cGU7XG5leHBvcnRzLllBTUxFcnJvciA9IFlBTUxFcnJvcjtcbmV4cG9ydHMuWUFNTFJlZmVyZW5jZUVycm9yID0gWUFNTFJlZmVyZW5jZUVycm9yO1xuZXhwb3J0cy5ZQU1MU2VtYW50aWNFcnJvciA9IFlBTUxTZW1hbnRpY0Vycm9yO1xuZXhwb3J0cy5ZQU1MU3ludGF4RXJyb3IgPSBZQU1MU3ludGF4RXJyb3I7XG5leHBvcnRzLllBTUxXYXJuaW5nID0gWUFNTFdhcm5pbmc7XG5leHBvcnRzLl9kZWZpbmVQcm9wZXJ0eSA9IF9kZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydHMuZGVmYXVsdFRhZ1ByZWZpeCA9IGRlZmF1bHRUYWdQcmVmaXg7XG5leHBvcnRzLmRlZmF1bHRUYWdzID0gZGVmYXVsdFRhZ3M7XG4iXSwibmFtZXMiOlsiQ2hhciIsIkFOQ0hPUiIsIkNPTU1FTlQiLCJUQUciLCJESVJFQ1RJVkVTX0VORCIsIkRPQ1VNRU5UX0VORCIsIlR5cGUiLCJBTElBUyIsIkJMQU5LX0xJTkUiLCJCTE9DS19GT0xERUQiLCJCTE9DS19MSVRFUkFMIiwiRElSRUNUSVZFIiwiRE9DVU1FTlQiLCJGTE9XX01BUCIsIkZMT1dfU0VRIiwiTUFQIiwiTUFQX0tFWSIsIk1BUF9WQUxVRSIsIlBMQUlOIiwiUVVPVEVfRE9VQkxFIiwiUVVPVEVfU0lOR0xFIiwiU0VRIiwiU0VRX0lURU0iLCJkZWZhdWx0VGFnUHJlZml4IiwiZGVmYXVsdFRhZ3MiLCJTVFIiLCJmaW5kTGluZVN0YXJ0cyIsInNyYyIsImxzIiwib2Zmc2V0IiwiaW5kZXhPZiIsInB1c2giLCJnZXRTcmNJbmZvIiwiY3N0IiwibGluZVN0YXJ0cyIsIkFycmF5IiwiaXNBcnJheSIsImNvbnRleHQiLCJnZXRMaW5lUG9zIiwibGVuZ3RoIiwiaSIsInN0YXJ0IiwibGluZSIsImNvbCIsImdldExpbmUiLCJlbmQiLCJzbGljZSIsImdldFByZXR0eUNvbnRleHQiLCJtYXhXaWR0aCIsInN1YnN0ciIsImhhbGZXaWR0aCIsIk1hdGgiLCJyb3VuZCIsImVyckxlbiIsImVyckVuZCIsIm1pbiIsInJlcGVhdCIsImVyciIsIlJhbmdlIiwiY29weSIsIm9yaWciLCJjb25zdHJ1Y3RvciIsImlzRW1wdHkiLCJzZXRPcmlnUmFuZ2UiLCJjciIsIm9yaWdTdGFydCIsIm9yaWdFbmQiLCJuZXh0T2Zmc2V0IiwiTm9kZSIsImFkZFN0cmluZ1Rlcm1pbmF0b3IiLCJzdHIiLCJuZXh0IiwiZW5kT2ZXaGl0ZVNwYWNlIiwiYXREb2N1bWVudEJvdW5kYXJ5Iiwic2VwIiwiY2gwIiwicHJldiIsImNoMSIsImNoMiIsImNoMyIsImVuZE9mSWRlbnRpZmllciIsImNoIiwiaXNWZXJiYXRpbSIsIm5vdE9rIiwiZW5kT2ZJbmRlbnQiLCJlbmRPZkxpbmUiLCJzdGFydE9mTGluZSIsImVuZE9mQmxvY2tJbmRlbnQiLCJpbmRlbnQiLCJsaW5lU3RhcnQiLCJpbkVuZCIsIndzRW5kIiwiYXRCbGFuayIsImVuZEFzQmxhbmsiLCJuZXh0Tm9kZUlzSW5kZW50ZWQiLCJpbmRlbnREaWZmIiwiaW5kaWNhdG9yQXNJbmRlbnQiLCJub3JtYWxpemVPZmZzZXQiLCJmb2xkTmV3bGluZSIsImluQ291bnQiLCJlcnJvciIsImZvbGQiLCJ0eXBlIiwicHJvcHMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwid3JpdGFibGUiLCJyYW5nZSIsInZhbHVlUmFuZ2UiLCJnZXRQcm9wVmFsdWUiLCJpZHgiLCJrZXkiLCJza2lwS2V5IiwicHJvcCIsImFuY2hvciIsImNvbW1lbnQiLCJjb21tZW50cyIsImpvaW4iLCJjb21tZW50SGFzUmVxdWlyZWRXaGl0ZXNwYWNlIiwiaGVhZGVyIiwiaGFzQ29tbWVudCIsImhhc1Byb3BzIiwiaW5jbHVkZXNUcmFpbGluZ0xpbmVzIiwianNvbkxpa2UiLCJqc29uTGlrZVR5cGVzIiwicmFuZ2VBc0xpbmVQb3MiLCJ1bmRlZmluZWQiLCJyb290IiwicmF3VmFsdWUiLCJ0YWciLCJ2ZXJiYXRpbSIsIl8iLCJoYW5kbGUiLCJzdWZmaXgiLCJtYXRjaCIsInZhbHVlUmFuZ2VDb250YWluc05ld2xpbmUiLCJwYXJzZUNvbW1lbnQiLCJjb21tZW50UmFuZ2UiLCJzZXRPcmlnUmFuZ2VzIiwiZm9yRWFjaCIsInRvU3RyaW5nIiwiWUFNTEVycm9yIiwiRXJyb3IiLCJuYW1lIiwic291cmNlIiwibWVzc2FnZSIsIm1ha2VQcmV0dHkiLCJub2RlVHlwZSIsImxpbmVQb3MiLCJjdHgiLCJZQU1MUmVmZXJlbmNlRXJyb3IiLCJZQU1MU2VtYW50aWNFcnJvciIsIllBTUxTeW50YXhFcnJvciIsIllBTUxXYXJuaW5nIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/_rollupPluginBabelHelpers-eed30217.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/swagger-jsdoc/node_modules/yaml/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar _rollupPluginBabelHelpers = __webpack_require__(/*! ./_rollupPluginBabelHelpers-eed30217.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/_rollupPluginBabelHelpers-eed30217.js\");\nvar parseCst = __webpack_require__(/*! ./parse-3997f544.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/parse-3997f544.js\");\n__webpack_require__(/*! ./stringifyNumber-dea1120c.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/stringifyNumber-dea1120c.js\");\n__webpack_require__(/*! ./Schema-807430ba.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/Schema-807430ba.js\");\nvar Document = __webpack_require__(/*! ./Document-f89a2614.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/Document-f89a2614.js\");\n/* global console, process, YAML_SILENCE_WARNINGS */ function warn(warning, type) {\n    if (typeof YAML_SILENCE_WARNINGS !== \"undefined\" && YAML_SILENCE_WARNINGS) return;\n    if (typeof process !== \"undefined\") {\n        if (process.env.YAML_SILENCE_WARNINGS) return; // This will throw in Jest if `warning` is an Error instance due to\n        // https://github.com/facebook/jest/issues/2549\n        if (process.emitWarning) {\n            process.emitWarning(warning, type);\n            return;\n        }\n    } // eslint-disable-next-line no-console\n    console.warn(type ? `${type}: ${warning}` : warning);\n}\nfunction parseAllDocuments(src, options) {\n    const stream = [];\n    let prev;\n    for (const cstDoc of parseCst.parse(src)){\n        const doc = new Document.Document(undefined, null, options);\n        doc.parse(cstDoc, prev);\n        stream.push(doc);\n        prev = doc;\n    }\n    return stream;\n}\nfunction parseDocument(src, options) {\n    const cst = parseCst.parse(src);\n    const doc = new Document.Document(cst[0], null, options);\n    if (cst.length > 1) {\n        const errMsg = \"Source contains multiple documents; please use YAML.parseAllDocuments()\";\n        doc.errors.unshift(new _rollupPluginBabelHelpers.YAMLSemanticError(cst[1], errMsg));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    if (options === undefined && reviver && typeof reviver === \"object\") {\n        options = reviver;\n        reviver = undefined;\n    }\n    const doc = parseDocument(src, options);\n    doc.warnings.forEach((warning)=>warn(warning));\n    if (doc.errors.length > 0) throw doc.errors[0];\n    return doc.toJS({\n        reviver\n    });\n}\nfunction stringify(value, replacer, options) {\n    if (typeof options === \"string\") options = options.length;\n    if (typeof options === \"number\") {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? {\n            indent: 8\n        } : {\n            indent\n        };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options || replacer || {};\n        if (!keepUndefined) return undefined;\n    }\n    return new Document.Document(value, replacer, options).toString();\n}\nexports.parseCST = parseCst.parse;\nexports.Document = Document.Document;\nexports.defaultOptions = Document.defaultOptions;\nexports.scalarOptions = Document.scalarOptions;\nexports.parse = parse;\nexports.parseAllDocuments = parseAllDocuments;\nexports.parseDocument = parseDocument;\nexports.stringify = stringify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsNEJBQTRCQyxtQkFBT0EsQ0FBQztBQUN4QyxJQUFJQyxXQUFXRCxtQkFBT0EsQ0FBQztBQUN2QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixJQUFJRSxXQUFXRixtQkFBT0EsQ0FBQztBQUV2QixrREFBa0QsR0FDbEQsU0FBU0csS0FBS0MsT0FBTyxFQUFFQyxJQUFJO0lBQ3pCLElBQUksT0FBT0MsMEJBQTBCLGVBQWVBLHVCQUF1QjtJQUUzRSxJQUFJLE9BQU9DLFlBQVksYUFBYTtRQUNsQyxJQUFJQSxRQUFRQyxHQUFHLENBQUNGLHFCQUFxQixFQUFFLFFBQVEsbUVBQW1FO1FBQ2xILCtDQUErQztRQUUvQyxJQUFJQyxRQUFRRSxXQUFXLEVBQUU7WUFDdkJGLFFBQVFFLFdBQVcsQ0FBQ0wsU0FBU0M7WUFDN0I7UUFDRjtJQUNGLEVBQUUsc0NBQXNDO0lBR3hDSyxRQUFRUCxJQUFJLENBQUNFLE9BQU8sQ0FBQyxFQUFFQSxLQUFLLEVBQUUsRUFBRUQsUUFBUSxDQUFDLEdBQUdBO0FBQzlDO0FBRUEsU0FBU08sa0JBQWtCQyxHQUFHLEVBQUVDLE9BQU87SUFDckMsTUFBTUMsU0FBUyxFQUFFO0lBQ2pCLElBQUlDO0lBRUosS0FBSyxNQUFNQyxVQUFVZixTQUFTZ0IsS0FBSyxDQUFDTCxLQUFNO1FBQ3hDLE1BQU1NLE1BQU0sSUFBSWhCLFNBQVNBLFFBQVEsQ0FBQ2lCLFdBQVcsTUFBTU47UUFDbkRLLElBQUlELEtBQUssQ0FBQ0QsUUFBUUQ7UUFDbEJELE9BQU9NLElBQUksQ0FBQ0Y7UUFDWkgsT0FBT0c7SUFDVDtJQUVBLE9BQU9KO0FBQ1Q7QUFDQSxTQUFTTyxjQUFjVCxHQUFHLEVBQUVDLE9BQU87SUFDakMsTUFBTVMsTUFBTXJCLFNBQVNnQixLQUFLLENBQUNMO0lBQzNCLE1BQU1NLE1BQU0sSUFBSWhCLFNBQVNBLFFBQVEsQ0FBQ29CLEdBQUcsQ0FBQyxFQUFFLEVBQUUsTUFBTVQ7SUFFaEQsSUFBSVMsSUFBSUMsTUFBTSxHQUFHLEdBQUc7UUFDbEIsTUFBTUMsU0FBUztRQUNmTixJQUFJTyxNQUFNLENBQUNDLE9BQU8sQ0FBQyxJQUFJM0IsMEJBQTBCNEIsaUJBQWlCLENBQUNMLEdBQUcsQ0FBQyxFQUFFLEVBQUVFO0lBQzdFO0lBRUEsT0FBT047QUFDVDtBQUNBLFNBQVNELE1BQU1MLEdBQUcsRUFBRWdCLE9BQU8sRUFBRWYsT0FBTztJQUNsQyxJQUFJQSxZQUFZTSxhQUFhUyxXQUFXLE9BQU9BLFlBQVksVUFBVTtRQUNuRWYsVUFBVWU7UUFDVkEsVUFBVVQ7SUFDWjtJQUVBLE1BQU1ELE1BQU1HLGNBQWNULEtBQUtDO0lBQy9CSyxJQUFJVyxRQUFRLENBQUNDLE9BQU8sQ0FBQzFCLENBQUFBLFVBQVdELEtBQUtDO0lBQ3JDLElBQUljLElBQUlPLE1BQU0sQ0FBQ0YsTUFBTSxHQUFHLEdBQUcsTUFBTUwsSUFBSU8sTUFBTSxDQUFDLEVBQUU7SUFDOUMsT0FBT1AsSUFBSWEsSUFBSSxDQUFDO1FBQ2RIO0lBQ0Y7QUFDRjtBQUNBLFNBQVNJLFVBQVVDLEtBQUssRUFBRUMsUUFBUSxFQUFFckIsT0FBTztJQUN6QyxJQUFJLE9BQU9BLFlBQVksVUFBVUEsVUFBVUEsUUFBUVUsTUFBTTtJQUV6RCxJQUFJLE9BQU9WLFlBQVksVUFBVTtRQUMvQixNQUFNc0IsU0FBU0MsS0FBS0MsS0FBSyxDQUFDeEI7UUFDMUJBLFVBQVVzQixTQUFTLElBQUloQixZQUFZZ0IsU0FBUyxJQUFJO1lBQzlDQSxRQUFRO1FBQ1YsSUFBSTtZQUNGQTtRQUNGO0lBQ0Y7SUFFQSxJQUFJRixVQUFVZCxXQUFXO1FBQ3ZCLE1BQU0sRUFDSm1CLGFBQWEsRUFDZCxHQUFHekIsV0FBV3FCLFlBQVksQ0FBQztRQUM1QixJQUFJLENBQUNJLGVBQWUsT0FBT25CO0lBQzdCO0lBRUEsT0FBTyxJQUFJakIsU0FBU0EsUUFBUSxDQUFDK0IsT0FBT0MsVUFBVXJCLFNBQVMwQixRQUFRO0FBQ2pFO0FBRUFDLGdCQUFnQixHQUFHdkMsU0FBU2dCLEtBQUs7QUFDakN1QixnQkFBZ0IsR0FBR3RDLFNBQVNBLFFBQVE7QUFDcENzQyxzQkFBc0IsR0FBR3RDLFNBQVN3QyxjQUFjO0FBQ2hERixxQkFBcUIsR0FBR3RDLFNBQVN5QyxhQUFhO0FBQzlDSCxhQUFhLEdBQUd2QjtBQUNoQnVCLHlCQUF5QixHQUFHN0I7QUFDNUI2QixxQkFBcUIsR0FBR25CO0FBQ3hCbUIsaUJBQWlCLEdBQUdSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9zd2FnZ2VyLWpzZG9jL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvaW5kZXguanM/OTliYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzID0gcmVxdWlyZSgnLi9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLWVlZDMwMjE3LmpzJyk7XG52YXIgcGFyc2VDc3QgPSByZXF1aXJlKCcuL3BhcnNlLTM5OTdmNTQ0LmpzJyk7XG5yZXF1aXJlKCcuL3N0cmluZ2lmeU51bWJlci1kZWExMTIwYy5qcycpO1xucmVxdWlyZSgnLi9TY2hlbWEtODA3NDMwYmEuanMnKTtcbnZhciBEb2N1bWVudCA9IHJlcXVpcmUoJy4vRG9jdW1lbnQtZjg5YTI2MTQuanMnKTtcblxuLyogZ2xvYmFsIGNvbnNvbGUsIHByb2Nlc3MsIFlBTUxfU0lMRU5DRV9XQVJOSU5HUyAqL1xuZnVuY3Rpb24gd2Fybih3YXJuaW5nLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgWUFNTF9TSUxFTkNFX1dBUk5JTkdTICE9PSAndW5kZWZpbmVkJyAmJiBZQU1MX1NJTEVOQ0VfV0FSTklOR1MpIHJldHVybjtcblxuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LllBTUxfU0lMRU5DRV9XQVJOSU5HUykgcmV0dXJuOyAvLyBUaGlzIHdpbGwgdGhyb3cgaW4gSmVzdCBpZiBgd2FybmluZ2AgaXMgYW4gRXJyb3IgaW5zdGFuY2UgZHVlIHRvXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2plc3QvaXNzdWVzLzI1NDlcblxuICAgIGlmIChwcm9jZXNzLmVtaXRXYXJuaW5nKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKHdhcm5pbmcsIHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG5cbiAgY29uc29sZS53YXJuKHR5cGUgPyBgJHt0eXBlfTogJHt3YXJuaW5nfWAgOiB3YXJuaW5nKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBbGxEb2N1bWVudHMoc3JjLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0cmVhbSA9IFtdO1xuICBsZXQgcHJldjtcblxuICBmb3IgKGNvbnN0IGNzdERvYyBvZiBwYXJzZUNzdC5wYXJzZShzcmMpKSB7XG4gICAgY29uc3QgZG9jID0gbmV3IERvY3VtZW50LkRvY3VtZW50KHVuZGVmaW5lZCwgbnVsbCwgb3B0aW9ucyk7XG4gICAgZG9jLnBhcnNlKGNzdERvYywgcHJldik7XG4gICAgc3RyZWFtLnB1c2goZG9jKTtcbiAgICBwcmV2ID0gZG9jO1xuICB9XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoc3JjLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNzdCA9IHBhcnNlQ3N0LnBhcnNlKHNyYyk7XG4gIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudC5Eb2N1bWVudChjc3RbMF0sIG51bGwsIG9wdGlvbnMpO1xuXG4gIGlmIChjc3QubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGVyck1zZyA9ICdTb3VyY2UgY29udGFpbnMgbXVsdGlwbGUgZG9jdW1lbnRzOyBwbGVhc2UgdXNlIFlBTUwucGFyc2VBbGxEb2N1bWVudHMoKSc7XG4gICAgZG9jLmVycm9ycy51bnNoaWZ0KG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKGNzdFsxXSwgZXJyTXNnKSk7XG4gIH1cblxuICByZXR1cm4gZG9jO1xufVxuZnVuY3Rpb24gcGFyc2Uoc3JjLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmV2aXZlciAmJiB0eXBlb2YgcmV2aXZlciA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gcmV2aXZlcjtcbiAgICByZXZpdmVyID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgZG9jID0gcGFyc2VEb2N1bWVudChzcmMsIG9wdGlvbnMpO1xuICBkb2Mud2FybmluZ3MuZm9yRWFjaCh3YXJuaW5nID0+IHdhcm4od2FybmluZykpO1xuICBpZiAoZG9jLmVycm9ycy5sZW5ndGggPiAwKSB0aHJvdyBkb2MuZXJyb3JzWzBdO1xuICByZXR1cm4gZG9jLnRvSlMoe1xuICAgIHJldml2ZXJcbiAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMgPSBvcHRpb25zLmxlbmd0aDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgY29uc3QgaW5kZW50ID0gTWF0aC5yb3VuZChvcHRpb25zKTtcbiAgICBvcHRpb25zID0gaW5kZW50IDwgMSA/IHVuZGVmaW5lZCA6IGluZGVudCA+IDggPyB7XG4gICAgICBpbmRlbnQ6IDhcbiAgICB9IDoge1xuICAgICAgaW5kZW50XG4gICAgfTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qge1xuICAgICAga2VlcFVuZGVmaW5lZFxuICAgIH0gPSBvcHRpb25zIHx8IHJlcGxhY2VyIHx8IHt9O1xuICAgIGlmICgha2VlcFVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBuZXcgRG9jdW1lbnQuRG9jdW1lbnQodmFsdWUsIHJlcGxhY2VyLCBvcHRpb25zKS50b1N0cmluZygpO1xufVxuXG5leHBvcnRzLnBhcnNlQ1NUID0gcGFyc2VDc3QucGFyc2U7XG5leHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQuRG9jdW1lbnQ7XG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gRG9jdW1lbnQuZGVmYXVsdE9wdGlvbnM7XG5leHBvcnRzLnNjYWxhck9wdGlvbnMgPSBEb2N1bWVudC5zY2FsYXJPcHRpb25zO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZUFsbERvY3VtZW50cyA9IHBhcnNlQWxsRG9jdW1lbnRzO1xuZXhwb3J0cy5wYXJzZURvY3VtZW50ID0gcGFyc2VEb2N1bWVudDtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuIl0sIm5hbWVzIjpbIl9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMiLCJyZXF1aXJlIiwicGFyc2VDc3QiLCJEb2N1bWVudCIsIndhcm4iLCJ3YXJuaW5nIiwidHlwZSIsIllBTUxfU0lMRU5DRV9XQVJOSU5HUyIsInByb2Nlc3MiLCJlbnYiLCJlbWl0V2FybmluZyIsImNvbnNvbGUiLCJwYXJzZUFsbERvY3VtZW50cyIsInNyYyIsIm9wdGlvbnMiLCJzdHJlYW0iLCJwcmV2IiwiY3N0RG9jIiwicGFyc2UiLCJkb2MiLCJ1bmRlZmluZWQiLCJwdXNoIiwicGFyc2VEb2N1bWVudCIsImNzdCIsImxlbmd0aCIsImVyck1zZyIsImVycm9ycyIsInVuc2hpZnQiLCJZQU1MU2VtYW50aWNFcnJvciIsInJldml2ZXIiLCJ3YXJuaW5ncyIsImZvckVhY2giLCJ0b0pTIiwic3RyaW5naWZ5IiwidmFsdWUiLCJyZXBsYWNlciIsImluZGVudCIsIk1hdGgiLCJyb3VuZCIsImtlZXBVbmRlZmluZWQiLCJ0b1N0cmluZyIsImV4cG9ydHMiLCJwYXJzZUNTVCIsImRlZmF1bHRPcHRpb25zIiwic2NhbGFyT3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/parse-3997f544.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/swagger-jsdoc/node_modules/yaml/dist/parse-3997f544.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar _rollupPluginBabelHelpers = __webpack_require__(/*! ./_rollupPluginBabelHelpers-eed30217.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/_rollupPluginBabelHelpers-eed30217.js\");\nclass BlankLine extends _rollupPluginBabelHelpers.Node {\n    constructor(){\n        super(_rollupPluginBabelHelpers.Type.BLANK_LINE);\n    }\n    /* istanbul ignore next */ get includesTrailingLines() {\n        // This is never called from anywhere, but if it were,\n        // this is the value it should return.\n        return true;\n    }\n    /**\n   * Parses a blank line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first \\n character\n   * @returns {number} - Index of the character after this\n   */ parse(context, start) {\n        this.context = context;\n        this.range = new _rollupPluginBabelHelpers.Range(start, start + 1);\n        return start + 1;\n    }\n}\nclass CollectionItem extends _rollupPluginBabelHelpers.Node {\n    constructor(type, props){\n        super(type, props);\n        this.node = null;\n    }\n    get includesTrailingLines() {\n        return !!this.node && this.node.includesTrailingLines;\n    }\n    /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */ parse(context, start) {\n        this.context = context;\n        const { parseNode, src } = context;\n        let { atLineStart, lineStart } = context;\n        if (!atLineStart && this.type === _rollupPluginBabelHelpers.Type.SEQ_ITEM) this.error = new _rollupPluginBabelHelpers.YAMLSemanticError(this, \"Sequence items must not have preceding content on the same line\");\n        const indent = atLineStart ? start - lineStart : context.indent;\n        let offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, start + 1);\n        let ch = src[offset];\n        const inlineComment = ch === \"#\";\n        const comments = [];\n        let blankLine = null;\n        while(ch === \"\\n\" || ch === \"#\"){\n            if (ch === \"#\") {\n                const end = _rollupPluginBabelHelpers.Node.endOfLine(src, offset + 1);\n                comments.push(new _rollupPluginBabelHelpers.Range(offset, end));\n                offset = end;\n            } else {\n                atLineStart = true;\n                lineStart = offset + 1;\n                const wsEnd = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, lineStart);\n                if (src[wsEnd] === \"\\n\" && comments.length === 0) {\n                    blankLine = new BlankLine();\n                    lineStart = blankLine.parse({\n                        src\n                    }, lineStart);\n                }\n                offset = _rollupPluginBabelHelpers.Node.endOfIndent(src, lineStart);\n            }\n            ch = src[offset];\n        }\n        if (_rollupPluginBabelHelpers.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== _rollupPluginBabelHelpers.Type.SEQ_ITEM)) {\n            this.node = parseNode({\n                atLineStart,\n                inCollection: false,\n                indent,\n                lineStart,\n                parent: this\n            }, offset);\n        } else if (ch && lineStart > start + 1) {\n            offset = lineStart - 1;\n        }\n        if (this.node) {\n            if (blankLine) {\n                // Only blank lines preceding non-empty nodes are captured. Note that\n                // this means that collection item range start indices do not always\n                // increase monotonically. -- eemeli/yaml#126\n                const items = context.parent.items || context.parent.contents;\n                if (items) items.push(blankLine);\n            }\n            if (comments.length) Array.prototype.push.apply(this.props, comments);\n            offset = this.node.range.end;\n        } else {\n            if (inlineComment) {\n                const c = comments[0];\n                this.props.push(c);\n                offset = c.end;\n            } else {\n                offset = _rollupPluginBabelHelpers.Node.endOfLine(src, start + 1);\n            }\n        }\n        const end = this.node ? this.node.valueRange.end : offset;\n        this.valueRange = new _rollupPluginBabelHelpers.Range(start, end);\n        return offset;\n    }\n    setOrigRanges(cr, offset) {\n        offset = super.setOrigRanges(cr, offset);\n        return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n    toString() {\n        const { context: { src }, node, range, value } = this;\n        if (value != null) return value;\n        const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n        return _rollupPluginBabelHelpers.Node.addStringTerminator(src, range.end, str);\n    }\n}\nclass Comment extends _rollupPluginBabelHelpers.Node {\n    constructor(){\n        super(_rollupPluginBabelHelpers.Type.COMMENT);\n    }\n    /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */ parse(context, start) {\n        this.context = context;\n        const offset = this.parseComment(start);\n        this.range = new _rollupPluginBabelHelpers.Range(start, offset);\n        return offset;\n    }\n}\nfunction grabCollectionEndComments(node) {\n    let cnode = node;\n    while(cnode instanceof CollectionItem)cnode = cnode.node;\n    if (!(cnode instanceof Collection)) return null;\n    const len = cnode.items.length;\n    let ci = -1;\n    for(let i = len - 1; i >= 0; --i){\n        const n = cnode.items[i];\n        if (n.type === _rollupPluginBabelHelpers.Type.COMMENT) {\n            // Keep sufficiently indented comments with preceding node\n            const { indent, lineStart } = n.context;\n            if (indent > 0 && n.range.start >= lineStart + indent) break;\n            ci = i;\n        } else if (n.type === _rollupPluginBabelHelpers.Type.BLANK_LINE) ci = i;\n        else break;\n    }\n    if (ci === -1) return null;\n    const ca = cnode.items.splice(ci, len - ci);\n    const prevEnd = ca[0].range.start;\n    while(true){\n        cnode.range.end = prevEnd;\n        if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n        if (cnode === node) break;\n        cnode = cnode.context.parent;\n    }\n    return ca;\n}\nclass Collection extends _rollupPluginBabelHelpers.Node {\n    static nextContentHasIndent(src, offset, indent) {\n        const lineStart = _rollupPluginBabelHelpers.Node.endOfLine(src, offset) + 1;\n        offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, lineStart);\n        const ch = src[offset];\n        if (!ch) return false;\n        if (offset >= lineStart + indent) return true;\n        if (ch !== \"#\" && ch !== \"\\n\") return false;\n        return Collection.nextContentHasIndent(src, offset, indent);\n    }\n    constructor(firstItem){\n        super(firstItem.type === _rollupPluginBabelHelpers.Type.SEQ_ITEM ? _rollupPluginBabelHelpers.Type.SEQ : _rollupPluginBabelHelpers.Type.MAP);\n        for(let i = firstItem.props.length - 1; i >= 0; --i){\n            if (firstItem.props[i].start < firstItem.context.lineStart) {\n                // props on previous line are assumed by the collection\n                this.props = firstItem.props.slice(0, i + 1);\n                firstItem.props = firstItem.props.slice(i + 1);\n                const itemRange = firstItem.props[0] || firstItem.valueRange;\n                firstItem.range.start = itemRange.start;\n                break;\n            }\n        }\n        this.items = [\n            firstItem\n        ];\n        const ec = grabCollectionEndComments(firstItem);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n    }\n    get includesTrailingLines() {\n        return this.items.length > 0;\n    }\n    /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */ parse(context, start) {\n        this.context = context;\n        const { parseNode, src } = context; // It's easier to recalculate lineStart here rather than tracking down the\n        // last context from which to read it -- eemeli/yaml#2\n        let lineStart = _rollupPluginBabelHelpers.Node.startOfLine(src, start);\n        const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n        // -- eemeli/yaml#17\n        firstItem.context.parent = this;\n        this.valueRange = _rollupPluginBabelHelpers.Range.copy(firstItem.valueRange);\n        const indent = firstItem.range.start - firstItem.context.lineStart;\n        let offset = start;\n        offset = _rollupPluginBabelHelpers.Node.normalizeOffset(src, offset);\n        let ch = src[offset];\n        let atLineStart = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, lineStart) === offset;\n        let prevIncludesTrailingLines = false;\n        while(ch){\n            while(ch === \"\\n\" || ch === \"#\"){\n                if (atLineStart && ch === \"\\n\" && !prevIncludesTrailingLines) {\n                    const blankLine = new BlankLine();\n                    offset = blankLine.parse({\n                        src\n                    }, offset);\n                    this.valueRange.end = offset;\n                    if (offset >= src.length) {\n                        ch = null;\n                        break;\n                    }\n                    this.items.push(blankLine);\n                    offset -= 1; // blankLine.parse() consumes terminal newline\n                } else if (ch === \"#\") {\n                    if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n                        return offset;\n                    }\n                    const comment = new Comment();\n                    offset = comment.parse({\n                        indent,\n                        lineStart,\n                        src\n                    }, offset);\n                    this.items.push(comment);\n                    this.valueRange.end = offset;\n                    if (offset >= src.length) {\n                        ch = null;\n                        break;\n                    }\n                }\n                lineStart = offset + 1;\n                offset = _rollupPluginBabelHelpers.Node.endOfIndent(src, lineStart);\n                if (_rollupPluginBabelHelpers.Node.atBlank(src, offset)) {\n                    const wsEnd = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset);\n                    const next = src[wsEnd];\n                    if (!next || next === \"\\n\" || next === \"#\") {\n                        offset = wsEnd;\n                    }\n                }\n                ch = src[offset];\n                atLineStart = true;\n            }\n            if (!ch) {\n                break;\n            }\n            if (offset !== lineStart + indent && (atLineStart || ch !== \":\")) {\n                if (offset < lineStart + indent) {\n                    if (lineStart > start) offset = lineStart;\n                    break;\n                } else if (!this.error) {\n                    const msg = \"All collection items must start at the same column\";\n                    this.error = new _rollupPluginBabelHelpers.YAMLSyntaxError(this, msg);\n                }\n            }\n            if (firstItem.type === _rollupPluginBabelHelpers.Type.SEQ_ITEM) {\n                if (ch !== \"-\") {\n                    if (lineStart > start) offset = lineStart;\n                    break;\n                }\n            } else if (ch === \"-\" && !this.error) {\n                // map key may start with -, as long as it's followed by a non-whitespace char\n                const next = src[offset + 1];\n                if (!next || next === \"\\n\" || next === \"\t\" || next === \" \") {\n                    const msg = \"A collection cannot be both a mapping and a sequence\";\n                    this.error = new _rollupPluginBabelHelpers.YAMLSyntaxError(this, msg);\n                }\n            }\n            const node = parseNode({\n                atLineStart,\n                inCollection: true,\n                indent,\n                lineStart,\n                parent: this\n            }, offset);\n            if (!node) return offset; // at next document start\n            this.items.push(node);\n            this.valueRange.end = node.valueRange.end;\n            offset = _rollupPluginBabelHelpers.Node.normalizeOffset(src, node.range.end);\n            ch = src[offset];\n            atLineStart = false;\n            prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n            // has advanced to check the current line's indentation level\n            // -- eemeli/yaml#10 & eemeli/yaml#38\n            if (ch) {\n                let ls = offset - 1;\n                let prev = src[ls];\n                while(prev === \" \" || prev === \"\t\")prev = src[--ls];\n                if (prev === \"\\n\") {\n                    lineStart = ls + 1;\n                    atLineStart = true;\n                }\n            }\n            const ec = grabCollectionEndComments(node);\n            if (ec) Array.prototype.push.apply(this.items, ec);\n        }\n        return offset;\n    }\n    setOrigRanges(cr, offset) {\n        offset = super.setOrigRanges(cr, offset);\n        this.items.forEach((node)=>{\n            offset = node.setOrigRanges(cr, offset);\n        });\n        return offset;\n    }\n    toString() {\n        const { context: { src }, items, range, value } = this;\n        if (value != null) return value;\n        let str = src.slice(range.start, items[0].range.start) + String(items[0]);\n        for(let i = 1; i < items.length; ++i){\n            const item = items[i];\n            const { atLineStart, indent } = item.context;\n            if (atLineStart) for(let i = 0; i < indent; ++i)str += \" \";\n            str += String(item);\n        }\n        return _rollupPluginBabelHelpers.Node.addStringTerminator(src, range.end, str);\n    }\n}\nclass Directive extends _rollupPluginBabelHelpers.Node {\n    constructor(){\n        super(_rollupPluginBabelHelpers.Type.DIRECTIVE);\n        this.name = null;\n    }\n    get parameters() {\n        const raw = this.rawValue;\n        return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n    parseName(start) {\n        const { src } = this.context;\n        let offset = start;\n        let ch = src[offset];\n        while(ch && ch !== \"\\n\" && ch !== \"\t\" && ch !== \" \")ch = src[offset += 1];\n        this.name = src.slice(start, offset);\n        return offset;\n    }\n    parseParameters(start) {\n        const { src } = this.context;\n        let offset = start;\n        let ch = src[offset];\n        while(ch && ch !== \"\\n\" && ch !== \"#\")ch = src[offset += 1];\n        this.valueRange = new _rollupPluginBabelHelpers.Range(start, offset);\n        return offset;\n    }\n    parse(context, start) {\n        this.context = context;\n        let offset = this.parseName(start + 1);\n        offset = this.parseParameters(offset);\n        offset = this.parseComment(offset);\n        this.range = new _rollupPluginBabelHelpers.Range(start, offset);\n        return offset;\n    }\n}\nclass Document extends _rollupPluginBabelHelpers.Node {\n    static startCommentOrEndBlankLine(src, start) {\n        const offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, start);\n        const ch = src[offset];\n        return ch === \"#\" || ch === \"\\n\" ? offset : start;\n    }\n    constructor(){\n        super(_rollupPluginBabelHelpers.Type.DOCUMENT);\n        this.directives = null;\n        this.contents = null;\n        this.directivesEndMarker = null;\n        this.documentEndMarker = null;\n    }\n    parseDirectives(start) {\n        const { src } = this.context;\n        this.directives = [];\n        let atLineStart = true;\n        let hasDirectives = false;\n        let offset = start;\n        while(!_rollupPluginBabelHelpers.Node.atDocumentBoundary(src, offset, _rollupPluginBabelHelpers.Char.DIRECTIVES_END)){\n            offset = Document.startCommentOrEndBlankLine(src, offset);\n            switch(src[offset]){\n                case \"\\n\":\n                    if (atLineStart) {\n                        const blankLine = new BlankLine();\n                        offset = blankLine.parse({\n                            src\n                        }, offset);\n                        if (offset < src.length) {\n                            this.directives.push(blankLine);\n                        }\n                    } else {\n                        offset += 1;\n                        atLineStart = true;\n                    }\n                    break;\n                case \"#\":\n                    {\n                        const comment = new Comment();\n                        offset = comment.parse({\n                            src\n                        }, offset);\n                        this.directives.push(comment);\n                        atLineStart = false;\n                    }\n                    break;\n                case \"%\":\n                    {\n                        const directive = new Directive();\n                        offset = directive.parse({\n                            parent: this,\n                            src\n                        }, offset);\n                        this.directives.push(directive);\n                        hasDirectives = true;\n                        atLineStart = false;\n                    }\n                    break;\n                default:\n                    if (hasDirectives) {\n                        this.error = new _rollupPluginBabelHelpers.YAMLSemanticError(this, \"Missing directives-end indicator line\");\n                    } else if (this.directives.length > 0) {\n                        this.contents = this.directives;\n                        this.directives = [];\n                    }\n                    return offset;\n            }\n        }\n        if (src[offset]) {\n            this.directivesEndMarker = new _rollupPluginBabelHelpers.Range(offset, offset + 3);\n            return offset + 3;\n        }\n        if (hasDirectives) {\n            this.error = new _rollupPluginBabelHelpers.YAMLSemanticError(this, \"Missing directives-end indicator line\");\n        } else if (this.directives.length > 0) {\n            this.contents = this.directives;\n            this.directives = [];\n        }\n        return offset;\n    }\n    parseContents(start) {\n        const { parseNode, src } = this.context;\n        if (!this.contents) this.contents = [];\n        let lineStart = start;\n        while(src[lineStart - 1] === \"-\")lineStart -= 1;\n        let offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, start);\n        let atLineStart = lineStart === start;\n        this.valueRange = new _rollupPluginBabelHelpers.Range(offset);\n        while(!_rollupPluginBabelHelpers.Node.atDocumentBoundary(src, offset, _rollupPluginBabelHelpers.Char.DOCUMENT_END)){\n            switch(src[offset]){\n                case \"\\n\":\n                    if (atLineStart) {\n                        const blankLine = new BlankLine();\n                        offset = blankLine.parse({\n                            src\n                        }, offset);\n                        if (offset < src.length) {\n                            this.contents.push(blankLine);\n                        }\n                    } else {\n                        offset += 1;\n                        atLineStart = true;\n                    }\n                    lineStart = offset;\n                    break;\n                case \"#\":\n                    {\n                        const comment = new Comment();\n                        offset = comment.parse({\n                            src\n                        }, offset);\n                        this.contents.push(comment);\n                        atLineStart = false;\n                    }\n                    break;\n                default:\n                    {\n                        const iEnd = _rollupPluginBabelHelpers.Node.endOfIndent(src, offset);\n                        const context = {\n                            atLineStart,\n                            indent: -1,\n                            inFlow: false,\n                            inCollection: false,\n                            lineStart,\n                            parent: this\n                        };\n                        const node = parseNode(context, iEnd);\n                        if (!node) return this.valueRange.end = iEnd; // at next document start\n                        this.contents.push(node);\n                        offset = node.range.end;\n                        atLineStart = false;\n                        const ec = grabCollectionEndComments(node);\n                        if (ec) Array.prototype.push.apply(this.contents, ec);\n                    }\n            }\n            offset = Document.startCommentOrEndBlankLine(src, offset);\n        }\n        this.valueRange.end = offset;\n        if (src[offset]) {\n            this.documentEndMarker = new _rollupPluginBabelHelpers.Range(offset, offset + 3);\n            offset += 3;\n            if (src[offset]) {\n                offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset);\n                if (src[offset] === \"#\") {\n                    const comment = new Comment();\n                    offset = comment.parse({\n                        src\n                    }, offset);\n                    this.contents.push(comment);\n                }\n                switch(src[offset]){\n                    case \"\\n\":\n                        offset += 1;\n                        break;\n                    case undefined:\n                        break;\n                    default:\n                        this.error = new _rollupPluginBabelHelpers.YAMLSyntaxError(this, \"Document end marker line cannot have a non-comment suffix\");\n                }\n            }\n        }\n        return offset;\n    }\n    /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */ parse(context, start) {\n        context.root = this;\n        this.context = context;\n        const { src } = context;\n        let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n        offset = this.parseDirectives(offset);\n        offset = this.parseContents(offset);\n        return offset;\n    }\n    setOrigRanges(cr, offset) {\n        offset = super.setOrigRanges(cr, offset);\n        this.directives.forEach((node)=>{\n            offset = node.setOrigRanges(cr, offset);\n        });\n        if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n        this.contents.forEach((node)=>{\n            offset = node.setOrigRanges(cr, offset);\n        });\n        if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n        return offset;\n    }\n    toString() {\n        const { contents, directives, value } = this;\n        if (value != null) return value;\n        let str = directives.join(\"\");\n        if (contents.length > 0) {\n            if (directives.length > 0 || contents[0].type === _rollupPluginBabelHelpers.Type.COMMENT) str += \"---\\n\";\n            str += contents.join(\"\");\n        }\n        if (str[str.length - 1] !== \"\\n\") str += \"\\n\";\n        return str;\n    }\n}\nclass Alias extends _rollupPluginBabelHelpers.Node {\n    /**\n   * Parses an *alias from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */ parse(context, start) {\n        this.context = context;\n        const { src } = context;\n        let offset = _rollupPluginBabelHelpers.Node.endOfIdentifier(src, start + 1);\n        this.valueRange = new _rollupPluginBabelHelpers.Range(start + 1, offset);\n        offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset);\n        offset = this.parseComment(offset);\n        return offset;\n    }\n}\nconst Chomp = {\n    CLIP: \"CLIP\",\n    KEEP: \"KEEP\",\n    STRIP: \"STRIP\"\n};\nclass BlockValue extends _rollupPluginBabelHelpers.Node {\n    constructor(type, props){\n        super(type, props);\n        this.blockIndent = null;\n        this.chomping = Chomp.CLIP;\n        this.header = null;\n    }\n    get includesTrailingLines() {\n        return this.chomping === Chomp.KEEP;\n    }\n    get strValue() {\n        if (!this.valueRange || !this.context) return null;\n        let { start, end } = this.valueRange;\n        const { indent, src } = this.context;\n        if (this.valueRange.isEmpty()) return \"\";\n        let lastNewLine = null;\n        let ch = src[end - 1];\n        while(ch === \"\\n\" || ch === \"\t\" || ch === \" \"){\n            end -= 1;\n            if (end <= start) {\n                if (this.chomping === Chomp.KEEP) break;\n                else return \"\"; // probably never happens\n            }\n            if (ch === \"\\n\") lastNewLine = end;\n            ch = src[end - 1];\n        }\n        let keepStart = end + 1;\n        if (lastNewLine) {\n            if (this.chomping === Chomp.KEEP) {\n                keepStart = lastNewLine;\n                end = this.valueRange.end;\n            } else {\n                end = lastNewLine;\n            }\n        }\n        const bi = indent + this.blockIndent;\n        const folded = this.type === _rollupPluginBabelHelpers.Type.BLOCK_FOLDED;\n        let atStart = true;\n        let str = \"\";\n        let sep = \"\";\n        let prevMoreIndented = false;\n        for(let i = start; i < end; ++i){\n            for(let j = 0; j < bi; ++j){\n                if (src[i] !== \" \") break;\n                i += 1;\n            }\n            const ch = src[i];\n            if (ch === \"\\n\") {\n                if (sep === \"\\n\") str += \"\\n\";\n                else sep = \"\\n\";\n            } else {\n                const lineEnd = _rollupPluginBabelHelpers.Node.endOfLine(src, i);\n                const line = src.slice(i, lineEnd);\n                i = lineEnd;\n                if (folded && (ch === \" \" || ch === \"\t\") && i < keepStart) {\n                    if (sep === \" \") sep = \"\\n\";\n                    else if (!prevMoreIndented && !atStart && sep === \"\\n\") sep = \"\\n\\n\";\n                    str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n                    sep = lineEnd < end && src[lineEnd] || \"\";\n                    prevMoreIndented = true;\n                } else {\n                    str += sep + line;\n                    sep = folded && i < keepStart ? \" \" : \"\\n\";\n                    prevMoreIndented = false;\n                }\n                if (atStart && line !== \"\") atStart = false;\n            }\n        }\n        return this.chomping === Chomp.STRIP ? str : str + \"\\n\";\n    }\n    parseBlockHeader(start) {\n        const { src } = this.context;\n        let offset = start + 1;\n        let bi = \"\";\n        while(true){\n            const ch = src[offset];\n            switch(ch){\n                case \"-\":\n                    this.chomping = Chomp.STRIP;\n                    break;\n                case \"+\":\n                    this.chomping = Chomp.KEEP;\n                    break;\n                case \"0\":\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    bi += ch;\n                    break;\n                default:\n                    this.blockIndent = Number(bi) || null;\n                    this.header = new _rollupPluginBabelHelpers.Range(start, offset);\n                    return offset;\n            }\n            offset += 1;\n        }\n    }\n    parseBlockValue(start) {\n        const { indent, src } = this.context;\n        const explicit = !!this.blockIndent;\n        let offset = start;\n        let valueEnd = start;\n        let minBlockIndent = 1;\n        for(let ch = src[offset]; ch === \"\\n\"; ch = src[offset]){\n            offset += 1;\n            if (_rollupPluginBabelHelpers.Node.atDocumentBoundary(src, offset)) break;\n            const end = _rollupPluginBabelHelpers.Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n            if (end === null) break;\n            const ch = src[end];\n            const lineIndent = end - (offset + indent);\n            if (!this.blockIndent) {\n                // no explicit block indent, none yet detected\n                if (src[end] !== \"\\n\") {\n                    // first line with non-whitespace content\n                    if (lineIndent < minBlockIndent) {\n                        const msg = \"Block scalars with more-indented leading empty lines must use an explicit indentation indicator\";\n                        this.error = new _rollupPluginBabelHelpers.YAMLSemanticError(this, msg);\n                    }\n                    this.blockIndent = lineIndent;\n                } else if (lineIndent > minBlockIndent) {\n                    // empty line with more whitespace\n                    minBlockIndent = lineIndent;\n                }\n            } else if (ch && ch !== \"\\n\" && lineIndent < this.blockIndent) {\n                if (src[end] === \"#\") break;\n                if (!this.error) {\n                    const src = explicit ? \"explicit indentation indicator\" : \"first line\";\n                    const msg = `Block scalars must not be less indented than their ${src}`;\n                    this.error = new _rollupPluginBabelHelpers.YAMLSemanticError(this, msg);\n                }\n            }\n            if (src[end] === \"\\n\") {\n                offset = end;\n            } else {\n                offset = valueEnd = _rollupPluginBabelHelpers.Node.endOfLine(src, end);\n            }\n        }\n        if (this.chomping !== Chomp.KEEP) {\n            offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n        }\n        this.valueRange = new _rollupPluginBabelHelpers.Range(start + 1, offset);\n        return offset;\n    }\n    /**\n   * Parses a block value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * BS\n   * block\n   * lines\n   *\n   * BS #comment\n   * block\n   * lines\n   * ```\n   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n   * are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this block\n   */ parse(context, start) {\n        this.context = context;\n        const { src } = context;\n        let offset = this.parseBlockHeader(start);\n        offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset);\n        offset = this.parseComment(offset);\n        offset = this.parseBlockValue(offset);\n        return offset;\n    }\n    setOrigRanges(cr, offset) {\n        offset = super.setOrigRanges(cr, offset);\n        return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n}\nclass FlowCollection extends _rollupPluginBabelHelpers.Node {\n    constructor(type, props){\n        super(type, props);\n        this.items = null;\n    }\n    prevNodeIsJsonLike(idx = this.items.length) {\n        const node = this.items[idx - 1];\n        return !!node && (node.jsonLike || node.type === _rollupPluginBabelHelpers.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */ parse(context, start) {\n        this.context = context;\n        const { parseNode, src } = context;\n        let { indent, lineStart } = context;\n        let char = src[start]; // { or [\n        this.items = [\n            {\n                char,\n                offset: start\n            }\n        ];\n        let offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, start + 1);\n        char = src[offset];\n        while(char && char !== \"]\" && char !== \"}\"){\n            switch(char){\n                case \"\\n\":\n                    {\n                        lineStart = offset + 1;\n                        const wsEnd = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, lineStart);\n                        if (src[wsEnd] === \"\\n\") {\n                            const blankLine = new BlankLine();\n                            lineStart = blankLine.parse({\n                                src\n                            }, lineStart);\n                            this.items.push(blankLine);\n                        }\n                        offset = _rollupPluginBabelHelpers.Node.endOfIndent(src, lineStart);\n                        if (offset <= lineStart + indent) {\n                            char = src[offset];\n                            if (offset < lineStart + indent || char !== \"]\" && char !== \"}\") {\n                                const msg = \"Insufficient indentation in flow collection\";\n                                this.error = new _rollupPluginBabelHelpers.YAMLSemanticError(this, msg);\n                            }\n                        }\n                    }\n                    break;\n                case \",\":\n                    {\n                        this.items.push({\n                            char,\n                            offset\n                        });\n                        offset += 1;\n                    }\n                    break;\n                case \"#\":\n                    {\n                        const comment = new Comment();\n                        offset = comment.parse({\n                            src\n                        }, offset);\n                        this.items.push(comment);\n                    }\n                    break;\n                case \"?\":\n                case \":\":\n                    {\n                        const next = src[offset + 1];\n                        if (next === \"\\n\" || next === \"\t\" || next === \" \" || next === \",\" || // in-flow : after JSON-like key does not need to be followed by whitespace\n                        char === \":\" && this.prevNodeIsJsonLike()) {\n                            this.items.push({\n                                char,\n                                offset\n                            });\n                            offset += 1;\n                            break;\n                        }\n                    }\n                // fallthrough\n                default:\n                    {\n                        const node = parseNode({\n                            atLineStart: false,\n                            inCollection: false,\n                            inFlow: true,\n                            indent: -1,\n                            lineStart,\n                            parent: this\n                        }, offset);\n                        if (!node) {\n                            // at next document start\n                            this.valueRange = new _rollupPluginBabelHelpers.Range(start, offset);\n                            return offset;\n                        }\n                        this.items.push(node);\n                        offset = _rollupPluginBabelHelpers.Node.normalizeOffset(src, node.range.end);\n                    }\n            }\n            offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset);\n            char = src[offset];\n        }\n        this.valueRange = new _rollupPluginBabelHelpers.Range(start, offset + 1);\n        if (char) {\n            this.items.push({\n                char,\n                offset\n            });\n            offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset + 1);\n            offset = this.parseComment(offset);\n        }\n        return offset;\n    }\n    setOrigRanges(cr, offset) {\n        offset = super.setOrigRanges(cr, offset);\n        this.items.forEach((node)=>{\n            if (node instanceof _rollupPluginBabelHelpers.Node) {\n                offset = node.setOrigRanges(cr, offset);\n            } else if (cr.length === 0) {\n                node.origOffset = node.offset;\n            } else {\n                let i = offset;\n                while(i < cr.length){\n                    if (cr[i] > node.offset) break;\n                    else ++i;\n                }\n                node.origOffset = node.offset + i;\n                offset = i;\n            }\n        });\n        return offset;\n    }\n    toString() {\n        const { context: { src }, items, range, value } = this;\n        if (value != null) return value;\n        const nodes = items.filter((item)=>item instanceof _rollupPluginBabelHelpers.Node);\n        let str = \"\";\n        let prevEnd = range.start;\n        nodes.forEach((node)=>{\n            const prefix = src.slice(prevEnd, node.range.start);\n            prevEnd = node.range.end;\n            str += prefix + String(node);\n            if (str[str.length - 1] === \"\\n\" && src[prevEnd - 1] !== \"\\n\" && src[prevEnd] === \"\\n\") {\n                // Comment range does not include the terminal newline, but its\n                // stringified value does. Without this fix, newlines at comment ends\n                // get duplicated.\n                prevEnd += 1;\n            }\n        });\n        str += src.slice(prevEnd, range.end);\n        return _rollupPluginBabelHelpers.Node.addStringTerminator(src, range.end, str);\n    }\n}\nclass PlainValue extends _rollupPluginBabelHelpers.Node {\n    static endOfLine(src, start, inFlow) {\n        let ch = src[start];\n        let offset = start;\n        while(ch && ch !== \"\\n\"){\n            if (inFlow && (ch === \"[\" || ch === \"]\" || ch === \"{\" || ch === \"}\" || ch === \",\")) break;\n            const next = src[offset + 1];\n            if (ch === \":\" && (!next || next === \"\\n\" || next === \"\t\" || next === \" \" || inFlow && next === \",\")) break;\n            if ((ch === \" \" || ch === \"\t\") && next === \"#\") break;\n            offset += 1;\n            ch = next;\n        }\n        return offset;\n    }\n    get strValue() {\n        if (!this.valueRange || !this.context) return null;\n        let { start, end } = this.valueRange;\n        const { src } = this.context;\n        let ch = src[end - 1];\n        while(start < end && (ch === \"\\n\" || ch === \"\t\" || ch === \" \"))ch = src[--end - 1];\n        let str = \"\";\n        for(let i = start; i < end; ++i){\n            const ch = src[i];\n            if (ch === \"\\n\") {\n                const { fold, offset } = _rollupPluginBabelHelpers.Node.foldNewline(src, i, -1);\n                str += fold;\n                i = offset;\n            } else if (ch === \" \" || ch === \"\t\") {\n                // trim trailing whitespace\n                const wsStart = i;\n                let next = src[i + 1];\n                while(i < end && (next === \" \" || next === \"\t\")){\n                    i += 1;\n                    next = src[i + 1];\n                }\n                if (next !== \"\\n\") str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n            } else {\n                str += ch;\n            }\n        }\n        const ch0 = src[start];\n        switch(ch0){\n            case \"\t\":\n                {\n                    const msg = \"Plain value cannot start with a tab character\";\n                    const errors = [\n                        new _rollupPluginBabelHelpers.YAMLSemanticError(this, msg)\n                    ];\n                    return {\n                        errors,\n                        str\n                    };\n                }\n            case \"@\":\n            case \"`\":\n                {\n                    const msg = `Plain value cannot start with reserved character ${ch0}`;\n                    const errors = [\n                        new _rollupPluginBabelHelpers.YAMLSemanticError(this, msg)\n                    ];\n                    return {\n                        errors,\n                        str\n                    };\n                }\n            default:\n                return str;\n        }\n    }\n    parseBlockValue(start) {\n        const { indent, inFlow, src } = this.context;\n        let offset = start;\n        let valueEnd = start;\n        for(let ch = src[offset]; ch === \"\\n\"; ch = src[offset]){\n            if (_rollupPluginBabelHelpers.Node.atDocumentBoundary(src, offset + 1)) break;\n            const end = _rollupPluginBabelHelpers.Node.endOfBlockIndent(src, indent, offset + 1);\n            if (end === null || src[end] === \"#\") break;\n            if (src[end] === \"\\n\") {\n                offset = end;\n            } else {\n                valueEnd = PlainValue.endOfLine(src, end, inFlow);\n                offset = valueEnd;\n            }\n        }\n        if (this.valueRange.isEmpty()) this.valueRange.start = start;\n        this.valueRange.end = valueEnd;\n        return valueEnd;\n    }\n    /**\n   * Parses a plain value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * #comment\n   *\n   * first line\n   *\n   * first line #comment\n   *\n   * first line\n   * block\n   * lines\n   *\n   * #comment\n   * block\n   * lines\n   * ```\n   * where block lines are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar, may be `\\n`\n   */ parse(context, start) {\n        this.context = context;\n        const { inFlow, src } = context;\n        let offset = start;\n        const ch = src[offset];\n        if (ch && ch !== \"#\" && ch !== \"\\n\") {\n            offset = PlainValue.endOfLine(src, start, inFlow);\n        }\n        this.valueRange = new _rollupPluginBabelHelpers.Range(start, offset);\n        offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset);\n        offset = this.parseComment(offset);\n        if (!this.hasComment || this.valueRange.isEmpty()) {\n            offset = this.parseBlockValue(offset);\n        }\n        return offset;\n    }\n}\nclass QuoteDouble extends _rollupPluginBabelHelpers.Node {\n    static endOfQuote(src, offset) {\n        let ch = src[offset];\n        while(ch && ch !== '\"'){\n            offset += ch === \"\\\\\" ? 2 : 1;\n            ch = src[offset];\n        }\n        return offset + 1;\n    }\n    /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */ get strValue() {\n        if (!this.valueRange || !this.context) return null;\n        const errors = [];\n        const { start, end } = this.valueRange;\n        const { indent, src } = this.context;\n        if (src[end - 1] !== '\"') errors.push(new _rollupPluginBabelHelpers.YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n        // escaped backslashes; also, this should be faster.\n        let str = \"\";\n        for(let i = start + 1; i < end - 1; ++i){\n            const ch = src[i];\n            if (ch === \"\\n\") {\n                if (_rollupPluginBabelHelpers.Node.atDocumentBoundary(src, i + 1)) errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(this, \"Document boundary indicators are not allowed within string values\"));\n                const { fold, offset, error } = _rollupPluginBabelHelpers.Node.foldNewline(src, i, indent);\n                str += fold;\n                i = offset;\n                if (error) errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(this, \"Multi-line double-quoted string needs to be sufficiently indented\"));\n            } else if (ch === \"\\\\\") {\n                i += 1;\n                switch(src[i]){\n                    case \"0\":\n                        str += \"\\x00\";\n                        break;\n                    // null character\n                    case \"a\":\n                        str += \"\\x07\";\n                        break;\n                    // bell character\n                    case \"b\":\n                        str += \"\\b\";\n                        break;\n                    // backspace\n                    case \"e\":\n                        str += \"\\x1b\";\n                        break;\n                    // escape character\n                    case \"f\":\n                        str += \"\\f\";\n                        break;\n                    // form feed\n                    case \"n\":\n                        str += \"\\n\";\n                        break;\n                    // line feed\n                    case \"r\":\n                        str += \"\\r\";\n                        break;\n                    // carriage return\n                    case \"t\":\n                        str += \"\t\";\n                        break;\n                    // horizontal tab\n                    case \"v\":\n                        str += \"\\v\";\n                        break;\n                    // vertical tab\n                    case \"N\":\n                        str += \"\\x85\";\n                        break;\n                    // Unicode next line\n                    case \"_\":\n                        str += \"\\xa0\";\n                        break;\n                    // Unicode non-breaking space\n                    case \"L\":\n                        str += \"\\u2028\";\n                        break;\n                    // Unicode line separator\n                    case \"P\":\n                        str += \"\\u2029\";\n                        break;\n                    // Unicode paragraph separator\n                    case \" \":\n                        str += \" \";\n                        break;\n                    case '\"':\n                        str += '\"';\n                        break;\n                    case \"/\":\n                        str += \"/\";\n                        break;\n                    case \"\\\\\":\n                        str += \"\\\\\";\n                        break;\n                    case \"\t\":\n                        str += \"\t\";\n                        break;\n                    case \"x\":\n                        str += this.parseCharCode(i + 1, 2, errors);\n                        i += 2;\n                        break;\n                    case \"u\":\n                        str += this.parseCharCode(i + 1, 4, errors);\n                        i += 4;\n                        break;\n                    case \"U\":\n                        str += this.parseCharCode(i + 1, 8, errors);\n                        i += 8;\n                        break;\n                    case \"\\n\":\n                        // skip escaped newlines, but still trim the following line\n                        while(src[i + 1] === \" \" || src[i + 1] === \"\t\")i += 1;\n                        break;\n                    default:\n                        errors.push(new _rollupPluginBabelHelpers.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));\n                        str += \"\\\\\" + src[i];\n                }\n            } else if (ch === \" \" || ch === \"\t\") {\n                // trim trailing whitespace\n                const wsStart = i;\n                let next = src[i + 1];\n                while(next === \" \" || next === \"\t\"){\n                    i += 1;\n                    next = src[i + 1];\n                }\n                if (next !== \"\\n\") str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n            } else {\n                str += ch;\n            }\n        }\n        return errors.length > 0 ? {\n            errors,\n            str\n        } : str;\n    }\n    parseCharCode(offset, length, errors) {\n        const { src } = this.context;\n        const cc = src.substr(offset, length);\n        const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n        const code = ok ? parseInt(cc, 16) : NaN;\n        if (isNaN(code)) {\n            errors.push(new _rollupPluginBabelHelpers.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));\n            return src.substr(offset - 2, length + 2);\n        }\n        return String.fromCodePoint(code);\n    }\n    /**\n   * Parses a \"double quoted\" value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */ parse(context, start) {\n        this.context = context;\n        const { src } = context;\n        let offset = QuoteDouble.endOfQuote(src, start + 1);\n        this.valueRange = new _rollupPluginBabelHelpers.Range(start, offset);\n        offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset);\n        offset = this.parseComment(offset);\n        return offset;\n    }\n}\nclass QuoteSingle extends _rollupPluginBabelHelpers.Node {\n    static endOfQuote(src, offset) {\n        let ch = src[offset];\n        while(ch){\n            if (ch === \"'\") {\n                if (src[offset + 1] !== \"'\") break;\n                ch = src[offset += 2];\n            } else {\n                ch = src[offset += 1];\n            }\n        }\n        return offset + 1;\n    }\n    /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */ get strValue() {\n        if (!this.valueRange || !this.context) return null;\n        const errors = [];\n        const { start, end } = this.valueRange;\n        const { indent, src } = this.context;\n        if (src[end - 1] !== \"'\") errors.push(new _rollupPluginBabelHelpers.YAMLSyntaxError(this, \"Missing closing 'quote\"));\n        let str = \"\";\n        for(let i = start + 1; i < end - 1; ++i){\n            const ch = src[i];\n            if (ch === \"\\n\") {\n                if (_rollupPluginBabelHelpers.Node.atDocumentBoundary(src, i + 1)) errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(this, \"Document boundary indicators are not allowed within string values\"));\n                const { fold, offset, error } = _rollupPluginBabelHelpers.Node.foldNewline(src, i, indent);\n                str += fold;\n                i = offset;\n                if (error) errors.push(new _rollupPluginBabelHelpers.YAMLSemanticError(this, \"Multi-line single-quoted string needs to be sufficiently indented\"));\n            } else if (ch === \"'\") {\n                str += ch;\n                i += 1;\n                if (src[i] !== \"'\") errors.push(new _rollupPluginBabelHelpers.YAMLSyntaxError(this, \"Unescaped single quote? This should not happen.\"));\n            } else if (ch === \" \" || ch === \"\t\") {\n                // trim trailing whitespace\n                const wsStart = i;\n                let next = src[i + 1];\n                while(next === \" \" || next === \"\t\"){\n                    i += 1;\n                    next = src[i + 1];\n                }\n                if (next !== \"\\n\") str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n            } else {\n                str += ch;\n            }\n        }\n        return errors.length > 0 ? {\n            errors,\n            str\n        } : str;\n    }\n    /**\n   * Parses a 'single quoted' value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */ parse(context, start) {\n        this.context = context;\n        const { src } = context;\n        let offset = QuoteSingle.endOfQuote(src, start + 1);\n        this.valueRange = new _rollupPluginBabelHelpers.Range(start, offset);\n        offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset);\n        offset = this.parseComment(offset);\n        return offset;\n    }\n}\nfunction createNewNode(type, props) {\n    switch(type){\n        case _rollupPluginBabelHelpers.Type.ALIAS:\n            return new Alias(type, props);\n        case _rollupPluginBabelHelpers.Type.BLOCK_FOLDED:\n        case _rollupPluginBabelHelpers.Type.BLOCK_LITERAL:\n            return new BlockValue(type, props);\n        case _rollupPluginBabelHelpers.Type.FLOW_MAP:\n        case _rollupPluginBabelHelpers.Type.FLOW_SEQ:\n            return new FlowCollection(type, props);\n        case _rollupPluginBabelHelpers.Type.MAP_KEY:\n        case _rollupPluginBabelHelpers.Type.MAP_VALUE:\n        case _rollupPluginBabelHelpers.Type.SEQ_ITEM:\n            return new CollectionItem(type, props);\n        case _rollupPluginBabelHelpers.Type.COMMENT:\n        case _rollupPluginBabelHelpers.Type.PLAIN:\n            return new PlainValue(type, props);\n        case _rollupPluginBabelHelpers.Type.QUOTE_DOUBLE:\n            return new QuoteDouble(type, props);\n        case _rollupPluginBabelHelpers.Type.QUOTE_SINGLE:\n            return new QuoteSingle(type, props);\n        /* istanbul ignore next */ default:\n            return null;\n    }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */ class ParseContext {\n    static parseType(src, offset, inFlow) {\n        switch(src[offset]){\n            case \"*\":\n                return _rollupPluginBabelHelpers.Type.ALIAS;\n            case \">\":\n                return _rollupPluginBabelHelpers.Type.BLOCK_FOLDED;\n            case \"|\":\n                return _rollupPluginBabelHelpers.Type.BLOCK_LITERAL;\n            case \"{\":\n                return _rollupPluginBabelHelpers.Type.FLOW_MAP;\n            case \"[\":\n                return _rollupPluginBabelHelpers.Type.FLOW_SEQ;\n            case \"?\":\n                return !inFlow && _rollupPluginBabelHelpers.Node.atBlank(src, offset + 1, true) ? _rollupPluginBabelHelpers.Type.MAP_KEY : _rollupPluginBabelHelpers.Type.PLAIN;\n            case \":\":\n                return !inFlow && _rollupPluginBabelHelpers.Node.atBlank(src, offset + 1, true) ? _rollupPluginBabelHelpers.Type.MAP_VALUE : _rollupPluginBabelHelpers.Type.PLAIN;\n            case \"-\":\n                return !inFlow && _rollupPluginBabelHelpers.Node.atBlank(src, offset + 1, true) ? _rollupPluginBabelHelpers.Type.SEQ_ITEM : _rollupPluginBabelHelpers.Type.PLAIN;\n            case '\"':\n                return _rollupPluginBabelHelpers.Type.QUOTE_DOUBLE;\n            case \"'\":\n                return _rollupPluginBabelHelpers.Type.QUOTE_SINGLE;\n            default:\n                return _rollupPluginBabelHelpers.Type.PLAIN;\n        }\n    }\n    constructor(orig = {}, { atLineStart, inCollection, inFlow, indent, lineStart, parent } = {}){\n        _rollupPluginBabelHelpers._defineProperty(this, \"parseNode\", (overlay, start)=>{\n            if (_rollupPluginBabelHelpers.Node.atDocumentBoundary(this.src, start)) return null;\n            const context = new ParseContext(this, overlay);\n            const { props, type, valueStart } = context.parseProps(start);\n            const node = createNewNode(type, props);\n            let offset = node.parse(context, valueStart);\n            node.range = new _rollupPluginBabelHelpers.Range(start, offset);\n            /* istanbul ignore if */ if (offset <= start) {\n                // This should never happen, but if it does, let's make sure to at least\n                // step one character forward to avoid a busy loop.\n                node.error = new Error(`Node#parse consumed no characters`);\n                node.error.parseEnd = offset;\n                node.error.source = node;\n                node.range.end = start + 1;\n            }\n            if (context.nodeStartsCollection(node)) {\n                if (!node.error && !context.atLineStart && context.parent.type === _rollupPluginBabelHelpers.Type.DOCUMENT) {\n                    node.error = new _rollupPluginBabelHelpers.YAMLSyntaxError(node, \"Block collection must not have preceding content here (e.g. directives-end indicator)\");\n                }\n                const collection = new Collection(node);\n                offset = collection.parse(new ParseContext(context), offset);\n                collection.range = new _rollupPluginBabelHelpers.Range(start, offset);\n                return collection;\n            }\n            return node;\n        });\n        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n        this.indent = indent != null ? indent : orig.indent;\n        this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n        this.parent = parent != null ? parent : orig.parent || {};\n        this.root = orig.root;\n        this.src = orig.src;\n    }\n    nodeStartsCollection(node) {\n        const { inCollection, inFlow, src } = this;\n        if (inCollection || inFlow) return false;\n        if (node instanceof CollectionItem) return true; // check for implicit key\n        let offset = node.range.end;\n        if (src[offset] === \"\\n\" || src[offset - 1] === \"\\n\") return false;\n        offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset);\n        return src[offset] === \":\";\n    }\n    // class; hence this intermediate step.\n    parseProps(offset) {\n        const { inFlow, parent, src } = this;\n        const props = [];\n        let lineHasProps = false;\n        offset = this.atLineStart ? _rollupPluginBabelHelpers.Node.endOfIndent(src, offset) : _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, offset);\n        let ch = src[offset];\n        while(ch === _rollupPluginBabelHelpers.Char.ANCHOR || ch === _rollupPluginBabelHelpers.Char.COMMENT || ch === _rollupPluginBabelHelpers.Char.TAG || ch === \"\\n\"){\n            if (ch === \"\\n\") {\n                const lineStart = offset + 1;\n                const inEnd = _rollupPluginBabelHelpers.Node.endOfIndent(src, lineStart);\n                const indentDiff = inEnd - (lineStart + this.indent);\n                const noIndicatorAsIndent = parent.type === _rollupPluginBabelHelpers.Type.SEQ_ITEM && parent.context.atLineStart;\n                if (!_rollupPluginBabelHelpers.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n                this.atLineStart = true;\n                this.lineStart = lineStart;\n                lineHasProps = false;\n                offset = inEnd;\n            } else if (ch === _rollupPluginBabelHelpers.Char.COMMENT) {\n                const end = _rollupPluginBabelHelpers.Node.endOfLine(src, offset + 1);\n                props.push(new _rollupPluginBabelHelpers.Range(offset, end));\n                offset = end;\n            } else {\n                let end = _rollupPluginBabelHelpers.Node.endOfIdentifier(src, offset + 1);\n                if (ch === _rollupPluginBabelHelpers.Char.TAG && src[end] === \",\" && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, end + 13))) {\n                    // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n                    // than an empty but 'foo.bar' private-tagged node in a flow collection\n                    // followed without whitespace by a plain string starting with a year\n                    // or date divided by something.\n                    end = _rollupPluginBabelHelpers.Node.endOfIdentifier(src, end + 5);\n                }\n                props.push(new _rollupPluginBabelHelpers.Range(offset, end));\n                lineHasProps = true;\n                offset = _rollupPluginBabelHelpers.Node.endOfWhiteSpace(src, end);\n            }\n            ch = src[offset];\n        } // '- &a : b' has an anchor on an empty node\n        if (lineHasProps && ch === \":\" && _rollupPluginBabelHelpers.Node.atBlank(src, offset + 1, true)) offset -= 1;\n        const type = ParseContext.parseType(src, offset, inFlow);\n        return {\n            props,\n            type,\n            valueStart: offset\n        };\n    }\n}\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n    const cr = [];\n    if (src.indexOf(\"\\r\") !== -1) {\n        src = src.replace(/\\r\\n?/g, (match, offset)=>{\n            if (match.length > 1) cr.push(offset);\n            return \"\\n\";\n        });\n    }\n    const documents = [];\n    let offset = 0;\n    do {\n        const doc = new Document();\n        const context = new ParseContext({\n            src\n        });\n        offset = doc.parse(context, offset);\n        documents.push(doc);\n    }while (offset < src.length);\n    documents.setOrigRanges = ()=>{\n        if (cr.length === 0) return false;\n        for(let i = 1; i < cr.length; ++i)cr[i] -= i;\n        let crOffset = 0;\n        for(let i = 0; i < documents.length; ++i){\n            crOffset = documents[i].setOrigRanges(cr, crOffset);\n        }\n        cr.splice(0, cr.length);\n        return true;\n    };\n    documents.toString = ()=>documents.join(\"...\\n\");\n    return documents;\n}\nexports.Document = Document;\nexports.PlainValue = PlainValue;\nexports.parse = parse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3BhcnNlLTM5OTdmNTQ0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsNEJBQTRCQyxtQkFBT0EsQ0FBQztBQUV4QyxNQUFNQyxrQkFBa0JGLDBCQUEwQkcsSUFBSTtJQUNwREMsYUFBYztRQUNaLEtBQUssQ0FBQ0osMEJBQTBCSyxJQUFJLENBQUNDLFVBQVU7SUFDakQ7SUFDQSx3QkFBd0IsR0FHeEIsSUFBSUMsd0JBQXdCO1FBQzFCLHNEQUFzRDtRQUN0RCxzQ0FBc0M7UUFDdEMsT0FBTztJQUNUO0lBQ0E7Ozs7OztHQU1DLEdBR0RDLE1BQU1DLE9BQU8sRUFBRUMsS0FBSyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0UsS0FBSyxHQUFHLElBQUlYLDBCQUEwQlksS0FBSyxDQUFDRixPQUFPQSxRQUFRO1FBQ2hFLE9BQU9BLFFBQVE7SUFDakI7QUFFRjtBQUVBLE1BQU1HLHVCQUF1QmIsMEJBQTBCRyxJQUFJO0lBQ3pEQyxZQUFZVSxJQUFJLEVBQUVDLEtBQUssQ0FBRTtRQUN2QixLQUFLLENBQUNELE1BQU1DO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtJQUVBLElBQUlULHdCQUF3QjtRQUMxQixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUNTLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUksQ0FBQ1QscUJBQXFCO0lBQ3ZEO0lBQ0E7Ozs7R0FJQyxHQUdEQyxNQUFNQyxPQUFPLEVBQUVDLEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUNELE9BQU8sR0FBR0E7UUFDZixNQUFNLEVBQ0pRLFNBQVMsRUFDVEMsR0FBRyxFQUNKLEdBQUdUO1FBQ0osSUFBSSxFQUNGVSxXQUFXLEVBQ1hDLFNBQVMsRUFDVixHQUFHWDtRQUNKLElBQUksQ0FBQ1UsZUFBZSxJQUFJLENBQUNMLElBQUksS0FBS2QsMEJBQTBC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QUFHO1FBQ0QsTUFBTXlMLE1BQU0sSUFBSWpIO1FBQ2hCLE1BQU14RixVQUFVLElBQUltTCxhQUFhO1lBQy9CMUs7UUFDRjtRQUNBTyxTQUFTeUwsSUFBSTFNLEtBQUssQ0FBQ0MsU0FBU2dCO1FBQzVCd0wsVUFBVWhMLElBQUksQ0FBQ2lMO0lBQ2pCLFFBQVN6TCxTQUFTUCxJQUFJaUIsTUFBTSxFQUFFO0lBRTlCOEssVUFBVWxLLGFBQWEsR0FBRztRQUN4QixJQUFJQyxHQUFHYixNQUFNLEtBQUssR0FBRyxPQUFPO1FBRTVCLElBQUssSUFBSTRCLElBQUksR0FBR0EsSUFBSWYsR0FBR2IsTUFBTSxFQUFFLEVBQUU0QixFQUFHZixFQUFFLENBQUNlLEVBQUUsSUFBSUE7UUFFN0MsSUFBSW9KLFdBQVc7UUFFZixJQUFLLElBQUlwSixJQUFJLEdBQUdBLElBQUlrSixVQUFVOUssTUFBTSxFQUFFLEVBQUU0QixFQUFHO1lBQ3pDb0osV0FBV0YsU0FBUyxDQUFDbEosRUFBRSxDQUFDaEIsYUFBYSxDQUFDQyxJQUFJbUs7UUFDNUM7UUFFQW5LLEdBQUdrQixNQUFNLENBQUMsR0FBR2xCLEdBQUdiLE1BQU07UUFDdEIsT0FBTztJQUNUO0lBRUE4SyxVQUFVaEssUUFBUSxHQUFHLElBQU1nSyxVQUFVNUYsSUFBSSxDQUFDO0lBRTFDLE9BQU80RjtBQUNUO0FBRUFHLGdCQUFnQixHQUFHbkg7QUFDbkJtSCxrQkFBa0IsR0FBR3REO0FBQ3JCc0QsYUFBYSxHQUFHNU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3N3YWdnZXItanNkb2Mvbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9wYXJzZS0zOTk3ZjU0NC5qcz9iYTg2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMgPSByZXF1aXJlKCcuL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtZWVkMzAyMTcuanMnKTtcblxuY2xhc3MgQmxhbmtMaW5lIGV4dGVuZHMgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkJMQU5LX0xJTkUpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICBnZXQgaW5jbHVkZXNUcmFpbGluZ0xpbmVzKCkge1xuICAgIC8vIFRoaXMgaXMgbmV2ZXIgY2FsbGVkIGZyb20gYW55d2hlcmUsIGJ1dCBpZiBpdCB3ZXJlLFxuICAgIC8vIHRoaXMgaXMgdGhlIHZhbHVlIGl0IHNob3VsZCByZXR1cm4uXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGJsYW5rIGxpbmUgZnJvbSB0aGUgc291cmNlXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IFxcbiBjaGFyYWN0ZXJcbiAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXNcbiAgICovXG5cblxuICBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5yYW5nZSA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlJhbmdlKHN0YXJ0LCBzdGFydCArIDEpO1xuICAgIHJldHVybiBzdGFydCArIDE7XG4gIH1cblxufVxuXG5jbGFzcyBDb2xsZWN0aW9uSXRlbSBleHRlbmRzIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHByb3BzKSB7XG4gICAgc3VwZXIodHlwZSwgcHJvcHMpO1xuICAgIHRoaXMubm9kZSA9IG51bGw7XG4gIH1cblxuICBnZXQgaW5jbHVkZXNUcmFpbGluZ0xpbmVzKCkge1xuICAgIHJldHVybiAhIXRoaXMubm9kZSAmJiB0aGlzLm5vZGUuaW5jbHVkZXNUcmFpbGluZ0xpbmVzO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBjaGFyYWN0ZXJcbiAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXNcbiAgICovXG5cblxuICBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgY29uc3Qge1xuICAgICAgcGFyc2VOb2RlLFxuICAgICAgc3JjXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHtcbiAgICAgIGF0TGluZVN0YXJ0LFxuICAgICAgbGluZVN0YXJ0XG4gICAgfSA9IGNvbnRleHQ7XG4gICAgaWYgKCFhdExpbmVTdGFydCAmJiB0aGlzLnR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5TRVFfSVRFTSkgdGhpcy5lcnJvciA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKHRoaXMsICdTZXF1ZW5jZSBpdGVtcyBtdXN0IG5vdCBoYXZlIHByZWNlZGluZyBjb250ZW50IG9uIHRoZSBzYW1lIGxpbmUnKTtcbiAgICBjb25zdCBpbmRlbnQgPSBhdExpbmVTdGFydCA/IHN0YXJ0IC0gbGluZVN0YXJ0IDogY29udGV4dC5pbmRlbnQ7XG4gICAgbGV0IG9mZnNldCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBzdGFydCArIDEpO1xuICAgIGxldCBjaCA9IHNyY1tvZmZzZXRdO1xuICAgIGNvbnN0IGlubGluZUNvbW1lbnQgPSBjaCA9PT0gJyMnO1xuICAgIGNvbnN0IGNvbW1lbnRzID0gW107XG4gICAgbGV0IGJsYW5rTGluZSA9IG51bGw7XG5cbiAgICB3aGlsZSAoY2ggPT09ICdcXG4nIHx8IGNoID09PSAnIycpIHtcbiAgICAgIGlmIChjaCA9PT0gJyMnKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZkxpbmUoc3JjLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgY29tbWVudHMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5SYW5nZShvZmZzZXQsIGVuZCkpO1xuICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdExpbmVTdGFydCA9IHRydWU7XG4gICAgICAgIGxpbmVTdGFydCA9IG9mZnNldCArIDE7XG4gICAgICAgIGNvbnN0IHdzRW5kID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIGxpbmVTdGFydCk7XG5cbiAgICAgICAgaWYgKHNyY1t3c0VuZF0gPT09ICdcXG4nICYmIGNvbW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGJsYW5rTGluZSA9IG5ldyBCbGFua0xpbmUoKTtcbiAgICAgICAgICBsaW5lU3RhcnQgPSBibGFua0xpbmUucGFyc2Uoe1xuICAgICAgICAgICAgc3JjXG4gICAgICAgICAgfSwgbGluZVN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZkluZGVudChzcmMsIGxpbmVTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3JjW29mZnNldF07XG4gICAgfVxuXG4gICAgaWYgKF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5uZXh0Tm9kZUlzSW5kZW50ZWQoY2gsIG9mZnNldCAtIChsaW5lU3RhcnQgKyBpbmRlbnQpLCB0aGlzLnR5cGUgIT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5TRVFfSVRFTSkpIHtcbiAgICAgIHRoaXMubm9kZSA9IHBhcnNlTm9kZSh7XG4gICAgICAgIGF0TGluZVN0YXJ0LFxuICAgICAgICBpbkNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgICBpbmRlbnQsXG4gICAgICAgIGxpbmVTdGFydCxcbiAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgICB9LCBvZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoY2ggJiYgbGluZVN0YXJ0ID4gc3RhcnQgKyAxKSB7XG4gICAgICBvZmZzZXQgPSBsaW5lU3RhcnQgLSAxO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgIGlmIChibGFua0xpbmUpIHtcbiAgICAgICAgLy8gT25seSBibGFuayBsaW5lcyBwcmVjZWRpbmcgbm9uLWVtcHR5IG5vZGVzIGFyZSBjYXB0dXJlZC4gTm90ZSB0aGF0XG4gICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBjb2xsZWN0aW9uIGl0ZW0gcmFuZ2Ugc3RhcnQgaW5kaWNlcyBkbyBub3QgYWx3YXlzXG4gICAgICAgIC8vIGluY3JlYXNlIG1vbm90b25pY2FsbHkuIC0tIGVlbWVsaS95YW1sIzEyNlxuICAgICAgICBjb25zdCBpdGVtcyA9IGNvbnRleHQucGFyZW50Lml0ZW1zIHx8IGNvbnRleHQucGFyZW50LmNvbnRlbnRzO1xuICAgICAgICBpZiAoaXRlbXMpIGl0ZW1zLnB1c2goYmxhbmtMaW5lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbW1lbnRzLmxlbmd0aCkgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5wcm9wcywgY29tbWVudHMpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5ub2RlLnJhbmdlLmVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlubGluZUNvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbW1lbnRzWzBdO1xuICAgICAgICB0aGlzLnByb3BzLnB1c2goYyk7XG4gICAgICAgIG9mZnNldCA9IGMuZW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mTGluZShzcmMsIHN0YXJ0ICsgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZW5kID0gdGhpcy5ub2RlID8gdGhpcy5ub2RlLnZhbHVlUmFuZ2UuZW5kIDogb2Zmc2V0O1xuICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBzZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBzdXBlci5zZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpO1xuICAgIHJldHVybiB0aGlzLm5vZGUgPyB0aGlzLm5vZGUuc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KSA6IG9mZnNldDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgc3JjXG4gICAgICB9LFxuICAgICAgbm9kZSxcbiAgICAgIHJhbmdlLFxuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHN0ciA9IG5vZGUgPyBzcmMuc2xpY2UocmFuZ2Uuc3RhcnQsIG5vZGUucmFuZ2Uuc3RhcnQpICsgU3RyaW5nKG5vZGUpIDogc3JjLnNsaWNlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgIHJldHVybiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuYWRkU3RyaW5nVGVybWluYXRvcihzcmMsIHJhbmdlLmVuZCwgc3RyKTtcbiAgfVxuXG59XG5cbmNsYXNzIENvbW1lbnQgZXh0ZW5kcyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQ09NTUVOVCk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGNvbW1lbnQgbGluZSBmcm9tIHRoZSBzb3VyY2VcbiAgICpcbiAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3QgY2hhcmFjdGVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzIHNjYWxhclxuICAgKi9cblxuXG4gIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnBhcnNlQ29tbWVudChzdGFydCk7XG4gICAgdGhpcy5yYW5nZSA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBncmFiQ29sbGVjdGlvbkVuZENvbW1lbnRzKG5vZGUpIHtcbiAgbGV0IGNub2RlID0gbm9kZTtcblxuICB3aGlsZSAoY25vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uSXRlbSkgY25vZGUgPSBjbm9kZS5ub2RlO1xuXG4gIGlmICghKGNub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbikpIHJldHVybiBudWxsO1xuICBjb25zdCBsZW4gPSBjbm9kZS5pdGVtcy5sZW5ndGg7XG4gIGxldCBjaSA9IC0xO1xuXG4gIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgIGNvbnN0IG4gPSBjbm9kZS5pdGVtc1tpXTtcblxuICAgIGlmIChuLnR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5DT01NRU5UKSB7XG4gICAgICAvLyBLZWVwIHN1ZmZpY2llbnRseSBpbmRlbnRlZCBjb21tZW50cyB3aXRoIHByZWNlZGluZyBub2RlXG4gICAgICBjb25zdCB7XG4gICAgICAgIGluZGVudCxcbiAgICAgICAgbGluZVN0YXJ0XG4gICAgICB9ID0gbi5jb250ZXh0O1xuICAgICAgaWYgKGluZGVudCA+IDAgJiYgbi5yYW5nZS5zdGFydCA+PSBsaW5lU3RhcnQgKyBpbmRlbnQpIGJyZWFrO1xuICAgICAgY2kgPSBpO1xuICAgIH0gZWxzZSBpZiAobi50eXBlID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxBTktfTElORSkgY2kgPSBpO2Vsc2UgYnJlYWs7XG4gIH1cblxuICBpZiAoY2kgPT09IC0xKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2EgPSBjbm9kZS5pdGVtcy5zcGxpY2UoY2ksIGxlbiAtIGNpKTtcbiAgY29uc3QgcHJldkVuZCA9IGNhWzBdLnJhbmdlLnN0YXJ0O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY25vZGUucmFuZ2UuZW5kID0gcHJldkVuZDtcbiAgICBpZiAoY25vZGUudmFsdWVSYW5nZSAmJiBjbm9kZS52YWx1ZVJhbmdlLmVuZCA+IHByZXZFbmQpIGNub2RlLnZhbHVlUmFuZ2UuZW5kID0gcHJldkVuZDtcbiAgICBpZiAoY25vZGUgPT09IG5vZGUpIGJyZWFrO1xuICAgIGNub2RlID0gY25vZGUuY29udGV4dC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gY2E7XG59XG5jbGFzcyBDb2xsZWN0aW9uIGV4dGVuZHMgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlIHtcbiAgc3RhdGljIG5leHRDb250ZW50SGFzSW5kZW50KHNyYywgb2Zmc2V0LCBpbmRlbnQpIHtcbiAgICBjb25zdCBsaW5lU3RhcnQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZMaW5lKHNyYywgb2Zmc2V0KSArIDE7XG4gICAgb2Zmc2V0ID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIGxpbmVTdGFydCk7XG4gICAgY29uc3QgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICBpZiAoIWNoKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG9mZnNldCA+PSBsaW5lU3RhcnQgKyBpbmRlbnQpIHJldHVybiB0cnVlO1xuICAgIGlmIChjaCAhPT0gJyMnICYmIGNoICE9PSAnXFxuJykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBDb2xsZWN0aW9uLm5leHRDb250ZW50SGFzSW5kZW50KHNyYywgb2Zmc2V0LCBpbmRlbnQpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZmlyc3RJdGVtKSB7XG4gICAgc3VwZXIoZmlyc3RJdGVtLnR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5TRVFfSVRFTSA/IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5TRVEgOiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuTUFQKTtcblxuICAgIGZvciAobGV0IGkgPSBmaXJzdEl0ZW0ucHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGlmIChmaXJzdEl0ZW0ucHJvcHNbaV0uc3RhcnQgPCBmaXJzdEl0ZW0uY29udGV4dC5saW5lU3RhcnQpIHtcbiAgICAgICAgLy8gcHJvcHMgb24gcHJldmlvdXMgbGluZSBhcmUgYXNzdW1lZCBieSB0aGUgY29sbGVjdGlvblxuICAgICAgICB0aGlzLnByb3BzID0gZmlyc3RJdGVtLnByb3BzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgZmlyc3RJdGVtLnByb3BzID0gZmlyc3RJdGVtLnByb3BzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgY29uc3QgaXRlbVJhbmdlID0gZmlyc3RJdGVtLnByb3BzWzBdIHx8IGZpcnN0SXRlbS52YWx1ZVJhbmdlO1xuICAgICAgICBmaXJzdEl0ZW0ucmFuZ2Uuc3RhcnQgPSBpdGVtUmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaXRlbXMgPSBbZmlyc3RJdGVtXTtcbiAgICBjb25zdCBlYyA9IGdyYWJDb2xsZWN0aW9uRW5kQ29tbWVudHMoZmlyc3RJdGVtKTtcbiAgICBpZiAoZWMpIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuaXRlbXMsIGVjKTtcbiAgfVxuXG4gIGdldCBpbmNsdWRlc1RyYWlsaW5nTGluZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoID4gMDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3QgY2hhcmFjdGVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzXG4gICAqL1xuXG5cbiAgcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcnNlTm9kZSxcbiAgICAgIHNyY1xuICAgIH0gPSBjb250ZXh0OyAvLyBJdCdzIGVhc2llciB0byByZWNhbGN1bGF0ZSBsaW5lU3RhcnQgaGVyZSByYXRoZXIgdGhhbiB0cmFja2luZyBkb3duIHRoZVxuICAgIC8vIGxhc3QgY29udGV4dCBmcm9tIHdoaWNoIHRvIHJlYWQgaXQgLS0gZWVtZWxpL3lhbWwjMlxuXG4gICAgbGV0IGxpbmVTdGFydCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5zdGFydE9mTGluZShzcmMsIHN0YXJ0KTtcbiAgICBjb25zdCBmaXJzdEl0ZW0gPSB0aGlzLml0ZW1zWzBdOyAvLyBGaXJzdC1pdGVtIGNvbnRleHQgbmVlZHMgdG8gYmUgY29ycmVjdCBmb3IgbGF0ZXIgY29tbWVudCBoYW5kbGluZ1xuICAgIC8vIC0tIGVlbWVsaS95YW1sIzE3XG5cbiAgICBmaXJzdEl0ZW0uY29udGV4dC5wYXJlbnQgPSB0aGlzO1xuICAgIHRoaXMudmFsdWVSYW5nZSA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuUmFuZ2UuY29weShmaXJzdEl0ZW0udmFsdWVSYW5nZSk7XG4gICAgY29uc3QgaW5kZW50ID0gZmlyc3RJdGVtLnJhbmdlLnN0YXJ0IC0gZmlyc3RJdGVtLmNvbnRleHQubGluZVN0YXJ0O1xuICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICBvZmZzZXQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUubm9ybWFsaXplT2Zmc2V0KHNyYywgb2Zmc2V0KTtcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICBsZXQgYXRMaW5lU3RhcnQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgbGluZVN0YXJ0KSA9PT0gb2Zmc2V0O1xuICAgIGxldCBwcmV2SW5jbHVkZXNUcmFpbGluZ0xpbmVzID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoY2gpIHtcbiAgICAgIHdoaWxlIChjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICcjJykge1xuICAgICAgICBpZiAoYXRMaW5lU3RhcnQgJiYgY2ggPT09ICdcXG4nICYmICFwcmV2SW5jbHVkZXNUcmFpbGluZ0xpbmVzKSB7XG4gICAgICAgICAgY29uc3QgYmxhbmtMaW5lID0gbmV3IEJsYW5rTGluZSgpO1xuICAgICAgICAgIG9mZnNldCA9IGJsYW5rTGluZS5wYXJzZSh7XG4gICAgICAgICAgICBzcmNcbiAgICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgICAgIHRoaXMudmFsdWVSYW5nZS5lbmQgPSBvZmZzZXQ7XG5cbiAgICAgICAgICBpZiAob2Zmc2V0ID49IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChibGFua0xpbmUpO1xuICAgICAgICAgIG9mZnNldCAtPSAxOyAvLyBibGFua0xpbmUucGFyc2UoKSBjb25zdW1lcyB0ZXJtaW5hbCBuZXdsaW5lXG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcjJykge1xuICAgICAgICAgIGlmIChvZmZzZXQgPCBsaW5lU3RhcnQgKyBpbmRlbnQgJiYgIUNvbGxlY3Rpb24ubmV4dENvbnRlbnRIYXNJbmRlbnQoc3JjLCBvZmZzZXQsIGluZGVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY29tbWVudCA9IG5ldyBDb21tZW50KCk7XG4gICAgICAgICAgb2Zmc2V0ID0gY29tbWVudC5wYXJzZSh7XG4gICAgICAgICAgICBpbmRlbnQsXG4gICAgICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzcmNcbiAgICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChjb21tZW50KTtcbiAgICAgICAgICB0aGlzLnZhbHVlUmFuZ2UuZW5kID0gb2Zmc2V0O1xuXG4gICAgICAgICAgaWYgKG9mZnNldCA+PSBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lU3RhcnQgPSBvZmZzZXQgKyAxO1xuICAgICAgICBvZmZzZXQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZJbmRlbnQoc3JjLCBsaW5lU3RhcnQpO1xuXG4gICAgICAgIGlmIChfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuYXRCbGFuayhzcmMsIG9mZnNldCkpIHtcbiAgICAgICAgICBjb25zdCB3c0VuZCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBzcmNbd3NFbmRdO1xuXG4gICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQgPT09ICdcXG4nIHx8IG5leHQgPT09ICcjJykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gd3NFbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICAgICAgYXRMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAob2Zmc2V0ICE9PSBsaW5lU3RhcnQgKyBpbmRlbnQgJiYgKGF0TGluZVN0YXJ0IHx8IGNoICE9PSAnOicpKSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCBsaW5lU3RhcnQgKyBpbmRlbnQpIHtcbiAgICAgICAgICBpZiAobGluZVN0YXJ0ID4gc3RhcnQpIG9mZnNldCA9IGxpbmVTdGFydDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5lcnJvcikge1xuICAgICAgICAgIGNvbnN0IG1zZyA9ICdBbGwgY29sbGVjdGlvbiBpdGVtcyBtdXN0IHN0YXJ0IGF0IHRoZSBzYW1lIGNvbHVtbic7XG4gICAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTeW50YXhFcnJvcih0aGlzLCBtc2cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdEl0ZW0udHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlNFUV9JVEVNKSB7XG4gICAgICAgIGlmIChjaCAhPT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGxpbmVTdGFydCA+IHN0YXJ0KSBvZmZzZXQgPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICctJyAmJiAhdGhpcy5lcnJvcikge1xuICAgICAgICAvLyBtYXAga2V5IG1heSBzdGFydCB3aXRoIC0sIGFzIGxvbmcgYXMgaXQncyBmb2xsb3dlZCBieSBhIG5vbi13aGl0ZXNwYWNlIGNoYXJcbiAgICAgICAgY29uc3QgbmV4dCA9IHNyY1tvZmZzZXQgKyAxXTtcblxuICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PT0gJ1xcbicgfHwgbmV4dCA9PT0gJ1xcdCcgfHwgbmV4dCA9PT0gJyAnKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ0EgY29sbGVjdGlvbiBjYW5ub3QgYmUgYm90aCBhIG1hcHBpbmcgYW5kIGEgc2VxdWVuY2UnO1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU3ludGF4RXJyb3IodGhpcywgbXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gcGFyc2VOb2RlKHtcbiAgICAgICAgYXRMaW5lU3RhcnQsXG4gICAgICAgIGluQ29sbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgaW5kZW50LFxuICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgfSwgb2Zmc2V0KTtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIG9mZnNldDsgLy8gYXQgbmV4dCBkb2N1bWVudCBzdGFydFxuXG4gICAgICB0aGlzLml0ZW1zLnB1c2gobm9kZSk7XG4gICAgICB0aGlzLnZhbHVlUmFuZ2UuZW5kID0gbm9kZS52YWx1ZVJhbmdlLmVuZDtcbiAgICAgIG9mZnNldCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5ub3JtYWxpemVPZmZzZXQoc3JjLCBub2RlLnJhbmdlLmVuZCk7XG4gICAgICBjaCA9IHNyY1tvZmZzZXRdO1xuICAgICAgYXRMaW5lU3RhcnQgPSBmYWxzZTtcbiAgICAgIHByZXZJbmNsdWRlc1RyYWlsaW5nTGluZXMgPSBub2RlLmluY2x1ZGVzVHJhaWxpbmdMaW5lczsgLy8gTmVlZCB0byByZXNldCBsaW5lU3RhcnQgYW5kIGF0TGluZVN0YXJ0IGhlcmUgaWYgcHJlY2VkaW5nIG5vZGUncyByYW5nZVxuICAgICAgLy8gaGFzIGFkdmFuY2VkIHRvIGNoZWNrIHRoZSBjdXJyZW50IGxpbmUncyBpbmRlbnRhdGlvbiBsZXZlbFxuICAgICAgLy8gLS0gZWVtZWxpL3lhbWwjMTAgJiBlZW1lbGkveWFtbCMzOFxuXG4gICAgICBpZiAoY2gpIHtcbiAgICAgICAgbGV0IGxzID0gb2Zmc2V0IC0gMTtcbiAgICAgICAgbGV0IHByZXYgPSBzcmNbbHNdO1xuXG4gICAgICAgIHdoaWxlIChwcmV2ID09PSAnICcgfHwgcHJldiA9PT0gJ1xcdCcpIHByZXYgPSBzcmNbLS1sc107XG5cbiAgICAgICAgaWYgKHByZXYgPT09ICdcXG4nKSB7XG4gICAgICAgICAgbGluZVN0YXJ0ID0gbHMgKyAxO1xuICAgICAgICAgIGF0TGluZVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlYyA9IGdyYWJDb2xsZWN0aW9uRW5kQ29tbWVudHMobm9kZSk7XG4gICAgICBpZiAoZWMpIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuaXRlbXMsIGVjKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gc3VwZXIuc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KTtcbiAgICB0aGlzLml0ZW1zLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBvZmZzZXQgPSBub2RlLnNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgc3JjXG4gICAgICB9LFxuICAgICAgaXRlbXMsXG4gICAgICByYW5nZSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgICBsZXQgc3RyID0gc3JjLnNsaWNlKHJhbmdlLnN0YXJ0LCBpdGVtc1swXS5yYW5nZS5zdGFydCkgKyBTdHJpbmcoaXRlbXNbMF0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhdExpbmVTdGFydCxcbiAgICAgICAgaW5kZW50XG4gICAgICB9ID0gaXRlbS5jb250ZXh0O1xuICAgICAgaWYgKGF0TGluZVN0YXJ0KSBmb3IgKGxldCBpID0gMDsgaSA8IGluZGVudDsgKytpKSBzdHIgKz0gJyAnO1xuICAgICAgc3RyICs9IFN0cmluZyhpdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmFkZFN0cmluZ1Rlcm1pbmF0b3Ioc3JjLCByYW5nZS5lbmQsIHN0cik7XG4gIH1cblxufVxuXG5jbGFzcyBEaXJlY3RpdmUgZXh0ZW5kcyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRElSRUNUSVZFKTtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICB9XG5cbiAgZ2V0IHBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcmF3ID0gdGhpcy5yYXdWYWx1ZTtcbiAgICByZXR1cm4gcmF3ID8gcmF3LnRyaW0oKS5zcGxpdCgvWyBcXHRdKy8pIDogW107XG4gIH1cblxuICBwYXJzZU5hbWUoc3RhcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzcmNcbiAgICB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgIHdoaWxlIChjaCAmJiBjaCAhPT0gJ1xcbicgJiYgY2ggIT09ICdcXHQnICYmIGNoICE9PSAnICcpIGNoID0gc3JjW29mZnNldCArPSAxXTtcblxuICAgIHRoaXMubmFtZSA9IHNyYy5zbGljZShzdGFydCwgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgcGFyc2VQYXJhbWV0ZXJzKHN0YXJ0KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgbGV0IGNoID0gc3JjW29mZnNldF07XG5cbiAgICB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nICYmIGNoICE9PSAnIycpIGNoID0gc3JjW29mZnNldCArPSAxXTtcblxuICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgbGV0IG9mZnNldCA9IHRoaXMucGFyc2VOYW1lKHN0YXJ0ICsgMSk7XG4gICAgb2Zmc2V0ID0gdGhpcy5wYXJzZVBhcmFtZXRlcnMob2Zmc2V0KTtcbiAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQ29tbWVudChvZmZzZXQpO1xuICAgIHRoaXMucmFuZ2UgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5SYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbn1cblxuY2xhc3MgRG9jdW1lbnQgZXh0ZW5kcyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUge1xuICBzdGF0aWMgc3RhcnRDb21tZW50T3JFbmRCbGFua0xpbmUoc3JjLCBzdGFydCkge1xuICAgIGNvbnN0IG9mZnNldCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBzdGFydCk7XG4gICAgY29uc3QgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICByZXR1cm4gY2ggPT09ICcjJyB8fCBjaCA9PT0gJ1xcbicgPyBvZmZzZXQgOiBzdGFydDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5ET0NVTUVOVCk7XG4gICAgdGhpcy5kaXJlY3RpdmVzID0gbnVsbDtcbiAgICB0aGlzLmNvbnRlbnRzID0gbnVsbDtcbiAgICB0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMuZG9jdW1lbnRFbmRNYXJrZXIgPSBudWxsO1xuICB9XG5cbiAgcGFyc2VEaXJlY3RpdmVzKHN0YXJ0KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICBsZXQgYXRMaW5lU3RhcnQgPSB0cnVlO1xuICAgIGxldCBoYXNEaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuXG4gICAgd2hpbGUgKCFfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuYXREb2N1bWVudEJvdW5kYXJ5KHNyYywgb2Zmc2V0LCBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLkNoYXIuRElSRUNUSVZFU19FTkQpKSB7XG4gICAgICBvZmZzZXQgPSBEb2N1bWVudC5zdGFydENvbW1lbnRPckVuZEJsYW5rTGluZShzcmMsIG9mZnNldCk7XG5cbiAgICAgIHN3aXRjaCAoc3JjW29mZnNldF0pIHtcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICBpZiAoYXRMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsYW5rTGluZSA9IG5ldyBCbGFua0xpbmUoKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGJsYW5rTGluZS5wYXJzZSh7XG4gICAgICAgICAgICAgIHNyY1xuICAgICAgICAgICAgfSwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goYmxhbmtMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICBhdExpbmVTdGFydCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IG5ldyBDb21tZW50KCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBjb21tZW50LnBhcnNlKHtcbiAgICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICBhdExpbmVTdGFydCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmUgPSBuZXcgRGlyZWN0aXZlKCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBkaXJlY3RpdmUucGFyc2Uoe1xuICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgIHNyY1xuICAgICAgICAgICAgfSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7XG4gICAgICAgICAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGF0TGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcih0aGlzLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3RpdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSB0aGlzLmRpcmVjdGl2ZXM7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcmNbb2Zmc2V0XSkge1xuICAgICAgdGhpcy5kaXJlY3RpdmVzRW5kTWFya2VyID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuUmFuZ2Uob2Zmc2V0LCBvZmZzZXQgKyAzKTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyAzO1xuICAgIH1cblxuICAgIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgICB0aGlzLmVycm9yID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFNlbWFudGljRXJyb3IodGhpcywgJ01pc3NpbmcgZGlyZWN0aXZlcy1lbmQgaW5kaWNhdG9yIGxpbmUnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvbnRlbnRzID0gdGhpcy5kaXJlY3RpdmVzO1xuICAgICAgdGhpcy5kaXJlY3RpdmVzID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHBhcnNlQ29udGVudHMoc3RhcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJzZU5vZGUsXG4gICAgICBzcmNcbiAgICB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGlmICghdGhpcy5jb250ZW50cykgdGhpcy5jb250ZW50cyA9IFtdO1xuICAgIGxldCBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgIHdoaWxlIChzcmNbbGluZVN0YXJ0IC0gMV0gPT09ICctJykgbGluZVN0YXJ0IC09IDE7XG5cbiAgICBsZXQgb2Zmc2V0ID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIHN0YXJ0KTtcbiAgICBsZXQgYXRMaW5lU3RhcnQgPSBsaW5lU3RhcnQgPT09IHN0YXJ0O1xuICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlJhbmdlKG9mZnNldCk7XG5cbiAgICB3aGlsZSAoIV9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5hdERvY3VtZW50Qm91bmRhcnkoc3JjLCBvZmZzZXQsIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuQ2hhci5ET0NVTUVOVF9FTkQpKSB7XG4gICAgICBzd2l0Y2ggKHNyY1tvZmZzZXRdKSB7XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgaWYgKGF0TGluZVN0YXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBibGFua0xpbmUgPSBuZXcgQmxhbmtMaW5lKCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBibGFua0xpbmUucGFyc2Uoe1xuICAgICAgICAgICAgICBzcmNcbiAgICAgICAgICAgIH0sIG9mZnNldCk7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29udGVudHMucHVzaChibGFua0xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIGF0TGluZVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IG5ldyBDb21tZW50KCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBjb21tZW50LnBhcnNlKHtcbiAgICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgYXRMaW5lU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBpRW5kID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mSW5kZW50KHNyYywgb2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgIGF0TGluZVN0YXJ0LFxuICAgICAgICAgICAgICBpbmRlbnQ6IC0xLFxuICAgICAgICAgICAgICBpbkZsb3c6IGZhbHNlLFxuICAgICAgICAgICAgICBpbkNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBwYXJzZU5vZGUoY29udGV4dCwgaUVuZCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHJldHVybiB0aGlzLnZhbHVlUmFuZ2UuZW5kID0gaUVuZDsgLy8gYXQgbmV4dCBkb2N1bWVudCBzdGFydFxuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBvZmZzZXQgPSBub2RlLnJhbmdlLmVuZDtcbiAgICAgICAgICAgIGF0TGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBlYyA9IGdyYWJDb2xsZWN0aW9uRW5kQ29tbWVudHMobm9kZSk7XG4gICAgICAgICAgICBpZiAoZWMpIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuY29udGVudHMsIGVjKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCA9IERvY3VtZW50LnN0YXJ0Q29tbWVudE9yRW5kQmxhbmtMaW5lKHNyYywgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlUmFuZ2UuZW5kID0gb2Zmc2V0O1xuXG4gICAgaWYgKHNyY1tvZmZzZXRdKSB7XG4gICAgICB0aGlzLmRvY3VtZW50RW5kTWFya2VyID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuUmFuZ2Uob2Zmc2V0LCBvZmZzZXQgKyAzKTtcbiAgICAgIG9mZnNldCArPSAzO1xuXG4gICAgICBpZiAoc3JjW29mZnNldF0pIHtcbiAgICAgICAgb2Zmc2V0ID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG5cbiAgICAgICAgaWYgKHNyY1tvZmZzZXRdID09PSAnIycpIHtcbiAgICAgICAgICBjb25zdCBjb21tZW50ID0gbmV3IENvbW1lbnQoKTtcbiAgICAgICAgICBvZmZzZXQgPSBjb21tZW50LnBhcnNlKHtcbiAgICAgICAgICAgIHNyY1xuICAgICAgICAgIH0sIG9mZnNldCk7XG4gICAgICAgICAgdGhpcy5jb250ZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChzcmNbb2Zmc2V0XSkge1xuICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFN5bnRheEVycm9yKHRoaXMsICdEb2N1bWVudCBlbmQgbWFya2VyIGxpbmUgY2Fubm90IGhhdmUgYSBub24tY29tbWVudCBzdWZmaXgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpc1xuICAgKi9cblxuXG4gIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgY29udGV4dC5yb290ID0gdGhpcztcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIHNyY1xuICAgIH0gPSBjb250ZXh0O1xuICAgIGxldCBvZmZzZXQgPSBzcmMuY2hhckNvZGVBdChzdGFydCkgPT09IDB4ZmVmZiA/IHN0YXJ0ICsgMSA6IHN0YXJ0OyAvLyBza2lwIEJPTVxuXG4gICAgb2Zmc2V0ID0gdGhpcy5wYXJzZURpcmVjdGl2ZXMob2Zmc2V0KTtcbiAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQ29udGVudHMob2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gc3VwZXIuc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KTtcbiAgICB0aGlzLmRpcmVjdGl2ZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIG9mZnNldCA9IG5vZGUuc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5kaXJlY3RpdmVzRW5kTWFya2VyKSBvZmZzZXQgPSB0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIuc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpO1xuICAgIHRoaXMuY29udGVudHMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIG9mZnNldCA9IG5vZGUuc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5kb2N1bWVudEVuZE1hcmtlcikgb2Zmc2V0ID0gdGhpcy5kb2N1bWVudEVuZE1hcmtlci5zZXRPcmlnUmFuZ2UoY3IsIG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRlbnRzLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgICBsZXQgc3RyID0gZGlyZWN0aXZlcy5qb2luKCcnKTtcblxuICAgIGlmIChjb250ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPiAwIHx8IGNvbnRlbnRzWzBdLnR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5DT01NRU5UKSBzdHIgKz0gJy0tLVxcbic7XG4gICAgICBzdHIgKz0gY29udGVudHMuam9pbignJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gIT09ICdcXG4nKSBzdHIgKz0gJ1xcbic7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG59XG5cbmNsYXNzIEFsaWFzIGV4dGVuZHMgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlIHtcbiAgLyoqXG4gICAqIFBhcnNlcyBhbiAqYWxpYXMgZnJvbSB0aGUgc291cmNlXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpcyBzY2FsYXJcbiAgICovXG4gIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICBzcmNcbiAgICB9ID0gY29udGV4dDtcbiAgICBsZXQgb2Zmc2V0ID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mSWRlbnRpZmllcihzcmMsIHN0YXJ0ICsgMSk7XG4gICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuUmFuZ2Uoc3RhcnQgKyAxLCBvZmZzZXQpO1xuICAgIG9mZnNldCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgIG9mZnNldCA9IHRoaXMucGFyc2VDb21tZW50KG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG59XG5cbmNvbnN0IENob21wID0ge1xuICBDTElQOiAnQ0xJUCcsXG4gIEtFRVA6ICdLRUVQJyxcbiAgU1RSSVA6ICdTVFJJUCdcbn07XG5jbGFzcyBCbG9ja1ZhbHVlIGV4dGVuZHMgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlIHtcbiAgY29uc3RydWN0b3IodHlwZSwgcHJvcHMpIHtcbiAgICBzdXBlcih0eXBlLCBwcm9wcyk7XG4gICAgdGhpcy5ibG9ja0luZGVudCA9IG51bGw7XG4gICAgdGhpcy5jaG9tcGluZyA9IENob21wLkNMSVA7XG4gICAgdGhpcy5oZWFkZXIgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGluY2x1ZGVzVHJhaWxpbmdMaW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5jaG9tcGluZyA9PT0gQ2hvbXAuS0VFUDtcbiAgfVxuXG4gIGdldCBzdHJWYWx1ZSgpIHtcbiAgICBpZiAoIXRoaXMudmFsdWVSYW5nZSB8fCAhdGhpcy5jb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgICBsZXQge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9ID0gdGhpcy52YWx1ZVJhbmdlO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGVudCxcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgaWYgKHRoaXMudmFsdWVSYW5nZS5pc0VtcHR5KCkpIHJldHVybiAnJztcbiAgICBsZXQgbGFzdE5ld0xpbmUgPSBudWxsO1xuICAgIGxldCBjaCA9IHNyY1tlbmQgLSAxXTtcblxuICAgIHdoaWxlIChjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnICcpIHtcbiAgICAgIGVuZCAtPSAxO1xuXG4gICAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmNob21waW5nID09PSBDaG9tcC5LRUVQKSBicmVhaztlbHNlIHJldHVybiAnJzsgLy8gcHJvYmFibHkgbmV2ZXIgaGFwcGVuc1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICdcXG4nKSBsYXN0TmV3TGluZSA9IGVuZDtcbiAgICAgIGNoID0gc3JjW2VuZCAtIDFdO1xuICAgIH1cblxuICAgIGxldCBrZWVwU3RhcnQgPSBlbmQgKyAxO1xuXG4gICAgaWYgKGxhc3ROZXdMaW5lKSB7XG4gICAgICBpZiAodGhpcy5jaG9tcGluZyA9PT0gQ2hvbXAuS0VFUCkge1xuICAgICAgICBrZWVwU3RhcnQgPSBsYXN0TmV3TGluZTtcbiAgICAgICAgZW5kID0gdGhpcy52YWx1ZVJhbmdlLmVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IGxhc3ROZXdMaW5lO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJpID0gaW5kZW50ICsgdGhpcy5ibG9ja0luZGVudDtcbiAgICBjb25zdCBmb2xkZWQgPSB0aGlzLnR5cGUgPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5CTE9DS19GT0xERUQ7XG4gICAgbGV0IGF0U3RhcnQgPSB0cnVlO1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgc2VwID0gJyc7XG4gICAgbGV0IHByZXZNb3JlSW5kZW50ZWQgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJpOyArK2opIHtcbiAgICAgICAgaWYgKHNyY1tpXSAhPT0gJyAnKSBicmVhaztcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaCA9IHNyY1tpXTtcblxuICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICBpZiAoc2VwID09PSAnXFxuJykgc3RyICs9ICdcXG4nO2Vsc2Ugc2VwID0gJ1xcbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaW5lRW5kID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mTGluZShzcmMsIGkpO1xuICAgICAgICBjb25zdCBsaW5lID0gc3JjLnNsaWNlKGksIGxpbmVFbmQpO1xuICAgICAgICBpID0gbGluZUVuZDtcblxuICAgICAgICBpZiAoZm9sZGVkICYmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JykgJiYgaSA8IGtlZXBTdGFydCkge1xuICAgICAgICAgIGlmIChzZXAgPT09ICcgJykgc2VwID0gJ1xcbic7ZWxzZSBpZiAoIXByZXZNb3JlSW5kZW50ZWQgJiYgIWF0U3RhcnQgJiYgc2VwID09PSAnXFxuJykgc2VwID0gJ1xcblxcbic7XG4gICAgICAgICAgc3RyICs9IHNlcCArIGxpbmU7IC8vKyAoKGxpbmVFbmQgPCBlbmQgJiYgc3JjW2xpbmVFbmRdKSB8fCAnJylcblxuICAgICAgICAgIHNlcCA9IGxpbmVFbmQgPCBlbmQgJiYgc3JjW2xpbmVFbmRdIHx8ICcnO1xuICAgICAgICAgIHByZXZNb3JlSW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSBzZXAgKyBsaW5lO1xuICAgICAgICAgIHNlcCA9IGZvbGRlZCAmJiBpIDwga2VlcFN0YXJ0ID8gJyAnIDogJ1xcbic7XG4gICAgICAgICAgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0U3RhcnQgJiYgbGluZSAhPT0gJycpIGF0U3RhcnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaG9tcGluZyA9PT0gQ2hvbXAuU1RSSVAgPyBzdHIgOiBzdHIgKyAnXFxuJztcbiAgfVxuXG4gIHBhcnNlQmxvY2tIZWFkZXIoc3RhcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzcmNcbiAgICB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGxldCBvZmZzZXQgPSBzdGFydCArIDE7XG4gICAgbGV0IGJpID0gJyc7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICB0aGlzLmNob21waW5nID0gQ2hvbXAuU1RSSVA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgdGhpcy5jaG9tcGluZyA9IENob21wLktFRVA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzEnOlxuICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgIGNhc2UgJzQnOlxuICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgY2FzZSAnNic6XG4gICAgICAgIGNhc2UgJzcnOlxuICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgYmkgKz0gY2g7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmJsb2NrSW5kZW50ID0gTnVtYmVyKGJpKSB8fCBudWxsO1xuICAgICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuUmFuZ2Uoc3RhcnQsIG9mZnNldCk7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VCbG9ja1ZhbHVlKHN0YXJ0KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZW50LFxuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBleHBsaWNpdCA9ICEhdGhpcy5ibG9ja0luZGVudDtcbiAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgbGV0IHZhbHVlRW5kID0gc3RhcnQ7XG4gICAgbGV0IG1pbkJsb2NrSW5kZW50ID0gMTtcblxuICAgIGZvciAobGV0IGNoID0gc3JjW29mZnNldF07IGNoID09PSAnXFxuJzsgY2ggPSBzcmNbb2Zmc2V0XSkge1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICBpZiAoX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIG9mZnNldCkpIGJyZWFrO1xuICAgICAgY29uc3QgZW5kID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mQmxvY2tJbmRlbnQoc3JjLCBpbmRlbnQsIG9mZnNldCk7IC8vIHNob3VsZCBub3QgaW5jbHVkZSB0YWI/XG5cbiAgICAgIGlmIChlbmQgPT09IG51bGwpIGJyZWFrO1xuICAgICAgY29uc3QgY2ggPSBzcmNbZW5kXTtcbiAgICAgIGNvbnN0IGxpbmVJbmRlbnQgPSBlbmQgLSAob2Zmc2V0ICsgaW5kZW50KTtcblxuICAgICAgaWYgKCF0aGlzLmJsb2NrSW5kZW50KSB7XG4gICAgICAgIC8vIG5vIGV4cGxpY2l0IGJsb2NrIGluZGVudCwgbm9uZSB5ZXQgZGV0ZWN0ZWRcbiAgICAgICAgaWYgKHNyY1tlbmRdICE9PSAnXFxuJykge1xuICAgICAgICAgIC8vIGZpcnN0IGxpbmUgd2l0aCBub24td2hpdGVzcGFjZSBjb250ZW50XG4gICAgICAgICAgaWYgKGxpbmVJbmRlbnQgPCBtaW5CbG9ja0luZGVudCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ0Jsb2NrIHNjYWxhcnMgd2l0aCBtb3JlLWluZGVudGVkIGxlYWRpbmcgZW1wdHkgbGluZXMgbXVzdCB1c2UgYW4gZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJztcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcih0aGlzLCBtc2cpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYmxvY2tJbmRlbnQgPSBsaW5lSW5kZW50O1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmVJbmRlbnQgPiBtaW5CbG9ja0luZGVudCkge1xuICAgICAgICAgIC8vIGVtcHR5IGxpbmUgd2l0aCBtb3JlIHdoaXRlc3BhY2VcbiAgICAgICAgICBtaW5CbG9ja0luZGVudCA9IGxpbmVJbmRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2ggJiYgY2ggIT09ICdcXG4nICYmIGxpbmVJbmRlbnQgPCB0aGlzLmJsb2NrSW5kZW50KSB7XG4gICAgICAgIGlmIChzcmNbZW5kXSA9PT0gJyMnKSBicmVhaztcblxuICAgICAgICBpZiAoIXRoaXMuZXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBzcmMgPSBleHBsaWNpdCA/ICdleHBsaWNpdCBpbmRlbnRhdGlvbiBpbmRpY2F0b3InIDogJ2ZpcnN0IGxpbmUnO1xuICAgICAgICAgIGNvbnN0IG1zZyA9IGBCbG9jayBzY2FsYXJzIG11c3Qgbm90IGJlIGxlc3MgaW5kZW50ZWQgdGhhbiB0aGVpciAke3NyY31gO1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcih0aGlzLCBtc2cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmNbZW5kXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gdmFsdWVFbmQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZMaW5lKHNyYywgZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jaG9tcGluZyAhPT0gQ2hvbXAuS0VFUCkge1xuICAgICAgb2Zmc2V0ID0gc3JjW3ZhbHVlRW5kXSA/IHZhbHVlRW5kICsgMSA6IHZhbHVlRW5kO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlJhbmdlKHN0YXJ0ICsgMSwgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBibG9jayB2YWx1ZSBmcm9tIHRoZSBzb3VyY2VcbiAgICpcbiAgICogQWNjZXB0ZWQgZm9ybXMgYXJlOlxuICAgKiBgYGBcbiAgICogQlNcbiAgICogYmxvY2tcbiAgICogbGluZXNcbiAgICpcbiAgICogQlMgI2NvbW1lbnRcbiAgICogYmxvY2tcbiAgICogbGluZXNcbiAgICogYGBgXG4gICAqIHdoZXJlIHRoZSBibG9jayBzdHlsZSBCUyBtYXRjaGVzIHRoZSByZWdleHAgYFt8Pl1bLSsxLTldKmAgYW5kIGJsb2NrIGxpbmVzXG4gICAqIGFyZSBlbXB0eSBvciBoYXZlIGFuIGluZGVudCBsZXZlbCBncmVhdGVyIHRoYW4gYGluZGVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpcyBibG9ja1xuICAgKi9cblxuXG4gIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICBzcmNcbiAgICB9ID0gY29udGV4dDtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5wYXJzZUJsb2NrSGVhZGVyKHN0YXJ0KTtcbiAgICBvZmZzZXQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQ29tbWVudChvZmZzZXQpO1xuICAgIG9mZnNldCA9IHRoaXMucGFyc2VCbG9ja1ZhbHVlKG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IHN1cGVyLnNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCk7XG4gICAgcmV0dXJuIHRoaXMuaGVhZGVyID8gdGhpcy5oZWFkZXIuc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpIDogb2Zmc2V0O1xuICB9XG5cbn1cblxuY2xhc3MgRmxvd0NvbGxlY3Rpb24gZXh0ZW5kcyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBwcm9wcykge1xuICAgIHN1cGVyKHR5cGUsIHByb3BzKTtcbiAgICB0aGlzLml0ZW1zID0gbnVsbDtcbiAgfVxuXG4gIHByZXZOb2RlSXNKc29uTGlrZShpZHggPSB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLml0ZW1zW2lkeCAtIDFdO1xuICAgIHJldHVybiAhIW5vZGUgJiYgKG5vZGUuanNvbkxpa2UgfHwgbm9kZS50eXBlID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQ09NTUVOVCAmJiB0aGlzLnByZXZOb2RlSXNKc29uTGlrZShpZHggLSAxKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpc1xuICAgKi9cblxuXG4gIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICBwYXJzZU5vZGUsXG4gICAgICBzcmNcbiAgICB9ID0gY29udGV4dDtcbiAgICBsZXQge1xuICAgICAgaW5kZW50LFxuICAgICAgbGluZVN0YXJ0XG4gICAgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGNoYXIgPSBzcmNbc3RhcnRdOyAvLyB7IG9yIFtcblxuICAgIHRoaXMuaXRlbXMgPSBbe1xuICAgICAgY2hhcixcbiAgICAgIG9mZnNldDogc3RhcnRcbiAgICB9XTtcbiAgICBsZXQgb2Zmc2V0ID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIHN0YXJ0ICsgMSk7XG4gICAgY2hhciA9IHNyY1tvZmZzZXRdO1xuXG4gICAgd2hpbGUgKGNoYXIgJiYgY2hhciAhPT0gJ10nICYmIGNoYXIgIT09ICd9Jykge1xuICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGluZVN0YXJ0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHdzRW5kID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIGxpbmVTdGFydCk7XG5cbiAgICAgICAgICAgIGlmIChzcmNbd3NFbmRdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICBjb25zdCBibGFua0xpbmUgPSBuZXcgQmxhbmtMaW5lKCk7XG4gICAgICAgICAgICAgIGxpbmVTdGFydCA9IGJsYW5rTGluZS5wYXJzZSh7XG4gICAgICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICAgIH0sIGxpbmVTdGFydCk7XG4gICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChibGFua0xpbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZJbmRlbnQoc3JjLCBsaW5lU3RhcnQpO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDw9IGxpbmVTdGFydCArIGluZGVudCkge1xuICAgICAgICAgICAgICBjaGFyID0gc3JjW29mZnNldF07XG5cbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxpbmVTdGFydCArIGluZGVudCB8fCBjaGFyICE9PSAnXScgJiYgY2hhciAhPT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ0luc3VmZmljaWVudCBpbmRlbnRhdGlvbiBpbiBmbG93IGNvbGxlY3Rpb24nO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcih0aGlzLCBtc2cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgIGNoYXIsXG4gICAgICAgICAgICAgIG9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IG5ldyBDb21tZW50KCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBjb21tZW50LnBhcnNlKHtcbiAgICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHNyY1tvZmZzZXQgKyAxXTtcblxuICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nIHx8IG5leHQgPT09ICdcXHQnIHx8IG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnLCcgfHwgLy8gaW4tZmxvdyA6IGFmdGVyIEpTT04tbGlrZSBrZXkgZG9lcyBub3QgbmVlZCB0byBiZSBmb2xsb3dlZCBieSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBjaGFyID09PSAnOicgJiYgdGhpcy5wcmV2Tm9kZUlzSnNvbkxpa2UoKSkge1xuICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGNoYXIsXG4gICAgICAgICAgICAgICAgb2Zmc2V0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHBhcnNlTm9kZSh7XG4gICAgICAgICAgICAgIGF0TGluZVN0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgaW5Db2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgaW5GbG93OiB0cnVlLFxuICAgICAgICAgICAgICBpbmRlbnQ6IC0xLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICAgICAgfSwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgIC8vIGF0IG5leHQgZG9jdW1lbnQgc3RhcnRcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuUmFuZ2Uoc3RhcnQsIG9mZnNldCk7XG4gICAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5ub3JtYWxpemVPZmZzZXQoc3JjLCBub2RlLnJhbmdlLmVuZCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvZmZzZXQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICAgIGNoYXIgPSBzcmNbb2Zmc2V0XTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlUmFuZ2UgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5SYW5nZShzdGFydCwgb2Zmc2V0ICsgMSk7XG5cbiAgICBpZiAoY2hhcikge1xuICAgICAgdGhpcy5pdGVtcy5wdXNoKHtcbiAgICAgICAgY2hhcixcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9KTtcbiAgICAgIG9mZnNldCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQgKyAxKTtcbiAgICAgIG9mZnNldCA9IHRoaXMucGFyc2VDb21tZW50KG9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IHN1cGVyLnNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCk7XG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUpIHtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5zZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIGlmIChjci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbm9kZS5vcmlnT2Zmc2V0ID0gbm9kZS5vZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgaSA9IG9mZnNldDtcblxuICAgICAgICB3aGlsZSAoaSA8IGNyLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChjcltpXSA+IG5vZGUub2Zmc2V0KSBicmVhaztlbHNlICsraTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUub3JpZ09mZnNldCA9IG5vZGUub2Zmc2V0ICsgaTtcbiAgICAgICAgb2Zmc2V0ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBzcmNcbiAgICAgIH0sXG4gICAgICBpdGVtcyxcbiAgICAgIHJhbmdlLFxuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IG5vZGVzID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbSBpbnN0YW5jZW9mIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZSk7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBwcmV2RW5kID0gcmFuZ2Uuc3RhcnQ7XG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHNyYy5zbGljZShwcmV2RW5kLCBub2RlLnJhbmdlLnN0YXJ0KTtcbiAgICAgIHByZXZFbmQgPSBub2RlLnJhbmdlLmVuZDtcbiAgICAgIHN0ciArPSBwcmVmaXggKyBTdHJpbmcobm9kZSk7XG5cbiAgICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnXFxuJyAmJiBzcmNbcHJldkVuZCAtIDFdICE9PSAnXFxuJyAmJiBzcmNbcHJldkVuZF0gPT09ICdcXG4nKSB7XG4gICAgICAgIC8vIENvbW1lbnQgcmFuZ2UgZG9lcyBub3QgaW5jbHVkZSB0aGUgdGVybWluYWwgbmV3bGluZSwgYnV0IGl0c1xuICAgICAgICAvLyBzdHJpbmdpZmllZCB2YWx1ZSBkb2VzLiBXaXRob3V0IHRoaXMgZml4LCBuZXdsaW5lcyBhdCBjb21tZW50IGVuZHNcbiAgICAgICAgLy8gZ2V0IGR1cGxpY2F0ZWQuXG4gICAgICAgIHByZXZFbmQgKz0gMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdHIgKz0gc3JjLnNsaWNlKHByZXZFbmQsIHJhbmdlLmVuZCk7XG4gICAgcmV0dXJuIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5hZGRTdHJpbmdUZXJtaW5hdG9yKHNyYywgcmFuZ2UuZW5kLCBzdHIpO1xuICB9XG5cbn1cblxuY2xhc3MgUGxhaW5WYWx1ZSBleHRlbmRzIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZSB7XG4gIHN0YXRpYyBlbmRPZkxpbmUoc3JjLCBzdGFydCwgaW5GbG93KSB7XG4gICAgbGV0IGNoID0gc3JjW3N0YXJ0XTtcbiAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG5cbiAgICB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nKSB7XG4gICAgICBpZiAoaW5GbG93ICYmIChjaCA9PT0gJ1snIHx8IGNoID09PSAnXScgfHwgY2ggPT09ICd7JyB8fCBjaCA9PT0gJ30nIHx8IGNoID09PSAnLCcpKSBicmVhaztcbiAgICAgIGNvbnN0IG5leHQgPSBzcmNbb2Zmc2V0ICsgMV07XG4gICAgICBpZiAoY2ggPT09ICc6JyAmJiAoIW5leHQgfHwgbmV4dCA9PT0gJ1xcbicgfHwgbmV4dCA9PT0gJ1xcdCcgfHwgbmV4dCA9PT0gJyAnIHx8IGluRmxvdyAmJiBuZXh0ID09PSAnLCcpKSBicmVhaztcbiAgICAgIGlmICgoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpICYmIG5leHQgPT09ICcjJykgYnJlYWs7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIGNoID0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgZ2V0IHN0clZhbHVlKCkge1xuICAgIGlmICghdGhpcy52YWx1ZVJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiBudWxsO1xuICAgIGxldCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gPSB0aGlzLnZhbHVlUmFuZ2U7XG4gICAgY29uc3Qge1xuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICBsZXQgY2ggPSBzcmNbZW5kIC0gMV07XG5cbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgKGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJykpIGNoID0gc3JjWy0tZW5kIC0gMV07XG5cbiAgICBsZXQgc3RyID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgY29uc3QgY2ggPSBzcmNbaV07XG5cbiAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvbGQsXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgIH0gPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZm9sZE5ld2xpbmUoc3JjLCBpLCAtMSk7XG4gICAgICAgIHN0ciArPSBmb2xkO1xuICAgICAgICBpID0gb2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0Jykge1xuICAgICAgICAvLyB0cmltIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgY29uc3Qgd3NTdGFydCA9IGk7XG4gICAgICAgIGxldCBuZXh0ID0gc3JjW2kgKyAxXTtcblxuICAgICAgICB3aGlsZSAoaSA8IGVuZCAmJiAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKSkge1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBuZXh0ID0gc3JjW2kgKyAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ICE9PSAnXFxuJykgc3RyICs9IGkgPiB3c1N0YXJ0ID8gc3JjLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IGNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNoMCA9IHNyY1tzdGFydF07XG5cbiAgICBzd2l0Y2ggKGNoMCkge1xuICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG1zZyA9ICdQbGFpbiB2YWx1ZSBjYW5ub3Qgc3RhcnQgd2l0aCBhIHRhYiBjaGFyYWN0ZXInO1xuICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcih0aGlzLCBtc2cpXTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzLFxuICAgICAgICAgICAgc3RyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdAJzpcbiAgICAgIGNhc2UgJ2AnOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYFBsYWluIHZhbHVlIGNhbm5vdCBzdGFydCB3aXRoIHJlc2VydmVkIGNoYXJhY3RlciAke2NoMH1gO1xuICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU2VtYW50aWNFcnJvcih0aGlzLCBtc2cpXTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzLFxuICAgICAgICAgICAgc3RyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQmxvY2tWYWx1ZShzdGFydCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGVudCxcbiAgICAgIGluRmxvdyxcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuICAgIGxldCB2YWx1ZUVuZCA9IHN0YXJ0O1xuXG4gICAgZm9yIChsZXQgY2ggPSBzcmNbb2Zmc2V0XTsgY2ggPT09ICdcXG4nOyBjaCA9IHNyY1tvZmZzZXRdKSB7XG4gICAgICBpZiAoX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIG9mZnNldCArIDEpKSBicmVhaztcbiAgICAgIGNvbnN0IGVuZCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZkJsb2NrSW5kZW50KHNyYywgaW5kZW50LCBvZmZzZXQgKyAxKTtcbiAgICAgIGlmIChlbmQgPT09IG51bGwgfHwgc3JjW2VuZF0gPT09ICcjJykgYnJlYWs7XG5cbiAgICAgIGlmIChzcmNbZW5kXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVFbmQgPSBQbGFpblZhbHVlLmVuZE9mTGluZShzcmMsIGVuZCwgaW5GbG93KTtcbiAgICAgICAgb2Zmc2V0ID0gdmFsdWVFbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmFsdWVSYW5nZS5pc0VtcHR5KCkpIHRoaXMudmFsdWVSYW5nZS5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMudmFsdWVSYW5nZS5lbmQgPSB2YWx1ZUVuZDtcbiAgICByZXR1cm4gdmFsdWVFbmQ7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHBsYWluIHZhbHVlIGZyb20gdGhlIHNvdXJjZVxuICAgKlxuICAgKiBBY2NlcHRlZCBmb3JtcyBhcmU6XG4gICAqIGBgYFxuICAgKiAjY29tbWVudFxuICAgKlxuICAgKiBmaXJzdCBsaW5lXG4gICAqXG4gICAqIGZpcnN0IGxpbmUgI2NvbW1lbnRcbiAgICpcbiAgICogZmlyc3QgbGluZVxuICAgKiBibG9ja1xuICAgKiBsaW5lc1xuICAgKlxuICAgKiAjY29tbWVudFxuICAgKiBibG9ja1xuICAgKiBsaW5lc1xuICAgKiBgYGBcbiAgICogd2hlcmUgYmxvY2sgbGluZXMgYXJlIGVtcHR5IG9yIGhhdmUgYW4gaW5kZW50IGxldmVsIGdyZWF0ZXIgdGhhbiBgaW5kZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3QgY2hhcmFjdGVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzIHNjYWxhciwgbWF5IGJlIGBcXG5gXG4gICAqL1xuXG5cbiAgcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIGluRmxvdyxcbiAgICAgIHNyY1xuICAgIH0gPSBjb250ZXh0O1xuICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICBjb25zdCBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgaWYgKGNoICYmIGNoICE9PSAnIycgJiYgY2ggIT09ICdcXG4nKSB7XG4gICAgICBvZmZzZXQgPSBQbGFpblZhbHVlLmVuZE9mTGluZShzcmMsIHN0YXJ0LCBpbkZsb3cpO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgIG9mZnNldCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgIG9mZnNldCA9IHRoaXMucGFyc2VDb21tZW50KG9mZnNldCk7XG5cbiAgICBpZiAoIXRoaXMuaGFzQ29tbWVudCB8fCB0aGlzLnZhbHVlUmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQmxvY2tWYWx1ZShvZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxufVxuXG5jbGFzcyBRdW90ZURvdWJsZSBleHRlbmRzIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZSB7XG4gIHN0YXRpYyBlbmRPZlF1b3RlKHNyYywgb2Zmc2V0KSB7XG4gICAgbGV0IGNoID0gc3JjW29mZnNldF07XG5cbiAgICB3aGlsZSAoY2ggJiYgY2ggIT09ICdcIicpIHtcbiAgICAgIG9mZnNldCArPSBjaCA9PT0gJ1xcXFwnID8gMiA6IDE7XG4gICAgICBjaCA9IHNyY1tvZmZzZXRdO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgeyBzdHI6IHN0cmluZywgZXJyb3JzOiBZQU1MU3ludGF4RXJyb3JbXSB9fVxuICAgKi9cblxuXG4gIGdldCBzdHJWYWx1ZSgpIHtcbiAgICBpZiAoIXRoaXMudmFsdWVSYW5nZSB8fCAhdGhpcy5jb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gPSB0aGlzLnZhbHVlUmFuZ2U7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZW50LFxuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICBpZiAoc3JjW2VuZCAtIDFdICE9PSAnXCInKSBlcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU3ludGF4RXJyb3IodGhpcywgJ01pc3NpbmcgY2xvc2luZyBcInF1b3RlJykpOyAvLyBVc2luZyBTdHJpbmcjcmVwbGFjZSBpcyB0b28gcGFpbmZ1bCB3aXRoIGVzY2FwZWQgbmV3bGluZXMgcHJlY2VkZWQgYnlcbiAgICAvLyBlc2NhcGVkIGJhY2tzbGFzaGVzOyBhbHNvLCB0aGlzIHNob3VsZCBiZSBmYXN0ZXIuXG5cbiAgICBsZXQgc3RyID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQgKyAxOyBpIDwgZW5kIC0gMTsgKytpKSB7XG4gICAgICBjb25zdCBjaCA9IHNyY1tpXTtcblxuICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICBpZiAoX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIGkgKyAxKSkgZXJyb3JzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFNlbWFudGljRXJyb3IodGhpcywgJ0RvY3VtZW50IGJvdW5kYXJ5IGluZGljYXRvcnMgYXJlIG5vdCBhbGxvd2VkIHdpdGhpbiBzdHJpbmcgdmFsdWVzJykpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9sZCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5mb2xkTmV3bGluZShzcmMsIGksIGluZGVudCk7XG4gICAgICAgIHN0ciArPSBmb2xkO1xuICAgICAgICBpID0gb2Zmc2V0O1xuICAgICAgICBpZiAoZXJyb3IpIGVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKHRoaXMsICdNdWx0aS1saW5lIGRvdWJsZS1xdW90ZWQgc3RyaW5nIG5lZWRzIHRvIGJlIHN1ZmZpY2llbnRseSBpbmRlbnRlZCcpKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICBpICs9IDE7XG5cbiAgICAgICAgc3dpdGNoIChzcmNbaV0pIHtcbiAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFwwJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIG51bGwgY2hhcmFjdGVyXG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFx4MDcnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gYmVsbCBjaGFyYWN0ZXJcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gYmFja3NwYWNlXG5cbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFx4MWInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gZXNjYXBlIGNoYXJhY3RlclxuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcZic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBmb3JtIGZlZWRcblxuICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gbGluZSBmZWVkXG5cbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIGNhcnJpYWdlIHJldHVyblxuXG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBob3Jpem9udGFsIHRhYlxuXG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcdic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyB2ZXJ0aWNhbCB0YWJcblxuICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgc3RyICs9ICdcXHUwMDg1JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIFVuaWNvZGUgbmV4dCBsaW5lXG5cbiAgICAgICAgICBjYXNlICdfJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFx1MDBhMCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBVbmljb2RlIG5vbi1icmVha2luZyBzcGFjZVxuXG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcdTIwMjgnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gVW5pY29kZSBsaW5lIHNlcGFyYXRvclxuXG4gICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcdTIwMjknO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gVW5pY29kZSBwYXJhZ3JhcGggc2VwYXJhdG9yXG5cbiAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIHN0ciArPSAnICc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHN0ciArPSAnXCInO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgIHN0ciArPSAnLyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIHN0ciArPSAnXFx0JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBzdHIgKz0gdGhpcy5wYXJzZUNoYXJDb2RlKGkgKyAxLCAyLCBlcnJvcnMpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLnBhcnNlQ2hhckNvZGUoaSArIDEsIDQsIGVycm9ycyk7XG4gICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICAgICAgc3RyICs9IHRoaXMucGFyc2VDaGFyQ29kZShpICsgMSwgOCwgZXJyb3JzKTtcbiAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgIC8vIHNraXAgZXNjYXBlZCBuZXdsaW5lcywgYnV0IHN0aWxsIHRyaW0gdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgICAgICB3aGlsZSAoc3JjW2kgKyAxXSA9PT0gJyAnIHx8IHNyY1tpICsgMV0gPT09ICdcXHQnKSBpICs9IDE7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTeW50YXhFcnJvcih0aGlzLCBgSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgJHtzcmMuc3Vic3RyKGkgLSAxLCAyKX1gKSk7XG4gICAgICAgICAgICBzdHIgKz0gJ1xcXFwnICsgc3JjW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICBjb25zdCB3c1N0YXJ0ID0gaTtcbiAgICAgICAgbGV0IG5leHQgPSBzcmNbaSArIDFdO1xuXG4gICAgICAgIHdoaWxlIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgbmV4dCA9IHNyY1tpICsgMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCAhPT0gJ1xcbicpIHN0ciArPSBpID4gd3NTdGFydCA/IHNyYy5zbGljZSh3c1N0YXJ0LCBpICsgMSkgOiBjaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSBjaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA+IDAgPyB7XG4gICAgICBlcnJvcnMsXG4gICAgICBzdHJcbiAgICB9IDogc3RyO1xuICB9XG5cbiAgcGFyc2VDaGFyQ29kZShvZmZzZXQsIGxlbmd0aCwgZXJyb3JzKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBjYyA9IHNyYy5zdWJzdHIob2Zmc2V0LCBsZW5ndGgpO1xuICAgIGNvbnN0IG9rID0gY2MubGVuZ3RoID09PSBsZW5ndGggJiYgL15bMC05YS1mQS1GXSskLy50ZXN0KGNjKTtcbiAgICBjb25zdCBjb2RlID0gb2sgPyBwYXJzZUludChjYywgMTYpIDogTmFOO1xuXG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICBlcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU3ludGF4RXJyb3IodGhpcywgYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlICR7c3JjLnN1YnN0cihvZmZzZXQgLSAyLCBsZW5ndGggKyAyKX1gKSk7XG4gICAgICByZXR1cm4gc3JjLnN1YnN0cihvZmZzZXQgLSAyLCBsZW5ndGggKyAyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIFwiZG91YmxlIHF1b3RlZFwiIHZhbHVlIGZyb20gdGhlIHNvdXJjZVxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBjaGFyYWN0ZXJcbiAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXMgc2NhbGFyXG4gICAqL1xuXG5cbiAgcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIHNyY1xuICAgIH0gPSBjb250ZXh0O1xuICAgIGxldCBvZmZzZXQgPSBRdW90ZURvdWJsZS5lbmRPZlF1b3RlKHNyYywgc3RhcnQgKyAxKTtcbiAgICB0aGlzLnZhbHVlUmFuZ2UgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5SYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQ29tbWVudChvZmZzZXQpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxufVxuXG5jbGFzcyBRdW90ZVNpbmdsZSBleHRlbmRzIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZSB7XG4gIHN0YXRpYyBlbmRPZlF1b3RlKHNyYywgb2Zmc2V0KSB7XG4gICAgbGV0IGNoID0gc3JjW29mZnNldF07XG5cbiAgICB3aGlsZSAoY2gpIHtcbiAgICAgIGlmIChjaCA9PT0gXCInXCIpIHtcbiAgICAgICAgaWYgKHNyY1tvZmZzZXQgKyAxXSAhPT0gXCInXCIpIGJyZWFrO1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXQgKz0gMl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXQgKz0gMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIDE7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB7IHN0cjogc3RyaW5nLCBlcnJvcnM6IFlBTUxTeW50YXhFcnJvcltdIH19XG4gICAqL1xuXG5cbiAgZ2V0IHN0clZhbHVlKCkge1xuICAgIGlmICghdGhpcy52YWx1ZVJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSA9IHRoaXMudmFsdWVSYW5nZTtcbiAgICBjb25zdCB7XG4gICAgICBpbmRlbnQsXG4gICAgICBzcmNcbiAgICB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGlmIChzcmNbZW5kIC0gMV0gIT09IFwiJ1wiKSBlcnJvcnMucHVzaChuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MU3ludGF4RXJyb3IodGhpcywgXCJNaXNzaW5nIGNsb3NpbmcgJ3F1b3RlXCIpKTtcbiAgICBsZXQgc3RyID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQgKyAxOyBpIDwgZW5kIC0gMTsgKytpKSB7XG4gICAgICBjb25zdCBjaCA9IHNyY1tpXTtcblxuICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICBpZiAoX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIGkgKyAxKSkgZXJyb3JzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFNlbWFudGljRXJyb3IodGhpcywgJ0RvY3VtZW50IGJvdW5kYXJ5IGluZGljYXRvcnMgYXJlIG5vdCBhbGxvd2VkIHdpdGhpbiBzdHJpbmcgdmFsdWVzJykpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9sZCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5mb2xkTmV3bGluZShzcmMsIGksIGluZGVudCk7XG4gICAgICAgIHN0ciArPSBmb2xkO1xuICAgICAgICBpID0gb2Zmc2V0O1xuICAgICAgICBpZiAoZXJyb3IpIGVycm9ycy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxTZW1hbnRpY0Vycm9yKHRoaXMsICdNdWx0aS1saW5lIHNpbmdsZS1xdW90ZWQgc3RyaW5nIG5lZWRzIHRvIGJlIHN1ZmZpY2llbnRseSBpbmRlbnRlZCcpKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiJ1wiKSB7XG4gICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBpZiAoc3JjW2ldICE9PSBcIidcIikgZXJyb3JzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFN5bnRheEVycm9yKHRoaXMsICdVbmVzY2FwZWQgc2luZ2xlIHF1b3RlPyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLicpKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgLy8gdHJpbSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgIGNvbnN0IHdzU3RhcnQgPSBpO1xuICAgICAgICBsZXQgbmV4dCA9IHNyY1tpICsgMV07XG5cbiAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0Jykge1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBuZXh0ID0gc3JjW2kgKyAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ICE9PSAnXFxuJykgc3RyICs9IGkgPiB3c1N0YXJ0ID8gc3JjLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IGNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID4gMCA/IHtcbiAgICAgIGVycm9ycyxcbiAgICAgIHN0clxuICAgIH0gOiBzdHI7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhICdzaW5nbGUgcXVvdGVkJyB2YWx1ZSBmcm9tIHRoZSBzb3VyY2VcbiAgICpcbiAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3QgY2hhcmFjdGVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzIHNjYWxhclxuICAgKi9cblxuXG4gIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICBzcmNcbiAgICB9ID0gY29udGV4dDtcbiAgICBsZXQgb2Zmc2V0ID0gUXVvdGVTaW5nbGUuZW5kT2ZRdW90ZShzcmMsIHN0YXJ0ICsgMSk7XG4gICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuUmFuZ2Uoc3RhcnQsIG9mZnNldCk7XG4gICAgb2Zmc2V0ID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUNvbW1lbnQob2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlTmV3Tm9kZSh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5BTElBUzpcbiAgICAgIHJldHVybiBuZXcgQWxpYXModHlwZSwgcHJvcHMpO1xuXG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxPQ0tfRk9MREVEOlxuICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkJMT0NLX0xJVEVSQUw6XG4gICAgICByZXR1cm4gbmV3IEJsb2NrVmFsdWUodHlwZSwgcHJvcHMpO1xuXG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRkxPV19NQVA6XG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRkxPV19TRVE6XG4gICAgICByZXR1cm4gbmV3IEZsb3dDb2xsZWN0aW9uKHR5cGUsIHByb3BzKTtcblxuICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLk1BUF9LRVk6XG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuTUFQX1ZBTFVFOlxuICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlNFUV9JVEVNOlxuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uSXRlbSh0eXBlLCBwcm9wcyk7XG5cbiAgICBjYXNlIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5DT01NRU5UOlxuICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlBMQUlOOlxuICAgICAgcmV0dXJuIG5ldyBQbGFpblZhbHVlKHR5cGUsIHByb3BzKTtcblxuICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlFVT1RFX0RPVUJMRTpcbiAgICAgIHJldHVybiBuZXcgUXVvdGVEb3VibGUodHlwZSwgcHJvcHMpO1xuXG4gICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuUVVPVEVfU0lOR0xFOlxuICAgICAgcmV0dXJuIG5ldyBRdW90ZVNpbmdsZSh0eXBlLCBwcm9wcyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGF0TGluZVN0YXJ0IC0gTm9kZSBzdGFydHMgYXQgYmVnaW5uaW5nIG9mIGxpbmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5GbG93IC0gdHJ1ZSBpZiBjdXJyZW50bHkgaW4gYSBmbG93IGNvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5Db2xsZWN0aW9uIC0gdHJ1ZSBpZiBjdXJyZW50bHkgaW4gYSBjb2xsZWN0aW9uIGNvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRlbnQgLSBDdXJyZW50IGxldmVsIG9mIGluZGVudGF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbGluZVN0YXJ0IC0gU3RhcnQgb2YgdGhlIGN1cnJlbnQgbGluZVxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQgLSBUaGUgcGFyZW50IG9mIHRoZSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIC0gU291cmNlIG9mIHRoZSBZQU1MIGRvY3VtZW50XG4gKi9cblxuXG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICBzdGF0aWMgcGFyc2VUeXBlKHNyYywgb2Zmc2V0LCBpbkZsb3cpIHtcbiAgICBzd2l0Y2ggKHNyY1tvZmZzZXRdKSB7XG4gICAgICBjYXNlICcqJzpcbiAgICAgICAgcmV0dXJuIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5BTElBUztcblxuICAgICAgY2FzZSAnPic6XG4gICAgICAgIHJldHVybiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxPQ0tfRk9MREVEO1xuXG4gICAgICBjYXNlICd8JzpcbiAgICAgICAgcmV0dXJuIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5CTE9DS19MSVRFUkFMO1xuXG4gICAgICBjYXNlICd7JzpcbiAgICAgICAgcmV0dXJuIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5GTE9XX01BUDtcblxuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIHJldHVybiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRkxPV19TRVE7XG5cbiAgICAgIGNhc2UgJz8nOlxuICAgICAgICByZXR1cm4gIWluRmxvdyAmJiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuYXRCbGFuayhzcmMsIG9mZnNldCArIDEsIHRydWUpID8gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLk1BUF9LRVkgOiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuUExBSU47XG5cbiAgICAgIGNhc2UgJzonOlxuICAgICAgICByZXR1cm4gIWluRmxvdyAmJiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuYXRCbGFuayhzcmMsIG9mZnNldCArIDEsIHRydWUpID8gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLk1BUF9WQUxVRSA6IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5QTEFJTjtcblxuICAgICAgY2FzZSAnLSc6XG4gICAgICAgIHJldHVybiAhaW5GbG93ICYmIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5hdEJsYW5rKHNyYywgb2Zmc2V0ICsgMSwgdHJ1ZSkgPyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuU0VRX0lURU0gOiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuUExBSU47XG5cbiAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgcmV0dXJuIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5RVU9URV9ET1VCTEU7XG5cbiAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgIHJldHVybiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuUVVPVEVfU0lOR0xFO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlBMQUlOO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9yaWcgPSB7fSwge1xuICAgIGF0TGluZVN0YXJ0LFxuICAgIGluQ29sbGVjdGlvbixcbiAgICBpbkZsb3csXG4gICAgaW5kZW50LFxuICAgIGxpbmVTdGFydCxcbiAgICBwYXJlbnRcbiAgfSA9IHt9KSB7XG4gICAgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJzZU5vZGVcIiwgKG92ZXJsYXksIHN0YXJ0KSA9PiB7XG4gICAgICBpZiAoX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmF0RG9jdW1lbnRCb3VuZGFyeSh0aGlzLnNyYywgc3RhcnQpKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG92ZXJsYXkpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmFsdWVTdGFydFxuICAgICAgfSA9IGNvbnRleHQucGFyc2VQcm9wcyhzdGFydCk7XG4gICAgICBjb25zdCBub2RlID0gY3JlYXRlTmV3Tm9kZSh0eXBlLCBwcm9wcyk7XG4gICAgICBsZXQgb2Zmc2V0ID0gbm9kZS5wYXJzZShjb250ZXh0LCB2YWx1ZVN0YXJ0KTtcbiAgICAgIG5vZGUucmFuZ2UgPSBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5SYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IHN0YXJ0KSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMsIGxldCdzIG1ha2Ugc3VyZSB0byBhdCBsZWFzdFxuICAgICAgICAvLyBzdGVwIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZCB0byBhdm9pZCBhIGJ1c3kgbG9vcC5cbiAgICAgICAgbm9kZS5lcnJvciA9IG5ldyBFcnJvcihgTm9kZSNwYXJzZSBjb25zdW1lZCBubyBjaGFyYWN0ZXJzYCk7XG4gICAgICAgIG5vZGUuZXJyb3IucGFyc2VFbmQgPSBvZmZzZXQ7XG4gICAgICAgIG5vZGUuZXJyb3Iuc291cmNlID0gbm9kZTtcbiAgICAgICAgbm9kZS5yYW5nZS5lbmQgPSBzdGFydCArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZXh0Lm5vZGVTdGFydHNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgIGlmICghbm9kZS5lcnJvciAmJiAhY29udGV4dC5hdExpbmVTdGFydCAmJiBjb250ZXh0LnBhcmVudC50eXBlID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRE9DVU1FTlQpIHtcbiAgICAgICAgICBub2RlLmVycm9yID0gbmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuWUFNTFN5bnRheEVycm9yKG5vZGUsICdCbG9jayBjb2xsZWN0aW9uIG11c3Qgbm90IGhhdmUgcHJlY2VkaW5nIGNvbnRlbnQgaGVyZSAoZS5nLiBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24obm9kZSk7XG4gICAgICAgIG9mZnNldCA9IGNvbGxlY3Rpb24ucGFyc2UobmV3IFBhcnNlQ29udGV4dChjb250ZXh0KSwgb2Zmc2V0KTtcbiAgICAgICAgY29sbGVjdGlvbi5yYW5nZSA9IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG5cbiAgICB0aGlzLmF0TGluZVN0YXJ0ID0gYXRMaW5lU3RhcnQgIT0gbnVsbCA/IGF0TGluZVN0YXJ0IDogb3JpZy5hdExpbmVTdGFydCB8fCBmYWxzZTtcbiAgICB0aGlzLmluQ29sbGVjdGlvbiA9IGluQ29sbGVjdGlvbiAhPSBudWxsID8gaW5Db2xsZWN0aW9uIDogb3JpZy5pbkNvbGxlY3Rpb24gfHwgZmFsc2U7XG4gICAgdGhpcy5pbkZsb3cgPSBpbkZsb3cgIT0gbnVsbCA/IGluRmxvdyA6IG9yaWcuaW5GbG93IHx8IGZhbHNlO1xuICAgIHRoaXMuaW5kZW50ID0gaW5kZW50ICE9IG51bGwgPyBpbmRlbnQgOiBvcmlnLmluZGVudDtcbiAgICB0aGlzLmxpbmVTdGFydCA9IGxpbmVTdGFydCAhPSBudWxsID8gbGluZVN0YXJ0IDogb3JpZy5saW5lU3RhcnQ7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgIT0gbnVsbCA/IHBhcmVudCA6IG9yaWcucGFyZW50IHx8IHt9O1xuICAgIHRoaXMucm9vdCA9IG9yaWcucm9vdDtcbiAgICB0aGlzLnNyYyA9IG9yaWcuc3JjO1xuICB9XG5cbiAgbm9kZVN0YXJ0c0NvbGxlY3Rpb24obm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluQ29sbGVjdGlvbixcbiAgICAgIGluRmxvdyxcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChpbkNvbGxlY3Rpb24gfHwgaW5GbG93KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uSXRlbSkgcmV0dXJuIHRydWU7IC8vIGNoZWNrIGZvciBpbXBsaWNpdCBrZXlcblxuICAgIGxldCBvZmZzZXQgPSBub2RlLnJhbmdlLmVuZDtcbiAgICBpZiAoc3JjW29mZnNldF0gPT09ICdcXG4nIHx8IHNyY1tvZmZzZXQgLSAxXSA9PT0gJ1xcbicpIHJldHVybiBmYWxzZTtcbiAgICBvZmZzZXQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICByZXR1cm4gc3JjW29mZnNldF0gPT09ICc6JztcbiAgfSAvLyBBbmNob3IgYW5kIHRhZyBhcmUgYmVmb3JlIHR5cGUsIHdoaWNoIGRldGVybWluZXMgdGhlIG5vZGUgaW1wbGVtZW50YXRpb25cbiAgLy8gY2xhc3M7IGhlbmNlIHRoaXMgaW50ZXJtZWRpYXRlIHN0ZXAuXG5cblxuICBwYXJzZVByb3BzKG9mZnNldCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluRmxvdyxcbiAgICAgIHBhcmVudCxcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgbGV0IGxpbmVIYXNQcm9wcyA9IGZhbHNlO1xuICAgIG9mZnNldCA9IHRoaXMuYXRMaW5lU3RhcnQgPyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZJbmRlbnQoc3JjLCBvZmZzZXQpIDogX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5Ob2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gICAgbGV0IGNoID0gc3JjW29mZnNldF07XG5cbiAgICB3aGlsZSAoY2ggPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuQ2hhci5BTkNIT1IgfHwgY2ggPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuQ2hhci5DT01NRU5UIHx8IGNoID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLkNoYXIuVEFHIHx8IGNoID09PSAnXFxuJykge1xuICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICBjb25zdCBsaW5lU3RhcnQgPSBvZmZzZXQgKyAxO1xuICAgICAgICBjb25zdCBpbkVuZCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZkluZGVudChzcmMsIGxpbmVTdGFydCk7XG4gICAgICAgIGNvbnN0IGluZGVudERpZmYgPSBpbkVuZCAtIChsaW5lU3RhcnQgKyB0aGlzLmluZGVudCk7XG4gICAgICAgIGNvbnN0IG5vSW5kaWNhdG9yQXNJbmRlbnQgPSBwYXJlbnQudHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlNFUV9JVEVNICYmIHBhcmVudC5jb250ZXh0LmF0TGluZVN0YXJ0O1xuICAgICAgICBpZiAoIV9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5uZXh0Tm9kZUlzSW5kZW50ZWQoc3JjW2luRW5kXSwgaW5kZW50RGlmZiwgIW5vSW5kaWNhdG9yQXNJbmRlbnQpKSBicmVhaztcbiAgICAgICAgdGhpcy5hdExpbmVTdGFydCA9IHRydWU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBsaW5lSGFzUHJvcHMgPSBmYWxzZTtcbiAgICAgICAgb2Zmc2V0ID0gaW5FbmQ7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLkNoYXIuQ09NTUVOVCkge1xuICAgICAgICBjb25zdCBlbmQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZMaW5lKHNyYywgb2Zmc2V0ICsgMSk7XG4gICAgICAgIHByb3BzLnB1c2gobmV3IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuUmFuZ2Uob2Zmc2V0LCBlbmQpKTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVuZCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZklkZW50aWZpZXIoc3JjLCBvZmZzZXQgKyAxKTtcblxuICAgICAgICBpZiAoY2ggPT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuQ2hhci5UQUcgJiYgc3JjW2VuZF0gPT09ICcsJyAmJiAvXlthLXpBLVowLTktXStcXC5bYS16QS1aMC05LV0rLFxcZFxcZFxcZFxcZCgtXFxkXFxkKXswLDJ9XFwvXFxTLy50ZXN0KHNyYy5zbGljZShvZmZzZXQgKyAxLCBlbmQgKyAxMykpKSB7XG4gICAgICAgICAgLy8gTGV0J3MgcHJlc3VtZSB3ZSdyZSBkZWFsaW5nIHdpdGggYSBZQU1MIDEuMCBkb21haW4gdGFnIGhlcmUsIHJhdGhlclxuICAgICAgICAgIC8vIHRoYW4gYW4gZW1wdHkgYnV0ICdmb28uYmFyJyBwcml2YXRlLXRhZ2dlZCBub2RlIGluIGEgZmxvdyBjb2xsZWN0aW9uXG4gICAgICAgICAgLy8gZm9sbG93ZWQgd2l0aG91dCB3aGl0ZXNwYWNlIGJ5IGEgcGxhaW4gc3RyaW5nIHN0YXJ0aW5nIHdpdGggYSB5ZWFyXG4gICAgICAgICAgLy8gb3IgZGF0ZSBkaXZpZGVkIGJ5IHNvbWV0aGluZy5cbiAgICAgICAgICBlbmQgPSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLk5vZGUuZW5kT2ZJZGVudGlmaWVyKHNyYywgZW5kICsgNSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcy5wdXNoKG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlJhbmdlKG9mZnNldCwgZW5kKSk7XG4gICAgICAgIGxpbmVIYXNQcm9wcyA9IHRydWU7XG4gICAgICAgIG9mZnNldCA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBlbmQpO1xuICAgICAgfVxuXG4gICAgICBjaCA9IHNyY1tvZmZzZXRdO1xuICAgIH0gLy8gJy0gJmEgOiBiJyBoYXMgYW4gYW5jaG9yIG9uIGFuIGVtcHR5IG5vZGVcblxuXG4gICAgaWYgKGxpbmVIYXNQcm9wcyAmJiBjaCA9PT0gJzonICYmIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuTm9kZS5hdEJsYW5rKHNyYywgb2Zmc2V0ICsgMSwgdHJ1ZSkpIG9mZnNldCAtPSAxO1xuICAgIGNvbnN0IHR5cGUgPSBQYXJzZUNvbnRleHQucGFyc2VUeXBlKHNyYywgb2Zmc2V0LCBpbkZsb3cpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wcyxcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZVN0YXJ0OiBvZmZzZXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBub2RlIGZyb20gdGhlIHNvdXJjZVxuICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gb3ZlcmxheVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIgZm9yIHRoZSBub2RlXG4gICAqIEByZXR1cm5zIHs/Tm9kZX0gLSBudWxsIGlmIGF0IGEgZG9jdW1lbnQgYm91bmRhcnlcbiAgICovXG5cblxufVxuXG4vLyBQdWJsaXNoZWQgYXMgJ3lhbWwvcGFyc2UtY3N0J1xuZnVuY3Rpb24gcGFyc2Uoc3JjKSB7XG4gIGNvbnN0IGNyID0gW107XG5cbiAgaWYgKHNyYy5pbmRleE9mKCdcXHInKSAhPT0gLTEpIHtcbiAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFxyXFxuPy9nLCAobWF0Y2gsIG9mZnNldCkgPT4ge1xuICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEpIGNyLnB1c2gob2Zmc2V0KTtcbiAgICAgIHJldHVybiAnXFxuJztcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGRvY3VtZW50cyA9IFtdO1xuICBsZXQgb2Zmc2V0ID0gMDtcblxuICBkbyB7XG4gICAgY29uc3QgZG9jID0gbmV3IERvY3VtZW50KCk7XG4gICAgY29uc3QgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQoe1xuICAgICAgc3JjXG4gICAgfSk7XG4gICAgb2Zmc2V0ID0gZG9jLnBhcnNlKGNvbnRleHQsIG9mZnNldCk7XG4gICAgZG9jdW1lbnRzLnB1c2goZG9jKTtcbiAgfSB3aGlsZSAob2Zmc2V0IDwgc3JjLmxlbmd0aCk7XG5cbiAgZG9jdW1lbnRzLnNldE9yaWdSYW5nZXMgPSAoKSA9PiB7XG4gICAgaWYgKGNyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjci5sZW5ndGg7ICsraSkgY3JbaV0gLT0gaTtcblxuICAgIGxldCBjck9mZnNldCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvY3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgY3JPZmZzZXQgPSBkb2N1bWVudHNbaV0uc2V0T3JpZ1JhbmdlcyhjciwgY3JPZmZzZXQpO1xuICAgIH1cblxuICAgIGNyLnNwbGljZSgwLCBjci5sZW5ndGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGRvY3VtZW50cy50b1N0cmluZyA9ICgpID0+IGRvY3VtZW50cy5qb2luKCcuLi5cXG4nKTtcblxuICByZXR1cm4gZG9jdW1lbnRzO1xufVxuXG5leHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQ7XG5leHBvcnRzLlBsYWluVmFsdWUgPSBQbGFpblZhbHVlO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuIl0sIm5hbWVzIjpbIl9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMiLCJyZXF1aXJlIiwiQmxhbmtMaW5lIiwiTm9kZSIsImNvbnN0cnVjdG9yIiwiVHlwZSIsIkJMQU5LX0xJTkUiLCJpbmNsdWRlc1RyYWlsaW5nTGluZXMiLCJwYXJzZSIsImNvbnRleHQiLCJzdGFydCIsInJhbmdlIiwiUmFuZ2UiLCJDb2xsZWN0aW9uSXRlbSIsInR5cGUiLCJwcm9wcyIsIm5vZGUiLCJwYXJzZU5vZGUiLCJzcmMiLCJhdExpbmVTdGFydCIsImxpbmVTdGFydCIsIlNFUV9JVEVNIiwiZXJyb3IiLCJZQU1MU2VtYW50aWNFcnJvciIsImluZGVudCIsIm9mZnNldCIsImVuZE9mV2hpdGVTcGFjZSIsImNoIiwiaW5saW5lQ29tbWVudCIsImNvbW1lbnRzIiwiYmxhbmtMaW5lIiwiZW5kIiwiZW5kT2ZMaW5lIiwicHVzaCIsIndzRW5kIiwibGVuZ3RoIiwiZW5kT2ZJbmRlbnQiLCJuZXh0Tm9kZUlzSW5kZW50ZWQiLCJpbkNvbGxlY3Rpb24iLCJwYXJlbnQiLCJpdGVtcyIsImNvbnRlbnRzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsImMiLCJ2YWx1ZVJhbmdlIiwic2V0T3JpZ1JhbmdlcyIsImNyIiwidG9TdHJpbmciLCJ2YWx1ZSIsInN0ciIsInNsaWNlIiwiU3RyaW5nIiwiYWRkU3RyaW5nVGVybWluYXRvciIsIkNvbW1lbnQiLCJDT01NRU5UIiwicGFyc2VDb21tZW50IiwiZ3JhYkNvbGxlY3Rpb25FbmRDb21tZW50cyIsImNub2RlIiwiQ29sbGVjdGlvbiIsImxlbiIsImNpIiwiaSIsIm4iLCJjYSIsInNwbGljZSIsInByZXZFbmQiLCJuZXh0Q29udGVudEhhc0luZGVudCIsImZpcnN0SXRlbSIsIlNFUSIsIk1BUCIsIml0ZW1SYW5nZSIsImVjIiwic3RhcnRPZkxpbmUiLCJjb3B5Iiwibm9ybWFsaXplT2Zmc2V0IiwicHJldkluY2x1ZGVzVHJhaWxpbmdMaW5lcyIsImNvbW1lbnQiLCJhdEJsYW5rIiwibmV4dCIsIm1zZyIsIllBTUxTeW50YXhFcnJvciIsImxzIiwicHJldiIsImZvckVhY2giLCJpdGVtIiwiRGlyZWN0aXZlIiwiRElSRUNUSVZFIiwibmFtZSIsInBhcmFtZXRlcnMiLCJyYXciLCJyYXdWYWx1ZSIsInRyaW0iLCJzcGxpdCIsInBhcnNlTmFtZSIsInBhcnNlUGFyYW1ldGVycyIsIkRvY3VtZW50Iiwic3RhcnRDb21tZW50T3JFbmRCbGFua0xpbmUiLCJET0NVTUVOVCIsImRpcmVjdGl2ZXMiLCJkaXJlY3RpdmVzRW5kTWFya2VyIiwiZG9jdW1lbnRFbmRNYXJrZXIiLCJwYXJzZURpcmVjdGl2ZXMiLCJoYXNEaXJlY3RpdmVzIiwiYXREb2N1bWVudEJvdW5kYXJ5IiwiQ2hhciIsIkRJUkVDVElWRVNfRU5EIiwiZGlyZWN0aXZlIiwicGFyc2VDb250ZW50cyIsIkRPQ1VNRU5UX0VORCIsImlFbmQiLCJpbkZsb3ciLCJ1bmRlZmluZWQiLCJyb290IiwiY2hhckNvZGVBdCIsInNldE9yaWdSYW5nZSIsImpvaW4iLCJBbGlhcyIsImVuZE9mSWRlbnRpZmllciIsIkNob21wIiwiQ0xJUCIsIktFRVAiLCJTVFJJUCIsIkJsb2NrVmFsdWUiLCJibG9ja0luZGVudCIsImNob21waW5nIiwiaGVhZGVyIiwic3RyVmFsdWUiLCJpc0VtcHR5IiwibGFzdE5ld0xpbmUiLCJrZWVwU3RhcnQiLCJiaSIsImZvbGRlZCIsIkJMT0NLX0ZPTERFRCIsImF0U3RhcnQiLCJzZXAiLCJwcmV2TW9yZUluZGVudGVkIiwiaiIsImxpbmVFbmQiLCJsaW5lIiwicGFyc2VCbG9ja0hlYWRlciIsIk51bWJlciIsInBhcnNlQmxvY2tWYWx1ZSIsImV4cGxpY2l0IiwidmFsdWVFbmQiLCJtaW5CbG9ja0luZGVudCIsImVuZE9mQmxvY2tJbmRlbnQiLCJsaW5lSW5kZW50IiwiRmxvd0NvbGxlY3Rpb24iLCJwcmV2Tm9kZUlzSnNvbkxpa2UiLCJpZHgiLCJqc29uTGlrZSIsImNoYXIiLCJvcmlnT2Zmc2V0Iiwibm9kZXMiLCJmaWx0ZXIiLCJwcmVmaXgiLCJQbGFpblZhbHVlIiwiZm9sZCIsImZvbGROZXdsaW5lIiwid3NTdGFydCIsImNoMCIsImVycm9ycyIsImhhc0NvbW1lbnQiLCJRdW90ZURvdWJsZSIsImVuZE9mUXVvdGUiLCJwYXJzZUNoYXJDb2RlIiwic3Vic3RyIiwiY2MiLCJvayIsInRlc3QiLCJjb2RlIiwicGFyc2VJbnQiLCJOYU4iLCJpc05hTiIsImZyb21Db2RlUG9pbnQiLCJRdW90ZVNpbmdsZSIsImNyZWF0ZU5ld05vZGUiLCJBTElBUyIsIkJMT0NLX0xJVEVSQUwiLCJGTE9XX01BUCIsIkZMT1dfU0VRIiwiTUFQX0tFWSIsIk1BUF9WQUxVRSIsIlBMQUlOIiwiUVVPVEVfRE9VQkxFIiwiUVVPVEVfU0lOR0xFIiwiUGFyc2VDb250ZXh0IiwicGFyc2VUeXBlIiwib3JpZyIsIl9kZWZpbmVQcm9wZXJ0eSIsIm92ZXJsYXkiLCJ2YWx1ZVN0YXJ0IiwicGFyc2VQcm9wcyIsIkVycm9yIiwicGFyc2VFbmQiLCJzb3VyY2UiLCJub2RlU3RhcnRzQ29sbGVjdGlvbiIsImNvbGxlY3Rpb24iLCJsaW5lSGFzUHJvcHMiLCJBTkNIT1IiLCJUQUciLCJpbkVuZCIsImluZGVudERpZmYiLCJub0luZGljYXRvckFzSW5kZW50IiwiaW5kZXhPZiIsInJlcGxhY2UiLCJtYXRjaCIsImRvY3VtZW50cyIsImRvYyIsImNyT2Zmc2V0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/parse-3997f544.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/stringifyNumber-dea1120c.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/swagger-jsdoc/node_modules/yaml/dist/stringifyNumber-dea1120c.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar _rollupPluginBabelHelpers = __webpack_require__(/*! ./_rollupPluginBabelHelpers-eed30217.js */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/_rollupPluginBabelHelpers-eed30217.js\");\nfunction addCommentBefore(str, indent, comment) {\n    if (!comment) return str;\n    const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n    return `#${cc}\\n${indent}${str}`;\n}\nfunction addComment(str, indent, comment) {\n    return !comment ? str : comment.indexOf(\"\\n\") === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || \"\"}#`);\n}\nclass Node {\n}\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param {string|null} arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */ function toJS(value, arg, ctx) {\n    if (Array.isArray(value)) return value.map((v, i)=>toJS(v, String(i), ctx));\n    if (value && typeof value.toJSON === \"function\") {\n        const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n        if (anchor) ctx.onCreate = (res)=>{\n            anchor.res = res;\n            delete ctx.onCreate;\n        };\n        const res = value.toJSON(arg, ctx);\n        if (anchor && ctx.onCreate) ctx.onCreate(res);\n        return res;\n    }\n    if (!(ctx && ctx.keep) && typeof value === \"bigint\") return Number(value);\n    return value;\n}\nconst isScalarValue = (value)=>!value || typeof value !== \"function\" && typeof value !== \"object\";\nclass Scalar extends Node {\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    toJSON(arg, ctx) {\n        return ctx && ctx.keep ? this.value : toJS(this.value, arg, ctx);\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter((t)=>t.tag === tagName);\n        const tagObj = match.find((t)=>!t.format) || match[0];\n        if (!tagObj) throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find((t)=>t.identify && t.identify(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (value instanceof Node) return value;\n    const { onAlias, onTagObj, prevObjects, wrapScalars } = ctx;\n    const { map, seq, tags } = ctx.schema;\n    if (tagName && tagName.startsWith(\"!!\")) tagName = _rollupPluginBabelHelpers.defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, tags);\n    if (!tagObj) {\n        if (typeof value.toJSON === \"function\") value = value.toJSON();\n        if (!value || typeof value !== \"object\") return wrapScalars ? new Scalar(value) : value;\n        tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    } // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `obj` wrapper allows for circular references to resolve.\n    const obj = {\n        value: undefined,\n        node: undefined\n    };\n    if (value && typeof value === \"object\") {\n        const prev = prevObjects.get(value);\n        if (prev) return onAlias(prev);\n        obj.value = value;\n        prevObjects.set(value, obj);\n    }\n    obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new Scalar(value) : value;\n    if (tagName && obj.node instanceof Node) obj.node.tag = tagName;\n    return obj.node;\n}\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for(let i = path.length - 1; i >= 0; --i){\n        const k = path[i];\n        if (Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        } else {\n            const o = {};\n            Object.defineProperty(o, k, {\n                value: v,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n            v = o;\n        }\n    }\n    return createNode(v, null, {\n        onAlias () {\n            throw new Error(\"Repeated objects are not supported here\");\n        },\n        prevObjects: new Map(),\n        schema,\n        wrapScalars: false\n    });\n} // null, undefined, or an empty non-string iterable (e.g. [])\nconst isEmptyPath = (path)=>path == null || typeof path === \"object\" && path[Symbol.iterator]().next().done;\nclass Collection extends Node {\n    constructor(schema){\n        super();\n        _rollupPluginBabelHelpers._defineProperty(this, \"items\", []);\n        this.schema = schema;\n    }\n    addIn(path, value) {\n        if (isEmptyPath(path)) this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (node instanceof Collection) node.addIn(rest, value);\n            else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));\n            else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    deleteIn([key, ...rest]) {\n        if (rest.length === 0) return this.delete(key);\n        const node = this.get(key, true);\n        if (node instanceof Collection) return node.deleteIn(rest);\n        else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    getIn([key, ...rest], keepScalar) {\n        const node = this.get(key, true);\n        if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;\n        else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues() {\n        return this.items.every((node)=>{\n            if (!node || node.type !== \"PAIR\") return false;\n            const n = node.value;\n            return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n        });\n    }\n    hasIn([key, ...rest]) {\n        if (rest.length === 0) return this.has(key);\n        const node = this.get(key, true);\n        return node instanceof Collection ? node.hasIn(rest) : false;\n    }\n    setIn([key, ...rest], value) {\n        if (rest.length === 0) {\n            this.set(key, value);\n        } else {\n            const node = this.get(key, true);\n            if (node instanceof Collection) node.setIn(rest, value);\n            else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));\n            else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /* istanbul ignore next: overridden in implementations */ toJSON() {\n        return null;\n    }\n    toString(ctx, { blockItem, flowChars, isMap, itemIndent }, onComment, onChompKeep) {\n        const { indent, indentStep, stringify } = ctx;\n        const inFlow = this.type === _rollupPluginBabelHelpers.Type.FLOW_MAP || this.type === _rollupPluginBabelHelpers.Type.FLOW_SEQ || ctx.inFlow;\n        if (inFlow) itemIndent += indentStep;\n        const allNullValues = isMap && this.hasAllNullValues();\n        ctx = Object.assign({}, ctx, {\n            allNullValues,\n            indent: itemIndent,\n            inFlow,\n            type: null\n        });\n        let chompKeep = false;\n        let hasItemWithNewLine = false;\n        const nodes = this.items.reduce((nodes, item, i)=>{\n            let comment;\n            if (item) {\n                if (!chompKeep && item.spaceBefore) nodes.push({\n                    type: \"comment\",\n                    str: \"\"\n                });\n                if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach((line)=>{\n                    nodes.push({\n                        type: \"comment\",\n                        str: `#${line}`\n                    });\n                });\n                if (item.comment) comment = item.comment;\n                if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n            }\n            chompKeep = false;\n            let str = stringify(item, ctx, ()=>comment = null, ()=>chompKeep = true);\n            if (inFlow && !hasItemWithNewLine && str.includes(\"\\n\")) hasItemWithNewLine = true;\n            if (inFlow && i < this.items.length - 1) str += \",\";\n            str = addComment(str, itemIndent, comment);\n            if (chompKeep && (comment || inFlow)) chompKeep = false;\n            nodes.push({\n                type: \"item\",\n                str\n            });\n            return nodes;\n        }, []);\n        let str;\n        if (nodes.length === 0) {\n            str = flowChars.start + flowChars.end;\n        } else if (inFlow) {\n            const { start, end } = flowChars;\n            const strings = nodes.map((n)=>n.str);\n            if (hasItemWithNewLine || strings.reduce((sum, str)=>sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n                str = start;\n                for (const s of strings){\n                    str += s ? `\\n${indentStep}${indent}${s}` : \"\\n\";\n                }\n                str += `\\n${indent}${end}`;\n            } else {\n                str = `${start} ${strings.join(\" \")} ${end}`;\n            }\n        } else {\n            const strings = nodes.map(blockItem);\n            str = strings.shift();\n            for (const s of strings)str += s ? `\\n${indent}${s}` : \"\\n\";\n        }\n        if (this.comment) {\n            str += \"\\n\" + this.comment.replace(/^/gm, `${indent}#`);\n            if (onComment) onComment();\n        } else if (chompKeep && onChompKeep) onChompKeep();\n        return str;\n    }\n}\n_rollupPluginBabelHelpers._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\nfunction asItemIndex(key) {\n    let idx = key instanceof Scalar ? key.value : key;\n    if (idx && typeof idx === \"string\") idx = Number(idx);\n    return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\nclass YAMLSeq extends Collection {\n    add(value) {\n        this.items.push(value);\n    }\n    delete(key) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== \"number\") return false;\n        const del = this.items.splice(idx, 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== \"number\") return undefined;\n        const it = this.items[idx];\n        return !keepScalar && it instanceof Scalar ? it.value : it;\n    }\n    has(key) {\n        const idx = asItemIndex(key);\n        return typeof idx === \"number\" && idx < this.items.length;\n    }\n    set(key, value) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== \"number\") throw new Error(`Expected a valid index, not ${key}.`);\n        const prev = this.items[idx];\n        if (prev instanceof Scalar && isScalarValue(value)) prev.value = value;\n        else this.items[idx] = value;\n    }\n    toJSON(_, ctx) {\n        const seq = [];\n        if (ctx && ctx.onCreate) ctx.onCreate(seq);\n        let i = 0;\n        for (const item of this.items)seq.push(toJS(item, String(i++), ctx));\n        return seq;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx) return JSON.stringify(this);\n        return super.toString(ctx, {\n            blockItem: (n)=>n.type === \"comment\" ? n.str : `- ${n.str}`,\n            flowChars: {\n                start: \"[\",\n                end: \"]\"\n            },\n            isMap: false,\n            itemIndent: (ctx.indent || \"\") + \"  \"\n        }, onComment, onChompKeep);\n    }\n}\nconst stringifyKey = (key, jsKey, ctx)=>{\n    if (jsKey === null) return \"\";\n    if (typeof jsKey !== \"object\") return String(jsKey);\n    if (key instanceof Node && ctx && ctx.doc) return key.toString({\n        anchors: Object.create(null),\n        doc: ctx.doc,\n        indent: \"\",\n        indentStep: ctx.indentStep,\n        inFlow: true,\n        inStringifyKey: true,\n        stringify: ctx.stringify\n    });\n    return JSON.stringify(jsKey);\n};\nfunction createPair(key, value, ctx) {\n    const k = createNode(key, null, ctx);\n    const v = createNode(value, null, ctx);\n    return new Pair(k, v);\n}\nclass Pair extends Node {\n    constructor(key, value = null){\n        super();\n        this.key = key;\n        this.value = value;\n        this.type = Pair.Type.PAIR;\n    }\n    get commentBefore() {\n        return this.key instanceof Node ? this.key.commentBefore : undefined;\n    }\n    set commentBefore(cb) {\n        if (this.key == null) this.key = new Scalar(null);\n        if (this.key instanceof Node) this.key.commentBefore = cb;\n        else {\n            const msg = \"Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.\";\n            throw new Error(msg);\n        }\n    }\n    addToJSMap(ctx, map) {\n        const key = toJS(this.key, \"\", ctx);\n        if (map instanceof Map) {\n            const value = toJS(this.value, key, ctx);\n            map.set(key, value);\n        } else if (map instanceof Set) {\n            map.add(key);\n        } else {\n            const stringKey = stringifyKey(this.key, key, ctx);\n            const value = toJS(this.value, stringKey, ctx);\n            if (stringKey in map) Object.defineProperty(map, stringKey, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n            else map[stringKey] = value;\n        }\n        return map;\n    }\n    toJSON(_, ctx) {\n        const pair = ctx && ctx.mapAsMap ? new Map() : {};\n        return this.addToJSMap(ctx, pair);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx || !ctx.doc) return JSON.stringify(this);\n        const { indent: indentSize, indentSeq, simpleKeys } = ctx.doc.options;\n        let { key, value } = this;\n        let keyComment = key instanceof Node && key.comment;\n        if (simpleKeys) {\n            if (keyComment) {\n                throw new Error(\"With simple keys, key nodes cannot have comments\");\n            }\n            if (key instanceof Collection) {\n                const msg = \"With simple keys, collection cannot be used as a key value\";\n                throw new Error(msg);\n            }\n        }\n        let explicitKey = !simpleKeys && (!key || keyComment || key instanceof Collection || key.type === _rollupPluginBabelHelpers.Type.BLOCK_FOLDED || key.type === _rollupPluginBabelHelpers.Type.BLOCK_LITERAL);\n        const { allNullValues, doc, indent, indentStep, stringify } = ctx;\n        ctx = Object.assign({}, ctx, {\n            implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n            indent: indent + indentStep\n        });\n        let chompKeep = false;\n        let str = stringify(key, ctx, ()=>keyComment = null, ()=>chompKeep = true);\n        str = addComment(str, ctx.indent, keyComment);\n        if (allNullValues && !simpleKeys) {\n            if (this.comment) {\n                str = addComment(str, ctx.indent, this.comment);\n                if (onComment) onComment();\n            } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n            return ctx.inFlow ? str : `? ${str}`;\n        }\n        if (!explicitKey && str.length > 1024) {\n            if (!simpleKeys) {\n                explicitKey = true;\n            } else {\n                const msg = \"With simple keys, single line scalar must not span more than 1024 characters\";\n                throw new Error(msg);\n            }\n        }\n        str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n        if (this.comment) {\n            // expected (but not strictly required) to be a single-line comment\n            str = addComment(str, ctx.indent, this.comment);\n            if (onComment) onComment();\n        }\n        let vcb = \"\";\n        let valueComment = null;\n        if (value instanceof Node) {\n            if (value.spaceBefore) vcb = \"\\n\";\n            if (value.commentBefore) {\n                const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n                vcb += `\\n${cs}`;\n            }\n            valueComment = value.comment;\n        } else if (value && typeof value === \"object\") {\n            value = doc.createNode(value);\n        }\n        ctx.implicitKey = false;\n        if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n        chompKeep = false;\n        if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== _rollupPluginBabelHelpers.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n            // If indentSeq === false, consider '- ' as part of indentation where possible\n            ctx.indent = ctx.indent.substr(2);\n        }\n        const valueStr = stringify(value, ctx, ()=>valueComment = null, ()=>chompKeep = true);\n        let ws = \" \";\n        if (vcb || this.comment) {\n            ws = `${vcb}\\n${ctx.indent}`;\n        } else if (!explicitKey && value instanceof Collection) {\n            const flow = valueStr[0] === \"[\" || valueStr[0] === \"{\";\n            if (!flow || valueStr.includes(\"\\n\")) ws = `\\n${ctx.indent}`;\n        } else if (valueStr[0] === \"\\n\") ws = \"\";\n        if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n        return addComment(str + ws + valueStr, ctx.indent, valueComment);\n    }\n}\n_rollupPluginBabelHelpers._defineProperty(Pair, \"Type\", {\n    PAIR: \"PAIR\",\n    MERGE_PAIR: \"MERGE_PAIR\"\n});\nconst getAliasCount = (node, anchors)=>{\n    if (node instanceof Alias) {\n        const anchor = anchors.get(node.source);\n        return anchor.count * anchor.aliasCount;\n    } else if (node instanceof Collection) {\n        let count = 0;\n        for (const item of node.items){\n            const c = getAliasCount(item, anchors);\n            if (c > count) count = c;\n        }\n        return count;\n    } else if (node instanceof Pair) {\n        const kc = getAliasCount(node.key, anchors);\n        const vc = getAliasCount(node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n};\nclass Alias extends Node {\n    static stringify({ range, source }, { anchors, doc, implicitKey, inStringifyKey }) {\n        let anchor = Object.keys(anchors).find((a)=>anchors[a] === source);\n        if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n        if (anchor) return `*${anchor}${implicitKey ? \" \" : \"\"}`;\n        const msg = doc.anchors.getName(source) ? \"Alias node must be after source node\" : \"Source node not found for alias node\";\n        throw new Error(`${msg} [${range}]`);\n    }\n    constructor(source){\n        super();\n        this.source = source;\n        this.type = _rollupPluginBabelHelpers.Type.ALIAS;\n    }\n    set tag(t) {\n        throw new Error(\"Alias nodes cannot have tags\");\n    }\n    toJSON(arg, ctx) {\n        if (!ctx) return toJS(this.source, arg, ctx);\n        const { anchors, maxAliasCount } = ctx;\n        const anchor = anchors.get(this.source);\n        /* istanbul ignore if */ if (!anchor || anchor.res === undefined) {\n            const msg = \"This should not happen: Alias anchor was not resolved?\";\n            if (this.cstNode) throw new _rollupPluginBabelHelpers.YAMLReferenceError(this.cstNode, msg);\n            else throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            anchor.count += 1;\n            if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n            if (anchor.count * anchor.aliasCount > maxAliasCount) {\n                const msg = \"Excessive alias count indicates a resource exhaustion attack\";\n                if (this.cstNode) throw new _rollupPluginBabelHelpers.YAMLReferenceError(this.cstNode, msg);\n                else throw new ReferenceError(msg);\n            }\n        }\n        return anchor.res;\n    }\n    // Object output.\n    toString(ctx) {\n        return Alias.stringify(this, ctx);\n    }\n}\n_rollupPluginBabelHelpers._defineProperty(Alias, \"default\", true);\nfunction findPair(items, key) {\n    const k = key instanceof Scalar ? key.value : key;\n    for (const it of items){\n        if (it instanceof Pair) {\n            if (it.key === key || it.key === k) return it;\n            if (it.key && it.key.value === k) return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection {\n    add(pair, overwrite) {\n        if (!pair) pair = new Pair(pair);\n        else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n        const prev = findPair(this.items, pair.key);\n        const sortEntries = this.schema && this.schema.sortMapEntries;\n        if (prev) {\n            if (!overwrite) throw new Error(`Key ${pair.key} already set`); // For scalars, keep the old node & its comments and anchors\n            if (prev.value instanceof Scalar && isScalarValue(pair.value)) prev.value.value = pair.value;\n            else prev.value = pair.value;\n        } else if (sortEntries) {\n            const i = this.items.findIndex((item)=>sortEntries(pair, item) < 0);\n            if (i === -1) this.items.push(pair);\n            else this.items.splice(i, 0, pair);\n        } else {\n            this.items.push(pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it) return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it && it.value;\n        return !keepScalar && node instanceof Scalar ? node.value : node;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair(key, value), true);\n    }\n    /**\n   * @param ctx - Conversion context, originally set in Document#toJS()\n   * @param {Class} Type - If set, forces the returned collection type\n   * @returns Instance of Type, Map, or Object\n   */ toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n        if (ctx && ctx.onCreate) ctx.onCreate(map);\n        for (const item of this.items)item.addToJSMap(ctx, map);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx) return JSON.stringify(this);\n        for (const item of this.items){\n            if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        return super.toString(ctx, {\n            blockItem: (n)=>n.str,\n            flowChars: {\n                start: \"{\",\n                end: \"}\"\n            },\n            isMap: true,\n            itemIndent: ctx.indent || \"\"\n        }, onComment, onChompKeep);\n    }\n}\nconst binaryOptions = {\n    defaultType: _rollupPluginBabelHelpers.Type.BLOCK_LITERAL,\n    lineWidth: 76\n};\nconst boolOptions = {\n    trueStr: \"true\",\n    falseStr: \"false\"\n};\nconst intOptions = {\n    asBigInt: false\n};\nconst nullOptions = {\n    nullStr: \"null\"\n};\nconst strOptions = {\n    defaultType: _rollupPluginBabelHelpers.Type.PLAIN,\n    defaultKeyType: _rollupPluginBabelHelpers.Type.PLAIN,\n    defaultQuoteSingle: false,\n    doubleQuoted: {\n        jsonEncoding: false,\n        minMultiLineLength: 40\n    },\n    fold: {\n        lineWidth: 80,\n        minContentWidth: 20\n    }\n};\nfunction resolveScalar(str, tags) {\n    for (const { format, test, resolve } of tags){\n        if (test && test.test(str)) {\n            let res = resolve(str);\n            if (!(res instanceof Scalar)) res = new Scalar(res);\n            if (format) res.format = format;\n            return res;\n        }\n    }\n    return new Scalar(str); // fallback to string\n}\nconst FOLD_FLOW = \"flow\";\nconst FOLD_BLOCK = \"block\";\nconst FOLD_QUOTED = \"quoted\"; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\nconst consumeMoreIndentedLines = (text, i)=>{\n    let ch = text[i + 1];\n    while(ch === \" \" || ch === \"\t\"){\n        do {\n            ch = text[i += 1];\n        }while (ch && ch !== \"\\n\");\n        ch = text[i + 1];\n    }\n    return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width or indent content from the start\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */ function foldFlowLines(text, indent, mode, { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow }) {\n    if (!lineWidth || lineWidth < 0) return text;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep) return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === \"number\") {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);\n        else end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i);\n        if (i !== -1) end = i + endStep;\n    }\n    for(let ch; ch = text[i += 1];){\n        if (mode === FOLD_QUOTED && ch === \"\\\\\") {\n            switch(text[i + 1]){\n                case \"x\":\n                    i += 3;\n                    break;\n                case \"u\":\n                    i += 5;\n                    break;\n                case \"U\":\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n        }\n        if (ch === \"\\n\") {\n            if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n            end = i + endStep;\n            split = undefined;\n        } else {\n            if (ch === \" \" && prev && prev !== \" \" && prev !== \"\\n\" && prev !== \"\t\") {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== \" \" && next !== \"\\n\" && next !== \"\t\") split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                } else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while(prev === \" \" || prev === \"\t\"){\n                        prev = ch;\n                        ch = text[i += 1];\n                        overflow = true;\n                    } // i - 2 accounts for not-dropped last char + newline-escaping \\\n                    folds.push(i - 2);\n                    escapedFolds[i - 2] = true;\n                    end = i - 2 + endStep;\n                    split = undefined;\n                } else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow) onOverflow();\n    if (folds.length === 0) return text;\n    if (onFold) onFold();\n    let res = text.slice(0, folds[0]);\n    for(let i = 0; i < folds.length; ++i){\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0) res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\nconst getFoldOptions = ({ indentAtStart })=>indentAtStart ? Object.assign({\n        indentAtStart\n    }, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str)=>/^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, limit) {\n    const strLen = str.length;\n    if (strLen <= limit) return false;\n    for(let i = 0, start = 0; i < strLen; ++i){\n        if (str[i] === \"\\n\") {\n            if (i - start > limit) return true;\n            start = i + 1;\n            if (strLen - start <= limit) return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const { implicitKey } = ctx;\n    const { jsonEncoding, minMultiLineLength } = strOptions.doubleQuoted;\n    const json = JSON.stringify(value);\n    if (jsonEncoding) return json;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? \"  \" : \"\");\n    let str = \"\";\n    let start = 0;\n    for(let i = 0, ch = json[i]; ch; ch = json[++i]){\n        if (ch === \" \" && json[i + 1] === \"\\\\\" && json[i + 2] === \"n\") {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + \"\\\\ \";\n            i += 1;\n            start = i;\n            ch = \"\\\\\";\n        }\n        if (ch === \"\\\\\") switch(json[i + 1]){\n            case \"u\":\n                {\n                    str += json.slice(start, i);\n                    const code = json.substr(i + 2, 4);\n                    switch(code){\n                        case \"0000\":\n                            str += \"\\\\0\";\n                            break;\n                        case \"0007\":\n                            str += \"\\\\a\";\n                            break;\n                        case \"000b\":\n                            str += \"\\\\v\";\n                            break;\n                        case \"001b\":\n                            str += \"\\\\e\";\n                            break;\n                        case \"0085\":\n                            str += \"\\\\N\";\n                            break;\n                        case \"00a0\":\n                            str += \"\\\\_\";\n                            break;\n                        case \"2028\":\n                            str += \"\\\\L\";\n                            break;\n                        case \"2029\":\n                            str += \"\\\\P\";\n                            break;\n                        default:\n                            if (code.substr(0, 2) === \"00\") str += \"\\\\x\" + code.substr(2);\n                            else str += json.substr(i, 6);\n                    }\n                    i += 5;\n                    start = i + 1;\n                }\n                break;\n            case \"n\":\n                if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n                    i += 1;\n                } else {\n                    // folding will eat first newline\n                    str += json.slice(start, i) + \"\\n\\n\";\n                    while(json[i + 2] === \"\\\\\" && json[i + 3] === \"n\" && json[i + 4] !== '\"'){\n                        str += \"\\n\";\n                        i += 2;\n                    }\n                    str += indent; // space after newline needs to be escaped to not be folded\n                    if (json[i + 2] === \" \") str += \"\\\\\";\n                    i += 1;\n                    start = i + 1;\n                }\n                break;\n            default:\n                i += 1;\n        }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.implicitKey) {\n        if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n    } else {\n        // single quoted string can't have leading or trailing whitespace around newline\n        if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n    }\n    const indent = ctx.indent || (containsDocumentMarker(value) ? \"  \" : \"\");\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n        return doubleQuotedString(value, ctx);\n    }\n    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? \"  \" : \"\");\n    const indentSize = indent ? \"2\" : \"1\"; // root is at -1\n    const literal = type === _rollupPluginBabelHelpers.Type.BLOCK_FOLDED ? false : type === _rollupPluginBabelHelpers.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);\n    let header = literal ? \"|\" : \">\";\n    if (!value) return header + \"\\n\";\n    let wsStart = \"\";\n    let wsEnd = \"\";\n    value = value.replace(/[\\n\\t ]*$/, (ws)=>{\n        const n = ws.indexOf(\"\\n\");\n        if (n === -1) {\n            header += \"-\"; // strip\n        } else if (value === ws || n !== ws.length - 1) {\n            header += \"+\"; // keep\n            if (onChompKeep) onChompKeep();\n        }\n        wsEnd = ws.replace(/\\n$/, \"\");\n        return \"\";\n    }).replace(/^[\\n ]*/, (ws)=>{\n        if (ws.indexOf(\" \") !== -1) header += indentSize;\n        const m = ws.match(/ +$/);\n        if (m) {\n            wsStart = ws.slice(0, -m[0].length);\n            return m[0];\n        } else {\n            wsStart = ws;\n            return \"\";\n        }\n    });\n    if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n    if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n    if (comment) {\n        header += \" #\" + comment.replace(/ ?[\\r\\n]+/g, \" \");\n        if (onComment) onComment();\n    }\n    if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n    if (literal) {\n        value = value.replace(/\\n+/g, `$&${indent}`);\n        return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n    }\n    value = value.replace(/\\n+/g, \"\\n$&\").replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, \"$1$2\") // more-indented lines aren't folded\n    //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n    .replace(/\\n+/g, `$&${indent}`);\n    const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n    return `${header}\\n${indent}${body}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { comment, type, value } = item;\n    const { actualString, implicitKey, indent, inFlow } = ctx;\n    if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n        return doubleQuotedString(value, ctx);\n    }\n    if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        const hasDouble = value.indexOf('\"') !== -1;\n        const hasSingle = value.indexOf(\"'\") !== -1;\n        let quotedString;\n        if (hasDouble && !hasSingle) {\n            quotedString = singleQuotedString;\n        } else if (hasSingle && !hasDouble) {\n            quotedString = doubleQuotedString;\n        } else if (strOptions.defaultQuoteSingle) {\n            quotedString = singleQuotedString;\n        } else {\n            quotedString = doubleQuotedString;\n        } // not allowed:\n        // - empty string, '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || value.indexOf(\"\\n\") === -1 ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey && !inFlow && type !== _rollupPluginBabelHelpers.Type.PLAIN && value.indexOf(\"\\n\") !== -1) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (indent === \"\" && containsDocumentMarker(value)) {\n        ctx.forceBlockIndent = true;\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const { tags } = ctx.doc.schema;\n        const resolved = resolveScalar(str, tags).value;\n        if (typeof resolved !== \"string\") return doubleQuotedString(value, ctx);\n    }\n    const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n    if (comment && !inFlow && (body.indexOf(\"\\n\") !== -1 || comment.indexOf(\"\\n\") !== -1)) {\n        if (onComment) onComment();\n        return addCommentBefore(body, indent, comment);\n    }\n    return body;\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { defaultKeyType, defaultType } = strOptions;\n    const { implicitKey, inFlow } = ctx;\n    let { type, value } = item;\n    if (typeof value !== \"string\") {\n        value = String(value);\n        item = Object.assign({}, item, {\n            value\n        });\n    }\n    if (type !== _rollupPluginBabelHelpers.Type.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(value)) type = _rollupPluginBabelHelpers.Type.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type)=>{\n        switch(_type){\n            case _rollupPluginBabelHelpers.Type.BLOCK_FOLDED:\n            case _rollupPluginBabelHelpers.Type.BLOCK_LITERAL:\n                return implicitKey || inFlow ? doubleQuotedString(value, ctx) // blocks are not valid inside flow containers\n                 : blockString(item, ctx, onComment, onChompKeep);\n            case _rollupPluginBabelHelpers.Type.QUOTE_DOUBLE:\n                return doubleQuotedString(value, ctx);\n            case _rollupPluginBabelHelpers.Type.QUOTE_SINGLE:\n                return singleQuotedString(value, ctx);\n            case _rollupPluginBabelHelpers.Type.PLAIN:\n                return plainString(item, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const t = implicitKey ? defaultKeyType : defaultType;\n        res = _stringify(t);\n        if (res === null) throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\nfunction stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === \"bigint\") return String(value);\n    if (!isFinite(value)) return isNaN(value) ? \".nan\" : value < 0 ? \"-.inf\" : \".inf\";\n    let n = JSON.stringify(value);\n    if (!format && minFractionDigits && (!tag || tag === \"tag:yaml.org,2002:float\") && /^\\d/.test(n)) {\n        let i = n.indexOf(\".\");\n        if (i < 0) {\n            i = n.length;\n            n += \".\";\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while(d-- > 0)n += \"0\";\n    }\n    return n;\n}\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.collectionFromPath = collectionFromPath;\nexports.createNode = createNode;\nexports.createPair = createPair;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveScalar = resolveScalar;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJS = toJS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3N0cmluZ2lmeU51bWJlci1kZWExMTIwYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLDRCQUE0QkMsbUJBQU9BLENBQUM7QUFFeEMsU0FBU0MsaUJBQWlCQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsT0FBTztJQUM1QyxJQUFJLENBQUNBLFNBQVMsT0FBT0Y7SUFDckIsTUFBTUcsS0FBS0QsUUFBUUUsT0FBTyxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUVILE9BQU8sQ0FBQyxDQUFDO0lBQ3RELE9BQU8sQ0FBQyxDQUFDLEVBQUVFLEdBQUcsRUFBRSxFQUFFRixPQUFPLEVBQUVELElBQUksQ0FBQztBQUNsQztBQUNBLFNBQVNLLFdBQVdMLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxPQUFPO0lBQ3RDLE9BQU8sQ0FBQ0EsVUFBVUYsTUFBTUUsUUFBUUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRU4sSUFBSSxFQUFFLEVBQUVFLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRUYsSUFBSSxFQUFFLENBQUMsR0FBR0UsUUFBUUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFSCxVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQ3RJO0FBRUEsTUFBTU07QUFBTTtBQUVaOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNDLEtBQUtDLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQzNCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0osUUFBUSxPQUFPQSxNQUFNSyxHQUFHLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTVIsS0FBS08sR0FBR0UsT0FBT0QsSUFBSUw7SUFFeEUsSUFBSUYsU0FBUyxPQUFPQSxNQUFNUyxNQUFNLEtBQUssWUFBWTtRQUMvQyxNQUFNQyxTQUFTUixPQUFPQSxJQUFJUyxPQUFPLElBQUlULElBQUlTLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDWjtRQUNy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QjBNLGtCQUFrQixHQUFHNU47QUFDckI0TixrQkFBa0IsR0FBRzNIO0FBQ3JCMkgsZ0JBQWdCLEdBQUc1RTtBQUNuQjRFLGtCQUFrQixHQUFHaEU7QUFDckJnRSxtQkFBbUIsR0FBRzlMO0FBQ3RCOEwsbUJBQW1CLEdBQUc5RDtBQUN0QjhELHFCQUFxQixHQUFHbkQ7QUFDeEJtRCxrQkFBa0IsR0FBRzVEO0FBQ3JCNEQsdUJBQXVCLEdBQUdMO0FBQzFCSyx1QkFBdUIsR0FBR1Y7QUFDMUJVLFlBQVksR0FBRzlQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFudGVzLXB1YmxpYy1kYXRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9zd2FnZ2VyLWpzZG9jL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc3RyaW5naWZ5TnVtYmVyLWRlYTExMjBjLmpzPzJmMmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycyA9IHJlcXVpcmUoJy4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy1lZWQzMDIxNy5qcycpO1xuXG5mdW5jdGlvbiBhZGRDb21tZW50QmVmb3JlKHN0ciwgaW5kZW50LCBjb21tZW50KSB7XG4gIGlmICghY29tbWVudCkgcmV0dXJuIHN0cjtcbiAgY29uc3QgY2MgPSBjb21tZW50LnJlcGxhY2UoL1tcXHNcXFNdXi9nbSwgYCQmJHtpbmRlbnR9I2ApO1xuICByZXR1cm4gYCMke2NjfVxcbiR7aW5kZW50fSR7c3RyfWA7XG59XG5mdW5jdGlvbiBhZGRDb21tZW50KHN0ciwgaW5kZW50LCBjb21tZW50KSB7XG4gIHJldHVybiAhY29tbWVudCA/IHN0ciA6IGNvbW1lbnQuaW5kZXhPZignXFxuJykgPT09IC0xID8gYCR7c3RyfSAjJHtjb21tZW50fWAgOiBgJHtzdHJ9XFxuYCArIGNvbW1lbnQucmVwbGFjZSgvXi9nbSwgYCR7aW5kZW50IHx8ICcnfSNgKTtcbn1cblxuY2xhc3MgTm9kZSB7fVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgYW55IG5vZGUgb3IgaXRzIGNvbnRlbnRzIHRvIG5hdGl2ZSBKYXZhU2NyaXB0XG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGlucHV0IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBhcmcgLSBJZiBgdmFsdWVgIGRlZmluZXMgYSBgdG9KU09OKClgIG1ldGhvZCwgdXNlIHRoaXNcbiAqICAgYXMgaXRzIGZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0gY3R4IC0gQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTKCkuIElmXG4gKiAgIGB7IGtlZXA6IHRydWUgfWAgaXMgbm90IHNldCwgb3V0cHV0IHNob3VsZCBiZSBzdWl0YWJsZSBmb3IgSlNPTlxuICogICBzdHJpbmdpZmljYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRvSlModmFsdWUsIGFyZywgY3R4KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gdG9KUyh2LCBTdHJpbmcoaSksIGN0eCkpO1xuXG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgYW5jaG9yID0gY3R4ICYmIGN0eC5hbmNob3JzICYmIGN0eC5hbmNob3JzLmdldCh2YWx1ZSk7XG4gICAgaWYgKGFuY2hvcikgY3R4Lm9uQ3JlYXRlID0gcmVzID0+IHtcbiAgICAgIGFuY2hvci5yZXMgPSByZXM7XG4gICAgICBkZWxldGUgY3R4Lm9uQ3JlYXRlO1xuICAgIH07XG4gICAgY29uc3QgcmVzID0gdmFsdWUudG9KU09OKGFyZywgY3R4KTtcbiAgICBpZiAoYW5jaG9yICYmIGN0eC5vbkNyZWF0ZSkgY3R4Lm9uQ3JlYXRlKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGlmICghKGN0eCAmJiBjdHgua2VlcCkgJiYgdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JykgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuY29uc3QgaXNTY2FsYXJWYWx1ZSA9IHZhbHVlID0+ICF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JztcbmNsYXNzIFNjYWxhciBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgdG9KU09OKGFyZywgY3R4KSB7XG4gICAgcmV0dXJuIGN0eCAmJiBjdHgua2VlcCA/IHRoaXMudmFsdWUgOiB0b0pTKHRoaXMudmFsdWUsIGFyZywgY3R4KTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBmaW5kVGFnT2JqZWN0KHZhbHVlLCB0YWdOYW1lLCB0YWdzKSB7XG4gIGlmICh0YWdOYW1lKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSB0YWdOYW1lKTtcbiAgICBjb25zdCB0YWdPYmogPSBtYXRjaC5maW5kKHQgPT4gIXQuZm9ybWF0KSB8fCBtYXRjaFswXTtcbiAgICBpZiAoIXRhZ09iaikgdGhyb3cgbmV3IEVycm9yKGBUYWcgJHt0YWdOYW1lfSBub3QgZm91bmRgKTtcbiAgICByZXR1cm4gdGFnT2JqO1xuICB9XG5cbiAgcmV0dXJuIHRhZ3MuZmluZCh0ID0+IHQuaWRlbnRpZnkgJiYgdC5pZGVudGlmeSh2YWx1ZSkgJiYgIXQuZm9ybWF0KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZSh2YWx1ZSwgdGFnTmFtZSwgY3R4KSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qge1xuICAgIG9uQWxpYXMsXG4gICAgb25UYWdPYmosXG4gICAgcHJldk9iamVjdHMsXG4gICAgd3JhcFNjYWxhcnNcbiAgfSA9IGN0eDtcbiAgY29uc3Qge1xuICAgIG1hcCxcbiAgICBzZXEsXG4gICAgdGFnc1xuICB9ID0gY3R4LnNjaGVtYTtcbiAgaWYgKHRhZ05hbWUgJiYgdGFnTmFtZS5zdGFydHNXaXRoKCchIScpKSB0YWdOYW1lID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5kZWZhdWx0VGFnUHJlZml4ICsgdGFnTmFtZS5zbGljZSgyKTtcbiAgbGV0IHRhZ09iaiA9IGZpbmRUYWdPYmplY3QodmFsdWUsIHRhZ05hbWUsIHRhZ3MpO1xuXG4gIGlmICghdGFnT2JqKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHZhbHVlID0gdmFsdWUudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSByZXR1cm4gd3JhcFNjYWxhcnMgPyBuZXcgU2NhbGFyKHZhbHVlKSA6IHZhbHVlO1xuICAgIHRhZ09iaiA9IHZhbHVlIGluc3RhbmNlb2YgTWFwID8gbWFwIDogdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSA/IHNlcSA6IG1hcDtcbiAgfVxuXG4gIGlmIChvblRhZ09iaikge1xuICAgIG9uVGFnT2JqKHRhZ09iaik7XG4gICAgZGVsZXRlIGN0eC5vblRhZ09iajtcbiAgfSAvLyBEZXRlY3QgZHVwbGljYXRlIHJlZmVyZW5jZXMgdG8gdGhlIHNhbWUgb2JqZWN0ICYgdXNlIEFsaWFzIG5vZGVzIGZvciBhbGxcbiAgLy8gYWZ0ZXIgZmlyc3QuIFRoZSBgb2JqYCB3cmFwcGVyIGFsbG93cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byByZXNvbHZlLlxuXG5cbiAgY29uc3Qgb2JqID0ge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgbm9kZTogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBwcmV2ID0gcHJldk9iamVjdHMuZ2V0KHZhbHVlKTtcbiAgICBpZiAocHJldikgcmV0dXJuIG9uQWxpYXMocHJldik7XG4gICAgb2JqLnZhbHVlID0gdmFsdWU7XG4gICAgcHJldk9iamVjdHMuc2V0KHZhbHVlLCBvYmopO1xuICB9XG5cbiAgb2JqLm5vZGUgPSB0YWdPYmouY3JlYXRlTm9kZSA/IHRhZ09iai5jcmVhdGVOb2RlKGN0eC5zY2hlbWEsIHZhbHVlLCBjdHgpIDogd3JhcFNjYWxhcnMgPyBuZXcgU2NhbGFyKHZhbHVlKSA6IHZhbHVlO1xuICBpZiAodGFnTmFtZSAmJiBvYmoubm9kZSBpbnN0YW5jZW9mIE5vZGUpIG9iai5ub2RlLnRhZyA9IHRhZ05hbWU7XG4gIHJldHVybiBvYmoubm9kZTtcbn1cblxuZnVuY3Rpb24gY29sbGVjdGlvbkZyb21QYXRoKHNjaGVtYSwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IHYgPSB2YWx1ZTtcblxuICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGNvbnN0IGsgPSBwYXRoW2ldO1xuXG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaykgJiYgayA+PSAwKSB7XG4gICAgICBjb25zdCBhID0gW107XG4gICAgICBhW2tdID0gdjtcbiAgICAgIHYgPSBhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgaywge1xuICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2ID0gbztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3JlYXRlTm9kZSh2LCBudWxsLCB7XG4gICAgb25BbGlhcygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVwZWF0ZWQgb2JqZWN0cyBhcmUgbm90IHN1cHBvcnRlZCBoZXJlJyk7XG4gICAgfSxcblxuICAgIHByZXZPYmplY3RzOiBuZXcgTWFwKCksXG4gICAgc2NoZW1hLFxuICAgIHdyYXBTY2FsYXJzOiBmYWxzZVxuICB9KTtcbn0gLy8gbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBlbXB0eSBub24tc3RyaW5nIGl0ZXJhYmxlIChlLmcuIFtdKVxuXG5jb25zdCBpc0VtcHR5UGF0aCA9IHBhdGggPT4gcGF0aCA9PSBudWxsIHx8IHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiBwYXRoW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkuZG9uZTtcbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXRlbXNcIiwgW10pO1xuXG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIH1cblxuICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSkgdGhpcy5hZGQodmFsdWUpO2Vsc2Uge1xuICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIG5vZGUuYWRkSW4ocmVzdCwgdmFsdWUpO2Vsc2UgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNjaGVtYSkgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlSW4oW2tleSwgLi4ucmVzdF0pIHtcbiAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbikgcmV0dXJuIG5vZGUuZGVsZXRlSW4ocmVzdCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gIH1cblxuICBnZXRJbihba2V5LCAuLi5yZXN0XSwga2VlcFNjYWxhcikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuICFrZWVwU2NhbGFyICYmIG5vZGUgaW5zdGFuY2VvZiBTY2FsYXIgPyBub2RlLnZhbHVlIDogbm9kZTtlbHNlIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbiA/IG5vZGUuZ2V0SW4ocmVzdCwga2VlcFNjYWxhcikgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBoYXNBbGxOdWxsVmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmV2ZXJ5KG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSAhPT0gJ1BBSVInKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBuID0gbm9kZS52YWx1ZTtcbiAgICAgIHJldHVybiBuID09IG51bGwgfHwgbiBpbnN0YW5jZW9mIFNjYWxhciAmJiBuLnZhbHVlID09IG51bGwgJiYgIW4uY29tbWVudEJlZm9yZSAmJiAhbi5jb21tZW50ICYmICFuLnRhZztcbiAgICB9KTtcbiAgfVxuXG4gIGhhc0luKFtrZXksIC4uLnJlc3RdKSB7XG4gICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5oYXMoa2V5KTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24gPyBub2RlLmhhc0luKHJlc3QpIDogZmFsc2U7XG4gIH1cblxuICBzZXRJbihba2V5LCAuLi5yZXN0XSwgdmFsdWUpIHtcbiAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbikgbm9kZS5zZXRJbihyZXN0LCB2YWx1ZSk7ZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKSB0aGlzLnNldChrZXksIGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgcmVzdCwgdmFsdWUpKTtlbHNlIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG92ZXJyaWRkZW4gaW4gaW1wbGVtZW50YXRpb25zICovXG5cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0b1N0cmluZyhjdHgsIHtcbiAgICBibG9ja0l0ZW0sXG4gICAgZmxvd0NoYXJzLFxuICAgIGlzTWFwLFxuICAgIGl0ZW1JbmRlbnRcbiAgfSwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGVudCxcbiAgICAgIGluZGVudFN0ZXAsXG4gICAgICBzdHJpbmdpZnlcbiAgICB9ID0gY3R4O1xuICAgIGNvbnN0IGluRmxvdyA9IHRoaXMudHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkZMT1dfTUFQIHx8IHRoaXMudHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkZMT1dfU0VRIHx8IGN0eC5pbkZsb3c7XG4gICAgaWYgKGluRmxvdykgaXRlbUluZGVudCArPSBpbmRlbnRTdGVwO1xuICAgIGNvbnN0IGFsbE51bGxWYWx1ZXMgPSBpc01hcCAmJiB0aGlzLmhhc0FsbE51bGxWYWx1ZXMoKTtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgIGFsbE51bGxWYWx1ZXMsXG4gICAgICBpbmRlbnQ6IGl0ZW1JbmRlbnQsXG4gICAgICBpbkZsb3csXG4gICAgICB0eXBlOiBudWxsXG4gICAgfSk7XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBoYXNJdGVtV2l0aE5ld0xpbmUgPSBmYWxzZTtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuaXRlbXMucmVkdWNlKChub2RlcywgaXRlbSwgaSkgPT4ge1xuICAgICAgbGV0IGNvbW1lbnQ7XG5cbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGlmICghY2hvbXBLZWVwICYmIGl0ZW0uc3BhY2VCZWZvcmUpIG5vZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdjb21tZW50JyxcbiAgICAgICAgICBzdHI6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKSBpdGVtLmNvbW1lbnRCZWZvcmUubWF0Y2goL14uKiQvZ20pLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWVudCcsXG4gICAgICAgICAgICBzdHI6IGAjJHtsaW5lfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpdGVtLmNvbW1lbnQpIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgIGlmIChpbkZsb3cgJiYgKCFjaG9tcEtlZXAgJiYgaXRlbS5zcGFjZUJlZm9yZSB8fCBpdGVtLmNvbW1lbnRCZWZvcmUgfHwgaXRlbS5jb21tZW50IHx8IGl0ZW0ua2V5ICYmIChpdGVtLmtleS5jb21tZW50QmVmb3JlIHx8IGl0ZW0ua2V5LmNvbW1lbnQpIHx8IGl0ZW0udmFsdWUgJiYgKGl0ZW0udmFsdWUuY29tbWVudEJlZm9yZSB8fCBpdGVtLnZhbHVlLmNvbW1lbnQpKSkgaGFzSXRlbVdpdGhOZXdMaW5lID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICBsZXQgc3RyID0gc3RyaW5naWZ5KGl0ZW0sIGN0eCwgKCkgPT4gY29tbWVudCA9IG51bGwsICgpID0+IGNob21wS2VlcCA9IHRydWUpO1xuICAgICAgaWYgKGluRmxvdyAmJiAhaGFzSXRlbVdpdGhOZXdMaW5lICYmIHN0ci5pbmNsdWRlcygnXFxuJykpIGhhc0l0ZW1XaXRoTmV3TGluZSA9IHRydWU7XG4gICAgICBpZiAoaW5GbG93ICYmIGkgPCB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpIHN0ciArPSAnLCc7XG4gICAgICBzdHIgPSBhZGRDb21tZW50KHN0ciwgaXRlbUluZGVudCwgY29tbWVudCk7XG4gICAgICBpZiAoY2hvbXBLZWVwICYmIChjb21tZW50IHx8IGluRmxvdykpIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdpdGVtJyxcbiAgICAgICAgc3RyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9LCBbXSk7XG4gICAgbGV0IHN0cjtcblxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHN0ciA9IGZsb3dDaGFycy5zdGFydCArIGZsb3dDaGFycy5lbmQ7XG4gICAgfSBlbHNlIGlmIChpbkZsb3cpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZFxuICAgICAgfSA9IGZsb3dDaGFycztcbiAgICAgIGNvbnN0IHN0cmluZ3MgPSBub2Rlcy5tYXAobiA9PiBuLnN0cik7XG5cbiAgICAgIGlmIChoYXNJdGVtV2l0aE5ld0xpbmUgfHwgc3RyaW5ncy5yZWR1Y2UoKHN1bSwgc3RyKSA9PiBzdW0gKyBzdHIubGVuZ3RoICsgMiwgMikgPiBDb2xsZWN0aW9uLm1heEZsb3dTdHJpbmdTaW5nbGVMaW5lTGVuZ3RoKSB7XG4gICAgICAgIHN0ciA9IHN0YXJ0O1xuXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzdHJpbmdzKSB7XG4gICAgICAgICAgc3RyICs9IHMgPyBgXFxuJHtpbmRlbnRTdGVwfSR7aW5kZW50fSR7c31gIDogJ1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gYFxcbiR7aW5kZW50fSR7ZW5kfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBgJHtzdGFydH0gJHtzdHJpbmdzLmpvaW4oJyAnKX0gJHtlbmR9YDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyaW5ncyA9IG5vZGVzLm1hcChibG9ja0l0ZW0pO1xuICAgICAgc3RyID0gc3RyaW5ncy5zaGlmdCgpO1xuXG4gICAgICBmb3IgKGNvbnN0IHMgb2Ygc3RyaW5ncykgc3RyICs9IHMgPyBgXFxuJHtpbmRlbnR9JHtzfWAgOiAnXFxuJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICBzdHIgKz0gJ1xcbicgKyB0aGlzLmNvbW1lbnQucmVwbGFjZSgvXi9nbSwgYCR7aW5kZW50fSNgKTtcbiAgICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICAgIH0gZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKSBvbkNob21wS2VlcCgpO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG59XG5cbl9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuX2RlZmluZVByb3BlcnR5KENvbGxlY3Rpb24sIFwibWF4Rmxvd1N0cmluZ1NpbmdsZUxpbmVMZW5ndGhcIiwgNjApO1xuXG5mdW5jdGlvbiBhc0l0ZW1JbmRleChrZXkpIHtcbiAgbGV0IGlkeCA9IGtleSBpbnN0YW5jZW9mIFNjYWxhciA/IGtleS52YWx1ZSA6IGtleTtcbiAgaWYgKGlkeCAmJiB0eXBlb2YgaWR4ID09PSAnc3RyaW5nJykgaWR4ID0gTnVtYmVyKGlkeCk7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGlkeCkgJiYgaWR4ID49IDAgPyBpZHggOiBudWxsO1xufVxuXG5jbGFzcyBZQU1MU2VxIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gIGFkZCh2YWx1ZSkge1xuICAgIHRoaXMuaXRlbXMucHVzaCh2YWx1ZSk7XG4gIH1cblxuICBkZWxldGUoa2V5KSB7XG4gICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBkZWwgPSB0aGlzLml0ZW1zLnNwbGljZShpZHgsIDEpO1xuICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgfVxuXG4gIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBpdCA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXQgaW5zdGFuY2VvZiBTY2FsYXIgPyBpdC52YWx1ZSA6IGl0O1xuICB9XG5cbiAgaGFzKGtleSkge1xuICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIGlkeCA8IHRoaXMuaXRlbXMubGVuZ3RoO1xuICB9XG5cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHZhbGlkIGluZGV4LCBub3QgJHtrZXl9LmApO1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgaWYgKHByZXYgaW5zdGFuY2VvZiBTY2FsYXIgJiYgaXNTY2FsYXJWYWx1ZSh2YWx1ZSkpIHByZXYudmFsdWUgPSB2YWx1ZTtlbHNlIHRoaXMuaXRlbXNbaWR4XSA9IHZhbHVlO1xuICB9XG5cbiAgdG9KU09OKF8sIGN0eCkge1xuICAgIGNvbnN0IHNlcSA9IFtdO1xuICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKSBjdHgub25DcmVhdGUoc2VxKTtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykgc2VxLnB1c2godG9KUyhpdGVtLCBTdHJpbmcoaSsrKSwgY3R4KSk7XG5cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgaWYgKCFjdHgpIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICByZXR1cm4gc3VwZXIudG9TdHJpbmcoY3R4LCB7XG4gICAgICBibG9ja0l0ZW06IG4gPT4gbi50eXBlID09PSAnY29tbWVudCcgPyBuLnN0ciA6IGAtICR7bi5zdHJ9YCxcbiAgICAgIGZsb3dDaGFyczoge1xuICAgICAgICBzdGFydDogJ1snLFxuICAgICAgICBlbmQ6ICddJ1xuICAgICAgfSxcbiAgICAgIGlzTWFwOiBmYWxzZSxcbiAgICAgIGl0ZW1JbmRlbnQ6IChjdHguaW5kZW50IHx8ICcnKSArICcgICdcbiAgICB9LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfVxuXG59XG5cbmNvbnN0IHN0cmluZ2lmeUtleSA9IChrZXksIGpzS2V5LCBjdHgpID0+IHtcbiAgaWYgKGpzS2V5ID09PSBudWxsKSByZXR1cm4gJyc7XG4gIGlmICh0eXBlb2YganNLZXkgIT09ICdvYmplY3QnKSByZXR1cm4gU3RyaW5nKGpzS2V5KTtcbiAgaWYgKGtleSBpbnN0YW5jZW9mIE5vZGUgJiYgY3R4ICYmIGN0eC5kb2MpIHJldHVybiBrZXkudG9TdHJpbmcoe1xuICAgIGFuY2hvcnM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgZG9jOiBjdHguZG9jLFxuICAgIGluZGVudDogJycsXG4gICAgaW5kZW50U3RlcDogY3R4LmluZGVudFN0ZXAsXG4gICAgaW5GbG93OiB0cnVlLFxuICAgIGluU3RyaW5naWZ5S2V5OiB0cnVlLFxuICAgIHN0cmluZ2lmeTogY3R4LnN0cmluZ2lmeVxuICB9KTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzS2V5KTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgY3R4KSB7XG4gIGNvbnN0IGsgPSBjcmVhdGVOb2RlKGtleSwgbnVsbCwgY3R4KTtcbiAgY29uc3QgdiA9IGNyZWF0ZU5vZGUodmFsdWUsIG51bGwsIGN0eCk7XG4gIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbn1cbmNsYXNzIFBhaXIgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSA9IG51bGwpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnR5cGUgPSBQYWlyLlR5cGUuUEFJUjtcbiAgfVxuXG4gIGdldCBjb21tZW50QmVmb3JlKCkge1xuICAgIHJldHVybiB0aGlzLmtleSBpbnN0YW5jZW9mIE5vZGUgPyB0aGlzLmtleS5jb21tZW50QmVmb3JlIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgc2V0IGNvbW1lbnRCZWZvcmUoY2IpIHtcbiAgICBpZiAodGhpcy5rZXkgPT0gbnVsbCkgdGhpcy5rZXkgPSBuZXcgU2NhbGFyKG51bGwpO1xuICAgIGlmICh0aGlzLmtleSBpbnN0YW5jZW9mIE5vZGUpIHRoaXMua2V5LmNvbW1lbnRCZWZvcmUgPSBjYjtlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdQYWlyLmNvbW1lbnRCZWZvcmUgaXMgYW4gYWxpYXMgZm9yIFBhaXIua2V5LmNvbW1lbnRCZWZvcmUuIFRvIHNldCBpdCwgdGhlIGtleSBtdXN0IGJlIGEgTm9kZS4nO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgYWRkVG9KU01hcChjdHgsIG1hcCkge1xuICAgIGNvbnN0IGtleSA9IHRvSlModGhpcy5rZXksICcnLCBjdHgpO1xuXG4gICAgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0b0pTKHRoaXMudmFsdWUsIGtleSwgY3R4KTtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChtYXAgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIG1hcC5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyaW5nS2V5ID0gc3RyaW5naWZ5S2V5KHRoaXMua2V5LCBrZXksIGN0eCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRvSlModGhpcy52YWx1ZSwgc3RyaW5nS2V5LCBjdHgpO1xuICAgICAgaWYgKHN0cmluZ0tleSBpbiBtYXApIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIHN0cmluZ0tleSwge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7ZWxzZSBtYXBbc3RyaW5nS2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICB0b0pTT04oXywgY3R4KSB7XG4gICAgY29uc3QgcGFpciA9IGN0eCAmJiBjdHgubWFwQXNNYXAgPyBuZXcgTWFwKCkgOiB7fTtcbiAgICByZXR1cm4gdGhpcy5hZGRUb0pTTWFwKGN0eCwgcGFpcik7XG4gIH1cblxuICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBpZiAoIWN0eCB8fCAhY3R4LmRvYykgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGVudDogaW5kZW50U2l6ZSxcbiAgICAgIGluZGVudFNlcSxcbiAgICAgIHNpbXBsZUtleXNcbiAgICB9ID0gY3R4LmRvYy5vcHRpb25zO1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBrZXlDb21tZW50ID0ga2V5IGluc3RhbmNlb2YgTm9kZSAmJiBrZXkuY29tbWVudDtcblxuICAgIGlmIChzaW1wbGVLZXlzKSB7XG4gICAgICBpZiAoa2V5Q29tbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIGtleSBub2RlcyBjYW5ub3QgaGF2ZSBjb21tZW50cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5IGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgICAgICBjb25zdCBtc2cgPSAnV2l0aCBzaW1wbGUga2V5cywgY29sbGVjdGlvbiBjYW5ub3QgYmUgdXNlZCBhcyBhIGtleSB2YWx1ZSc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBleHBsaWNpdEtleSA9ICFzaW1wbGVLZXlzICYmICgha2V5IHx8IGtleUNvbW1lbnQgfHwga2V5IGluc3RhbmNlb2YgQ29sbGVjdGlvbiB8fCBrZXkudHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkJMT0NLX0ZPTERFRCB8fCBrZXkudHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkJMT0NLX0xJVEVSQUwpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFsbE51bGxWYWx1ZXMsXG4gICAgICBkb2MsXG4gICAgICBpbmRlbnQsXG4gICAgICBpbmRlbnRTdGVwLFxuICAgICAgc3RyaW5naWZ5XG4gICAgfSA9IGN0eDtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgIGltcGxpY2l0S2V5OiAhZXhwbGljaXRLZXkgJiYgKHNpbXBsZUtleXMgfHwgIWFsbE51bGxWYWx1ZXMpLFxuICAgICAgaW5kZW50OiBpbmRlbnQgKyBpbmRlbnRTdGVwXG4gICAgfSk7XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnkoa2V5LCBjdHgsICgpID0+IGtleUNvbW1lbnQgPSBudWxsLCAoKSA9PiBjaG9tcEtlZXAgPSB0cnVlKTtcbiAgICBzdHIgPSBhZGRDb21tZW50KHN0ciwgY3R4LmluZGVudCwga2V5Q29tbWVudCk7XG5cbiAgICBpZiAoYWxsTnVsbFZhbHVlcyAmJiAhc2ltcGxlS2V5cykge1xuICAgICAgaWYgKHRoaXMuY29tbWVudCkge1xuICAgICAgICBzdHIgPSBhZGRDb21tZW50KHN0ciwgY3R4LmluZGVudCwgdGhpcy5jb21tZW50KTtcbiAgICAgICAgaWYgKG9uQ29tbWVudCkgb25Db21tZW50KCk7XG4gICAgICB9IGVsc2UgaWYgKGNob21wS2VlcCAmJiAha2V5Q29tbWVudCAmJiBvbkNob21wS2VlcCkgb25DaG9tcEtlZXAoKTtcblxuICAgICAgcmV0dXJuIGN0eC5pbkZsb3cgPyBzdHIgOiBgPyAke3N0cn1gO1xuICAgIH1cblxuICAgIGlmICghZXhwbGljaXRLZXkgJiYgc3RyLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgIGlmICghc2ltcGxlS2V5cykge1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtc2cgPSAnV2l0aCBzaW1wbGUga2V5cywgc2luZ2xlIGxpbmUgc2NhbGFyIG11c3Qgbm90IHNwYW4gbW9yZSB0aGFuIDEwMjQgY2hhcmFjdGVycyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0ciA9IGV4cGxpY2l0S2V5ID8gYD8gJHtzdHJ9XFxuJHtpbmRlbnR9OmAgOiBgJHtzdHJ9OmA7XG5cbiAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAvLyBleHBlY3RlZCAoYnV0IG5vdCBzdHJpY3RseSByZXF1aXJlZCkgdG8gYmUgYSBzaW5nbGUtbGluZSBjb21tZW50XG4gICAgICBzdHIgPSBhZGRDb21tZW50KHN0ciwgY3R4LmluZGVudCwgdGhpcy5jb21tZW50KTtcbiAgICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICAgIH1cblxuICAgIGxldCB2Y2IgPSAnJztcbiAgICBsZXQgdmFsdWVDb21tZW50ID0gbnVsbDtcblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgIGlmICh2YWx1ZS5zcGFjZUJlZm9yZSkgdmNiID0gJ1xcbic7XG5cbiAgICAgIGlmICh2YWx1ZS5jb21tZW50QmVmb3JlKSB7XG4gICAgICAgIGNvbnN0IGNzID0gdmFsdWUuY29tbWVudEJlZm9yZS5yZXBsYWNlKC9eL2dtLCBgJHtjdHguaW5kZW50fSNgKTtcbiAgICAgICAgdmNiICs9IGBcXG4ke2NzfWA7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlQ29tbWVudCA9IHZhbHVlLmNvbW1lbnQ7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWx1ZSA9IGRvYy5jcmVhdGVOb2RlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBjdHguaW1wbGljaXRLZXkgPSBmYWxzZTtcbiAgICBpZiAoIWV4cGxpY2l0S2V5ICYmICF0aGlzLmNvbW1lbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTY2FsYXIpIGN0eC5pbmRlbnRBdFN0YXJ0ID0gc3RyLmxlbmd0aCArIDE7XG4gICAgY2hvbXBLZWVwID0gZmFsc2U7XG5cbiAgICBpZiAoIWluZGVudFNlcSAmJiBpbmRlbnRTaXplID49IDIgJiYgIWN0eC5pbkZsb3cgJiYgIWV4cGxpY2l0S2V5ICYmIHZhbHVlIGluc3RhbmNlb2YgWUFNTFNlcSAmJiB2YWx1ZS50eXBlICE9PSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuRkxPV19TRVEgJiYgIXZhbHVlLnRhZyAmJiAhZG9jLmFuY2hvcnMuZ2V0TmFtZSh2YWx1ZSkpIHtcbiAgICAgIC8vIElmIGluZGVudFNlcSA9PT0gZmFsc2UsIGNvbnNpZGVyICctICcgYXMgcGFydCBvZiBpbmRlbnRhdGlvbiB3aGVyZSBwb3NzaWJsZVxuICAgICAgY3R4LmluZGVudCA9IGN0eC5pbmRlbnQuc3Vic3RyKDIpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlU3RyID0gc3RyaW5naWZ5KHZhbHVlLCBjdHgsICgpID0+IHZhbHVlQ29tbWVudCA9IG51bGwsICgpID0+IGNob21wS2VlcCA9IHRydWUpO1xuICAgIGxldCB3cyA9ICcgJztcblxuICAgIGlmICh2Y2IgfHwgdGhpcy5jb21tZW50KSB7XG4gICAgICB3cyA9IGAke3ZjYn1cXG4ke2N0eC5pbmRlbnR9YDtcbiAgICB9IGVsc2UgaWYgKCFleHBsaWNpdEtleSAmJiB2YWx1ZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGZsb3cgPSB2YWx1ZVN0clswXSA9PT0gJ1snIHx8IHZhbHVlU3RyWzBdID09PSAneyc7XG4gICAgICBpZiAoIWZsb3cgfHwgdmFsdWVTdHIuaW5jbHVkZXMoJ1xcbicpKSB3cyA9IGBcXG4ke2N0eC5pbmRlbnR9YDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlU3RyWzBdID09PSAnXFxuJykgd3MgPSAnJztcblxuICAgIGlmIChjaG9tcEtlZXAgJiYgIXZhbHVlQ29tbWVudCAmJiBvbkNob21wS2VlcCkgb25DaG9tcEtlZXAoKTtcbiAgICByZXR1cm4gYWRkQ29tbWVudChzdHIgKyB3cyArIHZhbHVlU3RyLCBjdHguaW5kZW50LCB2YWx1ZUNvbW1lbnQpO1xuICB9XG5cbn1cblxuX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5fZGVmaW5lUHJvcGVydHkoUGFpciwgXCJUeXBlXCIsIHtcbiAgUEFJUjogJ1BBSVInLFxuICBNRVJHRV9QQUlSOiAnTUVSR0VfUEFJUidcbn0pO1xuXG5jb25zdCBnZXRBbGlhc0NvdW50ID0gKG5vZGUsIGFuY2hvcnMpID0+IHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBbGlhcykge1xuICAgIGNvbnN0IGFuY2hvciA9IGFuY2hvcnMuZ2V0KG5vZGUuc291cmNlKTtcbiAgICByZXR1cm4gYW5jaG9yLmNvdW50ICogYW5jaG9yLmFsaWFzQ291bnQ7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIG5vZGUuaXRlbXMpIHtcbiAgICAgIGNvbnN0IGMgPSBnZXRBbGlhc0NvdW50KGl0ZW0sIGFuY2hvcnMpO1xuICAgICAgaWYgKGMgPiBjb3VudCkgY291bnQgPSBjO1xuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUGFpcikge1xuICAgIGNvbnN0IGtjID0gZ2V0QWxpYXNDb3VudChub2RlLmtleSwgYW5jaG9ycyk7XG4gICAgY29uc3QgdmMgPSBnZXRBbGlhc0NvdW50KG5vZGUudmFsdWUsIGFuY2hvcnMpO1xuICAgIHJldHVybiBNYXRoLm1heChrYywgdmMpO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59O1xuXG5jbGFzcyBBbGlhcyBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgc3RyaW5naWZ5KHtcbiAgICByYW5nZSxcbiAgICBzb3VyY2VcbiAgfSwge1xuICAgIGFuY2hvcnMsXG4gICAgZG9jLFxuICAgIGltcGxpY2l0S2V5LFxuICAgIGluU3RyaW5naWZ5S2V5XG4gIH0pIHtcbiAgICBsZXQgYW5jaG9yID0gT2JqZWN0LmtleXMoYW5jaG9ycykuZmluZChhID0+IGFuY2hvcnNbYV0gPT09IHNvdXJjZSk7XG4gICAgaWYgKCFhbmNob3IgJiYgaW5TdHJpbmdpZnlLZXkpIGFuY2hvciA9IGRvYy5hbmNob3JzLmdldE5hbWUoc291cmNlKSB8fCBkb2MuYW5jaG9ycy5uZXdOYW1lKCk7XG4gICAgaWYgKGFuY2hvcikgcmV0dXJuIGAqJHthbmNob3J9JHtpbXBsaWNpdEtleSA/ICcgJyA6ICcnfWA7XG4gICAgY29uc3QgbXNnID0gZG9jLmFuY2hvcnMuZ2V0TmFtZShzb3VyY2UpID8gJ0FsaWFzIG5vZGUgbXVzdCBiZSBhZnRlciBzb3VyY2Ugbm9kZScgOiAnU291cmNlIG5vZGUgbm90IGZvdW5kIGZvciBhbGlhcyBub2RlJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bXNnfSBbJHtyYW5nZX1dYCk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudHlwZSA9IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5BTElBUztcbiAgfVxuXG4gIHNldCB0YWcodCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWxpYXMgbm9kZXMgY2Fubm90IGhhdmUgdGFncycpO1xuICB9XG5cbiAgdG9KU09OKGFyZywgY3R4KSB7XG4gICAgaWYgKCFjdHgpIHJldHVybiB0b0pTKHRoaXMuc291cmNlLCBhcmcsIGN0eCk7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9ycyxcbiAgICAgIG1heEFsaWFzQ291bnRcbiAgICB9ID0gY3R4O1xuICAgIGNvbnN0IGFuY2hvciA9IGFuY2hvcnMuZ2V0KHRoaXMuc291cmNlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgIGlmICghYW5jaG9yIHx8IGFuY2hvci5yZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbXNnID0gJ1RoaXMgc2hvdWxkIG5vdCBoYXBwZW46IEFsaWFzIGFuY2hvciB3YXMgbm90IHJlc29sdmVkPyc7XG4gICAgICBpZiAodGhpcy5jc3ROb2RlKSB0aHJvdyBuZXcgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5ZQU1MUmVmZXJlbmNlRXJyb3IodGhpcy5jc3ROb2RlLCBtc2cpO2Vsc2UgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgaWYgKG1heEFsaWFzQ291bnQgPj0gMCkge1xuICAgICAgYW5jaG9yLmNvdW50ICs9IDE7XG4gICAgICBpZiAoYW5jaG9yLmFsaWFzQ291bnQgPT09IDApIGFuY2hvci5hbGlhc0NvdW50ID0gZ2V0QWxpYXNDb3VudCh0aGlzLnNvdXJjZSwgYW5jaG9ycyk7XG5cbiAgICAgIGlmIChhbmNob3IuY291bnQgKiBhbmNob3IuYWxpYXNDb3VudCA+IG1heEFsaWFzQ291bnQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gJ0V4Y2Vzc2l2ZSBhbGlhcyBjb3VudCBpbmRpY2F0ZXMgYSByZXNvdXJjZSBleGhhdXN0aW9uIGF0dGFjayc7XG4gICAgICAgIGlmICh0aGlzLmNzdE5vZGUpIHRocm93IG5ldyBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLllBTUxSZWZlcmVuY2VFcnJvcih0aGlzLmNzdE5vZGUsIG1zZyk7ZWxzZSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5jaG9yLnJlcztcbiAgfSAvLyBPbmx5IGNhbGxlZCB3aGVuIHN0cmluZ2lmeWluZyBhbiBhbGlhcyBtYXBwaW5nIGtleSB3aGlsZSBjb25zdHJ1Y3RpbmdcbiAgLy8gT2JqZWN0IG91dHB1dC5cblxuXG4gIHRvU3RyaW5nKGN0eCkge1xuICAgIHJldHVybiBBbGlhcy5zdHJpbmdpZnkodGhpcywgY3R4KTtcbiAgfVxuXG59XG5cbl9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuX2RlZmluZVByb3BlcnR5KEFsaWFzLCBcImRlZmF1bHRcIiwgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGZpbmRQYWlyKGl0ZW1zLCBrZXkpIHtcbiAgY29uc3QgayA9IGtleSBpbnN0YW5jZW9mIFNjYWxhciA/IGtleS52YWx1ZSA6IGtleTtcblxuICBmb3IgKGNvbnN0IGl0IG9mIGl0ZW1zKSB7XG4gICAgaWYgKGl0IGluc3RhbmNlb2YgUGFpcikge1xuICAgICAgaWYgKGl0LmtleSA9PT0ga2V5IHx8IGl0LmtleSA9PT0gaykgcmV0dXJuIGl0O1xuICAgICAgaWYgKGl0LmtleSAmJiBpdC5rZXkudmFsdWUgPT09IGspIHJldHVybiBpdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgWUFNTE1hcCBleHRlbmRzIENvbGxlY3Rpb24ge1xuICBhZGQocGFpciwgb3ZlcndyaXRlKSB7XG4gICAgaWYgKCFwYWlyKSBwYWlyID0gbmV3IFBhaXIocGFpcik7ZWxzZSBpZiAoIShwYWlyIGluc3RhbmNlb2YgUGFpcikpIHBhaXIgPSBuZXcgUGFpcihwYWlyLmtleSB8fCBwYWlyLCBwYWlyLnZhbHVlKTtcbiAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywgcGFpci5rZXkpO1xuICAgIGNvbnN0IHNvcnRFbnRyaWVzID0gdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuc29ydE1hcEVudHJpZXM7XG5cbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKCFvdmVyd3JpdGUpIHRocm93IG5ldyBFcnJvcihgS2V5ICR7cGFpci5rZXl9IGFscmVhZHkgc2V0YCk7IC8vIEZvciBzY2FsYXJzLCBrZWVwIHRoZSBvbGQgbm9kZSAmIGl0cyBjb21tZW50cyBhbmQgYW5jaG9yc1xuXG4gICAgICBpZiAocHJldi52YWx1ZSBpbnN0YW5jZW9mIFNjYWxhciAmJiBpc1NjYWxhclZhbHVlKHBhaXIudmFsdWUpKSBwcmV2LnZhbHVlLnZhbHVlID0gcGFpci52YWx1ZTtlbHNlIHByZXYudmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAoc29ydEVudHJpZXMpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLml0ZW1zLmZpbmRJbmRleChpdGVtID0+IHNvcnRFbnRyaWVzKHBhaXIsIGl0ZW0pIDwgMCk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHRoaXMuaXRlbXMucHVzaChwYWlyKTtlbHNlIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIHBhaXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLml0ZW1zLnB1c2gocGFpcik7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlKGtleSkge1xuICAgIGNvbnN0IGl0ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICBpZiAoIWl0KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKGl0KSwgMSk7XG4gICAgcmV0dXJuIGRlbC5sZW5ndGggPiAwO1xuICB9XG5cbiAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgIGNvbnN0IGl0ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICBjb25zdCBub2RlID0gaXQgJiYgaXQudmFsdWU7XG4gICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIG5vZGUgaW5zdGFuY2VvZiBTY2FsYXIgPyBub2RlLnZhbHVlIDogbm9kZTtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICB9XG5cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmFkZChuZXcgUGFpcihrZXksIHZhbHVlKSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBjdHggLSBDb252ZXJzaW9uIGNvbnRleHQsIG9yaWdpbmFsbHkgc2V0IGluIERvY3VtZW50I3RvSlMoKVxuICAgKiBAcGFyYW0ge0NsYXNzfSBUeXBlIC0gSWYgc2V0LCBmb3JjZXMgdGhlIHJldHVybmVkIGNvbGxlY3Rpb24gdHlwZVxuICAgKiBAcmV0dXJucyBJbnN0YW5jZSBvZiBUeXBlLCBNYXAsIG9yIE9iamVjdFxuICAgKi9cblxuXG4gIHRvSlNPTihfLCBjdHgsIFR5cGUpIHtcbiAgICBjb25zdCBtYXAgPSBUeXBlID8gbmV3IFR5cGUoKSA6IGN0eCAmJiBjdHgubWFwQXNNYXAgPyBuZXcgTWFwKCkgOiB7fTtcbiAgICBpZiAoY3R4ICYmIGN0eC5vbkNyZWF0ZSkgY3R4Lm9uQ3JlYXRlKG1hcCk7XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykgaXRlbS5hZGRUb0pTTWFwKGN0eCwgbWFwKTtcblxuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBpZiAoIWN0eCkgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBQYWlyKSkgdGhyb3cgbmV3IEVycm9yKGBNYXAgaXRlbXMgbXVzdCBhbGwgYmUgcGFpcnM7IGZvdW5kICR7SlNPTi5zdHJpbmdpZnkoaXRlbSl9IGluc3RlYWRgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIudG9TdHJpbmcoY3R4LCB7XG4gICAgICBibG9ja0l0ZW06IG4gPT4gbi5zdHIsXG4gICAgICBmbG93Q2hhcnM6IHtcbiAgICAgICAgc3RhcnQ6ICd7JyxcbiAgICAgICAgZW5kOiAnfSdcbiAgICAgIH0sXG4gICAgICBpc01hcDogdHJ1ZSxcbiAgICAgIGl0ZW1JbmRlbnQ6IGN0eC5pbmRlbnQgfHwgJydcbiAgICB9LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfVxuXG59XG5cbmNvbnN0IGJpbmFyeU9wdGlvbnMgPSB7XG4gIGRlZmF1bHRUeXBlOiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxPQ0tfTElURVJBTCxcbiAgbGluZVdpZHRoOiA3NlxufTtcbmNvbnN0IGJvb2xPcHRpb25zID0ge1xuICB0cnVlU3RyOiAndHJ1ZScsXG4gIGZhbHNlU3RyOiAnZmFsc2UnXG59O1xuY29uc3QgaW50T3B0aW9ucyA9IHtcbiAgYXNCaWdJbnQ6IGZhbHNlXG59O1xuY29uc3QgbnVsbE9wdGlvbnMgPSB7XG4gIG51bGxTdHI6ICdudWxsJ1xufTtcbmNvbnN0IHN0ck9wdGlvbnMgPSB7XG4gIGRlZmF1bHRUeXBlOiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuUExBSU4sXG4gIGRlZmF1bHRLZXlUeXBlOiBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuUExBSU4sXG4gIGRlZmF1bHRRdW90ZVNpbmdsZTogZmFsc2UsXG4gIGRvdWJsZVF1b3RlZDoge1xuICAgIGpzb25FbmNvZGluZzogZmFsc2UsXG4gICAgbWluTXVsdGlMaW5lTGVuZ3RoOiA0MFxuICB9LFxuICBmb2xkOiB7XG4gICAgbGluZVdpZHRoOiA4MCxcbiAgICBtaW5Db250ZW50V2lkdGg6IDIwXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVTY2FsYXIoc3RyLCB0YWdzKSB7XG4gIGZvciAoY29uc3Qge1xuICAgIGZvcm1hdCxcbiAgICB0ZXN0LFxuICAgIHJlc29sdmVcbiAgfSBvZiB0YWdzKSB7XG4gICAgaWYgKHRlc3QgJiYgdGVzdC50ZXN0KHN0cikpIHtcbiAgICAgIGxldCByZXMgPSByZXNvbHZlKHN0cik7XG4gICAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiBTY2FsYXIpKSByZXMgPSBuZXcgU2NhbGFyKHJlcyk7XG4gICAgICBpZiAoZm9ybWF0KSByZXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNjYWxhcihzdHIpOyAvLyBmYWxsYmFjayB0byBzdHJpbmdcbn1cblxuY29uc3QgRk9MRF9GTE9XID0gJ2Zsb3cnO1xuY29uc3QgRk9MRF9CTE9DSyA9ICdibG9jayc7XG5jb25zdCBGT0xEX1FVT1RFRCA9ICdxdW90ZWQnOyAvLyBwcmVzdW1lcyBpKzEgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZVxuLy8gcmV0dXJucyBpbmRleCBvZiBsYXN0IG5ld2xpbmUgaW4gbW9yZS1pbmRlbnRlZCBibG9ja1xuXG5jb25zdCBjb25zdW1lTW9yZUluZGVudGVkTGluZXMgPSAodGV4dCwgaSkgPT4ge1xuICBsZXQgY2ggPSB0ZXh0W2kgKyAxXTtcblxuICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICBkbyB7XG4gICAgICBjaCA9IHRleHRbaSArPSAxXTtcbiAgICB9IHdoaWxlIChjaCAmJiBjaCAhPT0gJ1xcbicpO1xuXG4gICAgY2ggPSB0ZXh0W2kgKyAxXTtcbiAgfVxuXG4gIHJldHVybiBpO1xufTtcbi8qKlxuICogVHJpZXMgdG8ga2VlcCBpbnB1dCBhdCB1cCB0byBgbGluZVdpZHRoYCBjaGFyYWN0ZXJzLCBzcGxpdHRpbmcgb25seSBvbiBzcGFjZXNcbiAqIG5vdCBmb2xsb3dlZCBieSBuZXdsaW5lcyBvciBzcGFjZXMgdW5sZXNzIGBtb2RlYCBpcyBgJ3F1b3RlZCdgLiBMaW5lcyBhcmVcbiAqIHRlcm1pbmF0ZWQgd2l0aCBgXFxuYCBhbmQgc3RhcnRlZCB3aXRoIGBpbmRlbnRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW21vZGU9J2Zsb3cnXSBgJ2Jsb2NrJ2AgcHJldmVudHMgbW9yZS1pbmRlbnRlZCBsaW5lc1xuICogICBmcm9tIGJlaW5nIGZvbGRlZDsgYCdxdW90ZWQnYCBhbGxvd3MgZm9yIGBcXGAgZXNjYXBlcywgaW5jbHVkaW5nIGVzY2FwZWRcbiAqICAgbmV3bGluZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaW5kZW50QXRTdGFydF0gQWNjb3VudHMgZm9yIGxlYWRpbmcgY29udGVudHMgb25cbiAqICAgdGhlIGZpcnN0IGxpbmUsIGRlZmF1bHRpbmcgdG8gYGluZGVudC5sZW5ndGhgXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGluZVdpZHRoPTgwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pbkNvbnRlbnRXaWR0aD0yMF0gQWxsb3cgaGlnaGx5IGluZGVudGVkIGxpbmVzIHRvXG4gKiAgIHN0cmV0Y2ggdGhlIGxpbmUgd2lkdGggb3IgaW5kZW50IGNvbnRlbnQgZnJvbSB0aGUgc3RhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMub25Gb2xkIENhbGxlZCBvbmNlIGlmIHRoZSB0ZXh0IGlzIGZvbGRlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5vbkZvbGQgQ2FsbGVkIG9uY2UgaWYgYW55IGxpbmUgb2YgdGV4dCBleGNlZWRzXG4gKiAgIGxpbmVXaWR0aCBjaGFyYWN0ZXJzXG4gKi9cblxuXG5mdW5jdGlvbiBmb2xkRmxvd0xpbmVzKHRleHQsIGluZGVudCwgbW9kZSwge1xuICBpbmRlbnRBdFN0YXJ0LFxuICBsaW5lV2lkdGggPSA4MCxcbiAgbWluQ29udGVudFdpZHRoID0gMjAsXG4gIG9uRm9sZCxcbiAgb25PdmVyZmxvd1xufSkge1xuICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKSByZXR1cm4gdGV4dDtcbiAgY29uc3QgZW5kU3RlcCA9IE1hdGgubWF4KDEgKyBtaW5Db250ZW50V2lkdGgsIDEgKyBsaW5lV2lkdGggLSBpbmRlbnQubGVuZ3RoKTtcbiAgaWYgKHRleHQubGVuZ3RoIDw9IGVuZFN0ZXApIHJldHVybiB0ZXh0O1xuICBjb25zdCBmb2xkcyA9IFtdO1xuICBjb25zdCBlc2NhcGVkRm9sZHMgPSB7fTtcbiAgbGV0IGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudC5sZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiBpbmRlbnRBdFN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgIGlmIChpbmRlbnRBdFN0YXJ0ID4gbGluZVdpZHRoIC0gTWF0aC5tYXgoMiwgbWluQ29udGVudFdpZHRoKSkgZm9sZHMucHVzaCgwKTtlbHNlIGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudEF0U3RhcnQ7XG4gIH1cblxuICBsZXQgc3BsaXQgPSB1bmRlZmluZWQ7XG4gIGxldCBwcmV2ID0gdW5kZWZpbmVkO1xuICBsZXQgb3ZlcmZsb3cgPSBmYWxzZTtcbiAgbGV0IGkgPSAtMTtcblxuICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSykge1xuICAgIGkgPSBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSk7XG4gICAgaWYgKGkgIT09IC0xKSBlbmQgPSBpICsgZW5kU3RlcDtcbiAgfVxuXG4gIGZvciAobGV0IGNoOyBjaCA9IHRleHRbaSArPSAxXTspIHtcbiAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgY2ggPT09ICdcXFxcJykge1xuICAgICAgc3dpdGNoICh0ZXh0W2kgKyAxXSkge1xuICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgaSArPSA1O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSykgaSA9IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpKTtcbiAgICAgIGVuZCA9IGkgKyBlbmRTdGVwO1xuICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaCA9PT0gJyAnICYmIHByZXYgJiYgcHJldiAhPT0gJyAnICYmIHByZXYgIT09ICdcXG4nICYmIHByZXYgIT09ICdcXHQnKSB7XG4gICAgICAgIC8vIHNwYWNlIHN1cnJvdW5kZWQgYnkgbm9uLXNwYWNlIGNhbiBiZSByZXBsYWNlZCB3aXRoIG5ld2xpbmUgKyBpbmRlbnRcbiAgICAgICAgY29uc3QgbmV4dCA9IHRleHRbaSArIDFdO1xuICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSAnICcgJiYgbmV4dCAhPT0gJ1xcbicgJiYgbmV4dCAhPT0gJ1xcdCcpIHNwbGl0ID0gaTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPj0gZW5kKSB7XG4gICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgIGZvbGRzLnB1c2goc3BsaXQpO1xuICAgICAgICAgIGVuZCA9IHNwbGl0ICsgZW5kU3RlcDtcbiAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCkge1xuICAgICAgICAgIC8vIHdoaXRlLXNwYWNlIGNvbGxlY3RlZCBhdCBlbmQgbWF5IHN0cmV0Y2ggcGFzdCBsaW5lV2lkdGhcbiAgICAgICAgICB3aGlsZSAocHJldiA9PT0gJyAnIHx8IHByZXYgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBwcmV2ID0gY2g7XG4gICAgICAgICAgICBjaCA9IHRleHRbaSArPSAxXTtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIGkgLSAyIGFjY291bnRzIGZvciBub3QtZHJvcHBlZCBsYXN0IGNoYXIgKyBuZXdsaW5lLWVzY2FwaW5nIFxcXG5cblxuICAgICAgICAgIGZvbGRzLnB1c2goaSAtIDIpO1xuICAgICAgICAgIGVzY2FwZWRGb2xkc1tpIC0gMl0gPSB0cnVlO1xuICAgICAgICAgIGVuZCA9IGkgLSAyICsgZW5kU3RlcDtcbiAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2ID0gY2g7XG4gIH1cblxuICBpZiAob3ZlcmZsb3cgJiYgb25PdmVyZmxvdykgb25PdmVyZmxvdygpO1xuICBpZiAoZm9sZHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGV4dDtcbiAgaWYgKG9uRm9sZCkgb25Gb2xkKCk7XG4gIGxldCByZXMgPSB0ZXh0LnNsaWNlKDAsIGZvbGRzWzBdKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgZm9sZCA9IGZvbGRzW2ldO1xuICAgIGNvbnN0IGVuZCA9IGZvbGRzW2kgKyAxXSB8fCB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoZm9sZCA9PT0gMCkgcmVzID0gYFxcbiR7aW5kZW50fSR7dGV4dC5zbGljZSgwLCBlbmQpfWA7ZWxzZSB7XG4gICAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgZXNjYXBlZEZvbGRzW2ZvbGRdKSByZXMgKz0gYCR7dGV4dFtmb2xkXX1cXFxcYDtcbiAgICAgIHJlcyArPSBgXFxuJHtpbmRlbnR9JHt0ZXh0LnNsaWNlKGZvbGQgKyAxLCBlbmQpfWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgZ2V0Rm9sZE9wdGlvbnMgPSAoe1xuICBpbmRlbnRBdFN0YXJ0XG59KSA9PiBpbmRlbnRBdFN0YXJ0ID8gT2JqZWN0LmFzc2lnbih7XG4gIGluZGVudEF0U3RhcnRcbn0sIHN0ck9wdGlvbnMuZm9sZCkgOiBzdHJPcHRpb25zLmZvbGQ7IC8vIEFsc28gY2hlY2tzIGZvciBsaW5lcyBzdGFydGluZyB3aXRoICUsIGFzIHBhcnNpbmcgdGhlIG91dHB1dCBhcyBZQU1MIDEuMSB3aWxsXG4vLyBwcmVzdW1lIHRoYXQncyBzdGFydGluZyBhIG5ldyBkb2N1bWVudC5cblxuXG5jb25zdCBjb250YWluc0RvY3VtZW50TWFya2VyID0gc3RyID0+IC9eKCV8LS0tfFxcLlxcLlxcLikvbS50ZXN0KHN0cik7XG5cbmZ1bmN0aW9uIGxpbmVMZW5ndGhPdmVyTGltaXQoc3RyLCBsaW1pdCkge1xuICBjb25zdCBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuICBpZiAoc3RyTGVuIDw9IGxpbWl0KSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gMDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gJ1xcbicpIHtcbiAgICAgIGlmIChpIC0gc3RhcnQgPiBsaW1pdCkgcmV0dXJuIHRydWU7XG4gICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgaWYgKHN0ckxlbiAtIHN0YXJ0IDw9IGxpbWl0KSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBpbXBsaWNpdEtleVxuICB9ID0gY3R4O1xuICBjb25zdCB7XG4gICAganNvbkVuY29kaW5nLFxuICAgIG1pbk11bHRpTGluZUxlbmd0aFxuICB9ID0gc3RyT3B0aW9ucy5kb3VibGVRdW90ZWQ7XG4gIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIGlmIChqc29uRW5jb2RpbmcpIHJldHVybiBqc29uO1xuICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gIGxldCBzdHIgPSAnJztcbiAgbGV0IHN0YXJ0ID0gMDtcblxuICBmb3IgKGxldCBpID0gMCwgY2ggPSBqc29uW2ldOyBjaDsgY2ggPSBqc29uWysraV0pIHtcbiAgICBpZiAoY2ggPT09ICcgJyAmJiBqc29uW2kgKyAxXSA9PT0gJ1xcXFwnICYmIGpzb25baSArIDJdID09PSAnbicpIHtcbiAgICAgIC8vIHNwYWNlIGJlZm9yZSBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcXFwgJztcbiAgICAgIGkgKz0gMTtcbiAgICAgIHN0YXJ0ID0gaTtcbiAgICAgIGNoID0gJ1xcXFwnO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJ1xcXFwnKSBzd2l0Y2ggKGpzb25baSArIDFdKSB7XG4gICAgICBjYXNlICd1JzpcbiAgICAgICAge1xuICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICBjb25zdCBjb2RlID0ganNvbi5zdWJzdHIoaSArIDIsIDQpO1xuXG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlICcwMDAwJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcMCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDA3JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcYSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDBiJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDFiJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcZSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDg1JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMGEwJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcXyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcyMDI4JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcyMDI5JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcUCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoY29kZS5zdWJzdHIoMCwgMikgPT09ICcwMCcpIHN0ciArPSAnXFxcXHgnICsgY29kZS5zdWJzdHIoMik7ZWxzZSBzdHIgKz0ganNvbi5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA1O1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ24nOlxuICAgICAgICBpZiAoaW1wbGljaXRLZXkgfHwganNvbltpICsgMl0gPT09ICdcIicgfHwganNvbi5sZW5ndGggPCBtaW5NdWx0aUxpbmVMZW5ndGgpIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZm9sZGluZyB3aWxsIGVhdCBmaXJzdCBuZXdsaW5lXG4gICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcblxcbic7XG5cbiAgICAgICAgICB3aGlsZSAoanNvbltpICsgMl0gPT09ICdcXFxcJyAmJiBqc29uW2kgKyAzXSA9PT0gJ24nICYmIGpzb25baSArIDRdICE9PSAnXCInKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyICs9IGluZGVudDsgLy8gc3BhY2UgYWZ0ZXIgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcblxuICAgICAgICAgIGlmIChqc29uW2kgKyAyXSA9PT0gJyAnKSBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGkgKz0gMTtcbiAgICB9XG4gIH1cblxuICBzdHIgPSBzdGFydCA/IHN0ciArIGpzb24uc2xpY2Uoc3RhcnQpIDoganNvbjtcbiAgcmV0dXJuIGltcGxpY2l0S2V5ID8gc3RyIDogZm9sZEZsb3dMaW5lcyhzdHIsIGluZGVudCwgRk9MRF9RVU9URUQsIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICBpZiAoY3R4LmltcGxpY2l0S2V5KSB7XG4gICAgaWYgKC9cXG4vLnRlc3QodmFsdWUpKSByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHNpbmdsZSBxdW90ZWQgc3RyaW5nIGNhbid0IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBuZXdsaW5lXG4gICAgaWYgKC9bIFxcdF1cXG58XFxuWyBcXHRdLy50ZXN0KHZhbHVlKSkgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgfVxuXG4gIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgY29uc3QgcmVzID0gXCInXCIgKyB2YWx1ZS5yZXBsYWNlKC8nL2csIFwiJydcIikucmVwbGFjZSgvXFxuKy9nLCBgJCZcXG4ke2luZGVudH1gKSArIFwiJ1wiO1xuICByZXR1cm4gY3R4LmltcGxpY2l0S2V5ID8gcmVzIDogZm9sZEZsb3dMaW5lcyhyZXMsIGluZGVudCwgRk9MRF9GTE9XLCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcbn1cblxuZnVuY3Rpb24gYmxvY2tTdHJpbmcoe1xuICBjb21tZW50LFxuICB0eXBlLFxuICB2YWx1ZVxufSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gIC8vIDEuIEJsb2NrIGNhbid0IGVuZCBpbiB3aGl0ZXNwYWNlIHVubGVzcyB0aGUgbGFzdCBsaW5lIGlzIG5vbi1lbXB0eS5cbiAgLy8gMi4gU3RyaW5ncyBjb25zaXN0aW5nIG9mIG9ubHkgd2hpdGVzcGFjZSBhcmUgYmVzdCByZW5kZXJlZCBleHBsaWNpdGx5LlxuICBpZiAoL1xcbltcXHQgXSskLy50ZXN0KHZhbHVlKSB8fCAvXlxccyokLy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gIH1cblxuICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjdHguZm9yY2VCbG9ja0luZGVudCB8fCBjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gIGNvbnN0IGluZGVudFNpemUgPSBpbmRlbnQgPyAnMicgOiAnMSc7IC8vIHJvb3QgaXMgYXQgLTFcblxuICBjb25zdCBsaXRlcmFsID0gdHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkJMT0NLX0ZPTERFRCA/IGZhbHNlIDogdHlwZSA9PT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLkJMT0NLX0xJVEVSQUwgPyB0cnVlIDogIWxpbmVMZW5ndGhPdmVyTGltaXQodmFsdWUsIHN0ck9wdGlvbnMuZm9sZC5saW5lV2lkdGggLSBpbmRlbnQubGVuZ3RoKTtcbiAgbGV0IGhlYWRlciA9IGxpdGVyYWwgPyAnfCcgOiAnPic7XG4gIGlmICghdmFsdWUpIHJldHVybiBoZWFkZXIgKyAnXFxuJztcbiAgbGV0IHdzU3RhcnQgPSAnJztcbiAgbGV0IHdzRW5kID0gJyc7XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW1xcblxcdCBdKiQvLCB3cyA9PiB7XG4gICAgY29uc3QgbiA9IHdzLmluZGV4T2YoJ1xcbicpO1xuXG4gICAgaWYgKG4gPT09IC0xKSB7XG4gICAgICBoZWFkZXIgKz0gJy0nOyAvLyBzdHJpcFxuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHdzIHx8IG4gIT09IHdzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGhlYWRlciArPSAnKyc7IC8vIGtlZXBcblxuICAgICAgaWYgKG9uQ2hvbXBLZWVwKSBvbkNob21wS2VlcCgpO1xuICAgIH1cblxuICAgIHdzRW5kID0gd3MucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICByZXR1cm4gJyc7XG4gIH0pLnJlcGxhY2UoL15bXFxuIF0qLywgd3MgPT4ge1xuICAgIGlmICh3cy5pbmRleE9mKCcgJykgIT09IC0xKSBoZWFkZXIgKz0gaW5kZW50U2l6ZTtcbiAgICBjb25zdCBtID0gd3MubWF0Y2goLyArJC8pO1xuXG4gICAgaWYgKG0pIHtcbiAgICAgIHdzU3RhcnQgPSB3cy5zbGljZSgwLCAtbVswXS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIG1bMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHdzU3RhcnQgPSB3cztcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0pO1xuICBpZiAod3NFbmQpIHdzRW5kID0gd3NFbmQucmVwbGFjZSgvXFxuKyg/IVxcbnwkKS9nLCBgJCYke2luZGVudH1gKTtcbiAgaWYgKHdzU3RhcnQpIHdzU3RhcnQgPSB3c1N0YXJ0LnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG5cbiAgaWYgKGNvbW1lbnQpIHtcbiAgICBoZWFkZXIgKz0gJyAjJyArIGNvbW1lbnQucmVwbGFjZSgvID9bXFxyXFxuXSsvZywgJyAnKTtcbiAgICBpZiAob25Db21tZW50KSBvbkNvbW1lbnQoKTtcbiAgfVxuXG4gIGlmICghdmFsdWUpIHJldHVybiBgJHtoZWFkZXJ9JHtpbmRlbnRTaXplfVxcbiR7aW5kZW50fSR7d3NFbmR9YDtcblxuICBpZiAobGl0ZXJhbCkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICByZXR1cm4gYCR7aGVhZGVyfVxcbiR7aW5kZW50fSR7d3NTdGFydH0ke3ZhbHVlfSR7d3NFbmR9YDtcbiAgfVxuXG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxuKy9nLCAnXFxuJCYnKS5yZXBsYWNlKC8oPzpefFxcbikoW1xcdCBdLiopKD86KFtcXG5cXHQgXSopXFxuKD8hW1xcblxcdCBdKSk/L2csICckMSQyJykgLy8gbW9yZS1pbmRlbnRlZCBsaW5lcyBhcmVuJ3QgZm9sZGVkXG4gIC8vICAgICAgICAgXiBpbmQubGluZSAgXiBlbXB0eSAgICAgXiBjYXB0dXJlIG5leHQgZW1wdHkgbGluZXMgb25seSBhdCBlbmQgb2YgaW5kZW50XG4gIC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICBjb25zdCBib2R5ID0gZm9sZEZsb3dMaW5lcyhgJHt3c1N0YXJ0fSR7dmFsdWV9JHt3c0VuZH1gLCBpbmRlbnQsIEZPTERfQkxPQ0ssIHN0ck9wdGlvbnMuZm9sZCk7XG4gIHJldHVybiBgJHtoZWFkZXJ9XFxuJHtpbmRlbnR9JHtib2R5fWA7XG59XG5cbmZ1bmN0aW9uIHBsYWluU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICBjb25zdCB7XG4gICAgY29tbWVudCxcbiAgICB0eXBlLFxuICAgIHZhbHVlXG4gIH0gPSBpdGVtO1xuICBjb25zdCB7XG4gICAgYWN0dWFsU3RyaW5nLFxuICAgIGltcGxpY2l0S2V5LFxuICAgIGluZGVudCxcbiAgICBpbkZsb3dcbiAgfSA9IGN0eDtcblxuICBpZiAoaW1wbGljaXRLZXkgJiYgL1tcXG5bXFxde30sXS8udGVzdCh2YWx1ZSkgfHwgaW5GbG93ICYmIC9bW1xcXXt9LF0vLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgfVxuXG4gIGlmICghdmFsdWUgfHwgL15bXFxuXFx0ICxbXFxde30jJiohfD4nXCIlQGBdfF5bPy1dJHxeWz8tXVsgXFx0XXxbXFxuOl1bIFxcdF18WyBcXHRdXFxufFtcXG5cXHQgXSN8W1xcblxcdCA6XSQvLnRlc3QodmFsdWUpKSB7XG4gICAgY29uc3QgaGFzRG91YmxlID0gdmFsdWUuaW5kZXhPZignXCInKSAhPT0gLTE7XG4gICAgY29uc3QgaGFzU2luZ2xlID0gdmFsdWUuaW5kZXhPZihcIidcIikgIT09IC0xO1xuICAgIGxldCBxdW90ZWRTdHJpbmc7XG5cbiAgICBpZiAoaGFzRG91YmxlICYmICFoYXNTaW5nbGUpIHtcbiAgICAgIHF1b3RlZFN0cmluZyA9IHNpbmdsZVF1b3RlZFN0cmluZztcbiAgICB9IGVsc2UgaWYgKGhhc1NpbmdsZSAmJiAhaGFzRG91YmxlKSB7XG4gICAgICBxdW90ZWRTdHJpbmcgPSBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgfSBlbHNlIGlmIChzdHJPcHRpb25zLmRlZmF1bHRRdW90ZVNpbmdsZSkge1xuICAgICAgcXVvdGVkU3RyaW5nID0gc2luZ2xlUXVvdGVkU3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdW90ZWRTdHJpbmcgPSBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgfSAvLyBub3QgYWxsb3dlZDpcbiAgICAvLyAtIGVtcHR5IHN0cmluZywgJy0nIG9yICc/J1xuICAgIC8vIC0gc3RhcnQgd2l0aCBhbiBpbmRpY2F0b3IgY2hhcmFjdGVyIChleGNlcHQgWz86LV0pIG9yIC9bPy1dIC9cbiAgICAvLyAtICdcXG4gJywgJzogJyBvciAnIFxcbicgYW55d2hlcmVcbiAgICAvLyAtICcjJyBub3QgcHJlY2VkZWQgYnkgYSBub24tc3BhY2UgY2hhclxuICAgIC8vIC0gZW5kIHdpdGggJyAnIG9yICc6J1xuXG5cbiAgICByZXR1cm4gaW1wbGljaXRLZXkgfHwgaW5GbG93IHx8IHZhbHVlLmluZGV4T2YoJ1xcbicpID09PSAtMSA/IHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSA6IGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIH1cblxuICBpZiAoIWltcGxpY2l0S2V5ICYmICFpbkZsb3cgJiYgdHlwZSAhPT0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlBMQUlOICYmIHZhbHVlLmluZGV4T2YoJ1xcbicpICE9PSAtMSkge1xuICAgIC8vIFdoZXJlIGFsbG93ZWQgJiB0eXBlIG5vdCBzZXQgZXhwbGljaXRseSwgcHJlZmVyIGJsb2NrIHN0eWxlIGZvciBtdWx0aWxpbmUgc3RyaW5nc1xuICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICB9XG5cbiAgaWYgKGluZGVudCA9PT0gJycgJiYgY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkpIHtcbiAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9IHRydWU7XG4gICAgcmV0dXJuIGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIH1cblxuICBjb25zdCBzdHIgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApOyAvLyBWZXJpZnkgdGhhdCBvdXRwdXQgd2lsbCBiZSBwYXJzZWQgYXMgYSBzdHJpbmcsIGFzIGUuZy4gcGxhaW4gbnVtYmVycyBhbmRcbiAgLy8gYm9vbGVhbnMgZ2V0IHBhcnNlZCB3aXRoIHRob3NlIHR5cGVzIGluIHYxLjIgKGUuZy4gJzQyJywgJ3RydWUnICYgJzAuOWUtMycpLFxuICAvLyBhbmQgb3RoZXJzIGluIHYxLjEuXG5cbiAgaWYgKGFjdHVhbFN0cmluZykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhZ3NcbiAgICB9ID0gY3R4LmRvYy5zY2hlbWE7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlU2NhbGFyKHN0ciwgdGFncykudmFsdWU7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlZCAhPT0gJ3N0cmluZycpIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gIH1cblxuICBjb25zdCBib2R5ID0gaW1wbGljaXRLZXkgPyBzdHIgOiBmb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBGT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCkpO1xuXG4gIGlmIChjb21tZW50ICYmICFpbkZsb3cgJiYgKGJvZHkuaW5kZXhPZignXFxuJykgIT09IC0xIHx8IGNvbW1lbnQuaW5kZXhPZignXFxuJykgIT09IC0xKSkge1xuICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICAgIHJldHVybiBhZGRDb21tZW50QmVmb3JlKGJvZHksIGluZGVudCwgY29tbWVudCk7XG4gIH1cblxuICByZXR1cm4gYm9keTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5U3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICBjb25zdCB7XG4gICAgZGVmYXVsdEtleVR5cGUsXG4gICAgZGVmYXVsdFR5cGVcbiAgfSA9IHN0ck9wdGlvbnM7XG4gIGNvbnN0IHtcbiAgICBpbXBsaWNpdEtleSxcbiAgICBpbkZsb3dcbiAgfSA9IGN0eDtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIHZhbHVlXG4gIH0gPSBpdGVtO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBpdGVtLCB7XG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHR5cGUgIT09IF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5RVU9URV9ET1VCTEUpIHtcbiAgICAvLyBmb3JjZSBkb3VibGUgcXVvdGVzIG9uIGNvbnRyb2wgY2hhcmFjdGVycyAmIHVucGFpcmVkIHN1cnJvZ2F0ZXNcbiAgICBpZiAoL1tcXHgwMC1cXHgwOFxceDBiLVxceDFmXFx4N2YtXFx4OWZcXHV7RDgwMH0tXFx1e0RGRkZ9XS91LnRlc3QodmFsdWUpKSB0eXBlID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlFVT1RFX0RPVUJMRTtcbiAgfVxuXG4gIGNvbnN0IF9zdHJpbmdpZnkgPSBfdHlwZSA9PiB7XG4gICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxPQ0tfRk9MREVEOlxuICAgICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuQkxPQ0tfTElURVJBTDpcbiAgICAgICAgcmV0dXJuIGltcGxpY2l0S2V5IHx8IGluRmxvdyA/IGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSAvLyBibG9ja3MgYXJlIG5vdCB2YWxpZCBpbnNpZGUgZmxvdyBjb250YWluZXJzXG4gICAgICAgIDogYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcblxuICAgICAgY2FzZSBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLlR5cGUuUVVPVEVfRE9VQkxFOlxuICAgICAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuXG4gICAgICBjYXNlIF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuVHlwZS5RVU9URV9TSU5HTEU6XG4gICAgICAgIHJldHVybiBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG5cbiAgICAgIGNhc2UgX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5UeXBlLlBMQUlOOlxuICAgICAgICByZXR1cm4gcGxhaW5TdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGxldCByZXMgPSBfc3RyaW5naWZ5KHR5cGUpO1xuXG4gIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICBjb25zdCB0ID0gaW1wbGljaXRLZXkgPyBkZWZhdWx0S2V5VHlwZSA6IGRlZmF1bHRUeXBlO1xuICAgIHJlcyA9IF9zdHJpbmdpZnkodCk7XG4gICAgaWYgKHJlcyA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZWZhdWx0IHN0cmluZyB0eXBlICR7dH1gKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU51bWJlcih7XG4gIGZvcm1hdCxcbiAgbWluRnJhY3Rpb25EaWdpdHMsXG4gIHRhZyxcbiAgdmFsdWVcbn0pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICBpZiAoIWlzRmluaXRlKHZhbHVlKSkgcmV0dXJuIGlzTmFOKHZhbHVlKSA/ICcubmFuJyA6IHZhbHVlIDwgMCA/ICctLmluZicgOiAnLmluZic7XG4gIGxldCBuID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gIGlmICghZm9ybWF0ICYmIG1pbkZyYWN0aW9uRGlnaXRzICYmICghdGFnIHx8IHRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JykgJiYgL15cXGQvLnRlc3QobikpIHtcbiAgICBsZXQgaSA9IG4uaW5kZXhPZignLicpO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBpID0gbi5sZW5ndGg7XG4gICAgICBuICs9ICcuJztcbiAgICB9XG5cbiAgICBsZXQgZCA9IG1pbkZyYWN0aW9uRGlnaXRzIC0gKG4ubGVuZ3RoIC0gaSAtIDEpO1xuXG4gICAgd2hpbGUgKGQtLSA+IDApIG4gKz0gJzAnO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbmV4cG9ydHMuQWxpYXMgPSBBbGlhcztcbmV4cG9ydHMuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xuZXhwb3J0cy5QYWlyID0gUGFpcjtcbmV4cG9ydHMuU2NhbGFyID0gU2NhbGFyO1xuZXhwb3J0cy5ZQU1MTWFwID0gWUFNTE1hcDtcbmV4cG9ydHMuWUFNTFNlcSA9IFlBTUxTZXE7XG5leHBvcnRzLmFkZENvbW1lbnQgPSBhZGRDb21tZW50O1xuZXhwb3J0cy5iaW5hcnlPcHRpb25zID0gYmluYXJ5T3B0aW9ucztcbmV4cG9ydHMuYm9vbE9wdGlvbnMgPSBib29sT3B0aW9ucztcbmV4cG9ydHMuY29sbGVjdGlvbkZyb21QYXRoID0gY29sbGVjdGlvbkZyb21QYXRoO1xuZXhwb3J0cy5jcmVhdGVOb2RlID0gY3JlYXRlTm9kZTtcbmV4cG9ydHMuY3JlYXRlUGFpciA9IGNyZWF0ZVBhaXI7XG5leHBvcnRzLmZpbmRQYWlyID0gZmluZFBhaXI7XG5leHBvcnRzLmludE9wdGlvbnMgPSBpbnRPcHRpb25zO1xuZXhwb3J0cy5pc0VtcHR5UGF0aCA9IGlzRW1wdHlQYXRoO1xuZXhwb3J0cy5udWxsT3B0aW9ucyA9IG51bGxPcHRpb25zO1xuZXhwb3J0cy5yZXNvbHZlU2NhbGFyID0gcmVzb2x2ZVNjYWxhcjtcbmV4cG9ydHMuc3RyT3B0aW9ucyA9IHN0ck9wdGlvbnM7XG5leHBvcnRzLnN0cmluZ2lmeU51bWJlciA9IHN0cmluZ2lmeU51bWJlcjtcbmV4cG9ydHMuc3RyaW5naWZ5U3RyaW5nID0gc3RyaW5naWZ5U3RyaW5nO1xuZXhwb3J0cy50b0pTID0gdG9KUztcbiJdLCJuYW1lcyI6WyJfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzIiwicmVxdWlyZSIsImFkZENvbW1lbnRCZWZvcmUiLCJzdHIiLCJpbmRlbnQiLCJjb21tZW50IiwiY2MiLCJyZXBsYWNlIiwiYWRkQ29tbWVudCIsImluZGV4T2YiLCJOb2RlIiwidG9KUyIsInZhbHVlIiwiYXJnIiwiY3R4IiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwidiIsImkiLCJTdHJpbmciLCJ0b0pTT04iLCJhbmNob3IiLCJhbmNob3JzIiwiZ2V0Iiwib25DcmVhdGUiLCJyZXMiLCJrZWVwIiwiTnVtYmVyIiwiaXNTY2FsYXJWYWx1ZSIsIlNjYWxhciIsImNvbnN0cnVjdG9yIiwidG9TdHJpbmciLCJmaW5kVGFnT2JqZWN0IiwidGFnTmFtZSIsInRhZ3MiLCJtYXRjaCIsImZpbHRlciIsInQiLCJ0YWciLCJ0YWdPYmoiLCJmaW5kIiwiZm9ybWF0IiwiRXJyb3IiLCJpZGVudGlmeSIsImNyZWF0ZU5vZGUiLCJvbkFsaWFzIiwib25UYWdPYmoiLCJwcmV2T2JqZWN0cyIsIndyYXBTY2FsYXJzIiwic2VxIiwic2NoZW1hIiwic3RhcnRzV2l0aCIsImRlZmF1bHRUYWdQcmVmaXgiLCJzbGljZSIsIk1hcCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwib2JqIiwidW5kZWZpbmVkIiwibm9kZSIsInByZXYiLCJzZXQiLCJjb2xsZWN0aW9uRnJvbVBhdGgiLCJwYXRoIiwibGVuZ3RoIiwiayIsImlzSW50ZWdlciIsImEiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJpc0VtcHR5UGF0aCIsIm5leHQiLCJkb25lIiwiQ29sbGVjdGlvbiIsIl9kZWZpbmVQcm9wZXJ0eSIsImFkZEluIiwiYWRkIiwia2V5IiwicmVzdCIsImRlbGV0ZUluIiwiZGVsZXRlIiwiZ2V0SW4iLCJrZWVwU2NhbGFyIiwiaGFzQWxsTnVsbFZhbHVlcyIsIml0ZW1zIiwiZXZlcnkiLCJ0eXBlIiwibiIsImNvbW1lbnRCZWZvcmUiLCJoYXNJbiIsImhhcyIsInNldEluIiwiYmxvY2tJdGVtIiwiZmxvd0NoYXJzIiwiaXNNYXAiLCJpdGVtSW5kZW50Iiwib25Db21tZW50Iiwib25DaG9tcEtlZXAiLCJpbmRlbnRTdGVwIiwic3RyaW5naWZ5IiwiaW5GbG93IiwiVHlwZSIsIkZMT1dfTUFQIiwiRkxPV19TRVEiLCJhbGxOdWxsVmFsdWVzIiwiYXNzaWduIiwiY2hvbXBLZWVwIiwiaGFzSXRlbVdpdGhOZXdMaW5lIiwibm9kZXMiLCJyZWR1Y2UiLCJpdGVtIiwic3BhY2VCZWZvcmUiLCJwdXNoIiwiZm9yRWFjaCIsImxpbmUiLCJpbmNsdWRlcyIsInN0YXJ0IiwiZW5kIiwic3RyaW5ncyIsInN1bSIsIm1heEZsb3dTdHJpbmdTaW5nbGVMaW5lTGVuZ3RoIiwicyIsImpvaW4iLCJzaGlmdCIsImFzSXRlbUluZGV4IiwiaWR4IiwiWUFNTFNlcSIsImRlbCIsInNwbGljZSIsIml0IiwiXyIsIkpTT04iLCJzdHJpbmdpZnlLZXkiLCJqc0tleSIsImRvYyIsImNyZWF0ZSIsImluU3RyaW5naWZ5S2V5IiwiY3JlYXRlUGFpciIsIlBhaXIiLCJQQUlSIiwiY2IiLCJtc2ciLCJhZGRUb0pTTWFwIiwiU2V0Iiwic3RyaW5nS2V5IiwicGFpciIsIm1hcEFzTWFwIiwiaW5kZW50U2l6ZSIsImluZGVudFNlcSIsInNpbXBsZUtleXMiLCJvcHRpb25zIiwia2V5Q29tbWVudCIsImV4cGxpY2l0S2V5IiwiQkxPQ0tfRk9MREVEIiwiQkxPQ0tfTElURVJBTCIsImltcGxpY2l0S2V5IiwidmNiIiwidmFsdWVDb21tZW50IiwiY3MiLCJpbmRlbnRBdFN0YXJ0IiwiZ2V0TmFtZSIsInN1YnN0ciIsInZhbHVlU3RyIiwid3MiLCJmbG93IiwiTUVSR0VfUEFJUiIsImdldEFsaWFzQ291bnQiLCJBbGlhcyIsInNvdXJjZSIsImNvdW50IiwiYWxpYXNDb3VudCIsImMiLCJrYyIsInZjIiwiTWF0aCIsIm1heCIsInJhbmdlIiwia2V5cyIsIm5ld05hbWUiLCJBTElBUyIsIm1heEFsaWFzQ291bnQiLCJjc3ROb2RlIiwiWUFNTFJlZmVyZW5jZUVycm9yIiwiUmVmZXJlbmNlRXJyb3IiLCJmaW5kUGFpciIsIllBTUxNYXAiLCJvdmVyd3JpdGUiLCJzb3J0RW50cmllcyIsInNvcnRNYXBFbnRyaWVzIiwiZmluZEluZGV4IiwiYmluYXJ5T3B0aW9ucyIsImRlZmF1bHRUeXBlIiwibGluZVdpZHRoIiwiYm9vbE9wdGlvbnMiLCJ0cnVlU3RyIiwiZmFsc2VTdHIiLCJpbnRPcHRpb25zIiwiYXNCaWdJbnQiLCJudWxsT3B0aW9ucyIsIm51bGxTdHIiLCJzdHJPcHRpb25zIiwiUExBSU4iLCJkZWZhdWx0S2V5VHlwZSIsImRlZmF1bHRRdW90ZVNpbmdsZSIsImRvdWJsZVF1b3RlZCIsImpzb25FbmNvZGluZyIsIm1pbk11bHRpTGluZUxlbmd0aCIsImZvbGQiLCJtaW5Db250ZW50V2lkdGgiLCJyZXNvbHZlU2NhbGFyIiwidGVzdCIsInJlc29sdmUiLCJGT0xEX0ZMT1ciLCJGT0xEX0JMT0NLIiwiRk9MRF9RVU9URUQiLCJjb25zdW1lTW9yZUluZGVudGVkTGluZXMiLCJ0ZXh0IiwiY2giLCJmb2xkRmxvd0xpbmVzIiwibW9kZSIsIm9uRm9sZCIsIm9uT3ZlcmZsb3ciLCJlbmRTdGVwIiwiZm9sZHMiLCJlc2NhcGVkRm9sZHMiLCJzcGxpdCIsIm92ZXJmbG93IiwiZ2V0Rm9sZE9wdGlvbnMiLCJjb250YWluc0RvY3VtZW50TWFya2VyIiwibGluZUxlbmd0aE92ZXJMaW1pdCIsImxpbWl0Iiwic3RyTGVuIiwiZG91YmxlUXVvdGVkU3RyaW5nIiwianNvbiIsImNvZGUiLCJzaW5nbGVRdW90ZWRTdHJpbmciLCJibG9ja1N0cmluZyIsImZvcmNlQmxvY2tJbmRlbnQiLCJsaXRlcmFsIiwiaGVhZGVyIiwid3NTdGFydCIsIndzRW5kIiwibSIsImJvZHkiLCJwbGFpblN0cmluZyIsImFjdHVhbFN0cmluZyIsImhhc0RvdWJsZSIsImhhc1NpbmdsZSIsInF1b3RlZFN0cmluZyIsInJlc29sdmVkIiwic3RyaW5naWZ5U3RyaW5nIiwiUVVPVEVfRE9VQkxFIiwiX3N0cmluZ2lmeSIsIl90eXBlIiwiUVVPVEVfU0lOR0xFIiwic3RyaW5naWZ5TnVtYmVyIiwibWluRnJhY3Rpb25EaWdpdHMiLCJpc0Zpbml0ZSIsImlzTmFOIiwiZCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/stringifyNumber-dea1120c.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/swagger-jsdoc/node_modules/yaml/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./dist */ \"(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/dist/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9ub2RlX21vZHVsZXMveWFtbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLHdIQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL25hbnRlcy1wdWJsaWMtZGF0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9ub2RlX21vZHVsZXMveWFtbC9pbmRleC5qcz81OWY2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0JylcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/node_modules/yaml/index.js\n");

/***/ })

};
;