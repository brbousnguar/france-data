/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/glob";
exports.ids = ["vendor-chunks/glob"];
exports.modules = {

/***/ "(rsc)/./node_modules/glob/common.js":
/*!*************************************!*\
  !*** ./node_modules/glob/common.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.alphasort = alphasort;\nexports.alphasorti = alphasorti;\nexports.setopts = setopts;\nexports.ownProp = ownProp;\nexports.makeAbs = makeAbs;\nexports.finish = finish;\nexports.mark = mark;\nexports.isIgnored = isIgnored;\nexports.childrenIgnored = childrenIgnored;\nfunction ownProp(obj, field) {\n    return Object.prototype.hasOwnProperty.call(obj, field);\n}\nvar path = __webpack_require__(/*! path */ \"path\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/minimatch.js\");\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"(rsc)/./node_modules/path-is-absolute/index.js\");\nvar Minimatch = minimatch.Minimatch;\nfunction alphasorti(a, b) {\n    return a.toLowerCase().localeCompare(b.toLowerCase());\n}\nfunction alphasort(a, b) {\n    return a.localeCompare(b);\n}\nfunction setupIgnores(self, options) {\n    self.ignore = options.ignore || [];\n    if (!Array.isArray(self.ignore)) self.ignore = [\n        self.ignore\n    ];\n    if (self.ignore.length) {\n        self.ignore = self.ignore.map(ignoreMap);\n    }\n}\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap(pattern) {\n    var gmatcher = null;\n    if (pattern.slice(-3) === \"/**\") {\n        var gpattern = pattern.replace(/(\\/\\*\\*)+$/, \"\");\n        gmatcher = new Minimatch(gpattern, {\n            dot: true\n        });\n    }\n    return {\n        matcher: new Minimatch(pattern, {\n            dot: true\n        }),\n        gmatcher: gmatcher\n    };\n}\nfunction setopts(self, pattern, options) {\n    if (!options) options = {};\n    // base-matching: just use globstar for that.\n    if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n        if (options.noglobstar) {\n            throw new Error(\"base matching requires globstar\");\n        }\n        pattern = \"**/\" + pattern;\n    }\n    self.silent = !!options.silent;\n    self.pattern = pattern;\n    self.strict = options.strict !== false;\n    self.realpath = !!options.realpath;\n    self.realpathCache = options.realpathCache || Object.create(null);\n    self.follow = !!options.follow;\n    self.dot = !!options.dot;\n    self.mark = !!options.mark;\n    self.nodir = !!options.nodir;\n    if (self.nodir) self.mark = true;\n    self.sync = !!options.sync;\n    self.nounique = !!options.nounique;\n    self.nonull = !!options.nonull;\n    self.nosort = !!options.nosort;\n    self.nocase = !!options.nocase;\n    self.stat = !!options.stat;\n    self.noprocess = !!options.noprocess;\n    self.absolute = !!options.absolute;\n    self.maxLength = options.maxLength || Infinity;\n    self.cache = options.cache || Object.create(null);\n    self.statCache = options.statCache || Object.create(null);\n    self.symlinks = options.symlinks || Object.create(null);\n    setupIgnores(self, options);\n    self.changedCwd = false;\n    var cwd = process.cwd();\n    if (!ownProp(options, \"cwd\")) self.cwd = cwd;\n    else {\n        self.cwd = path.resolve(options.cwd);\n        self.changedCwd = self.cwd !== cwd;\n    }\n    self.root = options.root || path.resolve(self.cwd, \"/\");\n    self.root = path.resolve(self.root);\n    if (process.platform === \"win32\") self.root = self.root.replace(/\\\\/g, \"/\");\n    // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n    // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n    self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);\n    if (process.platform === \"win32\") self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\");\n    self.nomount = !!options.nomount;\n    // disable comments and negation in Minimatch.\n    // Note that they are not supported in Glob itself anyway.\n    options.nonegate = true;\n    options.nocomment = true;\n    self.minimatch = new Minimatch(pattern, options);\n    self.options = self.minimatch.options;\n}\nfunction finish(self) {\n    var nou = self.nounique;\n    var all = nou ? [] : Object.create(null);\n    for(var i = 0, l = self.matches.length; i < l; i++){\n        var matches = self.matches[i];\n        if (!matches || Object.keys(matches).length === 0) {\n            if (self.nonull) {\n                // do like the shell, and spit out the literal glob\n                var literal = self.minimatch.globSet[i];\n                if (nou) all.push(literal);\n                else all[literal] = true;\n            }\n        } else {\n            // had matches\n            var m = Object.keys(matches);\n            if (nou) all.push.apply(all, m);\n            else m.forEach(function(m) {\n                all[m] = true;\n            });\n        }\n    }\n    if (!nou) all = Object.keys(all);\n    if (!self.nosort) all = all.sort(self.nocase ? alphasorti : alphasort);\n    // at *some* point we statted all of these\n    if (self.mark) {\n        for(var i = 0; i < all.length; i++){\n            all[i] = self._mark(all[i]);\n        }\n        if (self.nodir) {\n            all = all.filter(function(e) {\n                var notDir = !/\\/$/.test(e);\n                var c = self.cache[e] || self.cache[makeAbs(self, e)];\n                if (notDir && c) notDir = c !== \"DIR\" && !Array.isArray(c);\n                return notDir;\n            });\n        }\n    }\n    if (self.ignore.length) all = all.filter(function(m) {\n        return !isIgnored(self, m);\n    });\n    self.found = all;\n}\nfunction mark(self, p) {\n    var abs = makeAbs(self, p);\n    var c = self.cache[abs];\n    var m = p;\n    if (c) {\n        var isDir = c === \"DIR\" || Array.isArray(c);\n        var slash = p.slice(-1) === \"/\";\n        if (isDir && !slash) m += \"/\";\n        else if (!isDir && slash) m = m.slice(0, -1);\n        if (m !== p) {\n            var mabs = makeAbs(self, m);\n            self.statCache[mabs] = self.statCache[abs];\n            self.cache[mabs] = self.cache[abs];\n        }\n    }\n    return m;\n}\n// lotta situps...\nfunction makeAbs(self, f) {\n    var abs = f;\n    if (f.charAt(0) === \"/\") {\n        abs = path.join(self.root, f);\n    } else if (isAbsolute(f) || f === \"\") {\n        abs = f;\n    } else if (self.changedCwd) {\n        abs = path.resolve(self.cwd, f);\n    } else {\n        abs = path.resolve(f);\n    }\n    if (process.platform === \"win32\") abs = abs.replace(/\\\\/g, \"/\");\n    return abs;\n}\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored(self, path) {\n    if (!self.ignore.length) return false;\n    return self.ignore.some(function(item) {\n        return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));\n    });\n}\nfunction childrenIgnored(self, path) {\n    if (!self.ignore.length) return false;\n    return self.ignore.some(function(item) {\n        return !!(item.gmatcher && item.gmatcher.match(path));\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2dsb2IvY29tbW9uLmpzPzc2YjciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5hbHBoYXNvcnQgPSBhbHBoYXNvcnRcbmV4cG9ydHMuYWxwaGFzb3J0aSA9IGFscGhhc29ydGlcbmV4cG9ydHMuc2V0b3B0cyA9IHNldG9wdHNcbmV4cG9ydHMub3duUHJvcCA9IG93blByb3BcbmV4cG9ydHMubWFrZUFicyA9IG1ha2VBYnNcbmV4cG9ydHMuZmluaXNoID0gZmluaXNoXG5leHBvcnRzLm1hcmsgPSBtYXJrXG5leHBvcnRzLmlzSWdub3JlZCA9IGlzSWdub3JlZFxuZXhwb3J0cy5jaGlsZHJlbklnbm9yZWQgPSBjaGlsZHJlbklnbm9yZWRcblxuZnVuY3Rpb24gb3duUHJvcCAob2JqLCBmaWVsZCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgZmllbGQpXG59XG5cbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIilcbnZhciBtaW5pbWF0Y2ggPSByZXF1aXJlKFwibWluaW1hdGNoXCIpXG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUoXCJwYXRoLWlzLWFic29sdXRlXCIpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxuXG5mdW5jdGlvbiBhbHBoYXNvcnRpIChhLCBiKSB7XG4gIHJldHVybiBhLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShiLnRvTG93ZXJDYXNlKCkpXG59XG5cbmZ1bmN0aW9uIGFscGhhc29ydCAoYSwgYikge1xuICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpXG59XG5cbmZ1bmN0aW9uIHNldHVwSWdub3JlcyAoc2VsZiwgb3B0aW9ucykge1xuICBzZWxmLmlnbm9yZSA9IG9wdGlvbnMuaWdub3JlIHx8IFtdXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHNlbGYuaWdub3JlKSlcbiAgICBzZWxmLmlnbm9yZSA9IFtzZWxmLmlnbm9yZV1cblxuICBpZiAoc2VsZi5pZ25vcmUubGVuZ3RoKSB7XG4gICAgc2VsZi5pZ25vcmUgPSBzZWxmLmlnbm9yZS5tYXAoaWdub3JlTWFwKVxuICB9XG59XG5cbi8vIGlnbm9yZSBwYXR0ZXJucyBhcmUgYWx3YXlzIGluIGRvdDp0cnVlIG1vZGUuXG5mdW5jdGlvbiBpZ25vcmVNYXAgKHBhdHRlcm4pIHtcbiAgdmFyIGdtYXRjaGVyID0gbnVsbFxuICBpZiAocGF0dGVybi5zbGljZSgtMykgPT09ICcvKionKSB7XG4gICAgdmFyIGdwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC8oXFwvXFwqXFwqKSskLywgJycpXG4gICAgZ21hdGNoZXIgPSBuZXcgTWluaW1hdGNoKGdwYXR0ZXJuLCB7IGRvdDogdHJ1ZSB9KVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVyOiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIHsgZG90OiB0cnVlIH0pLFxuICAgIGdtYXRjaGVyOiBnbWF0Y2hlclxuICB9XG59XG5cbmZ1bmN0aW9uIHNldG9wdHMgKHNlbGYsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fVxuXG4gIC8vIGJhc2UtbWF0Y2hpbmc6IGp1c3QgdXNlIGdsb2JzdGFyIGZvciB0aGF0LlxuICBpZiAob3B0aW9ucy5tYXRjaEJhc2UgJiYgLTEgPT09IHBhdHRlcm4uaW5kZXhPZihcIi9cIikpIHtcbiAgICBpZiAob3B0aW9ucy5ub2dsb2JzdGFyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYXNlIG1hdGNoaW5nIHJlcXVpcmVzIGdsb2JzdGFyXCIpXG4gICAgfVxuICAgIHBhdHRlcm4gPSBcIioqL1wiICsgcGF0dGVyblxuICB9XG5cbiAgc2VsZi5zaWxlbnQgPSAhIW9wdGlvbnMuc2lsZW50XG4gIHNlbGYucGF0dGVybiA9IHBhdHRlcm5cbiAgc2VsZi5zdHJpY3QgPSBvcHRpb25zLnN0cmljdCAhPT0gZmFsc2VcbiAgc2VsZi5yZWFscGF0aCA9ICEhb3B0aW9ucy5yZWFscGF0aFxuICBzZWxmLnJlYWxwYXRoQ2FjaGUgPSBvcHRpb25zLnJlYWxwYXRoQ2FjaGUgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICBzZWxmLmZvbGxvdyA9ICEhb3B0aW9ucy5mb2xsb3dcbiAgc2VsZi5kb3QgPSAhIW9wdGlvbnMuZG90XG4gIHNlbGYubWFyayA9ICEhb3B0aW9ucy5tYXJrXG4gIHNlbGYubm9kaXIgPSAhIW9wdGlvbnMubm9kaXJcbiAgaWYgKHNlbGYubm9kaXIpXG4gICAgc2VsZi5tYXJrID0gdHJ1ZVxuICBzZWxmLnN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICBzZWxmLm5vdW5pcXVlID0gISFvcHRpb25zLm5vdW5pcXVlXG4gIHNlbGYubm9udWxsID0gISFvcHRpb25zLm5vbnVsbFxuICBzZWxmLm5vc29ydCA9ICEhb3B0aW9ucy5ub3NvcnRcbiAgc2VsZi5ub2Nhc2UgPSAhIW9wdGlvbnMubm9jYXNlXG4gIHNlbGYuc3RhdCA9ICEhb3B0aW9ucy5zdGF0XG4gIHNlbGYubm9wcm9jZXNzID0gISFvcHRpb25zLm5vcHJvY2Vzc1xuICBzZWxmLmFic29sdXRlID0gISFvcHRpb25zLmFic29sdXRlXG5cbiAgc2VsZi5tYXhMZW5ndGggPSBvcHRpb25zLm1heExlbmd0aCB8fCBJbmZpbml0eVxuICBzZWxmLmNhY2hlID0gb3B0aW9ucy5jYWNoZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHNlbGYuc3RhdENhY2hlID0gb3B0aW9ucy5zdGF0Q2FjaGUgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICBzZWxmLnN5bWxpbmtzID0gb3B0aW9ucy5zeW1saW5rcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgc2V0dXBJZ25vcmVzKHNlbGYsIG9wdGlvbnMpXG5cbiAgc2VsZi5jaGFuZ2VkQ3dkID0gZmFsc2VcbiAgdmFyIGN3ZCA9IHByb2Nlc3MuY3dkKClcbiAgaWYgKCFvd25Qcm9wKG9wdGlvbnMsIFwiY3dkXCIpKVxuICAgIHNlbGYuY3dkID0gY3dkXG4gIGVsc2Uge1xuICAgIHNlbGYuY3dkID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkKVxuICAgIHNlbGYuY2hhbmdlZEN3ZCA9IHNlbGYuY3dkICE9PSBjd2RcbiAgfVxuXG4gIHNlbGYucm9vdCA9IG9wdGlvbnMucm9vdCB8fCBwYXRoLnJlc29sdmUoc2VsZi5jd2QsIFwiL1wiKVxuICBzZWxmLnJvb3QgPSBwYXRoLnJlc29sdmUoc2VsZi5yb290KVxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKVxuICAgIHNlbGYucm9vdCA9IHNlbGYucm9vdC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxuXG4gIC8vIFRPRE86IGlzIGFuIGFic29sdXRlIGBjd2RgIHN1cHBvc2VkIHRvIGJlIHJlc29sdmVkIGFnYWluc3QgYHJvb3RgP1xuICAvLyBlLmcuIHsgY3dkOiAnL3Rlc3QnLCByb290OiBfX2Rpcm5hbWUgfSA9PT0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy90ZXN0JylcbiAgc2VsZi5jd2RBYnMgPSBpc0Fic29sdXRlKHNlbGYuY3dkKSA/IHNlbGYuY3dkIDogbWFrZUFicyhzZWxmLCBzZWxmLmN3ZClcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIilcbiAgICBzZWxmLmN3ZEFicyA9IHNlbGYuY3dkQWJzLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG4gIHNlbGYubm9tb3VudCA9ICEhb3B0aW9ucy5ub21vdW50XG5cbiAgLy8gZGlzYWJsZSBjb21tZW50cyBhbmQgbmVnYXRpb24gaW4gTWluaW1hdGNoLlxuICAvLyBOb3RlIHRoYXQgdGhleSBhcmUgbm90IHN1cHBvcnRlZCBpbiBHbG9iIGl0c2VsZiBhbnl3YXkuXG4gIG9wdGlvbnMubm9uZWdhdGUgPSB0cnVlXG4gIG9wdGlvbnMubm9jb21tZW50ID0gdHJ1ZVxuXG4gIHNlbGYubWluaW1hdGNoID0gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKVxuICBzZWxmLm9wdGlvbnMgPSBzZWxmLm1pbmltYXRjaC5vcHRpb25zXG59XG5cbmZ1bmN0aW9uIGZpbmlzaCAoc2VsZikge1xuICB2YXIgbm91ID0gc2VsZi5ub3VuaXF1ZVxuICB2YXIgYWxsID0gbm91ID8gW10gOiBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWxmLm1hdGNoZXMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgIHZhciBtYXRjaGVzID0gc2VsZi5tYXRjaGVzW2ldXG4gICAgaWYgKCFtYXRjaGVzIHx8IE9iamVjdC5rZXlzKG1hdGNoZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHNlbGYubm9udWxsKSB7XG4gICAgICAgIC8vIGRvIGxpa2UgdGhlIHNoZWxsLCBhbmQgc3BpdCBvdXQgdGhlIGxpdGVyYWwgZ2xvYlxuICAgICAgICB2YXIgbGl0ZXJhbCA9IHNlbGYubWluaW1hdGNoLmdsb2JTZXRbaV1cbiAgICAgICAgaWYgKG5vdSlcbiAgICAgICAgICBhbGwucHVzaChsaXRlcmFsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYWxsW2xpdGVyYWxdID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYWQgbWF0Y2hlc1xuICAgICAgdmFyIG0gPSBPYmplY3Qua2V5cyhtYXRjaGVzKVxuICAgICAgaWYgKG5vdSlcbiAgICAgICAgYWxsLnB1c2guYXBwbHkoYWxsLCBtKVxuICAgICAgZWxzZVxuICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICBhbGxbbV0gPSB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKCFub3UpXG4gICAgYWxsID0gT2JqZWN0LmtleXMoYWxsKVxuXG4gIGlmICghc2VsZi5ub3NvcnQpXG4gICAgYWxsID0gYWxsLnNvcnQoc2VsZi5ub2Nhc2UgPyBhbHBoYXNvcnRpIDogYWxwaGFzb3J0KVxuXG4gIC8vIGF0ICpzb21lKiBwb2ludCB3ZSBzdGF0dGVkIGFsbCBvZiB0aGVzZVxuICBpZiAoc2VsZi5tYXJrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFsbFtpXSA9IHNlbGYuX21hcmsoYWxsW2ldKVxuICAgIH1cbiAgICBpZiAoc2VsZi5ub2Rpcikge1xuICAgICAgYWxsID0gYWxsLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbm90RGlyID0gISgvXFwvJC8udGVzdChlKSlcbiAgICAgICAgdmFyIGMgPSBzZWxmLmNhY2hlW2VdIHx8IHNlbGYuY2FjaGVbbWFrZUFicyhzZWxmLCBlKV1cbiAgICAgICAgaWYgKG5vdERpciAmJiBjKVxuICAgICAgICAgIG5vdERpciA9IGMgIT09ICdESVInICYmICFBcnJheS5pc0FycmF5KGMpXG4gICAgICAgIHJldHVybiBub3REaXJcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYuaWdub3JlLmxlbmd0aClcbiAgICBhbGwgPSBhbGwuZmlsdGVyKGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiAhaXNJZ25vcmVkKHNlbGYsIG0pXG4gICAgfSlcblxuICBzZWxmLmZvdW5kID0gYWxsXG59XG5cbmZ1bmN0aW9uIG1hcmsgKHNlbGYsIHApIHtcbiAgdmFyIGFicyA9IG1ha2VBYnMoc2VsZiwgcClcbiAgdmFyIGMgPSBzZWxmLmNhY2hlW2Fic11cbiAgdmFyIG0gPSBwXG4gIGlmIChjKSB7XG4gICAgdmFyIGlzRGlyID0gYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKVxuICAgIHZhciBzbGFzaCA9IHAuc2xpY2UoLTEpID09PSAnLydcblxuICAgIGlmIChpc0RpciAmJiAhc2xhc2gpXG4gICAgICBtICs9ICcvJ1xuICAgIGVsc2UgaWYgKCFpc0RpciAmJiBzbGFzaClcbiAgICAgIG0gPSBtLnNsaWNlKDAsIC0xKVxuXG4gICAgaWYgKG0gIT09IHApIHtcbiAgICAgIHZhciBtYWJzID0gbWFrZUFicyhzZWxmLCBtKVxuICAgICAgc2VsZi5zdGF0Q2FjaGVbbWFic10gPSBzZWxmLnN0YXRDYWNoZVthYnNdXG4gICAgICBzZWxmLmNhY2hlW21hYnNdID0gc2VsZi5jYWNoZVthYnNdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1cbn1cblxuLy8gbG90dGEgc2l0dXBzLi4uXG5mdW5jdGlvbiBtYWtlQWJzIChzZWxmLCBmKSB7XG4gIHZhciBhYnMgPSBmXG4gIGlmIChmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgYWJzID0gcGF0aC5qb2luKHNlbGYucm9vdCwgZilcbiAgfSBlbHNlIGlmIChpc0Fic29sdXRlKGYpIHx8IGYgPT09ICcnKSB7XG4gICAgYWJzID0gZlxuICB9IGVsc2UgaWYgKHNlbGYuY2hhbmdlZEN3ZCkge1xuICAgIGFicyA9IHBhdGgucmVzb2x2ZShzZWxmLmN3ZCwgZilcbiAgfSBlbHNlIHtcbiAgICBhYnMgPSBwYXRoLnJlc29sdmUoZilcbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIGFicyA9IGFicy5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICByZXR1cm4gYWJzXG59XG5cblxuLy8gUmV0dXJuIHRydWUsIGlmIHBhdHRlcm4gZW5kcyB3aXRoIGdsb2JzdGFyICcqKicsIGZvciB0aGUgYWNjb21wYW55aW5nIHBhcmVudCBkaXJlY3RvcnkuXG4vLyBFeDotIElmIG5vZGVfbW9kdWxlcy8qKiBpcyB0aGUgcGF0dGVybiwgYWRkICdub2RlX21vZHVsZXMnIHRvIGlnbm9yZSBsaXN0IGFsb25nIHdpdGggaXQncyBjb250ZW50c1xuZnVuY3Rpb24gaXNJZ25vcmVkIChzZWxmLCBwYXRoKSB7XG4gIGlmICghc2VsZi5pZ25vcmUubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBzZWxmLmlnbm9yZS5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5tYXRjaGVyLm1hdGNoKHBhdGgpIHx8ICEhKGl0ZW0uZ21hdGNoZXIgJiYgaXRlbS5nbWF0Y2hlci5tYXRjaChwYXRoKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hpbGRyZW5JZ25vcmVkIChzZWxmLCBwYXRoKSB7XG4gIGlmICghc2VsZi5pZ25vcmUubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBzZWxmLmlnbm9yZS5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gISEoaXRlbS5nbWF0Y2hlciAmJiBpdGVtLmdtYXRjaGVyLm1hdGNoKHBhdGgpKVxuICB9KVxufVxuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJhbHBoYXNvcnQiLCJhbHBoYXNvcnRpIiwic2V0b3B0cyIsIm93blByb3AiLCJtYWtlQWJzIiwiZmluaXNoIiwibWFyayIsImlzSWdub3JlZCIsImNoaWxkcmVuSWdub3JlZCIsIm9iaiIsImZpZWxkIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwicGF0aCIsInJlcXVpcmUiLCJtaW5pbWF0Y2giLCJpc0Fic29sdXRlIiwiTWluaW1hdGNoIiwiYSIsImIiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZUNvbXBhcmUiLCJzZXR1cElnbm9yZXMiLCJzZWxmIiwib3B0aW9ucyIsImlnbm9yZSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsIm1hcCIsImlnbm9yZU1hcCIsInBhdHRlcm4iLCJnbWF0Y2hlciIsInNsaWNlIiwiZ3BhdHRlcm4iLCJyZXBsYWNlIiwiZG90IiwibWF0Y2hlciIsIm1hdGNoQmFzZSIsImluZGV4T2YiLCJub2dsb2JzdGFyIiwiRXJyb3IiLCJzaWxlbnQiLCJzdHJpY3QiLCJyZWFscGF0aCIsInJlYWxwYXRoQ2FjaGUiLCJjcmVhdGUiLCJmb2xsb3ciLCJub2RpciIsInN5bmMiLCJub3VuaXF1ZSIsIm5vbnVsbCIsIm5vc29ydCIsIm5vY2FzZSIsInN0YXQiLCJub3Byb2Nlc3MiLCJhYnNvbHV0ZSIsIm1heExlbmd0aCIsIkluZmluaXR5IiwiY2FjaGUiLCJzdGF0Q2FjaGUiLCJzeW1saW5rcyIsImNoYW5nZWRDd2QiLCJjd2QiLCJwcm9jZXNzIiwicmVzb2x2ZSIsInJvb3QiLCJwbGF0Zm9ybSIsImN3ZEFicyIsIm5vbW91bnQiLCJub25lZ2F0ZSIsIm5vY29tbWVudCIsIm5vdSIsImFsbCIsImkiLCJsIiwibWF0Y2hlcyIsImtleXMiLCJsaXRlcmFsIiwiZ2xvYlNldCIsInB1c2giLCJtIiwiYXBwbHkiLCJmb3JFYWNoIiwic29ydCIsIl9tYXJrIiwiZmlsdGVyIiwiZSIsIm5vdERpciIsInRlc3QiLCJjIiwiZm91bmQiLCJwIiwiYWJzIiwiaXNEaXIiLCJzbGFzaCIsIm1hYnMiLCJmIiwiY2hhckF0Iiwiam9pbiIsInNvbWUiLCJpdGVtIiwibWF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/glob.js":
/*!***********************************!*\
  !*** ./node_modules/glob/glob.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar rp = __webpack_require__(/*! fs.realpath */ \"(rsc)/./node_modules/fs.realpath/index.js\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/minimatch.js\");\nvar Minimatch = minimatch.Minimatch;\nvar inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar path = __webpack_require__(/*! path */ \"path\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"(rsc)/./node_modules/path-is-absolute/index.js\");\nvar globSync = __webpack_require__(/*! ./sync.js */ \"(rsc)/./node_modules/glob/sync.js\");\nvar common = __webpack_require__(/*! ./common.js */ \"(rsc)/./node_modules/glob/common.js\");\nvar alphasort = common.alphasort;\nvar alphasorti = common.alphasorti;\nvar setopts = common.setopts;\nvar ownProp = common.ownProp;\nvar inflight = __webpack_require__(/*! inflight */ \"(rsc)/./node_modules/inflight/inflight.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar childrenIgnored = common.childrenIgnored;\nvar isIgnored = common.isIgnored;\nvar once = __webpack_require__(/*! once */ \"(rsc)/./node_modules/once/once.js\");\nfunction glob(pattern, options, cb) {\n    if (typeof options === \"function\") cb = options, options = {};\n    if (!options) options = {};\n    if (options.sync) {\n        if (cb) throw new TypeError(\"callback provided to sync glob\");\n        return globSync(pattern, options);\n    }\n    return new Glob(pattern, options, cb);\n}\nglob.sync = globSync;\nvar GlobSync = glob.GlobSync = globSync.GlobSync;\n// old api surface\nglob.glob = glob;\nfunction extend(origin, add) {\n    if (add === null || typeof add !== \"object\") {\n        return origin;\n    }\n    var keys = Object.keys(add);\n    var i = keys.length;\n    while(i--){\n        origin[keys[i]] = add[keys[i]];\n    }\n    return origin;\n}\nglob.hasMagic = function(pattern, options_) {\n    var options = extend({}, options_);\n    options.noprocess = true;\n    var g = new Glob(pattern, options);\n    var set = g.minimatch.set;\n    if (!pattern) return false;\n    if (set.length > 1) return true;\n    for(var j = 0; j < set[0].length; j++){\n        if (typeof set[0][j] !== \"string\") return true;\n    }\n    return false;\n};\nglob.Glob = Glob;\ninherits(Glob, EE);\nfunction Glob(pattern, options, cb) {\n    if (typeof options === \"function\") {\n        cb = options;\n        options = null;\n    }\n    if (options && options.sync) {\n        if (cb) throw new TypeError(\"callback provided to sync glob\");\n        return new GlobSync(pattern, options);\n    }\n    if (!(this instanceof Glob)) return new Glob(pattern, options, cb);\n    setopts(this, pattern, options);\n    this._didRealPath = false;\n    // process each pattern in the minimatch set\n    var n = this.minimatch.set.length;\n    // The matches are stored as {<filename>: true,...} so that\n    // duplicates are automagically pruned.\n    // Later, we do an Object.keys() on these.\n    // Keep them as a list so we can fill in when nonull is set.\n    this.matches = new Array(n);\n    if (typeof cb === \"function\") {\n        cb = once(cb);\n        this.on(\"error\", cb);\n        this.on(\"end\", function(matches) {\n            cb(null, matches);\n        });\n    }\n    var self = this;\n    this._processing = 0;\n    this._emitQueue = [];\n    this._processQueue = [];\n    this.paused = false;\n    if (this.noprocess) return this;\n    if (n === 0) return done();\n    var sync = true;\n    for(var i = 0; i < n; i++){\n        this._process(this.minimatch.set[i], i, false, done);\n    }\n    sync = false;\n    function done() {\n        --self._processing;\n        if (self._processing <= 0) {\n            if (sync) {\n                process.nextTick(function() {\n                    self._finish();\n                });\n            } else {\n                self._finish();\n            }\n        }\n    }\n}\nGlob.prototype._finish = function() {\n    assert(this instanceof Glob);\n    if (this.aborted) return;\n    if (this.realpath && !this._didRealpath) return this._realpath();\n    common.finish(this);\n    this.emit(\"end\", this.found);\n};\nGlob.prototype._realpath = function() {\n    if (this._didRealpath) return;\n    this._didRealpath = true;\n    var n = this.matches.length;\n    if (n === 0) return this._finish();\n    var self = this;\n    for(var i = 0; i < this.matches.length; i++)this._realpathSet(i, next);\n    function next() {\n        if (--n === 0) self._finish();\n    }\n};\nGlob.prototype._realpathSet = function(index, cb) {\n    var matchset = this.matches[index];\n    if (!matchset) return cb();\n    var found = Object.keys(matchset);\n    var self = this;\n    var n = found.length;\n    if (n === 0) return cb();\n    var set = this.matches[index] = Object.create(null);\n    found.forEach(function(p, i) {\n        // If there's a problem with the stat, then it means that\n        // one or more of the links in the realpath couldn't be\n        // resolved.  just return the abs value in that case.\n        p = self._makeAbs(p);\n        rp.realpath(p, self.realpathCache, function(er, real) {\n            if (!er) set[real] = true;\n            else if (er.syscall === \"stat\") set[p] = true;\n            else self.emit(\"error\", er) // srsly wtf right here\n            ;\n            if (--n === 0) {\n                self.matches[index] = set;\n                cb();\n            }\n        });\n    });\n};\nGlob.prototype._mark = function(p) {\n    return common.mark(this, p);\n};\nGlob.prototype._makeAbs = function(f) {\n    return common.makeAbs(this, f);\n};\nGlob.prototype.abort = function() {\n    this.aborted = true;\n    this.emit(\"abort\");\n};\nGlob.prototype.pause = function() {\n    if (!this.paused) {\n        this.paused = true;\n        this.emit(\"pause\");\n    }\n};\nGlob.prototype.resume = function() {\n    if (this.paused) {\n        this.emit(\"resume\");\n        this.paused = false;\n        if (this._emitQueue.length) {\n            var eq = this._emitQueue.slice(0);\n            this._emitQueue.length = 0;\n            for(var i = 0; i < eq.length; i++){\n                var e = eq[i];\n                this._emitMatch(e[0], e[1]);\n            }\n        }\n        if (this._processQueue.length) {\n            var pq = this._processQueue.slice(0);\n            this._processQueue.length = 0;\n            for(var i = 0; i < pq.length; i++){\n                var p = pq[i];\n                this._processing--;\n                this._process(p[0], p[1], p[2], p[3]);\n            }\n        }\n    }\n};\nGlob.prototype._process = function(pattern, index, inGlobStar, cb) {\n    assert(this instanceof Glob);\n    assert(typeof cb === \"function\");\n    if (this.aborted) return;\n    this._processing++;\n    if (this.paused) {\n        this._processQueue.push([\n            pattern,\n            index,\n            inGlobStar,\n            cb\n        ]);\n        return;\n    }\n    //console.error('PROCESS %d', this._processing, pattern)\n    // Get the first [n] parts of pattern that are all strings.\n    var n = 0;\n    while(typeof pattern[n] === \"string\"){\n        n++;\n    }\n    // now n is the index of the first one that is *not* a string.\n    // see if there's anything else\n    var prefix;\n    switch(n){\n        // if not, then this is rather simple\n        case pattern.length:\n            this._processSimple(pattern.join(\"/\"), index, cb);\n            return;\n        case 0:\n            // pattern *starts* with some non-trivial item.\n            // going to readdir(cwd), but not include the prefix in matches.\n            prefix = null;\n            break;\n        default:\n            // pattern has some string bits in the front.\n            // whatever it starts with, whether that's 'absolute' like /foo/bar,\n            // or 'relative' like '../baz'\n            prefix = pattern.slice(0, n).join(\"/\");\n            break;\n    }\n    var remain = pattern.slice(n);\n    // get the list of entries.\n    var read;\n    if (prefix === null) read = \".\";\n    else if (isAbsolute(prefix) || isAbsolute(pattern.join(\"/\"))) {\n        if (!prefix || !isAbsolute(prefix)) prefix = \"/\" + prefix;\n        read = prefix;\n    } else read = prefix;\n    var abs = this._makeAbs(read);\n    //if ignored, skip _processing\n    if (childrenIgnored(this, read)) return cb();\n    var isGlobStar = remain[0] === minimatch.GLOBSTAR;\n    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);\n    else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);\n};\nGlob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {\n    var self = this;\n    this._readdir(abs, inGlobStar, function(er, entries) {\n        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n    });\n};\nGlob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n    // if the abs isn't a dir, then nothing can match!\n    if (!entries) return cb();\n    // It will only match dot entries if it starts with a dot, or if\n    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n    var pn = remain[0];\n    var negate = !!this.minimatch.negate;\n    var rawGlob = pn._glob;\n    var dotOk = this.dot || rawGlob.charAt(0) === \".\";\n    var matchedEntries = [];\n    for(var i = 0; i < entries.length; i++){\n        var e = entries[i];\n        if (e.charAt(0) !== \".\" || dotOk) {\n            var m;\n            if (negate && !prefix) {\n                m = !e.match(pn);\n            } else {\n                m = e.match(pn);\n            }\n            if (m) matchedEntries.push(e);\n        }\n    }\n    //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n    var len = matchedEntries.length;\n    // If there are no matched entries, then nothing matches.\n    if (len === 0) return cb();\n    // if this is the last remaining pattern bit, then no need for\n    // an additional stat *unless* the user has specified mark or\n    // stat explicitly.  We know they exist, since readdir returned\n    // them.\n    if (remain.length === 1 && !this.mark && !this.stat) {\n        if (!this.matches[index]) this.matches[index] = Object.create(null);\n        for(var i = 0; i < len; i++){\n            var e = matchedEntries[i];\n            if (prefix) {\n                if (prefix !== \"/\") e = prefix + \"/\" + e;\n                else e = prefix + e;\n            }\n            if (e.charAt(0) === \"/\" && !this.nomount) {\n                e = path.join(this.root, e);\n            }\n            this._emitMatch(index, e);\n        }\n        // This was the last one, and no stats were needed\n        return cb();\n    }\n    // now test all matched entries as stand-ins for that part\n    // of the pattern.\n    remain.shift();\n    for(var i = 0; i < len; i++){\n        var e = matchedEntries[i];\n        var newPattern;\n        if (prefix) {\n            if (prefix !== \"/\") e = prefix + \"/\" + e;\n            else e = prefix + e;\n        }\n        this._process([\n            e\n        ].concat(remain), index, inGlobStar, cb);\n    }\n    cb();\n};\nGlob.prototype._emitMatch = function(index, e) {\n    if (this.aborted) return;\n    if (isIgnored(this, e)) return;\n    if (this.paused) {\n        this._emitQueue.push([\n            index,\n            e\n        ]);\n        return;\n    }\n    var abs = isAbsolute(e) ? e : this._makeAbs(e);\n    if (this.mark) e = this._mark(e);\n    if (this.absolute) e = abs;\n    if (this.matches[index][e]) return;\n    if (this.nodir) {\n        var c = this.cache[abs];\n        if (c === \"DIR\" || Array.isArray(c)) return;\n    }\n    this.matches[index][e] = true;\n    var st = this.statCache[abs];\n    if (st) this.emit(\"stat\", e, st);\n    this.emit(\"match\", e);\n};\nGlob.prototype._readdirInGlobStar = function(abs, cb) {\n    if (this.aborted) return;\n    // follow all symlinked directories forever\n    // just proceed as if this is a non-globstar situation\n    if (this.follow) return this._readdir(abs, false, cb);\n    var lstatkey = \"lstat\\x00\" + abs;\n    var self = this;\n    var lstatcb = inflight(lstatkey, lstatcb_);\n    if (lstatcb) fs.lstat(abs, lstatcb);\n    function lstatcb_(er, lstat) {\n        if (er && er.code === \"ENOENT\") return cb();\n        var isSym = lstat && lstat.isSymbolicLink();\n        self.symlinks[abs] = isSym;\n        // If it's not a symlink or a dir, then it's definitely a regular file.\n        // don't bother doing a readdir in that case.\n        if (!isSym && lstat && !lstat.isDirectory()) {\n            self.cache[abs] = \"FILE\";\n            cb();\n        } else self._readdir(abs, false, cb);\n    }\n};\nGlob.prototype._readdir = function(abs, inGlobStar, cb) {\n    if (this.aborted) return;\n    cb = inflight(\"readdir\\x00\" + abs + \"\\x00\" + inGlobStar, cb);\n    if (!cb) return;\n    //console.error('RD %j %j', +inGlobStar, abs)\n    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);\n    if (ownProp(this.cache, abs)) {\n        var c = this.cache[abs];\n        if (!c || c === \"FILE\") return cb();\n        if (Array.isArray(c)) return cb(null, c);\n    }\n    var self = this;\n    fs.readdir(abs, readdirCb(this, abs, cb));\n};\nfunction readdirCb(self, abs, cb) {\n    return function(er, entries) {\n        if (er) self._readdirError(abs, er, cb);\n        else self._readdirEntries(abs, entries, cb);\n    };\n}\nGlob.prototype._readdirEntries = function(abs, entries, cb) {\n    if (this.aborted) return;\n    // if we haven't asked to stat everything, then just\n    // assume that everything in there exists, so we can avoid\n    // having to stat it a second time.\n    if (!this.mark && !this.stat) {\n        for(var i = 0; i < entries.length; i++){\n            var e = entries[i];\n            if (abs === \"/\") e = abs + e;\n            else e = abs + \"/\" + e;\n            this.cache[e] = true;\n        }\n    }\n    this.cache[abs] = entries;\n    return cb(null, entries);\n};\nGlob.prototype._readdirError = function(f, er, cb) {\n    if (this.aborted) return;\n    // handle errors, and cache the information\n    switch(er.code){\n        case \"ENOTSUP\":\n        case \"ENOTDIR\":\n            var abs = this._makeAbs(f);\n            this.cache[abs] = \"FILE\";\n            if (abs === this.cwdAbs) {\n                var error = new Error(er.code + \" invalid cwd \" + this.cwd);\n                error.path = this.cwd;\n                error.code = er.code;\n                this.emit(\"error\", error);\n                this.abort();\n            }\n            break;\n        case \"ENOENT\":\n        case \"ELOOP\":\n        case \"ENAMETOOLONG\":\n        case \"UNKNOWN\":\n            this.cache[this._makeAbs(f)] = false;\n            break;\n        default:\n            this.cache[this._makeAbs(f)] = false;\n            if (this.strict) {\n                this.emit(\"error\", er);\n                // If the error is handled, then we abort\n                // if not, we threw out of here\n                this.abort();\n            }\n            if (!this.silent) console.error(\"glob error\", er);\n            break;\n    }\n    return cb();\n};\nGlob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {\n    var self = this;\n    this._readdir(abs, inGlobStar, function(er, entries) {\n        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n    });\n};\nGlob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n    //console.error('pgs2', prefix, remain[0], entries)\n    // no entries means not a dir, so it can never have matches\n    // foo.txt/** doesn't match foo.txt\n    if (!entries) return cb();\n    // test without the globstar, and with every child both below\n    // and replacing the globstar.\n    var remainWithoutGlobStar = remain.slice(1);\n    var gspref = prefix ? [\n        prefix\n    ] : [];\n    var noGlobStar = gspref.concat(remainWithoutGlobStar);\n    // the noGlobStar pattern exits the inGlobStar state\n    this._process(noGlobStar, index, false, cb);\n    var isSym = this.symlinks[abs];\n    var len = entries.length;\n    // If it's a symlink, and we're in a globstar, then stop\n    if (isSym && inGlobStar) return cb();\n    for(var i = 0; i < len; i++){\n        var e = entries[i];\n        if (e.charAt(0) === \".\" && !this.dot) continue;\n        // these two cases enter the inGlobStar state\n        var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n        this._process(instead, index, true, cb);\n        var below = gspref.concat(entries[i], remain);\n        this._process(below, index, true, cb);\n    }\n    cb();\n};\nGlob.prototype._processSimple = function(prefix, index, cb) {\n    // XXX review this.  Shouldn't it be doing the mounting etc\n    // before doing stat?  kinda weird?\n    var self = this;\n    this._stat(prefix, function(er, exists) {\n        self._processSimple2(prefix, index, er, exists, cb);\n    });\n};\nGlob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {\n    //console.error('ps2', prefix, exists)\n    if (!this.matches[index]) this.matches[index] = Object.create(null);\n    // If it doesn't exist, then just mark the lack of results\n    if (!exists) return cb();\n    if (prefix && isAbsolute(prefix) && !this.nomount) {\n        var trail = /[\\/\\\\]$/.test(prefix);\n        if (prefix.charAt(0) === \"/\") {\n            prefix = path.join(this.root, prefix);\n        } else {\n            prefix = path.resolve(this.root, prefix);\n            if (trail) prefix += \"/\";\n        }\n    }\n    if (process.platform === \"win32\") prefix = prefix.replace(/\\\\/g, \"/\");\n    // Mark this as a match\n    this._emitMatch(index, prefix);\n    cb();\n};\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function(f, cb) {\n    var abs = this._makeAbs(f);\n    var needDir = f.slice(-1) === \"/\";\n    if (f.length > this.maxLength) return cb();\n    if (!this.stat && ownProp(this.cache, abs)) {\n        var c = this.cache[abs];\n        if (Array.isArray(c)) c = \"DIR\";\n        // It exists, but maybe not how we need it\n        if (!needDir || c === \"DIR\") return cb(null, c);\n        if (needDir && c === \"FILE\") return cb();\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n    }\n    var exists;\n    var stat = this.statCache[abs];\n    if (stat !== undefined) {\n        if (stat === false) return cb(null, stat);\n        else {\n            var type = stat.isDirectory() ? \"DIR\" : \"FILE\";\n            if (needDir && type === \"FILE\") return cb();\n            else return cb(null, type, stat);\n        }\n    }\n    var self = this;\n    var statcb = inflight(\"stat\\x00\" + abs, lstatcb_);\n    if (statcb) fs.lstat(abs, statcb);\n    function lstatcb_(er, lstat) {\n        if (lstat && lstat.isSymbolicLink()) {\n            // If it's a symlink, then treat it as the target, unless\n            // the target does not exist, then treat it as a file.\n            return fs.stat(abs, function(er, stat) {\n                if (er) self._stat2(f, abs, null, lstat, cb);\n                else self._stat2(f, abs, er, stat, cb);\n            });\n        } else {\n            self._stat2(f, abs, er, lstat, cb);\n        }\n    }\n};\nGlob.prototype._stat2 = function(f, abs, er, stat, cb) {\n    if (er && (er.code === \"ENOENT\" || er.code === \"ENOTDIR\")) {\n        this.statCache[abs] = false;\n        return cb();\n    }\n    var needDir = f.slice(-1) === \"/\";\n    this.statCache[abs] = stat;\n    if (abs.slice(-1) === \"/\" && stat && !stat.isDirectory()) return cb(null, false, stat);\n    var c = true;\n    if (stat) c = stat.isDirectory() ? \"DIR\" : \"FILE\";\n    this.cache[abs] = this.cache[abs] || c;\n    if (needDir && c === \"FILE\") return cb();\n    return cb(null, c, stat);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFQUcsS0FBSzhCLFNBQVMsQ0FBQ2dILE1BQU0sR0FBRyxTQUFVMUYsQ0FBQyxFQUFFaUIsR0FBRyxFQUFFdEIsRUFBRSxFQUFFeUMsSUFBSSxFQUFFM0YsRUFBRTtJQUNwRCxJQUFJa0QsTUFBT0EsQ0FBQUEsR0FBRzRELElBQUksS0FBSyxZQUFZNUQsR0FBRzRELElBQUksS0FBSyxTQUFRLEdBQUk7UUFDekQsSUFBSSxDQUFDUCxTQUFTLENBQUMvQixJQUFJLEdBQUc7UUFDdEIsT0FBT3hFO0lBQ1Q7SUFFQSxJQUFJNEksVUFBVXJGLEVBQUVNLEtBQUssQ0FBQyxDQUFDLE9BQU87SUFDOUIsSUFBSSxDQUFDMEMsU0FBUyxDQUFDL0IsSUFBSSxHQUFHbUI7SUFFdEIsSUFBSW5CLElBQUlYLEtBQUssQ0FBQyxDQUFDLE9BQU8sT0FBTzhCLFFBQVEsQ0FBQ0EsS0FBS3VCLFdBQVcsSUFDcEQsT0FBT2xILEdBQUcsTUFBTSxPQUFPMkY7SUFFekIsSUFBSVEsSUFBSTtJQUNSLElBQUlSLE1BQ0ZRLElBQUlSLEtBQUt1QixXQUFXLEtBQUssUUFBUTtJQUNuQyxJQUFJLENBQUNkLEtBQUssQ0FBQzVCLElBQUksR0FBRyxJQUFJLENBQUM0QixLQUFLLENBQUM1QixJQUFJLElBQUkyQjtJQUVyQyxJQUFJeUMsV0FBV3pDLE1BQU0sUUFDbkIsT0FBT25HO0lBRVQsT0FBT0EsR0FBRyxNQUFNbUcsR0FBR1I7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2dsb2IvZ2xvYi5qcz80MWJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFwcHJvYWNoOlxuLy9cbi8vIDEuIEdldCB0aGUgbWluaW1hdGNoIHNldFxuLy8gMi4gRm9yIGVhY2ggcGF0dGVybiBpbiB0aGUgc2V0LCBQUk9DRVNTKHBhdHRlcm4sIGZhbHNlKVxuLy8gMy4gU3RvcmUgbWF0Y2hlcyBwZXItc2V0LCB0aGVuIHVuaXEgdGhlbVxuLy9cbi8vIFBST0NFU1MocGF0dGVybiwgaW5HbG9iU3Rhcilcbi8vIEdldCB0aGUgZmlyc3QgW25dIGl0ZW1zIGZyb20gcGF0dGVybiB0aGF0IGFyZSBhbGwgc3RyaW5nc1xuLy8gSm9pbiB0aGVzZSB0b2dldGhlci4gIFRoaXMgaXMgUFJFRklYLlxuLy8gICBJZiB0aGVyZSBpcyBubyBtb3JlIHJlbWFpbmluZywgdGhlbiBzdGF0KFBSRUZJWCkgYW5kXG4vLyAgIGFkZCB0byBtYXRjaGVzIGlmIGl0IHN1Y2NlZWRzLiAgRU5ELlxuLy9cbi8vIElmIGluR2xvYlN0YXIgYW5kIFBSRUZJWCBpcyBzeW1saW5rIGFuZCBwb2ludHMgdG8gZGlyXG4vLyAgIHNldCBFTlRSSUVTID0gW11cbi8vIGVsc2UgcmVhZGRpcihQUkVGSVgpIGFzIEVOVFJJRVNcbi8vICAgSWYgZmFpbCwgRU5EXG4vL1xuLy8gd2l0aCBFTlRSSUVTXG4vLyAgIElmIHBhdHRlcm5bbl0gaXMgR0xPQlNUQVJcbi8vICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGdsb2JzdGFyIG1hdGNoIGlzIGVtcHR5XG4vLyAgICAgLy8gYnkgcHJ1bmluZyBpdCBvdXQsIGFuZCB0ZXN0aW5nIHRoZSByZXN1bHRpbmcgcGF0dGVyblxuLy8gICAgIFBST0NFU1MocGF0dGVyblswLi5uXSArIHBhdHRlcm5bbisxIC4uICRdLCBmYWxzZSlcbi8vICAgICAvLyBoYW5kbGUgb3RoZXIgY2FzZXMuXG4vLyAgICAgZm9yIEVOVFJZIGluIEVOVFJJRVMgKG5vdCBkb3RmaWxlcylcbi8vICAgICAgIC8vIGF0dGFjaCBnbG9ic3RhciArIHRhaWwgb250byB0aGUgZW50cnlcbi8vICAgICAgIC8vIE1hcmsgdGhhdCB0aGlzIGVudHJ5IGlzIGEgZ2xvYnN0YXIgbWF0Y2hcbi8vICAgICAgIFBST0NFU1MocGF0dGVyblswLi5uXSArIEVOVFJZICsgcGF0dGVybltuIC4uICRdLCB0cnVlKVxuLy9cbi8vICAgZWxzZSAvLyBub3QgZ2xvYnN0YXJcbi8vICAgICBmb3IgRU5UUlkgaW4gRU5UUklFUyAobm90IGRvdGZpbGVzLCB1bmxlc3MgcGF0dGVybltuXSBpcyBkb3QpXG4vLyAgICAgICBUZXN0IEVOVFJZIGFnYWluc3QgcGF0dGVybltuXVxuLy8gICAgICAgSWYgZmFpbHMsIGNvbnRpbnVlXG4vLyAgICAgICBJZiBwYXNzZXMsIFBST0NFU1MocGF0dGVyblswLi5uXSArIGl0ZW0gKyBwYXR0ZXJuW24rMSAuLiAkXSlcbi8vXG4vLyBDYXZlYXQ6XG4vLyAgIENhY2hlIGFsbCBzdGF0cyBhbmQgcmVhZGRpcnMgcmVzdWx0cyB0byBtaW5pbWl6ZSBzeXNjYWxsLiAgU2luY2UgYWxsXG4vLyAgIHdlIGV2ZXIgY2FyZSBhYm91dCBpcyBleGlzdGVuY2UgYW5kIGRpcmVjdG9yeS1uZXNzLCB3ZSBjYW4ganVzdCBrZWVwXG4vLyAgIGB0cnVlYCBmb3IgZmlsZXMsIGFuZCBbY2hpbGRyZW4sLi4uXSBmb3IgZGlyZWN0b3JpZXMsIG9yIGBmYWxzZWAgZm9yXG4vLyAgIHRoaW5ncyB0aGF0IGRvbid0IGV4aXN0LlxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHJwID0gcmVxdWlyZSgnZnMucmVhbHBhdGgnKVxudmFyIG1pbmltYXRjaCA9IHJlcXVpcmUoJ21pbmltYXRjaCcpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUoJ3BhdGgtaXMtYWJzb2x1dGUnKVxudmFyIGdsb2JTeW5jID0gcmVxdWlyZSgnLi9zeW5jLmpzJylcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpXG52YXIgYWxwaGFzb3J0ID0gY29tbW9uLmFscGhhc29ydFxudmFyIGFscGhhc29ydGkgPSBjb21tb24uYWxwaGFzb3J0aVxudmFyIHNldG9wdHMgPSBjb21tb24uc2V0b3B0c1xudmFyIG93blByb3AgPSBjb21tb24ub3duUHJvcFxudmFyIGluZmxpZ2h0ID0gcmVxdWlyZSgnaW5mbGlnaHQnKVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbnZhciBjaGlsZHJlbklnbm9yZWQgPSBjb21tb24uY2hpbGRyZW5JZ25vcmVkXG52YXIgaXNJZ25vcmVkID0gY29tbW9uLmlzSWdub3JlZFxuXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuXG5mdW5jdGlvbiBnbG9iIChwYXR0ZXJuLCBvcHRpb25zLCBjYikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IHt9XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKG9wdGlvbnMuc3luYykge1xuICAgIGlmIChjYilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYicpXG4gICAgcmV0dXJuIGdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucywgY2IpXG59XG5cbmdsb2Iuc3luYyA9IGdsb2JTeW5jXG52YXIgR2xvYlN5bmMgPSBnbG9iLkdsb2JTeW5jID0gZ2xvYlN5bmMuR2xvYlN5bmNcblxuLy8gb2xkIGFwaSBzdXJmYWNlXG5nbG9iLmdsb2IgPSBnbG9iXG5cbmZ1bmN0aW9uIGV4dGVuZCAob3JpZ2luLCBhZGQpIHtcbiAgaWYgKGFkZCA9PT0gbnVsbCB8fCB0eXBlb2YgYWRkICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcmlnaW5cbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKVxuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV1cbiAgfVxuICByZXR1cm4gb3JpZ2luXG59XG5cbmdsb2IuaGFzTWFnaWMgPSBmdW5jdGlvbiAocGF0dGVybiwgb3B0aW9uc18pIHtcbiAgdmFyIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnNfKVxuICBvcHRpb25zLm5vcHJvY2VzcyA9IHRydWVcblxuICB2YXIgZyA9IG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMpXG4gIHZhciBzZXQgPSBnLm1pbmltYXRjaC5zZXRcblxuICBpZiAoIXBhdHRlcm4pXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKHNldC5sZW5ndGggPiAxKVxuICAgIHJldHVybiB0cnVlXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXRbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICBpZiAodHlwZW9mIHNldFswXVtqXSAhPT0gJ3N0cmluZycpXG4gICAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmdsb2IuR2xvYiA9IEdsb2JcbmluaGVyaXRzKEdsb2IsIEVFKVxuZnVuY3Rpb24gR2xvYiAocGF0dGVybiwgb3B0aW9ucywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG51bGxcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3luYykge1xuICAgIGlmIChjYilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYicpXG4gICAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdsb2IpKVxuICAgIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zLCBjYilcblxuICBzZXRvcHRzKHRoaXMsIHBhdHRlcm4sIG9wdGlvbnMpXG4gIHRoaXMuX2RpZFJlYWxQYXRoID0gZmFsc2VcblxuICAvLyBwcm9jZXNzIGVhY2ggcGF0dGVybiBpbiB0aGUgbWluaW1hdGNoIHNldFxuICB2YXIgbiA9IHRoaXMubWluaW1hdGNoLnNldC5sZW5ndGhcblxuICAvLyBUaGUgbWF0Y2hlcyBhcmUgc3RvcmVkIGFzIHs8ZmlsZW5hbWU+OiB0cnVlLC4uLn0gc28gdGhhdFxuICAvLyBkdXBsaWNhdGVzIGFyZSBhdXRvbWFnaWNhbGx5IHBydW5lZC5cbiAgLy8gTGF0ZXIsIHdlIGRvIGFuIE9iamVjdC5rZXlzKCkgb24gdGhlc2UuXG4gIC8vIEtlZXAgdGhlbSBhcyBhIGxpc3Qgc28gd2UgY2FuIGZpbGwgaW4gd2hlbiBub251bGwgaXMgc2V0LlxuICB0aGlzLm1hdGNoZXMgPSBuZXcgQXJyYXkobilcblxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvbmNlKGNiKVxuICAgIHRoaXMub24oJ2Vycm9yJywgY2IpXG4gICAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24gKG1hdGNoZXMpIHtcbiAgICAgIGNiKG51bGwsIG1hdGNoZXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9wcm9jZXNzaW5nID0gMFxuXG4gIHRoaXMuX2VtaXRRdWV1ZSA9IFtdXG4gIHRoaXMuX3Byb2Nlc3NRdWV1ZSA9IFtdXG4gIHRoaXMucGF1c2VkID0gZmFsc2VcblxuICBpZiAodGhpcy5ub3Byb2Nlc3MpXG4gICAgcmV0dXJuIHRoaXNcblxuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gZG9uZSgpXG5cbiAgdmFyIHN5bmMgPSB0cnVlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSArKykge1xuICAgIHRoaXMuX3Byb2Nlc3ModGhpcy5taW5pbWF0Y2guc2V0W2ldLCBpLCBmYWxzZSwgZG9uZSlcbiAgfVxuICBzeW5jID0gZmFsc2VcblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICAtLXNlbGYuX3Byb2Nlc3NpbmdcbiAgICBpZiAoc2VsZi5fcHJvY2Vzc2luZyA8PSAwKSB7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLl9maW5pc2goKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fZmluaXNoKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iKVxuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLnJlYWxwYXRoICYmICF0aGlzLl9kaWRSZWFscGF0aClcbiAgICByZXR1cm4gdGhpcy5fcmVhbHBhdGgoKVxuXG4gIGNvbW1vbi5maW5pc2godGhpcylcbiAgdGhpcy5lbWl0KCdlbmQnLCB0aGlzLmZvdW5kKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhbHBhdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRSZWFscGF0aClcbiAgICByZXR1cm5cblxuICB0aGlzLl9kaWRSZWFscGF0aCA9IHRydWVcblxuICB2YXIgbiA9IHRoaXMubWF0Y2hlcy5sZW5ndGhcbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaCgpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRjaGVzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMuX3JlYWxwYXRoU2V0KGksIG5leHQpXG5cbiAgZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgaWYgKC0tbiA9PT0gMClcbiAgICAgIHNlbGYuX2ZpbmlzaCgpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWxwYXRoU2V0ID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB2YXIgbWF0Y2hzZXQgPSB0aGlzLm1hdGNoZXNbaW5kZXhdXG4gIGlmICghbWF0Y2hzZXQpXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgZm91bmQgPSBPYmplY3Qua2V5cyhtYXRjaHNldClcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBuID0gZm91bmQubGVuZ3RoXG5cbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgc2V0ID0gdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgZm91bmQuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgIC8vIElmIHRoZXJlJ3MgYSBwcm9ibGVtIHdpdGggdGhlIHN0YXQsIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgIC8vIG9uZSBvciBtb3JlIG9mIHRoZSBsaW5rcyBpbiB0aGUgcmVhbHBhdGggY291bGRuJ3QgYmVcbiAgICAvLyByZXNvbHZlZC4gIGp1c3QgcmV0dXJuIHRoZSBhYnMgdmFsdWUgaW4gdGhhdCBjYXNlLlxuICAgIHAgPSBzZWxmLl9tYWtlQWJzKHApXG4gICAgcnAucmVhbHBhdGgocCwgc2VsZi5yZWFscGF0aENhY2hlLCBmdW5jdGlvbiAoZXIsIHJlYWwpIHtcbiAgICAgIGlmICghZXIpXG4gICAgICAgIHNldFtyZWFsXSA9IHRydWVcbiAgICAgIGVsc2UgaWYgKGVyLnN5c2NhbGwgPT09ICdzdGF0JylcbiAgICAgICAgc2V0W3BdID0gdHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXIpIC8vIHNyc2x5IHd0ZiByaWdodCBoZXJlXG5cbiAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgc2VsZi5tYXRjaGVzW2luZGV4XSA9IHNldFxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX21hcmsgPSBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gY29tbW9uLm1hcmsodGhpcywgcClcbn1cblxuR2xvYi5wcm90b3R5cGUuX21ha2VBYnMgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gY29tbW9uLm1ha2VBYnModGhpcywgZilcbn1cblxuR2xvYi5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgdGhpcy5lbWl0KCdhYm9ydCcpXG59XG5cbkdsb2IucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIGlmICh0aGlzLl9lbWl0UXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgZXEgPSB0aGlzLl9lbWl0UXVldWUuc2xpY2UoMClcbiAgICAgIHRoaXMuX2VtaXRRdWV1ZS5sZW5ndGggPSAwXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVxLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIgZSA9IGVxW2ldXG4gICAgICAgIHRoaXMuX2VtaXRNYXRjaChlWzBdLCBlWzFdKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fcHJvY2Vzc1F1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIHBxID0gdGhpcy5fcHJvY2Vzc1F1ZXVlLnNsaWNlKDApXG4gICAgICB0aGlzLl9wcm9jZXNzUXVldWUubGVuZ3RoID0gMFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcS5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIHAgPSBwcVtpXVxuICAgICAgICB0aGlzLl9wcm9jZXNzaW5nLS1cbiAgICAgICAgdGhpcy5fcHJvY2VzcyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2VzcyA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgdGhpcy5fcHJvY2Vzc2luZysrXG4gIGlmICh0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZS5wdXNoKFtwYXR0ZXJuLCBpbmRleCwgaW5HbG9iU3RhciwgY2JdKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy9jb25zb2xlLmVycm9yKCdQUk9DRVNTICVkJywgdGhpcy5fcHJvY2Vzc2luZywgcGF0dGVybilcblxuICAvLyBHZXQgdGhlIGZpcnN0IFtuXSBwYXJ0cyBvZiBwYXR0ZXJuIHRoYXQgYXJlIGFsbCBzdHJpbmdzLlxuICB2YXIgbiA9IDBcbiAgd2hpbGUgKHR5cGVvZiBwYXR0ZXJuW25dID09PSAnc3RyaW5nJykge1xuICAgIG4gKytcbiAgfVxuICAvLyBub3cgbiBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9uZSB0aGF0IGlzICpub3QqIGEgc3RyaW5nLlxuXG4gIC8vIHNlZSBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2VcbiAgdmFyIHByZWZpeFxuICBzd2l0Y2ggKG4pIHtcbiAgICAvLyBpZiBub3QsIHRoZW4gdGhpcyBpcyByYXRoZXIgc2ltcGxlXG4gICAgY2FzZSBwYXR0ZXJuLmxlbmd0aDpcbiAgICAgIHRoaXMuX3Byb2Nlc3NTaW1wbGUocGF0dGVybi5qb2luKCcvJyksIGluZGV4LCBjYilcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAwOlxuICAgICAgLy8gcGF0dGVybiAqc3RhcnRzKiB3aXRoIHNvbWUgbm9uLXRyaXZpYWwgaXRlbS5cbiAgICAgIC8vIGdvaW5nIHRvIHJlYWRkaXIoY3dkKSwgYnV0IG5vdCBpbmNsdWRlIHRoZSBwcmVmaXggaW4gbWF0Y2hlcy5cbiAgICAgIHByZWZpeCA9IG51bGxcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gcGF0dGVybiBoYXMgc29tZSBzdHJpbmcgYml0cyBpbiB0aGUgZnJvbnQuXG4gICAgICAvLyB3aGF0ZXZlciBpdCBzdGFydHMgd2l0aCwgd2hldGhlciB0aGF0J3MgJ2Fic29sdXRlJyBsaWtlIC9mb28vYmFyLFxuICAgICAgLy8gb3IgJ3JlbGF0aXZlJyBsaWtlICcuLi9iYXonXG4gICAgICBwcmVmaXggPSBwYXR0ZXJuLnNsaWNlKDAsIG4pLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHZhciByZW1haW4gPSBwYXR0ZXJuLnNsaWNlKG4pXG5cbiAgLy8gZ2V0IHRoZSBsaXN0IG9mIGVudHJpZXMuXG4gIHZhciByZWFkXG4gIGlmIChwcmVmaXggPT09IG51bGwpXG4gICAgcmVhZCA9ICcuJ1xuICBlbHNlIGlmIChpc0Fic29sdXRlKHByZWZpeCkgfHwgaXNBYnNvbHV0ZShwYXR0ZXJuLmpvaW4oJy8nKSkpIHtcbiAgICBpZiAoIXByZWZpeCB8fCAhaXNBYnNvbHV0ZShwcmVmaXgpKVxuICAgICAgcHJlZml4ID0gJy8nICsgcHJlZml4XG4gICAgcmVhZCA9IHByZWZpeFxuICB9IGVsc2VcbiAgICByZWFkID0gcHJlZml4XG5cbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMocmVhZClcblxuICAvL2lmIGlnbm9yZWQsIHNraXAgX3Byb2Nlc3NpbmdcbiAgaWYgKGNoaWxkcmVuSWdub3JlZCh0aGlzLCByZWFkKSlcbiAgICByZXR1cm4gY2IoKVxuXG4gIHZhciBpc0dsb2JTdGFyID0gcmVtYWluWzBdID09PSBtaW5pbWF0Y2guR0xPQlNUQVJcbiAgaWYgKGlzR2xvYlN0YXIpXG4gICAgdGhpcy5fcHJvY2Vzc0dsb2JTdGFyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYilcbiAgZWxzZVxuICAgIHRoaXMuX3Byb2Nlc3NSZWFkZGlyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYilcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIsIGZ1bmN0aW9uIChlciwgZW50cmllcykge1xuICAgIHJldHVybiBzZWxmLl9wcm9jZXNzUmVhZGRpcjIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGVudHJpZXMsIGNiKVxuICB9KVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1JlYWRkaXIyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYikge1xuXG4gIC8vIGlmIHRoZSBhYnMgaXNuJ3QgYSBkaXIsIHRoZW4gbm90aGluZyBjYW4gbWF0Y2ghXG4gIGlmICghZW50cmllcylcbiAgICByZXR1cm4gY2IoKVxuXG4gIC8vIEl0IHdpbGwgb25seSBtYXRjaCBkb3QgZW50cmllcyBpZiBpdCBzdGFydHMgd2l0aCBhIGRvdCwgb3IgaWZcbiAgLy8gZG90IGlzIHNldC4gIFN0dWZmIGxpa2UgQCguZm9vfC5iYXIpIGlzbid0IGFsbG93ZWQuXG4gIHZhciBwbiA9IHJlbWFpblswXVxuICB2YXIgbmVnYXRlID0gISF0aGlzLm1pbmltYXRjaC5uZWdhdGVcbiAgdmFyIHJhd0dsb2IgPSBwbi5fZ2xvYlxuICB2YXIgZG90T2sgPSB0aGlzLmRvdCB8fCByYXdHbG9iLmNoYXJBdCgwKSA9PT0gJy4nXG5cbiAgdmFyIG1hdGNoZWRFbnRyaWVzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgaWYgKGUuY2hhckF0KDApICE9PSAnLicgfHwgZG90T2spIHtcbiAgICAgIHZhciBtXG4gICAgICBpZiAobmVnYXRlICYmICFwcmVmaXgpIHtcbiAgICAgICAgbSA9ICFlLm1hdGNoKHBuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGUubWF0Y2gocG4pXG4gICAgICB9XG4gICAgICBpZiAobSlcbiAgICAgICAgbWF0Y2hlZEVudHJpZXMucHVzaChlKVxuICAgIH1cbiAgfVxuXG4gIC8vY29uc29sZS5lcnJvcigncHJkMicsIHByZWZpeCwgZW50cmllcywgcmVtYWluWzBdLl9nbG9iLCBtYXRjaGVkRW50cmllcylcblxuICB2YXIgbGVuID0gbWF0Y2hlZEVudHJpZXMubGVuZ3RoXG4gIC8vIElmIHRoZXJlIGFyZSBubyBtYXRjaGVkIGVudHJpZXMsIHRoZW4gbm90aGluZyBtYXRjaGVzLlxuICBpZiAobGVuID09PSAwKVxuICAgIHJldHVybiBjYigpXG5cbiAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmcgcGF0dGVybiBiaXQsIHRoZW4gbm8gbmVlZCBmb3JcbiAgLy8gYW4gYWRkaXRpb25hbCBzdGF0ICp1bmxlc3MqIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgbWFyayBvclxuICAvLyBzdGF0IGV4cGxpY2l0bHkuICBXZSBrbm93IHRoZXkgZXhpc3QsIHNpbmNlIHJlYWRkaXIgcmV0dXJuZWRcbiAgLy8gdGhlbS5cblxuICBpZiAocmVtYWluLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeCAhPT0gJy8nKVxuICAgICAgICAgIGUgPSBwcmVmaXggKyAnLycgKyBlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlID0gcHJlZml4ICsgZVxuICAgICAgfVxuXG4gICAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcvJyAmJiAhdGhpcy5ub21vdW50KSB7XG4gICAgICAgIGUgPSBwYXRoLmpvaW4odGhpcy5yb290LCBlKVxuICAgICAgfVxuICAgICAgdGhpcy5fZW1pdE1hdGNoKGluZGV4LCBlKVxuICAgIH1cbiAgICAvLyBUaGlzIHdhcyB0aGUgbGFzdCBvbmUsIGFuZCBubyBzdGF0cyB3ZXJlIG5lZWRlZFxuICAgIHJldHVybiBjYigpXG4gIH1cblxuICAvLyBub3cgdGVzdCBhbGwgbWF0Y2hlZCBlbnRyaWVzIGFzIHN0YW5kLWlucyBmb3IgdGhhdCBwYXJ0XG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICByZW1haW4uc2hpZnQoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArKykge1xuICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICB2YXIgbmV3UGF0dGVyblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIGlmIChwcmVmaXggIT09ICcvJylcbiAgICAgICAgZSA9IHByZWZpeCArICcvJyArIGVcbiAgICAgIGVsc2VcbiAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICB9XG4gICAgdGhpcy5fcHJvY2VzcyhbZV0uY29uY2F0KHJlbWFpbiksIGluZGV4LCBpbkdsb2JTdGFyLCBjYilcbiAgfVxuICBjYigpXG59XG5cbkdsb2IucHJvdG90eXBlLl9lbWl0TWF0Y2ggPSBmdW5jdGlvbiAoaW5kZXgsIGUpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBpZiAoaXNJZ25vcmVkKHRoaXMsIGUpKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMuX2VtaXRRdWV1ZS5wdXNoKFtpbmRleCwgZV0pXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYWJzID0gaXNBYnNvbHV0ZShlKSA/IGUgOiB0aGlzLl9tYWtlQWJzKGUpXG5cbiAgaWYgKHRoaXMubWFyaylcbiAgICBlID0gdGhpcy5fbWFyayhlKVxuXG4gIGlmICh0aGlzLmFic29sdXRlKVxuICAgIGUgPSBhYnNcblxuICBpZiAodGhpcy5tYXRjaGVzW2luZGV4XVtlXSlcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5ub2Rpcikge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKGMgPT09ICdESVInIHx8IEFycmF5LmlzQXJyYXkoYykpXG4gICAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMubWF0Y2hlc1tpbmRleF1bZV0gPSB0cnVlXG5cbiAgdmFyIHN0ID0gdGhpcy5zdGF0Q2FjaGVbYWJzXVxuICBpZiAoc3QpXG4gICAgdGhpcy5lbWl0KCdzdGF0JywgZSwgc3QpXG5cbiAgdGhpcy5lbWl0KCdtYXRjaCcsIGUpXG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlySW5HbG9iU3RhciA9IGZ1bmN0aW9uIChhYnMsIGNiKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgLy8gZm9sbG93IGFsbCBzeW1saW5rZWQgZGlyZWN0b3JpZXMgZm9yZXZlclxuICAvLyBqdXN0IHByb2NlZWQgYXMgaWYgdGhpcyBpcyBhIG5vbi1nbG9ic3RhciBzaXR1YXRpb25cbiAgaWYgKHRoaXMuZm9sbG93KVxuICAgIHJldHVybiB0aGlzLl9yZWFkZGlyKGFicywgZmFsc2UsIGNiKVxuXG4gIHZhciBsc3RhdGtleSA9ICdsc3RhdFxcMCcgKyBhYnNcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBsc3RhdGNiID0gaW5mbGlnaHQobHN0YXRrZXksIGxzdGF0Y2JfKVxuXG4gIGlmIChsc3RhdGNiKVxuICAgIGZzLmxzdGF0KGFicywgbHN0YXRjYilcblxuICBmdW5jdGlvbiBsc3RhdGNiXyAoZXIsIGxzdGF0KSB7XG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIHZhciBpc1N5bSA9IGxzdGF0ICYmIGxzdGF0LmlzU3ltYm9saWNMaW5rKClcbiAgICBzZWxmLnN5bWxpbmtzW2Fic10gPSBpc1N5bVxuXG4gICAgLy8gSWYgaXQncyBub3QgYSBzeW1saW5rIG9yIGEgZGlyLCB0aGVuIGl0J3MgZGVmaW5pdGVseSBhIHJlZ3VsYXIgZmlsZS5cbiAgICAvLyBkb24ndCBib3RoZXIgZG9pbmcgYSByZWFkZGlyIGluIHRoYXQgY2FzZS5cbiAgICBpZiAoIWlzU3ltICYmIGxzdGF0ICYmICFsc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBzZWxmLmNhY2hlW2Fic10gPSAnRklMRSdcbiAgICAgIGNiKClcbiAgICB9IGVsc2VcbiAgICAgIHNlbGYuX3JlYWRkaXIoYWJzLCBmYWxzZSwgY2IpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWRkaXIgPSBmdW5jdGlvbiAoYWJzLCBpbkdsb2JTdGFyLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIGNiID0gaW5mbGlnaHQoJ3JlYWRkaXJcXDAnK2FicysnXFwwJytpbkdsb2JTdGFyLCBjYilcbiAgaWYgKCFjYilcbiAgICByZXR1cm5cblxuICAvL2NvbnNvbGUuZXJyb3IoJ1JEICVqICVqJywgK2luR2xvYlN0YXIsIGFicylcbiAgaWYgKGluR2xvYlN0YXIgJiYgIW93blByb3AodGhpcy5zeW1saW5rcywgYWJzKSlcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckluR2xvYlN0YXIoYWJzLCBjYilcblxuICBpZiAob3duUHJvcCh0aGlzLmNhY2hlLCBhYnMpKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoIWMgfHwgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKVxuICAgICAgcmV0dXJuIGNiKG51bGwsIGMpXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgZnMucmVhZGRpcihhYnMsIHJlYWRkaXJDYih0aGlzLCBhYnMsIGNiKSlcbn1cblxuZnVuY3Rpb24gcmVhZGRpckNiIChzZWxmLCBhYnMsIGNiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICBpZiAoZXIpXG4gICAgICBzZWxmLl9yZWFkZGlyRXJyb3IoYWJzLCBlciwgY2IpXG4gICAgZWxzZVxuICAgICAgc2VsZi5fcmVhZGRpckVudHJpZXMoYWJzLCBlbnRyaWVzLCBjYilcbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckVudHJpZXMgPSBmdW5jdGlvbiAoYWJzLCBlbnRyaWVzLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGlmIHdlIGhhdmVuJ3QgYXNrZWQgdG8gc3RhdCBldmVyeXRoaW5nLCB0aGVuIGp1c3RcbiAgLy8gYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpbiB0aGVyZSBleGlzdHMsIHNvIHdlIGNhbiBhdm9pZFxuICAvLyBoYXZpbmcgdG8gc3RhdCBpdCBhIHNlY29uZCB0aW1lLlxuICBpZiAoIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgICBpZiAoYWJzID09PSAnLycpXG4gICAgICAgIGUgPSBhYnMgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBhYnMgKyAnLycgKyBlXG4gICAgICB0aGlzLmNhY2hlW2VdID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IGVudHJpZXNcbiAgcmV0dXJuIGNiKG51bGwsIGVudHJpZXMpXG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyRXJyb3IgPSBmdW5jdGlvbiAoZiwgZXIsIGNiKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgLy8gaGFuZGxlIGVycm9ycywgYW5kIGNhY2hlIHRoZSBpbmZvcm1hdGlvblxuICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICBjYXNlICdFTk9UU1VQJzogLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzIwNVxuICAgIGNhc2UgJ0VOT1RESVInOiAvLyB0b3RhbGx5IG5vcm1hbC4gbWVhbnMgaXQgKmRvZXMqIGV4aXN0LlxuICAgICAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgICAgIHRoaXMuY2FjaGVbYWJzXSA9ICdGSUxFJ1xuICAgICAgaWYgKGFicyA9PT0gdGhpcy5jd2RBYnMpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVyLmNvZGUgKyAnIGludmFsaWQgY3dkICcgKyB0aGlzLmN3ZClcbiAgICAgICAgZXJyb3IucGF0aCA9IHRoaXMuY3dkXG4gICAgICAgIGVycm9yLmNvZGUgPSBlci5jb2RlXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICAgICAgdGhpcy5hYm9ydCgpXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnRU5PRU5UJzogLy8gbm90IHRlcnJpYmx5IHVudXN1YWxcbiAgICBjYXNlICdFTE9PUCc6XG4gICAgY2FzZSAnRU5BTUVUT09MT05HJzpcbiAgICBjYXNlICdVTktOT1dOJzpcbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6IC8vIHNvbWUgdW51c3VhbCBlcnJvci4gIFRyZWF0IGFzIGZhaWx1cmUuXG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGlmICh0aGlzLnN0cmljdCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBoYW5kbGVkLCB0aGVuIHdlIGFib3J0XG4gICAgICAgIC8vIGlmIG5vdCwgd2UgdGhyZXcgb3V0IG9mIGhlcmVcbiAgICAgICAgdGhpcy5hYm9ydCgpXG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2lsZW50KVxuICAgICAgICBjb25zb2xlLmVycm9yKCdnbG9iIGVycm9yJywgZXIpXG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyLCBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICBzZWxmLl9wcm9jZXNzR2xvYlN0YXIyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYilcbiAgfSlcbn1cblxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc0dsb2JTdGFyMiA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpIHtcbiAgLy9jb25zb2xlLmVycm9yKCdwZ3MyJywgcHJlZml4LCByZW1haW5bMF0sIGVudHJpZXMpXG5cbiAgLy8gbm8gZW50cmllcyBtZWFucyBub3QgYSBkaXIsIHNvIGl0IGNhbiBuZXZlciBoYXZlIG1hdGNoZXNcbiAgLy8gZm9vLnR4dC8qKiBkb2Vzbid0IG1hdGNoIGZvby50eHRcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVybiBjYigpXG5cbiAgLy8gdGVzdCB3aXRob3V0IHRoZSBnbG9ic3RhciwgYW5kIHdpdGggZXZlcnkgY2hpbGQgYm90aCBiZWxvd1xuICAvLyBhbmQgcmVwbGFjaW5nIHRoZSBnbG9ic3Rhci5cbiAgdmFyIHJlbWFpbldpdGhvdXRHbG9iU3RhciA9IHJlbWFpbi5zbGljZSgxKVxuICB2YXIgZ3NwcmVmID0gcHJlZml4ID8gWyBwcmVmaXggXSA6IFtdXG4gIHZhciBub0dsb2JTdGFyID0gZ3NwcmVmLmNvbmNhdChyZW1haW5XaXRob3V0R2xvYlN0YXIpXG5cbiAgLy8gdGhlIG5vR2xvYlN0YXIgcGF0dGVybiBleGl0cyB0aGUgaW5HbG9iU3RhciBzdGF0ZVxuICB0aGlzLl9wcm9jZXNzKG5vR2xvYlN0YXIsIGluZGV4LCBmYWxzZSwgY2IpXG5cbiAgdmFyIGlzU3ltID0gdGhpcy5zeW1saW5rc1thYnNdXG4gIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aFxuXG4gIC8vIElmIGl0J3MgYSBzeW1saW5rLCBhbmQgd2UncmUgaW4gYSBnbG9ic3RhciwgdGhlbiBzdG9wXG4gIGlmIChpc1N5bSAmJiBpbkdsb2JTdGFyKVxuICAgIHJldHVybiBjYigpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy4nICYmICF0aGlzLmRvdClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAvLyB0aGVzZSB0d28gY2FzZXMgZW50ZXIgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgICB2YXIgaW5zdGVhZCA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluV2l0aG91dEdsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3MoaW5zdGVhZCwgaW5kZXgsIHRydWUsIGNiKVxuXG4gICAgdmFyIGJlbG93ID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW4pXG4gICAgdGhpcy5fcHJvY2VzcyhiZWxvdywgaW5kZXgsIHRydWUsIGNiKVxuICB9XG5cbiAgY2IoKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1NpbXBsZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGluZGV4LCBjYikge1xuICAvLyBYWFggcmV2aWV3IHRoaXMuICBTaG91bGRuJ3QgaXQgYmUgZG9pbmcgdGhlIG1vdW50aW5nIGV0Y1xuICAvLyBiZWZvcmUgZG9pbmcgc3RhdD8gIGtpbmRhIHdlaXJkP1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fc3RhdChwcmVmaXgsIGZ1bmN0aW9uIChlciwgZXhpc3RzKSB7XG4gICAgc2VsZi5fcHJvY2Vzc1NpbXBsZTIocHJlZml4LCBpbmRleCwgZXIsIGV4aXN0cywgY2IpXG4gIH0pXG59XG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1NpbXBsZTIgPSBmdW5jdGlvbiAocHJlZml4LCBpbmRleCwgZXIsIGV4aXN0cywgY2IpIHtcblxuICAvL2NvbnNvbGUuZXJyb3IoJ3BzMicsIHByZWZpeCwgZXhpc3RzKVxuXG4gIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4ganVzdCBtYXJrIHRoZSBsYWNrIG9mIHJlc3VsdHNcbiAgaWYgKCFleGlzdHMpXG4gICAgcmV0dXJuIGNiKClcblxuICBpZiAocHJlZml4ICYmIGlzQWJzb2x1dGUocHJlZml4KSAmJiAhdGhpcy5ub21vdW50KSB7XG4gICAgdmFyIHRyYWlsID0gL1tcXC9cXFxcXSQvLnRlc3QocHJlZml4KVxuICAgIGlmIChwcmVmaXguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHByZWZpeCA9IHBhdGguam9pbih0aGlzLnJvb3QsIHByZWZpeClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gcGF0aC5yZXNvbHZlKHRoaXMucm9vdCwgcHJlZml4KVxuICAgICAgaWYgKHRyYWlsKVxuICAgICAgICBwcmVmaXggKz0gJy8nXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG4gICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIC8vIE1hcmsgdGhpcyBhcyBhIG1hdGNoXG4gIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgcHJlZml4KVxuICBjYigpXG59XG5cbi8vIFJldHVybnMgZWl0aGVyICdESVInLCAnRklMRScsIG9yIGZhbHNlXG5HbG9iLnByb3RvdHlwZS5fc3RhdCA9IGZ1bmN0aW9uIChmLCBjYikge1xuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICB2YXIgbmVlZERpciA9IGYuc2xpY2UoLTEpID09PSAnLydcblxuICBpZiAoZi5sZW5ndGggPiB0aGlzLm1heExlbmd0aClcbiAgICByZXR1cm4gY2IoKVxuXG4gIGlmICghdGhpcy5zdGF0ICYmIG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIGMgPSAnRElSJ1xuXG4gICAgLy8gSXQgZXhpc3RzLCBidXQgbWF5YmUgbm90IGhvdyB3ZSBuZWVkIGl0XG4gICAgaWYgKCFuZWVkRGlyIHx8IGMgPT09ICdESVInKVxuICAgICAgcmV0dXJuIGNiKG51bGwsIGMpXG5cbiAgICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgICByZXR1cm4gY2IoKVxuXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3RhdCwgYmVjYXVzZSBtYXliZSBjPXRydWVcbiAgICAvLyBpZiB3ZSBrbm93IGl0IGV4aXN0cywgYnV0IG5vdCB3aGF0IGl0IGlzLlxuICB9XG5cbiAgdmFyIGV4aXN0c1xuICB2YXIgc3RhdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKHN0YXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChzdGF0ID09PSBmYWxzZSlcbiAgICAgIHJldHVybiBjYihudWxsLCBzdGF0KVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHR5cGUgPSBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRElSJyA6ICdGSUxFJ1xuICAgICAgaWYgKG5lZWREaXIgJiYgdHlwZSA9PT0gJ0ZJTEUnKVxuICAgICAgICByZXR1cm4gY2IoKVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgdHlwZSwgc3RhdClcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHN0YXRjYiA9IGluZmxpZ2h0KCdzdGF0XFwwJyArIGFicywgbHN0YXRjYl8pXG4gIGlmIChzdGF0Y2IpXG4gICAgZnMubHN0YXQoYWJzLCBzdGF0Y2IpXG5cbiAgZnVuY3Rpb24gbHN0YXRjYl8gKGVyLCBsc3RhdCkge1xuICAgIGlmIChsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAvLyBJZiBpdCdzIGEgc3ltbGluaywgdGhlbiB0cmVhdCBpdCBhcyB0aGUgdGFyZ2V0LCB1bmxlc3NcbiAgICAgIC8vIHRoZSB0YXJnZXQgZG9lcyBub3QgZXhpc3QsIHRoZW4gdHJlYXQgaXQgYXMgYSBmaWxlLlxuICAgICAgcmV0dXJuIGZzLnN0YXQoYWJzLCBmdW5jdGlvbiAoZXIsIHN0YXQpIHtcbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgIHNlbGYuX3N0YXQyKGYsIGFicywgbnVsbCwgbHN0YXQsIGNiKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgc2VsZi5fc3RhdDIoZiwgYWJzLCBlciwgc3RhdCwgY2IpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9zdGF0MihmLCBhYnMsIGVyLCBsc3RhdCwgY2IpXG4gICAgfVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9zdGF0MiA9IGZ1bmN0aW9uIChmLCBhYnMsIGVyLCBzdGF0LCBjYikge1xuICBpZiAoZXIgJiYgKGVyLmNvZGUgPT09ICdFTk9FTlQnIHx8IGVyLmNvZGUgPT09ICdFTk9URElSJykpIHtcbiAgICB0aGlzLnN0YXRDYWNoZVthYnNdID0gZmFsc2VcbiAgICByZXR1cm4gY2IoKVxuICB9XG5cbiAgdmFyIG5lZWREaXIgPSBmLnNsaWNlKC0xKSA9PT0gJy8nXG4gIHRoaXMuc3RhdENhY2hlW2Fic10gPSBzdGF0XG5cbiAgaWYgKGFicy5zbGljZSgtMSkgPT09ICcvJyAmJiBzdGF0ICYmICFzdGF0LmlzRGlyZWN0b3J5KCkpXG4gICAgcmV0dXJuIGNiKG51bGwsIGZhbHNlLCBzdGF0KVxuXG4gIHZhciBjID0gdHJ1ZVxuICBpZiAoc3RhdClcbiAgICBjID0gc3RhdC5pc0RpcmVjdG9yeSgpID8gJ0RJUicgOiAnRklMRSdcbiAgdGhpcy5jYWNoZVthYnNdID0gdGhpcy5jYWNoZVthYnNdIHx8IGNcblxuICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgcmV0dXJuIGNiKClcblxuICByZXR1cm4gY2IobnVsbCwgYywgc3RhdClcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZ2xvYiIsImZzIiwicmVxdWlyZSIsInJwIiwibWluaW1hdGNoIiwiTWluaW1hdGNoIiwiaW5oZXJpdHMiLCJFRSIsIkV2ZW50RW1pdHRlciIsInBhdGgiLCJhc3NlcnQiLCJpc0Fic29sdXRlIiwiZ2xvYlN5bmMiLCJjb21tb24iLCJhbHBoYXNvcnQiLCJhbHBoYXNvcnRpIiwic2V0b3B0cyIsIm93blByb3AiLCJpbmZsaWdodCIsInV0aWwiLCJjaGlsZHJlbklnbm9yZWQiLCJpc0lnbm9yZWQiLCJvbmNlIiwicGF0dGVybiIsIm9wdGlvbnMiLCJjYiIsInN5bmMiLCJUeXBlRXJyb3IiLCJHbG9iIiwiR2xvYlN5bmMiLCJleHRlbmQiLCJvcmlnaW4iLCJhZGQiLCJrZXlzIiwiT2JqZWN0IiwiaSIsImxlbmd0aCIsImhhc01hZ2ljIiwib3B0aW9uc18iLCJub3Byb2Nlc3MiLCJnIiwic2V0IiwiaiIsIl9kaWRSZWFsUGF0aCIsIm4iLCJtYXRjaGVzIiwiQXJyYXkiLCJvbiIsInNlbGYiLCJfcHJvY2Vzc2luZyIsIl9lbWl0UXVldWUiLCJfcHJvY2Vzc1F1ZXVlIiwicGF1c2VkIiwiZG9uZSIsIl9wcm9jZXNzIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiX2ZpbmlzaCIsInByb3RvdHlwZSIsImFib3J0ZWQiLCJyZWFscGF0aCIsIl9kaWRSZWFscGF0aCIsIl9yZWFscGF0aCIsImZpbmlzaCIsImVtaXQiLCJmb3VuZCIsIl9yZWFscGF0aFNldCIsIm5leHQiLCJpbmRleCIsIm1hdGNoc2V0IiwiY3JlYXRlIiwiZm9yRWFjaCIsInAiLCJfbWFrZUFicyIsInJlYWxwYXRoQ2FjaGUiLCJlciIsInJlYWwiLCJzeXNjYWxsIiwiX21hcmsiLCJtYXJrIiwiZiIsIm1ha2VBYnMiLCJhYm9ydCIsInBhdXNlIiwicmVzdW1lIiwiZXEiLCJzbGljZSIsImUiLCJfZW1pdE1hdGNoIiwicHEiLCJpbkdsb2JTdGFyIiwicHVzaCIsInByZWZpeCIsIl9wcm9jZXNzU2ltcGxlIiwiam9pbiIsInJlbWFpbiIsInJlYWQiLCJhYnMiLCJpc0dsb2JTdGFyIiwiR0xPQlNUQVIiLCJfcHJvY2Vzc0dsb2JTdGFyIiwiX3Byb2Nlc3NSZWFkZGlyIiwiX3JlYWRkaXIiLCJlbnRyaWVzIiwiX3Byb2Nlc3NSZWFkZGlyMiIsInBuIiwibmVnYXRlIiwicmF3R2xvYiIsIl9nbG9iIiwiZG90T2siLCJkb3QiLCJjaGFyQXQiLCJtYXRjaGVkRW50cmllcyIsIm0iLCJtYXRjaCIsImxlbiIsInN0YXQiLCJub21vdW50Iiwicm9vdCIsInNoaWZ0IiwibmV3UGF0dGVybiIsImNvbmNhdCIsImFic29sdXRlIiwibm9kaXIiLCJjIiwiY2FjaGUiLCJpc0FycmF5Iiwic3QiLCJzdGF0Q2FjaGUiLCJfcmVhZGRpckluR2xvYlN0YXIiLCJmb2xsb3ciLCJsc3RhdGtleSIsImxzdGF0Y2IiLCJsc3RhdGNiXyIsImxzdGF0IiwiY29kZSIsImlzU3ltIiwiaXNTeW1ib2xpY0xpbmsiLCJzeW1saW5rcyIsImlzRGlyZWN0b3J5IiwicmVhZGRpciIsInJlYWRkaXJDYiIsIl9yZWFkZGlyRXJyb3IiLCJfcmVhZGRpckVudHJpZXMiLCJjd2RBYnMiLCJlcnJvciIsIkVycm9yIiwiY3dkIiwic3RyaWN0Iiwic2lsZW50IiwiY29uc29sZSIsIl9wcm9jZXNzR2xvYlN0YXIyIiwicmVtYWluV2l0aG91dEdsb2JTdGFyIiwiZ3NwcmVmIiwibm9HbG9iU3RhciIsImluc3RlYWQiLCJiZWxvdyIsIl9zdGF0IiwiZXhpc3RzIiwiX3Byb2Nlc3NTaW1wbGUyIiwidHJhaWwiLCJ0ZXN0IiwicmVzb2x2ZSIsInBsYXRmb3JtIiwicmVwbGFjZSIsIm5lZWREaXIiLCJtYXhMZW5ndGgiLCJ1bmRlZmluZWQiLCJ0eXBlIiwic3RhdGNiIiwiX3N0YXQyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/glob.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/sync.js":
/*!***********************************!*\
  !*** ./node_modules/glob/sync.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = globSync;\nglobSync.GlobSync = GlobSync;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar rp = __webpack_require__(/*! fs.realpath */ \"(rsc)/./node_modules/fs.realpath/index.js\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/minimatch.js\");\nvar Minimatch = minimatch.Minimatch;\nvar Glob = (__webpack_require__(/*! ./glob.js */ \"(rsc)/./node_modules/glob/glob.js\").Glob);\nvar util = __webpack_require__(/*! util */ \"util\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"(rsc)/./node_modules/path-is-absolute/index.js\");\nvar common = __webpack_require__(/*! ./common.js */ \"(rsc)/./node_modules/glob/common.js\");\nvar alphasort = common.alphasort;\nvar alphasorti = common.alphasorti;\nvar setopts = common.setopts;\nvar ownProp = common.ownProp;\nvar childrenIgnored = common.childrenIgnored;\nvar isIgnored = common.isIgnored;\nfunction globSync(pattern, options) {\n    if (typeof options === \"function\" || arguments.length === 3) throw new TypeError(\"callback provided to sync glob\\n\" + \"See: https://github.com/isaacs/node-glob/issues/167\");\n    return new GlobSync(pattern, options).found;\n}\nfunction GlobSync(pattern, options) {\n    if (!pattern) throw new Error(\"must provide pattern\");\n    if (typeof options === \"function\" || arguments.length === 3) throw new TypeError(\"callback provided to sync glob\\n\" + \"See: https://github.com/isaacs/node-glob/issues/167\");\n    if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);\n    setopts(this, pattern, options);\n    if (this.noprocess) return this;\n    var n = this.minimatch.set.length;\n    this.matches = new Array(n);\n    for(var i = 0; i < n; i++){\n        this._process(this.minimatch.set[i], i, false);\n    }\n    this._finish();\n}\nGlobSync.prototype._finish = function() {\n    assert(this instanceof GlobSync);\n    if (this.realpath) {\n        var self = this;\n        this.matches.forEach(function(matchset, index) {\n            var set = self.matches[index] = Object.create(null);\n            for(var p in matchset){\n                try {\n                    p = self._makeAbs(p);\n                    var real = rp.realpathSync(p, self.realpathCache);\n                    set[real] = true;\n                } catch (er) {\n                    if (er.syscall === \"stat\") set[self._makeAbs(p)] = true;\n                    else throw er;\n                }\n            }\n        });\n    }\n    common.finish(this);\n};\nGlobSync.prototype._process = function(pattern, index, inGlobStar) {\n    assert(this instanceof GlobSync);\n    // Get the first [n] parts of pattern that are all strings.\n    var n = 0;\n    while(typeof pattern[n] === \"string\"){\n        n++;\n    }\n    // now n is the index of the first one that is *not* a string.\n    // See if there's anything else\n    var prefix;\n    switch(n){\n        // if not, then this is rather simple\n        case pattern.length:\n            this._processSimple(pattern.join(\"/\"), index);\n            return;\n        case 0:\n            // pattern *starts* with some non-trivial item.\n            // going to readdir(cwd), but not include the prefix in matches.\n            prefix = null;\n            break;\n        default:\n            // pattern has some string bits in the front.\n            // whatever it starts with, whether that's 'absolute' like /foo/bar,\n            // or 'relative' like '../baz'\n            prefix = pattern.slice(0, n).join(\"/\");\n            break;\n    }\n    var remain = pattern.slice(n);\n    // get the list of entries.\n    var read;\n    if (prefix === null) read = \".\";\n    else if (isAbsolute(prefix) || isAbsolute(pattern.join(\"/\"))) {\n        if (!prefix || !isAbsolute(prefix)) prefix = \"/\" + prefix;\n        read = prefix;\n    } else read = prefix;\n    var abs = this._makeAbs(read);\n    //if ignored, skip processing\n    if (childrenIgnored(this, read)) return;\n    var isGlobStar = remain[0] === minimatch.GLOBSTAR;\n    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);\n    else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);\n};\nGlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {\n    var entries = this._readdir(abs, inGlobStar);\n    // if the abs isn't a dir, then nothing can match!\n    if (!entries) return;\n    // It will only match dot entries if it starts with a dot, or if\n    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n    var pn = remain[0];\n    var negate = !!this.minimatch.negate;\n    var rawGlob = pn._glob;\n    var dotOk = this.dot || rawGlob.charAt(0) === \".\";\n    var matchedEntries = [];\n    for(var i = 0; i < entries.length; i++){\n        var e = entries[i];\n        if (e.charAt(0) !== \".\" || dotOk) {\n            var m;\n            if (negate && !prefix) {\n                m = !e.match(pn);\n            } else {\n                m = e.match(pn);\n            }\n            if (m) matchedEntries.push(e);\n        }\n    }\n    var len = matchedEntries.length;\n    // If there are no matched entries, then nothing matches.\n    if (len === 0) return;\n    // if this is the last remaining pattern bit, then no need for\n    // an additional stat *unless* the user has specified mark or\n    // stat explicitly.  We know they exist, since readdir returned\n    // them.\n    if (remain.length === 1 && !this.mark && !this.stat) {\n        if (!this.matches[index]) this.matches[index] = Object.create(null);\n        for(var i = 0; i < len; i++){\n            var e = matchedEntries[i];\n            if (prefix) {\n                if (prefix.slice(-1) !== \"/\") e = prefix + \"/\" + e;\n                else e = prefix + e;\n            }\n            if (e.charAt(0) === \"/\" && !this.nomount) {\n                e = path.join(this.root, e);\n            }\n            this._emitMatch(index, e);\n        }\n        // This was the last one, and no stats were needed\n        return;\n    }\n    // now test all matched entries as stand-ins for that part\n    // of the pattern.\n    remain.shift();\n    for(var i = 0; i < len; i++){\n        var e = matchedEntries[i];\n        var newPattern;\n        if (prefix) newPattern = [\n            prefix,\n            e\n        ];\n        else newPattern = [\n            e\n        ];\n        this._process(newPattern.concat(remain), index, inGlobStar);\n    }\n};\nGlobSync.prototype._emitMatch = function(index, e) {\n    if (isIgnored(this, e)) return;\n    var abs = this._makeAbs(e);\n    if (this.mark) e = this._mark(e);\n    if (this.absolute) {\n        e = abs;\n    }\n    if (this.matches[index][e]) return;\n    if (this.nodir) {\n        var c = this.cache[abs];\n        if (c === \"DIR\" || Array.isArray(c)) return;\n    }\n    this.matches[index][e] = true;\n    if (this.stat) this._stat(e);\n};\nGlobSync.prototype._readdirInGlobStar = function(abs) {\n    // follow all symlinked directories forever\n    // just proceed as if this is a non-globstar situation\n    if (this.follow) return this._readdir(abs, false);\n    var entries;\n    var lstat;\n    var stat;\n    try {\n        lstat = fs.lstatSync(abs);\n    } catch (er) {\n        if (er.code === \"ENOENT\") {\n            // lstat failed, doesn't exist\n            return null;\n        }\n    }\n    var isSym = lstat && lstat.isSymbolicLink();\n    this.symlinks[abs] = isSym;\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = \"FILE\";\n    else entries = this._readdir(abs, false);\n    return entries;\n};\nGlobSync.prototype._readdir = function(abs, inGlobStar) {\n    var entries;\n    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);\n    if (ownProp(this.cache, abs)) {\n        var c = this.cache[abs];\n        if (!c || c === \"FILE\") return null;\n        if (Array.isArray(c)) return c;\n    }\n    try {\n        return this._readdirEntries(abs, fs.readdirSync(abs));\n    } catch (er) {\n        this._readdirError(abs, er);\n        return null;\n    }\n};\nGlobSync.prototype._readdirEntries = function(abs, entries) {\n    // if we haven't asked to stat everything, then just\n    // assume that everything in there exists, so we can avoid\n    // having to stat it a second time.\n    if (!this.mark && !this.stat) {\n        for(var i = 0; i < entries.length; i++){\n            var e = entries[i];\n            if (abs === \"/\") e = abs + e;\n            else e = abs + \"/\" + e;\n            this.cache[e] = true;\n        }\n    }\n    this.cache[abs] = entries;\n    // mark and cache dir-ness\n    return entries;\n};\nGlobSync.prototype._readdirError = function(f, er) {\n    // handle errors, and cache the information\n    switch(er.code){\n        case \"ENOTSUP\":\n        case \"ENOTDIR\":\n            var abs = this._makeAbs(f);\n            this.cache[abs] = \"FILE\";\n            if (abs === this.cwdAbs) {\n                var error = new Error(er.code + \" invalid cwd \" + this.cwd);\n                error.path = this.cwd;\n                error.code = er.code;\n                throw error;\n            }\n            break;\n        case \"ENOENT\":\n        case \"ELOOP\":\n        case \"ENAMETOOLONG\":\n        case \"UNKNOWN\":\n            this.cache[this._makeAbs(f)] = false;\n            break;\n        default:\n            this.cache[this._makeAbs(f)] = false;\n            if (this.strict) throw er;\n            if (!this.silent) console.error(\"glob error\", er);\n            break;\n    }\n};\nGlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {\n    var entries = this._readdir(abs, inGlobStar);\n    // no entries means not a dir, so it can never have matches\n    // foo.txt/** doesn't match foo.txt\n    if (!entries) return;\n    // test without the globstar, and with every child both below\n    // and replacing the globstar.\n    var remainWithoutGlobStar = remain.slice(1);\n    var gspref = prefix ? [\n        prefix\n    ] : [];\n    var noGlobStar = gspref.concat(remainWithoutGlobStar);\n    // the noGlobStar pattern exits the inGlobStar state\n    this._process(noGlobStar, index, false);\n    var len = entries.length;\n    var isSym = this.symlinks[abs];\n    // If it's a symlink, and we're in a globstar, then stop\n    if (isSym && inGlobStar) return;\n    for(var i = 0; i < len; i++){\n        var e = entries[i];\n        if (e.charAt(0) === \".\" && !this.dot) continue;\n        // these two cases enter the inGlobStar state\n        var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n        this._process(instead, index, true);\n        var below = gspref.concat(entries[i], remain);\n        this._process(below, index, true);\n    }\n};\nGlobSync.prototype._processSimple = function(prefix, index) {\n    // XXX review this.  Shouldn't it be doing the mounting etc\n    // before doing stat?  kinda weird?\n    var exists = this._stat(prefix);\n    if (!this.matches[index]) this.matches[index] = Object.create(null);\n    // If it doesn't exist, then just mark the lack of results\n    if (!exists) return;\n    if (prefix && isAbsolute(prefix) && !this.nomount) {\n        var trail = /[\\/\\\\]$/.test(prefix);\n        if (prefix.charAt(0) === \"/\") {\n            prefix = path.join(this.root, prefix);\n        } else {\n            prefix = path.resolve(this.root, prefix);\n            if (trail) prefix += \"/\";\n        }\n    }\n    if (process.platform === \"win32\") prefix = prefix.replace(/\\\\/g, \"/\");\n    // Mark this as a match\n    this._emitMatch(index, prefix);\n};\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function(f) {\n    var abs = this._makeAbs(f);\n    var needDir = f.slice(-1) === \"/\";\n    if (f.length > this.maxLength) return false;\n    if (!this.stat && ownProp(this.cache, abs)) {\n        var c = this.cache[abs];\n        if (Array.isArray(c)) c = \"DIR\";\n        // It exists, but maybe not how we need it\n        if (!needDir || c === \"DIR\") return c;\n        if (needDir && c === \"FILE\") return false;\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n    }\n    var exists;\n    var stat = this.statCache[abs];\n    if (!stat) {\n        var lstat;\n        try {\n            lstat = fs.lstatSync(abs);\n        } catch (er) {\n            if (er && (er.code === \"ENOENT\" || er.code === \"ENOTDIR\")) {\n                this.statCache[abs] = false;\n                return false;\n            }\n        }\n        if (lstat && lstat.isSymbolicLink()) {\n            try {\n                stat = fs.statSync(abs);\n            } catch (er) {\n                stat = lstat;\n            }\n        } else {\n            stat = lstat;\n        }\n    }\n    this.statCache[abs] = stat;\n    var c = true;\n    if (stat) c = stat.isDirectory() ? \"DIR\" : \"FILE\";\n    this.cache[abs] = this.cache[abs] || c;\n    if (needDir && c === \"FILE\") return false;\n    return c;\n};\nGlobSync.prototype._mark = function(p) {\n    return common.mark(this, p);\n};\nGlobSync.prototype._makeAbs = function(f) {\n    return common.makeAbs(this, f);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxNQUFNLFFBQ25CLE9BQU87SUFFVCxPQUFPQTtBQUNUO0FBRUF2RixTQUFTaUMsU0FBUyxDQUFDbUQsS0FBSyxHQUFHLFNBQVUzQyxDQUFDO0lBQ3BDLE9BQU85QixPQUFPaUUsSUFBSSxDQUFDLElBQUksRUFBRW5DO0FBQzNCO0FBRUF6QyxTQUFTaUMsU0FBUyxDQUFDUyxRQUFRLEdBQUcsU0FBVTZELENBQUM7SUFDdkMsT0FBTzVGLE9BQU9tSCxPQUFPLENBQUMsSUFBSSxFQUFFdkI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW50ZXMtcHVibGljLWRhdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2dsb2Ivc3luYy5qcz84ZTdkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZ2xvYlN5bmNcbmdsb2JTeW5jLkdsb2JTeW5jID0gR2xvYlN5bmNcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHJwID0gcmVxdWlyZSgnZnMucmVhbHBhdGgnKVxudmFyIG1pbmltYXRjaCA9IHJlcXVpcmUoJ21pbmltYXRjaCcpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxudmFyIEdsb2IgPSByZXF1aXJlKCcuL2dsb2IuanMnKS5HbG9iXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKCdwYXRoLWlzLWFic29sdXRlJylcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpXG52YXIgYWxwaGFzb3J0ID0gY29tbW9uLmFscGhhc29ydFxudmFyIGFscGhhc29ydGkgPSBjb21tb24uYWxwaGFzb3J0aVxudmFyIHNldG9wdHMgPSBjb21tb24uc2V0b3B0c1xudmFyIG93blByb3AgPSBjb21tb24ub3duUHJvcFxudmFyIGNoaWxkcmVuSWdub3JlZCA9IGNvbW1vbi5jaGlsZHJlbklnbm9yZWRcbnZhciBpc0lnbm9yZWQgPSBjb21tb24uaXNJZ25vcmVkXG5cbmZ1bmN0aW9uIGdsb2JTeW5jIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYlxcbicrXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMTY3JylcblxuICByZXR1cm4gbmV3IEdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpLmZvdW5kXG59XG5cbmZ1bmN0aW9uIEdsb2JTeW5jIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghcGF0dGVybilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBwYXR0ZXJuJylcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2JcXG4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzE2NycpXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdsb2JTeW5jKSlcbiAgICByZXR1cm4gbmV3IEdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpXG5cbiAgc2V0b3B0cyh0aGlzLCBwYXR0ZXJuLCBvcHRpb25zKVxuXG4gIGlmICh0aGlzLm5vcHJvY2VzcylcbiAgICByZXR1cm4gdGhpc1xuXG4gIHZhciBuID0gdGhpcy5taW5pbWF0Y2guc2V0Lmxlbmd0aFxuICB0aGlzLm1hdGNoZXMgPSBuZXcgQXJyYXkobilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICsrKSB7XG4gICAgdGhpcy5fcHJvY2Vzcyh0aGlzLm1pbmltYXRjaC5zZXRbaV0sIGksIGZhbHNlKVxuICB9XG4gIHRoaXMuX2ZpbmlzaCgpXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICBhc3NlcnQodGhpcyBpbnN0YW5jZW9mIEdsb2JTeW5jKVxuICBpZiAodGhpcy5yZWFscGF0aCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHRoaXMubWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaHNldCwgaW5kZXgpIHtcbiAgICAgIHZhciBzZXQgPSBzZWxmLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgZm9yICh2YXIgcCBpbiBtYXRjaHNldCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHAgPSBzZWxmLl9tYWtlQWJzKHApXG4gICAgICAgICAgdmFyIHJlYWwgPSBycC5yZWFscGF0aFN5bmMocCwgc2VsZi5yZWFscGF0aENhY2hlKVxuICAgICAgICAgIHNldFtyZWFsXSA9IHRydWVcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICBpZiAoZXIuc3lzY2FsbCA9PT0gJ3N0YXQnKVxuICAgICAgICAgICAgc2V0W3NlbGYuX21ha2VBYnMocCldID0gdHJ1ZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IGVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGNvbW1vbi5maW5pc2godGhpcylcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbiAocGF0dGVybiwgaW5kZXgsIGluR2xvYlN0YXIpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYylcblxuICAvLyBHZXQgdGhlIGZpcnN0IFtuXSBwYXJ0cyBvZiBwYXR0ZXJuIHRoYXQgYXJlIGFsbCBzdHJpbmdzLlxuICB2YXIgbiA9IDBcbiAgd2hpbGUgKHR5cGVvZiBwYXR0ZXJuW25dID09PSAnc3RyaW5nJykge1xuICAgIG4gKytcbiAgfVxuICAvLyBub3cgbiBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9uZSB0aGF0IGlzICpub3QqIGEgc3RyaW5nLlxuXG4gIC8vIFNlZSBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2VcbiAgdmFyIHByZWZpeFxuICBzd2l0Y2ggKG4pIHtcbiAgICAvLyBpZiBub3QsIHRoZW4gdGhpcyBpcyByYXRoZXIgc2ltcGxlXG4gICAgY2FzZSBwYXR0ZXJuLmxlbmd0aDpcbiAgICAgIHRoaXMuX3Byb2Nlc3NTaW1wbGUocGF0dGVybi5qb2luKCcvJyksIGluZGV4KVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlIDA6XG4gICAgICAvLyBwYXR0ZXJuICpzdGFydHMqIHdpdGggc29tZSBub24tdHJpdmlhbCBpdGVtLlxuICAgICAgLy8gZ29pbmcgdG8gcmVhZGRpcihjd2QpLCBidXQgbm90IGluY2x1ZGUgdGhlIHByZWZpeCBpbiBtYXRjaGVzLlxuICAgICAgcHJlZml4ID0gbnVsbFxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBwYXR0ZXJuIGhhcyBzb21lIHN0cmluZyBiaXRzIGluIHRoZSBmcm9udC5cbiAgICAgIC8vIHdoYXRldmVyIGl0IHN0YXJ0cyB3aXRoLCB3aGV0aGVyIHRoYXQncyAnYWJzb2x1dGUnIGxpa2UgL2Zvby9iYXIsXG4gICAgICAvLyBvciAncmVsYXRpdmUnIGxpa2UgJy4uL2JheidcbiAgICAgIHByZWZpeCA9IHBhdHRlcm4uc2xpY2UoMCwgbikuam9pbignLycpXG4gICAgICBicmVha1xuICB9XG5cbiAgdmFyIHJlbWFpbiA9IHBhdHRlcm4uc2xpY2UobilcblxuICAvLyBnZXQgdGhlIGxpc3Qgb2YgZW50cmllcy5cbiAgdmFyIHJlYWRcbiAgaWYgKHByZWZpeCA9PT0gbnVsbClcbiAgICByZWFkID0gJy4nXG4gIGVsc2UgaWYgKGlzQWJzb2x1dGUocHJlZml4KSB8fCBpc0Fic29sdXRlKHBhdHRlcm4uam9pbignLycpKSkge1xuICAgIGlmICghcHJlZml4IHx8ICFpc0Fic29sdXRlKHByZWZpeCkpXG4gICAgICBwcmVmaXggPSAnLycgKyBwcmVmaXhcbiAgICByZWFkID0gcHJlZml4XG4gIH0gZWxzZVxuICAgIHJlYWQgPSBwcmVmaXhcblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhyZWFkKVxuXG4gIC8vaWYgaWdub3JlZCwgc2tpcCBwcm9jZXNzaW5nXG4gIGlmIChjaGlsZHJlbklnbm9yZWQodGhpcywgcmVhZCkpXG4gICAgcmV0dXJuXG5cbiAgdmFyIGlzR2xvYlN0YXIgPSByZW1haW5bMF0gPT09IG1pbmltYXRjaC5HTE9CU1RBUlxuICBpZiAoaXNHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzR2xvYlN0YXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIpXG4gIGVsc2VcbiAgICB0aGlzLl9wcm9jZXNzUmVhZGRpcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcilcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gaWYgdGhlIGFicyBpc24ndCBhIGRpciwgdGhlbiBub3RoaW5nIGNhbiBtYXRjaCFcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIEl0IHdpbGwgb25seSBtYXRjaCBkb3QgZW50cmllcyBpZiBpdCBzdGFydHMgd2l0aCBhIGRvdCwgb3IgaWZcbiAgLy8gZG90IGlzIHNldC4gIFN0dWZmIGxpa2UgQCguZm9vfC5iYXIpIGlzbid0IGFsbG93ZWQuXG4gIHZhciBwbiA9IHJlbWFpblswXVxuICB2YXIgbmVnYXRlID0gISF0aGlzLm1pbmltYXRjaC5uZWdhdGVcbiAgdmFyIHJhd0dsb2IgPSBwbi5fZ2xvYlxuICB2YXIgZG90T2sgPSB0aGlzLmRvdCB8fCByYXdHbG9iLmNoYXJBdCgwKSA9PT0gJy4nXG5cbiAgdmFyIG1hdGNoZWRFbnRyaWVzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgaWYgKGUuY2hhckF0KDApICE9PSAnLicgfHwgZG90T2spIHtcbiAgICAgIHZhciBtXG4gICAgICBpZiAobmVnYXRlICYmICFwcmVmaXgpIHtcbiAgICAgICAgbSA9ICFlLm1hdGNoKHBuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGUubWF0Y2gocG4pXG4gICAgICB9XG4gICAgICBpZiAobSlcbiAgICAgICAgbWF0Y2hlZEVudHJpZXMucHVzaChlKVxuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBtYXRjaGVkRW50cmllcy5sZW5ndGhcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIG1hdGNoZWQgZW50cmllcywgdGhlbiBub3RoaW5nIG1hdGNoZXMuXG4gIGlmIChsZW4gPT09IDApXG4gICAgcmV0dXJuXG5cbiAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmcgcGF0dGVybiBiaXQsIHRoZW4gbm8gbmVlZCBmb3JcbiAgLy8gYW4gYWRkaXRpb25hbCBzdGF0ICp1bmxlc3MqIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgbWFyayBvclxuICAvLyBzdGF0IGV4cGxpY2l0bHkuICBXZSBrbm93IHRoZXkgZXhpc3QsIHNpbmNlIHJlYWRkaXIgcmV0dXJuZWRcbiAgLy8gdGhlbS5cblxuICBpZiAocmVtYWluLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeC5zbGljZSgtMSkgIT09ICcvJylcbiAgICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhckF0KDApID09PSAnLycgJiYgIXRoaXMubm9tb3VudCkge1xuICAgICAgICBlID0gcGF0aC5qb2luKHRoaXMucm9vdCwgZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgZSlcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBhbmQgbm8gc3RhdHMgd2VyZSBuZWVkZWRcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIG5vdyB0ZXN0IGFsbCBtYXRjaGVkIGVudHJpZXMgYXMgc3RhbmQtaW5zIGZvciB0aGF0IHBhcnRcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIHJlbWFpbi5zaGlmdCgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgIHZhciBuZXdQYXR0ZXJuXG4gICAgaWYgKHByZWZpeClcbiAgICAgIG5ld1BhdHRlcm4gPSBbcHJlZml4LCBlXVxuICAgIGVsc2VcbiAgICAgIG5ld1BhdHRlcm4gPSBbZV1cbiAgICB0aGlzLl9wcm9jZXNzKG5ld1BhdHRlcm4uY29uY2F0KHJlbWFpbiksIGluZGV4LCBpbkdsb2JTdGFyKVxuICB9XG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9lbWl0TWF0Y2ggPSBmdW5jdGlvbiAoaW5kZXgsIGUpIHtcbiAgaWYgKGlzSWdub3JlZCh0aGlzLCBlKSlcbiAgICByZXR1cm5cblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhlKVxuXG4gIGlmICh0aGlzLm1hcmspXG4gICAgZSA9IHRoaXMuX21hcmsoZSlcblxuICBpZiAodGhpcy5hYnNvbHV0ZSkge1xuICAgIGUgPSBhYnNcbiAgfVxuXG4gIGlmICh0aGlzLm1hdGNoZXNbaW5kZXhdW2VdKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLm5vZGlyKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5tYXRjaGVzW2luZGV4XVtlXSA9IHRydWVcblxuICBpZiAodGhpcy5zdGF0KVxuICAgIHRoaXMuX3N0YXQoZSlcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJJbkdsb2JTdGFyID0gZnVuY3Rpb24gKGFicykge1xuICAvLyBmb2xsb3cgYWxsIHN5bWxpbmtlZCBkaXJlY3RvcmllcyBmb3JldmVyXG4gIC8vIGp1c3QgcHJvY2VlZCBhcyBpZiB0aGlzIGlzIGEgbm9uLWdsb2JzdGFyIHNpdHVhdGlvblxuICBpZiAodGhpcy5mb2xsb3cpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSlcblxuICB2YXIgZW50cmllc1xuICB2YXIgbHN0YXRcbiAgdmFyIHN0YXRcbiAgdHJ5IHtcbiAgICBsc3RhdCA9IGZzLmxzdGF0U3luYyhhYnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAvLyBsc3RhdCBmYWlsZWQsIGRvZXNuJ3QgZXhpc3RcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgdmFyIGlzU3ltID0gbHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKVxuICB0aGlzLnN5bWxpbmtzW2Fic10gPSBpc1N5bVxuXG4gIC8vIElmIGl0J3Mgbm90IGEgc3ltbGluayBvciBhIGRpciwgdGhlbiBpdCdzIGRlZmluaXRlbHkgYSByZWd1bGFyIGZpbGUuXG4gIC8vIGRvbid0IGJvdGhlciBkb2luZyBhIHJlYWRkaXIgaW4gdGhhdCBjYXNlLlxuICBpZiAoIWlzU3ltICYmIGxzdGF0ICYmICFsc3RhdC5pc0RpcmVjdG9yeSgpKVxuICAgIHRoaXMuY2FjaGVbYWJzXSA9ICdGSUxFJ1xuICBlbHNlXG4gICAgZW50cmllcyA9IHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSlcblxuICByZXR1cm4gZW50cmllc1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXIgPSBmdW5jdGlvbiAoYWJzLCBpbkdsb2JTdGFyKSB7XG4gIHZhciBlbnRyaWVzXG5cbiAgaWYgKGluR2xvYlN0YXIgJiYgIW93blByb3AodGhpcy5zeW1saW5rcywgYWJzKSlcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckluR2xvYlN0YXIoYWJzKVxuXG4gIGlmIChvd25Qcm9wKHRoaXMuY2FjaGUsIGFicykpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuICAgIGlmICghYyB8fCBjID09PSAnRklMRScpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpXG4gICAgICByZXR1cm4gY1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckVudHJpZXMoYWJzLCBmcy5yZWFkZGlyU3luYyhhYnMpKVxuICB9IGNhdGNoIChlcikge1xuICAgIHRoaXMuX3JlYWRkaXJFcnJvcihhYnMsIGVyKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9yZWFkZGlyRW50cmllcyA9IGZ1bmN0aW9uIChhYnMsIGVudHJpZXMpIHtcbiAgLy8gaWYgd2UgaGF2ZW4ndCBhc2tlZCB0byBzdGF0IGV2ZXJ5dGhpbmcsIHRoZW4ganVzdFxuICAvLyBhc3N1bWUgdGhhdCBldmVyeXRoaW5nIGluIHRoZXJlIGV4aXN0cywgc28gd2UgY2FuIGF2b2lkXG4gIC8vIGhhdmluZyB0byBzdGF0IGl0IGEgc2Vjb25kIHRpbWUuXG4gIGlmICghdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICAgIGlmIChhYnMgPT09ICcvJylcbiAgICAgICAgZSA9IGFicyArIGVcbiAgICAgIGVsc2VcbiAgICAgICAgZSA9IGFicyArICcvJyArIGVcbiAgICAgIHRoaXMuY2FjaGVbZV0gPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgdGhpcy5jYWNoZVthYnNdID0gZW50cmllc1xuXG4gIC8vIG1hcmsgYW5kIGNhY2hlIGRpci1uZXNzXG4gIHJldHVybiBlbnRyaWVzXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpckVycm9yID0gZnVuY3Rpb24gKGYsIGVyKSB7XG4gIC8vIGhhbmRsZSBlcnJvcnMsIGFuZCBjYWNoZSB0aGUgaW5mb3JtYXRpb25cbiAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgY2FzZSAnRU5PVFNVUCc6IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8yMDVcbiAgICBjYXNlICdFTk9URElSJzogLy8gdG90YWxseSBub3JtYWwuIG1lYW5zIGl0ICpkb2VzKiBleGlzdC5cbiAgICAgIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gICAgICB0aGlzLmNhY2hlW2Fic10gPSAnRklMRSdcbiAgICAgIGlmIChhYnMgPT09IHRoaXMuY3dkQWJzKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihlci5jb2RlICsgJyBpbnZhbGlkIGN3ZCAnICsgdGhpcy5jd2QpXG4gICAgICAgIGVycm9yLnBhdGggPSB0aGlzLmN3ZFxuICAgICAgICBlcnJvci5jb2RlID0gZXIuY29kZVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ0VOT0VOVCc6IC8vIG5vdCB0ZXJyaWJseSB1bnVzdWFsXG4gICAgY2FzZSAnRUxPT1AnOlxuICAgIGNhc2UgJ0VOQU1FVE9PTE9ORyc6XG4gICAgY2FzZSAnVU5LTk9XTic6XG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OiAvLyBzb21lIHVudXN1YWwgZXJyb3IuICBUcmVhdCBhcyBmYWlsdXJlLlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBpZiAodGhpcy5zdHJpY3QpXG4gICAgICAgIHRocm93IGVyXG4gICAgICBpZiAoIXRoaXMuc2lsZW50KVxuICAgICAgICBjb25zb2xlLmVycm9yKCdnbG9iIGVycm9yJywgZXIpXG4gICAgICBicmVha1xuICB9XG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcHJvY2Vzc0dsb2JTdGFyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG5cbiAgdmFyIGVudHJpZXMgPSB0aGlzLl9yZWFkZGlyKGFicywgaW5HbG9iU3RhcilcblxuICAvLyBubyBlbnRyaWVzIG1lYW5zIG5vdCBhIGRpciwgc28gaXQgY2FuIG5ldmVyIGhhdmUgbWF0Y2hlc1xuICAvLyBmb28udHh0LyoqIGRvZXNuJ3QgbWF0Y2ggZm9vLnR4dFxuICBpZiAoIWVudHJpZXMpXG4gICAgcmV0dXJuXG5cbiAgLy8gdGVzdCB3aXRob3V0IHRoZSBnbG9ic3RhciwgYW5kIHdpdGggZXZlcnkgY2hpbGQgYm90aCBiZWxvd1xuICAvLyBhbmQgcmVwbGFjaW5nIHRoZSBnbG9ic3Rhci5cbiAgdmFyIHJlbWFpbldpdGhvdXRHbG9iU3RhciA9IHJlbWFpbi5zbGljZSgxKVxuICB2YXIgZ3NwcmVmID0gcHJlZml4ID8gWyBwcmVmaXggXSA6IFtdXG4gIHZhciBub0dsb2JTdGFyID0gZ3NwcmVmLmNvbmNhdChyZW1haW5XaXRob3V0R2xvYlN0YXIpXG5cbiAgLy8gdGhlIG5vR2xvYlN0YXIgcGF0dGVybiBleGl0cyB0aGUgaW5HbG9iU3RhciBzdGF0ZVxuICB0aGlzLl9wcm9jZXNzKG5vR2xvYlN0YXIsIGluZGV4LCBmYWxzZSlcblxuICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGhcbiAgdmFyIGlzU3ltID0gdGhpcy5zeW1saW5rc1thYnNdXG5cbiAgLy8gSWYgaXQncyBhIHN5bWxpbmssIGFuZCB3ZSdyZSBpbiBhIGdsb2JzdGFyLCB0aGVuIHN0b3BcbiAgaWYgKGlzU3ltICYmIGluR2xvYlN0YXIpXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy4nICYmICF0aGlzLmRvdClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAvLyB0aGVzZSB0d28gY2FzZXMgZW50ZXIgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgICB2YXIgaW5zdGVhZCA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluV2l0aG91dEdsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3MoaW5zdGVhZCwgaW5kZXgsIHRydWUpXG5cbiAgICB2YXIgYmVsb3cgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbilcbiAgICB0aGlzLl9wcm9jZXNzKGJlbG93LCBpbmRleCwgdHJ1ZSlcbiAgfVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NTaW1wbGUgPSBmdW5jdGlvbiAocHJlZml4LCBpbmRleCkge1xuICAvLyBYWFggcmV2aWV3IHRoaXMuICBTaG91bGRuJ3QgaXQgYmUgZG9pbmcgdGhlIG1vdW50aW5nIGV0Y1xuICAvLyBiZWZvcmUgZG9pbmcgc3RhdD8gIGtpbmRhIHdlaXJkP1xuICB2YXIgZXhpc3RzID0gdGhpcy5fc3RhdChwcmVmaXgpXG5cbiAgaWYgKCF0aGlzLm1hdGNoZXNbaW5kZXhdKVxuICAgIHRoaXMubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgLy8gSWYgaXQgZG9lc24ndCBleGlzdCwgdGhlbiBqdXN0IG1hcmsgdGhlIGxhY2sgb2YgcmVzdWx0c1xuICBpZiAoIWV4aXN0cylcbiAgICByZXR1cm5cblxuICBpZiAocHJlZml4ICYmIGlzQWJzb2x1dGUocHJlZml4KSAmJiAhdGhpcy5ub21vdW50KSB7XG4gICAgdmFyIHRyYWlsID0gL1tcXC9cXFxcXSQvLnRlc3QocHJlZml4KVxuICAgIGlmIChwcmVmaXguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHByZWZpeCA9IHBhdGguam9pbih0aGlzLnJvb3QsIHByZWZpeClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gcGF0aC5yZXNvbHZlKHRoaXMucm9vdCwgcHJlZml4KVxuICAgICAgaWYgKHRyYWlsKVxuICAgICAgICBwcmVmaXggKz0gJy8nXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG4gICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIC8vIE1hcmsgdGhpcyBhcyBhIG1hdGNoXG4gIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgcHJlZml4KVxufVxuXG4vLyBSZXR1cm5zIGVpdGhlciAnRElSJywgJ0ZJTEUnLCBvciBmYWxzZVxuR2xvYlN5bmMucHJvdG90eXBlLl9zdGF0ID0gZnVuY3Rpb24gKGYpIHtcbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgdmFyIG5lZWREaXIgPSBmLnNsaWNlKC0xKSA9PT0gJy8nXG5cbiAgaWYgKGYubGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKCF0aGlzLnN0YXQgJiYgb3duUHJvcCh0aGlzLmNhY2hlLCBhYnMpKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKVxuICAgICAgYyA9ICdESVInXG5cbiAgICAvLyBJdCBleGlzdHMsIGJ1dCBtYXliZSBub3QgaG93IHdlIG5lZWQgaXRcbiAgICBpZiAoIW5lZWREaXIgfHwgYyA9PT0gJ0RJUicpXG4gICAgICByZXR1cm4gY1xuXG4gICAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAvLyBvdGhlcndpc2Ugd2UgaGF2ZSB0byBzdGF0LCBiZWNhdXNlIG1heWJlIGM9dHJ1ZVxuICAgIC8vIGlmIHdlIGtub3cgaXQgZXhpc3RzLCBidXQgbm90IHdoYXQgaXQgaXMuXG4gIH1cblxuICB2YXIgZXhpc3RzXG4gIHZhciBzdGF0ID0gdGhpcy5zdGF0Q2FjaGVbYWJzXVxuICBpZiAoIXN0YXQpIHtcbiAgICB2YXIgbHN0YXRcbiAgICB0cnkge1xuICAgICAgbHN0YXQgPSBmcy5sc3RhdFN5bmMoYWJzKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoZXIgJiYgKGVyLmNvZGUgPT09ICdFTk9FTlQnIHx8IGVyLmNvZGUgPT09ICdFTk9URElSJykpIHtcbiAgICAgICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0ID0gZnMuc3RhdFN5bmMoYWJzKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgc3RhdCA9IGxzdGF0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXQgPSBsc3RhdFxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc3RhdENhY2hlW2Fic10gPSBzdGF0XG5cbiAgdmFyIGMgPSB0cnVlXG4gIGlmIChzdGF0KVxuICAgIGMgPSBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRElSJyA6ICdGSUxFJ1xuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IHRoaXMuY2FjaGVbYWJzXSB8fCBjXG5cbiAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBjXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fbWFyayA9IGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBjb21tb24ubWFyayh0aGlzLCBwKVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX21ha2VBYnMgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gY29tbW9uLm1ha2VBYnModGhpcywgZilcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZ2xvYlN5bmMiLCJHbG9iU3luYyIsImZzIiwicmVxdWlyZSIsInJwIiwibWluaW1hdGNoIiwiTWluaW1hdGNoIiwiR2xvYiIsInV0aWwiLCJwYXRoIiwiYXNzZXJ0IiwiaXNBYnNvbHV0ZSIsImNvbW1vbiIsImFscGhhc29ydCIsImFscGhhc29ydGkiLCJzZXRvcHRzIiwib3duUHJvcCIsImNoaWxkcmVuSWdub3JlZCIsImlzSWdub3JlZCIsInBhdHRlcm4iLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiZm91bmQiLCJFcnJvciIsIm5vcHJvY2VzcyIsIm4iLCJzZXQiLCJtYXRjaGVzIiwiQXJyYXkiLCJpIiwiX3Byb2Nlc3MiLCJfZmluaXNoIiwicHJvdG90eXBlIiwicmVhbHBhdGgiLCJzZWxmIiwiZm9yRWFjaCIsIm1hdGNoc2V0IiwiaW5kZXgiLCJPYmplY3QiLCJjcmVhdGUiLCJwIiwiX21ha2VBYnMiLCJyZWFsIiwicmVhbHBhdGhTeW5jIiwicmVhbHBhdGhDYWNoZSIsImVyIiwic3lzY2FsbCIsImZpbmlzaCIsImluR2xvYlN0YXIiLCJwcmVmaXgiLCJfcHJvY2Vzc1NpbXBsZSIsImpvaW4iLCJzbGljZSIsInJlbWFpbiIsInJlYWQiLCJhYnMiLCJpc0dsb2JTdGFyIiwiR0xPQlNUQVIiLCJfcHJvY2Vzc0dsb2JTdGFyIiwiX3Byb2Nlc3NSZWFkZGlyIiwiZW50cmllcyIsIl9yZWFkZGlyIiwicG4iLCJuZWdhdGUiLCJyYXdHbG9iIiwiX2dsb2IiLCJkb3RPayIsImRvdCIsImNoYXJBdCIsIm1hdGNoZWRFbnRyaWVzIiwiZSIsIm0iLCJtYXRjaCIsInB1c2giLCJsZW4iLCJtYXJrIiwic3RhdCIsIm5vbW91bnQiLCJyb290IiwiX2VtaXRNYXRjaCIsInNoaWZ0IiwibmV3UGF0dGVybiIsImNvbmNhdCIsIl9tYXJrIiwiYWJzb2x1dGUiLCJub2RpciIsImMiLCJjYWNoZSIsImlzQXJyYXkiLCJfc3RhdCIsIl9yZWFkZGlySW5HbG9iU3RhciIsImZvbGxvdyIsImxzdGF0IiwibHN0YXRTeW5jIiwiY29kZSIsImlzU3ltIiwiaXNTeW1ib2xpY0xpbmsiLCJzeW1saW5rcyIsImlzRGlyZWN0b3J5IiwiX3JlYWRkaXJFbnRyaWVzIiwicmVhZGRpclN5bmMiLCJfcmVhZGRpckVycm9yIiwiZiIsImN3ZEFicyIsImVycm9yIiwiY3dkIiwic3RyaWN0Iiwic2lsZW50IiwiY29uc29sZSIsInJlbWFpbldpdGhvdXRHbG9iU3RhciIsImdzcHJlZiIsIm5vR2xvYlN0YXIiLCJpbnN0ZWFkIiwiYmVsb3ciLCJleGlzdHMiLCJ0cmFpbCIsInRlc3QiLCJyZXNvbHZlIiwicHJvY2VzcyIsInBsYXRmb3JtIiwicmVwbGFjZSIsIm5lZWREaXIiLCJtYXhMZW5ndGgiLCJzdGF0Q2FjaGUiLCJzdGF0U3luYyIsIm1ha2VBYnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/sync.js\n");

/***/ })

};
;